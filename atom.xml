<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悦</title>
  
  <subtitle>逆流而上，悦我生涯</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-10-24T14:30:41.539Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sun Yue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用seaborn绘制数据图</title>
    <link href="http://yoursite.com/2021/10/24/%E4%BD%BF%E7%94%A8seaborn%E7%BB%98%E5%88%B6%E6%95%B0%E6%8D%AE%E5%9B%BE/"/>
    <id>http://yoursite.com/2021/10/24/%E4%BD%BF%E7%94%A8seaborn%E7%BB%98%E5%88%B6%E6%95%B0%E6%8D%AE%E5%9B%BE/</id>
    <published>2021-10-24T14:29:43.000Z</published>
    <updated>2021-10-24T14:30:41.539Z</updated>
    
    <content type="html"><![CDATA[<p>seaborn（以下简称 sns） 是以 matplotlib 为基础的绘图包，有非常丰富的绘图类型，而且形式精美，确实简化了画图的流程，非常适合统计领域的绘图。</p><p>目前尝试过的绘图方法有：scatter 散点图、regplot 拟合图、boxplot 箱线图、jointplot 联合分布图、distplot 分布图、heatmap热力图等。它们的画图风格普遍比直接用 matplotlib.pyplot 画图要好一点点，使用也非常方便，只是需要对其中的参数做一点点认识。</p><span id="more"></span><h1 id="数据分布图"><a href="#数据分布图" class="headerlink" title="数据分布图"></a>数据分布图</h1><h2 id="散点图-scatter"><a href="#散点图-scatter" class="headerlink" title="散点图 scatter"></a>散点图 scatter</h2><p><code>sns.scatterplot(x, y, data, ax, size)</code></p><p>其加载数据的方式比较独特，例如 <code>data</code> 项是一个 dataframe，参数 <code>x</code> 和 <code>y</code> 分别是数据的名称，那么 dataframe 中列名为 x 和 y 的列就分别是点的坐标数据了。</p><p>【其实也非常巧妙，只不过要是名称写的不对，那数据就加载不出来了】</p><p><code>ax </code>是画图的位置。方便了面向对象的画图，如果不指定，会单独画一张图的。</p><p><code>size</code> 指定点的大小，似乎可以简化为 s。这里的点是可以很细小的。</p><h2 id="分布图-distplot"><a href="#分布图-distplot" class="headerlink" title="分布图 distplot"></a>分布图 distplot</h2><p><code>sns.distplot(x, hist, kde, rug)</code> 可以画分布图</p><ol><li>参数 hist 表示是否画出直方图</li><li>参数 kde 表示是否画出高斯核密度估计图（大致感觉就是比直方图更平滑的分布图，对比较离散的数据更友好）</li><li>参数 rug 表示是否画出 rugplot，也叫地毯图，用短的竖线表示这里有数据</li></ol><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.distplot(x, rug=<span class="literal">True</span>, hist=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/seaborn-distplot-3.png" alt="distplot_exp"></p><h3 id="单独使用"><a href="#单独使用" class="headerlink" title="单独使用"></a>单独使用</h3><ol><li>可以单独使用 <code>kdeplot</code> 对数据作核密度统计</li><li>可以单独使用 <code>rugplot</code> 添加数据的地毯图 rugplot</li></ol><h2 id="箱线图-boxplot"><a href="#箱线图-boxplot" class="headerlink" title="箱线图 boxplot"></a>箱线图 boxplot</h2><p>箱线图是一种看上去奇奇怪怪，但是确实很反映数据分布的一种图，前提是数据密度足够：一个 x 最好对应多个 y。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxplot(x, y, data)</span><br></pre></td></tr></table></figure><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/seaborn-boxplot-2.png" alt="../_images/seaborn-boxplot-2.png"></p><blockquote><p>另外，了解箱线图的意义可能也很重要：</p><p>箱线图是基于五个数字汇总（“最小值”、第一四分位数 (Q1)、中位数、第三四分位数 (Q3) 和“最大值”）显示数据分布的标准化方式。</p><p>它可以表现出异常值及其值，还可以表明数据是否对称、数据分组的紧密程度以及数据是否以及如何倾斜。</p><p>参考：<a href="https://towardsdatascience.com/understanding-boxplots-5e2df7bcbd51">了解箱线图</a></p></blockquote><h2 id="联合分布-jointplot"><a href="#联合分布-jointplot" class="headerlink" title="联合分布 jointplot"></a>联合分布 jointplot</h2><p>有时，可能需要同时对 x 和 y 的分布规律做出统计，形成带有双侧分布图的散点图，那么就可以使用 联合分布 jointplot 绘图，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x, y, kind=<span class="string">&#x27;reg&#x27;</span>, data);</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-e6be71eae0c3c410b5762f21a099b5ad_720w.jpg" alt="jointplot_exp"></p><blockquote><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/52977472">Seaborn中文教程（三）：数据集的分布</a></li><li><a href="https://seaborn.pydata.org/generated/seaborn.scatterplot.html">sns scatterplot</a></li><li><a href="https://seaborn.pydata.org/generated/seaborn.distplot.html">sns distplot</a></li></ol></blockquote><h1 id="数据拟合图"><a href="#数据拟合图" class="headerlink" title="数据拟合图"></a>数据拟合图</h1><h2 id="regplot"><a href="#regplot" class="headerlink" title="regplot"></a>regplot</h2><p><code>sns.regplot(x, y, data, ax)</code></p><p>可以用来对数据进行拟合，上面的参数是必备的，给出数据的绘图位置。</p><p>如果想要对数据进行各种拟合，下面的设置才是关键：</p><p><code>order</code>：定义拟合的最大阶次；</p><p><code>ci</code>：回归估计的置信区间大小，数字在 0-100 之间（百分比）</p><p><code>logistic</code>：使用逻辑回归拟合；</p><p><code>lowess</code>：使用 statsmodels 估计非参数 Lowess模型，一种局部加权线性回归方法（没有置信区间）</p><p><code>rubust</code>：使用statsmodels 估计稳健回归；</p><p><code>logx</code>：进行 y ~ log(x) 形式的线性回归</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sns.regplot(x=cols_name[<span class="number">0</span>],</span><br><span class="line">            y=cols_name[<span class="number">1</span>],</span><br><span class="line">            data=dataframe,</span><br><span class="line">            ax=ax,</span><br><span class="line">            <span class="comment"># order=order, ci=90,</span></span><br><span class="line">            lowess=<span class="literal">True</span>,</span><br><span class="line">            color=<span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&#x27;s&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;gray&#x27;</span>&#125;,</span><br><span class="line">            line_kws=&#123;<span class="string">&#x27;lw&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line">           )</span><br></pre></td></tr></table></figure><p>这里就实现了局部加权线性拟合的方法，没有设置阶数和置信区间；</p><p>同时设置了线条类型、点的颜色等参数。</p><h2 id="lmplot"><a href="#lmplot" class="headerlink" title="lmplot"></a>lmplot</h2><p>lmplot 和 regplot 的区别在于传入的数据类型：</p><ol><li>regplot 可以接受numpy数组、pandas序列等类型的 x、y 变量，或者直接对 data 传入 dataframe 对象。</li><li>lmplot 必须有 data 数据，x 和 y 也必须是 字符串！</li></ol><p>除此之外，几乎是一样的</p><blockquote><p>参考：</p><ol><li><a href="https://seaborn.pydata.org/generated/seaborn.regplot.html">sns.regplot</a></li><li><a href="https://towardsdatascience.com/regression-plots-in-python-with-seaborn-118472b12e3d">Regression Plots in Python with Seaborn</a></li><li><a href="https://zhuanlan.zhihu.com/p/344076479">seaborn: 回归模型的可视化</a></li></ol></blockquote><h1 id="相关性分析"><a href="#相关性分析" class="headerlink" title="相关性分析"></a>相关性分析</h1><h2 id="变量关系组图-pairplot"><a href="#变量关系组图-pairplot" class="headerlink" title="变量关系组图 pairplot"></a>变量关系组图 pairplot</h2><p>如果有一组整理好的 dataframe 数据，可以直接使用 <code>sns.pairplot(data)</code> 进行绘制，结果如下：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/pairplot_1_0.png" alt="../_images/pairplot_1_0.png"></p><p>对于数据种类较少的情况，该图能够很好地囊括数据两两之间的分布关系，对于总体性的把握很有帮助。但是数据种类比较多的时候，这张图将会很拥挤，效果就不够好了。</p><p>可以通过添加和修改参数，非常灵活地定义图片内容：</p><ul><li><code>hue</code> 参数，可以分组</li><li><code>kind</code> <ul><li><code>=&#39;kde&#39;</code> 可以使用 高斯核密度估计画图，不仅对直方图进行 kde 估计，也会对两两数据之间的分布图进行 kde 估计（分布曲线+等高线图）</li><li><code>=&#39;hist&#39;</code> 可以画直方图 + 马赛克图</li></ul></li></ul><h2 id="热力图-heatmap"><a href="#热力图-heatmap" class="headerlink" title="热力图 heatmap"></a>热力图 heatmap</h2><p>经常用于绘制相关系数的图片。</p><p>一般思路：</p><ul><li>使用 pandas 包中的 <code>dataframe.corr(method=&#39;pearson&#39;)</code> 计算数据的相关系数矩阵</li><li>然后使用 <code>sns.heatmap(corr_matrix)</code> 就可以得到热力图了</li></ul><p>还有一些参数：</p><ul><li><code>cmap</code> 可以设置色阶，默认是一种黑橘红的配色，如果用 <code>YlGnBu</code> 会呈现出 青蓝的配色，很好看</li><li><code>annot</code> 布尔值，表示是不是要在格子中显示出数字</li><li><code>cbar</code> 颜色条</li></ul><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/v2-4f045986401015128b820d12c50a4ade_720w.jpg" alt="img"></p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/35494575">python3.x-seaborn.heatmap随笔</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;seaborn（以下简称 sns） 是以 matplotlib 为基础的绘图包，有非常丰富的绘图类型，而且形式精美，确实简化了画图的流程，非常适合统计领域的绘图。&lt;/p&gt;
&lt;p&gt;目前尝试过的绘图方法有：scatter 散点图、regplot 拟合图、boxplot 箱线图、jointplot 联合分布图、distplot 分布图、heatmap热力图等。它们的画图风格普遍比直接用 matplotlib.pyplot 画图要好一点点，使用也非常方便，只是需要对其中的参数做一点点认识。&lt;/p&gt;</summary>
    
    
    
    <category term="Data Analysis" scheme="http://yoursite.com/categories/Data-Analysis/"/>
    
    
    <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="seaborn" scheme="http://yoursite.com/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>python多子图绘制</title>
    <link href="http://yoursite.com/2021/10/20/python%E5%A4%9A%E5%AD%90%E5%9B%BE%E7%BB%98%E5%88%B6/"/>
    <id>http://yoursite.com/2021/10/20/python%E5%A4%9A%E5%AD%90%E5%9B%BE%E7%BB%98%E5%88%B6/</id>
    <published>2021-10-20T08:09:33.000Z</published>
    <updated>2021-10-20T08:55:19.002Z</updated>
    
    <content type="html"><![CDATA[<p>一张图往往不能容纳所有，多子图绘制是数据展示中非常重要的方法，网上资料零零散散，查阅起来不方便也不过瘾，现将所学整理成文档，力求简单易懂易上手。</p><p>Matplotlib 汲取了 MATLAB 和 R 语言中的绘图特点和方法，在多子图绘制方面有强大的功能，本文使用该库作多子图绘制方面的介绍。</p><span id="more"></span><h1 id="绘图思想"><a href="#绘图思想" class="headerlink" title="绘图思想"></a>绘图思想</h1><p>首先需要对 matplotlib 中的绘图思想作着重了解，否则会在绘图的过程中逐渐忘了自己在干什么。</p><p>我们经常会见到例如 <code>fig, ax = plt.subplots()</code> 的语句，不知道 fig、ax到底是什么，嫌麻烦直接 <code>plt.plot(data)</code> 了事，但是当想要调整坐标轴、调整数据、添加子图时才会发现，这种方法过于草率，学习一下游戏规则还是很有必要。</p><h2 id="基本观点"><a href="#基本观点" class="headerlink" title="基本观点"></a>基本观点</h2><p>从英文来看：</p><ul><li><p>FigureCanvas 画布，Figure 图</p></li><li><p>Axes 坐标轴系？</p></li></ul><p>按照官方的介绍，大概分别代表了图中的下面区域：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/fig_map.webp" alt="fig_map"></p><p>因此可以理解为：</p><ul><li>画图，需要一张画布，这个画布就是 fig</li><li>在画布上任你画什么，都在 Axes 下，这个单词究竟该怎么翻译，体现了不同人的观点，有两种观点：<ul><li>从模糊的角度说，不管 Axes 是什么意思，这里就是画图的地方（可能是名字起得不好）</li><li>另一种角度认为，画图时，实际上是有多个维度、多个坐标系的，最后呈现在一张图中，需要一个统一的维度，也就是 Axes 将多维度、多坐标系统一在了一张图中（听起来很有道理）</li></ul></li></ul><h2 id="核心结构"><a href="#核心结构" class="headerlink" title="核心结构"></a>核心结构</h2><p>个人觉得 fig、ax 的结构才是考验功底的地方。</p><p>目前看到比较浅显易懂的是：<a href="https://zhuanlan.zhihu.com/p/93423829">matplotlib：先搞明白plt. &#x2F;ax.&#x2F; fig再画</a></p><p>文中表明：</p><ol><li>造成困惑的最大问题是，pyplot 可以使用多种方式实现同一种绘图，对小白来说很不友好</li><li>plt 画图简单但是草率，<strong>ax 画图才是进阶与核心</strong></li><li>figure、axes、axis 的三级框架是 pyplot 画图必须掌握的结构，在 axes 层级绘图是比较专业的做法，很多操作，plt 和 ax 各自有实现的方法，优先采用 axes 的方法，主要都是在 plt 方法前加上了 set_ 的前缀</li></ol><p>ax 几乎可以填改各种图像中的内容，比如 <code>ax.legend() </code>可以添加子图的图例等等。</p><h1 id="子图绘制方法"><a href="#子图绘制方法" class="headerlink" title="子图绘制方法"></a>子图绘制方法</h1><p>有了上面的思想作为铺垫，接触下面的子图绘制方法将不再困难和枯燥。</p><p>总体来说就是：</p><ul><li>建立一张画布，顺便建立一个或者多个 axes 轴系</li><li>每个 axes 轴系上就是一个子图了，随便折腾</li></ul><p>细究起来，Matplotlib 提供了 subplot、subplots、add_subplot、add_axes 等五花八门的子图绘制方法，它们是有区别的，尤其是需要面向对象画图的时候，<strong>区别很大：直观来说，如果前缀是 <code>plt.</code> 那么就是普通的方法，如果前缀是 <code>fig.</code> 或者 <code>ax.</code> ，那么这个方法是面向对象的方法。</strong></p><h2 id="subplot-x-y-i"><a href="#subplot-x-y-i" class="headerlink" title="subplot(x, y, i)"></a>subplot(x, y, i)</h2><p><strong>定位：基本作图，不用面向对象。</strong></p><p><strong>作用：把一个绘图区域（可以认为是画布）分成多个小区域，用来绘制多个子图。</strong></p><p>多子图的产生方法：</p><p><code>subplot(222)</code> - 表示把画布分成（2*2&#x3D;4）个小区域，并将本图绘制在第2个子区域（也就是右上角位置），可以加逗号：<code>plt.subplot(2,2,2)</code></p><ul><li>第一个参数是&#x3D;&#x3D;行数&#x3D;&#x3D;</li><li>第二个参数是&#x3D;&#x3D;列数&#x3D;&#x3D;</li><li>第三个参数是当前图片的&#x3D;&#x3D;位置&#x3D;&#x3D;，是&#x3D;&#x3D;先行后列&#x3D;&#x3D;的！而且这里的索引是从 1 开始的！</li></ul><p>比如<code>1,3</code>，那么最终会得到3个图<strong>横向排列</strong>，如果是<code>3,1</code>，那么将会是3个图<strong>纵向排列</strong>。</p><h2 id="fig-add-subplot"><a href="#fig-add-subplot" class="headerlink" title="fig.add_subplot()"></a>fig.add_subplot()</h2><p><strong>定位：面向对象的方法！前缀是 fig</strong></p><p><strong>作用：先向 Figure 实例中添加 Axes实例，然后在Axes实例中绘制图片</strong></p><p>其实 <code>plt.subplot()</code> 和 <code>add_subplot()</code> 参数和含义都相同。</p><h2 id="plt-subplots"><a href="#plt-subplots" class="headerlink" title="plt.subplots()"></a>plt.subplots()</h2><p>定位：普通方法，可以不面向对象，也可以面向对象，例如  <code>fig.subplots()</code>  调用</p><p>作用：产生子图，会返回 fig 和 ax，如果是多子图场景，那么返回值 ax 将会是一个 list，包含所有轴系！</p><p>个人觉得这一套多子图绘制思路科学合理，很好用，很适合用于多子图的构建。</p><p>常用流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot()</span><br><span class="line">ax[<span class="number">1</span>].plot()</span><br></pre></td></tr></table></figure><p>其中， ax 是包含多个子图轴系的列表，使用索引调取子图，直接绘制，非常好用。</p><h3 id="值得注意的索引问题"><a href="#值得注意的索引问题" class="headerlink" title="值得注意的索引问题"></a>值得注意的索引问题</h3><p>（1）由于现在是多行了，所以索引本来也是要以 list 形式的，例如 [0, 0] 就表示第一行，第一列的位置</p><p>（这里的索引从0开始！）。</p><p>为了更加方便索引，也可以先展平，然后再绘图，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">25</span>,<span class="number">10</span>))</span><br><span class="line">ax = ax.flatten()</span><br><span class="line">ax[i].plot(xxx)</span><br></pre></td></tr></table></figure><p>此时索引就不需要再以 list 形式了，就可以直接用从0开始的数字索引了。</p><p>（2）另外，还要注意，索引代表的图像应该是先行后列的</p><h2 id="axes-与-add-axes"><a href="#axes-与-add-axes" class="headerlink" title="axes() 与 .add_axes()"></a>axes() 与 .add_axes()</h2><p><strong>定位：前者是普通方法，后者是面向对象的方法</strong></p><p><strong>作用：用于手绘子图</strong></p><p>举例：</p><p><code>plt.axes([0.65, 0.65, 0.2, 0.2])</code></p><p>其中：</p><ul><li>参数1：子图的位置 x（均为百分数，0-1之间）</li><li>参数2：子图的位置 y</li><li>参数3：子图的宽度 w</li><li>参数4：子图的高度 h</li></ul><p>以上参数全部使用百分数，0-1之间，一般来说，取0.1-0.9之间比较好</p><p>就像下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-02270b127046bd91b81c35390456750e_720w.jpg" alt="img"></p><blockquote><p>个人理解，在plt中画图时，应该是按照&#x3D;&#x3D;左下角为坐标原点&#x3D;&#x3D;来进行绘制的！</p></blockquote><p>面向对象时，可以如下使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_axes([<span class="number">0.65</span>, <span class="number">0.65</span>, <span class="number">0.2</span>, <span class="number">0.2</span>])</span><br></pre></td></tr></table></figure><h2 id="子图间隔调整"><a href="#子图间隔调整" class="headerlink" title="子图间隔调整"></a>子图间隔调整</h2><h3 id="tight-layout"><a href="#tight-layout" class="headerlink" title="tight_layout()"></a>tight_layout()</h3><p>根据默认的子图排列，可能会导致子图出现标题重叠的现象，比如：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/20181116151125160.png" alt="img"></p><p>为了避免这种情况，可以使用 <code>plt.tight_layout()</code> 自动调整子图，使之填充图像区域，避免重叠：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/20181116151140910.png" alt="img"></p><p>该函数有一个参数有意思，就是 pad，但是目前来看效果不明显，这个pad 似乎是根据字的大小来设置的一个相对数字。</p><blockquote><p>参考：</p><ol><li><a href="https://blog.csdn.net/Du_Shuang/article/details/84139716">plt.tight_layout()</a></li><li>官方：<a href="https://www.osgeo.cn/matplotlib/api/_as_gen/matplotlib.pyplot.tight_layout.html">matplotlib.pyplot.tight_layout</a></li><li>此外，还有多种方法可以实现比较紧密的布局，参考: <a href="https://www.jianshu.com/p/91eb0d616adb">Matplotlib 中文用户指南 3.4 密致布局指南</a></li></ol></blockquote><h3 id="subplots-adjust"><a href="#subplots-adjust" class="headerlink" title="subplots_adjust()"></a>subplots_adjust()</h3><p>还可以使用 <code>plt.subplots_adjust()</code> 可用于调整这些图之间的间隔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.subplots_adjust(hspace=<span class="number">0.4</span>, wspace=<span class="number">0.4</span>)</span><br></pre></td></tr></table></figure><p>要注意的是：hspace 和 wspace 表示的是占<strong>子图</strong>高度和宽度的百分比！所以介于0和1之间。</p><h2 id="GridSpec-弹性绘图"><a href="#GridSpec-弹性绘图" class="headerlink" title="GridSpec 弹性绘图"></a>GridSpec 弹性绘图</h2><p><code>plt.GridSpec(2, 3, wspace=0.4, hspace=0.3)</code></p><p>在该方法下，可以使用 切片的方法指定子图的位置和范围（仍然是先行，后列，左包，右不包）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(grid[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">plt.subplot(grid[<span class="number">0</span>, <span class="number">1</span>:])</span><br><span class="line">plt.subplot(grid[<span class="number">1</span>, :<span class="number">2</span>])</span><br><span class="line">plt.subplot(grid[<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/v2-c1ce13c65ac11d2428650625acf239cd_720w.jpg" alt="img"></p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/75276939">Matplotlib 多子图绘制</a></p></blockquote><h2 id="多子图标题"><a href="#多子图标题" class="headerlink" title="多子图标题"></a>多子图标题</h2><p>多子图情况下，如果需要添加总图标题，可以使用：</p><p><code>plt.suptitle(&quot;title&quot;)</code> 的方式添加总图的标题</p><p>还可以调整 suptitle 的位置：</p><p><code>plt.suptitle(&quot;title&quot;, y=0.98)</code></p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/55767312/how-to-position-suptitle">How to position suptitle?</a></p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>有一些本身就高定制化的图片，例如 seaborn 中的 jointplot 等图，就不太容易放置在子图中，如有需要，可以参考 <a href="https://stackoverflow.com/questions/35042255/how-to-plot-multiple-seaborn-jointplot-in-subplot">How to plot multiple Seaborn Jointplot in Subplot</a> 进行绘制，不过似乎是需要添加一些自定义的文件。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ol><li><code>plt.subplot(x,x,x)</code> 表示当前对该子图绘画</li><li><code>plt.plot()</code> 绘制曲线，也可以<strong>绘制直线</strong></li><li><code>plt.title(&quot;&quot;)</code> 起标题</li><li><code>plt.xlabel(&quot;&quot;)</code> 横轴意义</li><li><code>plt.ylabel(&quot;&quot;)</code> 纵轴意义</li><li><code>plt.xlim([start, end])</code> 横轴范围</li><li><code>plt.imshow(img)</code> 将图片放入子图（主要加载图片应该在其他画线操作都结束之后，否则图片加载不出来）</li><li><code>plt.show()</code> 最后把整个图进行展示</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;一张图往往不能容纳所有，多子图绘制是数据展示中非常重要的方法，网上资料零零散散，查阅起来不方便也不过瘾，现将所学整理成文档，力求简单易懂易上手。&lt;/p&gt;
&lt;p&gt;Matplotlib 汲取了 MATLAB 和 R 语言中的绘图特点和方法，在多子图绘制方面有强大的功能，本文使用该库作多子图绘制方面的介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="Data Analysis" scheme="http://yoursite.com/categories/Data-Analysis/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>使用python实现数据滤波</title>
    <link href="http://yoursite.com/2021/10/19/%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BB%A4%E6%B3%A2/"/>
    <id>http://yoursite.com/2021/10/19/%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%BB%A4%E6%B3%A2/</id>
    <published>2021-10-19T07:01:13.000Z</published>
    <updated>2021-10-19T07:25:14.648Z</updated>
    
    <content type="html"><![CDATA[<p>针对高采集率、含噪数据，滤波可能是不可避免的处理方法。</p><p>滤波可能会导致一定程度的失真、丧失了频域信息等，但优点是关注了核心内容，合理使用会产生不错的效果。</p><p>除 MATLAB 外，Python 函数所带的 seaborn、pandas、scipy 等包均有一些基础的滤波方法。本文使用 scipy 包实现低通和带通滤波器，并对数据进行滤波。</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/cof_graph_test_2.png" alt="cof_graph_test_2"></p><span id="more"></span><h1 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h1><p><code>scipy.signal</code> 系列用于数据处理，提供了所需的滤波器方法。</p><h2 id="滤波器的设计"><a href="#滤波器的设计" class="headerlink" title="滤波器的设计"></a>滤波器的设计</h2><p>可以使用 scipy中的巴特沃斯滤波器等，设计低通滤波器：</p><p><code>scipy.signal.butter()</code></p><ul><li><strong>参数1：滤波器的阶数</strong></li><li><strong>参数2：归一化截止频率 Wn</strong><ul><li>比如采样频率是 fs</li><li>奈奎斯特频率 nyq &#x3D; fs&#x2F;2 或者 fs*0.5</li><li>截止频率是 cut_off</li><li>那么归一化截止频率就应该是 Wn &#x3D; cut_off &#x2F; nyq &#x3D; 2 * cut_off &#x2F; fs</li><li>如果是带通，那么 Wn &#x3D; [Wn1, Wn2]</li></ul></li><li><strong>参数3：dtype，是滤波器的类型</strong><ul><li>可选：{‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’}</li></ul></li><li><strong>参数4：analog，布尔值</strong><ul><li>True，返回模拟滤波器</li><li>False，返回数字滤波器</li></ul></li><li><strong>参数5：output，输出类型，可选</strong><ul><li><code>“ba”</code>- IIR滤波器的分子（b）和分母（a）多项式系数向量<strong>【默认】</strong></li><li><code>“zpk”</code> - IIR滤波器传递函数的零点、极点和系统增益</li><li><code>“sos”</code> - IIR滤波器的二阶截面表示</li></ul></li></ul><h2 id="滤波器频响曲线"><a href="#滤波器频响曲线" class="headerlink" title="滤波器频响曲线"></a>滤波器频响曲线</h2><p><code>scipy.signal.freqs(b, a)</code></p><ul><li>Compute frequency response of analog filter.</li><li>计算 <strong>模拟滤波器</strong> 的频响曲线</li><li>需要角频率 rad&#x2F;s</li></ul><p><code>scipy.signal.freqz(b, a)</code></p><ul><li>Compute the frequency response of a digital filter.</li><li>计算 <strong>数字滤波器</strong> 的频响曲线</li></ul><p>例如，我们使用了传感器，获得了具有采样率的数字信号，就应该按照数字滤波器进行展示。</p><h2 id="滤波的执行"><a href="#滤波的执行" class="headerlink" title="滤波的执行"></a>滤波的执行</h2><p><code>scipy.signal.filtfilt()</code></p><ul><li>A forward-backward filter, to obtain a filter with linear phase.</li><li>一个前向-后向滤波器，以获得具有线性相位的滤波器</li></ul><blockquote><p>线性相位，filtfilt 和 lfilter 之间的区别</p><ul><li>一般会看到滤波过后，数据会出现延迟和失真</li><li>但是使用 filtfilt 对信号进行滤波，可以有效消除延迟和失真，保持信号的相位信息</li></ul><p>参考：<a href="https://ww2.mathworks.cn/help/signal/ug/compensate-for-delay-and-distortion-introduced-by-filters.html">补偿滤波器引入的延迟和失真</a></p></blockquote><p><code>scipy.signal.lfilter(b, a, x)</code></p><ul><li>Filter data along one-dimension with an IIR or FIR filter.</li><li>使用 IIR 或者 FIR 滤波器沿一维数据滤波</li><li>x - array_like 的参数</li></ul><p>确实是有区别的：蓝线-原始，绿线-lfilter，红线-filtfilt</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20211014162240847.png" alt="image-20211014162240847"></p><blockquote><p>此外，如果 filtfilt 之后，结果全部为 Nan，很可能存在的问题是：</p><ul><li>数据中有 Nan 值</li></ul><p>此时，使用 lfilter 仍然可以出结果，但是对于 filtfilt 就无法产生想要的结果了</p><p>可以使用  df.isnull() 检查数据是不是 Nan 值</p></blockquote><h1 id="滤波器示例"><a href="#滤波器示例" class="headerlink" title="滤波器示例"></a>滤波器示例</h1><p>在项目中，我使用巴特沃斯滤波器设计了低通和带通滤波器，代码如下。</p><h2 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="低通滤波器"></a>低通滤波器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">butter_lowpass</span>(<span class="params">cut_off, order=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 低通滤波器的设计 &#x27;&#x27;&#x27;</span></span><br><span class="line">    self.nyq = <span class="number">0.5</span> * self.sample_rate</span><br><span class="line">    normal_cut_off = cut_off / self.nyq     <span class="comment"># Wn 归一化的截止频率</span></span><br><span class="line">    b, a = butter(order, normal_cut_off,</span><br><span class="line">                  btype=<span class="string">&quot;low&quot;</span>, analog=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">butter_lowpass_filtfilt</span>(<span class="params">cut_off_frequency, order=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 低通滤波器的执行，消除延迟 &#x27;&#x27;&#x27;</span></span><br><span class="line">    b, a = self.butter_lowpass(cut_off_frequency, order=order)</span><br><span class="line">    y = filtfilt(b, a, self.dataframe)</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>使用效果如本文开头图片所示。</p><h2 id="带通滤波器"><a href="#带通滤波器" class="headerlink" title="带通滤波器"></a>带通滤波器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">butter_bandpass</span>(<span class="params">cut_off_frequency_list, order=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 带通滤波器，需要两个截止频率，以 list 形式输入 &#x27;&#x27;&#x27;</span></span><br><span class="line">    self.nyq = <span class="number">0.5</span> * self.sample_rate</span><br><span class="line">    normal_cut_off = np.array(cut_off_frequency_list) / self.nyq</span><br><span class="line">    b, a = butter(order, normal_cut_off,</span><br><span class="line">                  btype=<span class="string">&quot;bandpass&quot;</span>, analog=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">butter_bandpass_filtfilt</span>(<span class="params">cut_off_frequency_list, order=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 带通滤波器的执行，消除延迟 &#x27;&#x27;&#x27;</span></span><br><span class="line">    b, a = self.butter_bandpass(cut_off_frequency_list, order=order)</span><br><span class="line">    y = filtfilt(b, a, self.dataframe)</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>可以通过时频图谱观察带通滤波后的效果：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20211019151758521.png" alt="image-20211019151758521"></p><p>可以发现，使用带通滤波器确实将完整时频图中的两条亮带分离了出来。</p><h1 id="其他滤波方法"><a href="#其他滤波方法" class="headerlink" title="其他滤波方法"></a>其他滤波方法</h1><p>在处理数据过程中，还有一种非常常见的方法，简单滑动平均滤波（Simple Moving Average，SMA）。相关资料表明，均值滤波也是数字低通滤波的一种。</p><p>目前发现，可以使用 <code>pandas.rolling().mean()</code> 等函数实现滑动平均滤波。</p><hr><blockquote><p>参考：</p><ol><li><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html">scipy.signal.butter 官方介绍</a></li><li><a href="https://www.cnblogs.com/xiaosongshine/p/10831931.html">[开发技巧]·Python实现信号滤波（基于scipy）</a></li><li><a href="https://blog.csdn.net/iceboy314159/article/details/89716290">均值滤波</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;针对高采集率、含噪数据，滤波可能是不可避免的处理方法。&lt;/p&gt;
&lt;p&gt;滤波可能会导致一定程度的失真、丧失了频域信息等，但优点是关注了核心内容，合理使用会产生不错的效果。&lt;/p&gt;
&lt;p&gt;除 MATLAB 外，Python 函数所带的 seaborn、pandas、scipy 等包均有一些基础的滤波方法。本文使用 scipy 包实现低通和带通滤波器，并对数据进行滤波。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typoraim.oss-cn-shanghai.aliyuncs.com/image/cof_graph_test_2.png&quot; alt=&quot;cof_graph_test_2&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data Analysis" scheme="http://yoursite.com/categories/Data-Analysis/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="scipy" scheme="http://yoursite.com/tags/scipy/"/>
    
    <category term="数据处理" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>波动数据的特征值提取</title>
    <link href="http://yoursite.com/2021/10/18/%E6%B3%A2%E5%8A%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E6%8F%90%E5%8F%96/"/>
    <id>http://yoursite.com/2021/10/18/%E6%B3%A2%E5%8A%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E6%8F%90%E5%8F%96/</id>
    <published>2021-10-18T06:56:51.000Z</published>
    <updated>2021-10-19T07:01:54.108Z</updated>
    
    <content type="html"><![CDATA[<p>在试验中，类似位移、声压、声音之类的数据，数据值会有正有负，并且波动强烈，位移数据本身也常常用于振动信号的分析。怎样提取数据更加合理可靠呢？</p><p>比如某个试验中的位移信号，如下所示：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20211017104337223.png" alt="image-20211017104337223"></p><p>如果按照低通滤波（单纯的平滑滤波），那么所得结果就会是上图的蓝线所示。</p><p>相比原始数据（灰线），一方面丢失了高频信息，另一方面也丢失了原本的波动信息（变化情况）。</p><span id="more"></span><p>在数据处理过程中，先后考虑用以下方案进行提取：</p><h1 id="简单特征值"><a href="#简单特征值" class="headerlink" title="简单特征值"></a>简单特征值</h1><p>分成小节后，每节提取 max、min、mean 值。</p><p>针对本试验来说：</p><ul><li>max 或 min 值的走向，更接近包络线，更能贴近数据的变化</li><li>而 mean 值，很可能会像蓝线一样几乎为0。</li></ul><h1 id="统计特征值"><a href="#统计特征值" class="headerlink" title="统计特征值"></a>统计特征值</h1><p>不能简单地带入到计算之中，而是应该类似振动信息的特征提取进行计算，比如：</p><ul><li>峭度（有的地方也叫峰度），英文是 Kurtosis，正态分布为3，越大，越陡峭<ul><li>公式：$K&#x3D;\frac{\frac{1}{n}\Sigma_{i&#x3D;1}^n(x-\bar x)^4}{(\frac{1}{n}\Sigma_{i&#x3D;1}^n(x-\bar x)^2)^2}&#x3D;\frac{\mu^4}{\sigma^4}$ </li><li><code>pandas.series.kurt()</code> 可计算，发现 pandas 还有 kurtosis 一函数，从官网描述看，其差距不明；多用 kurt</li><li><code>stats.kurtosis(data)</code> 可计算</li><li><code>R_ku = np.mean((R - R_mean) ** 4) / pow(R_var, 2)</code> 计算峰度，衡量实数随机变量概率分布的峰态</li></ul></li><li>偏度（skewness），有的也叫峰度因子<ul><li>公式： $S_k&#x3D;\frac{\frac{1}{n}\Sigma_{i&#x3D;1}^n(x-\bar x)^3}{(\frac{1}{n}\Sigma_{i&#x3D;1}^n(x-\bar x)^2)^{\frac{3}{2}}}&#x3D;\frac{\mu^3}{\sigma^3}$ </li><li><code>pandas.series.skew()</code> 可计算</li><li><code>stats.skew(data)</code> 可计算</li><li><code>R_sc = np.mean((R - R_mean) ** 3)</code>  计算偏斜度，三阶矩，描述数据的偏斜程度</li></ul></li></ul><blockquote><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/149845146">振动信号常用的时域和频域指标</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTIyMDU3NA==&mid=2648492530&idx=1&sn=97b46297caaeebda75653089cbd9f601&chksm=83379843b44011559ed17e9fede75c0d249f59fe51d7f17341d63a914a39604e22ee7c039b0d&token=767525721&lang=zh_CN#rd">峰度与偏度(python)</a></li><li><a href="https://blog.csdn.net/u010665216/article/details/78591288">Pandas之skew,求偏度</a></li><li><a href="https://blog.csdn.net/weixin_41987641/article/details/82824267">偏斜度与峰度计算 python 与 numpy 实现</a></li><li><a href="https://www.zhihu.com/question/56562183">峰值因子、峭度因子、脉冲因子、裕度因子的物理意义？</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在试验中，类似位移、声压、声音之类的数据，数据值会有正有负，并且波动强烈，位移数据本身也常常用于振动信号的分析。怎样提取数据更加合理可靠呢？&lt;/p&gt;
&lt;p&gt;比如某个试验中的位移信号，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20211017104337223.png&quot; alt=&quot;image-20211017104337223&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果按照低通滤波（单纯的平滑滤波），那么所得结果就会是上图的蓝线所示。&lt;/p&gt;
&lt;p&gt;相比原始数据（灰线），一方面丢失了高频信息，另一方面也丢失了原本的波动信息（变化情况）。&lt;/p&gt;</summary>
    
    
    
    <category term="Data Analysis" scheme="http://yoursite.com/categories/Data-Analysis/"/>
    
    
    <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="Pandas" scheme="http://yoursite.com/tags/Pandas/"/>
    
    <category term="特征值" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>写在25岁时</title>
    <link href="http://yoursite.com/2021/09/10/%E5%86%99%E5%9C%A825%E5%B2%81%E6%97%B6/"/>
    <id>http://yoursite.com/2021/09/10/%E5%86%99%E5%9C%A825%E5%B2%81%E6%97%B6/</id>
    <published>2021-09-10T14:03:20.000Z</published>
    <updated>2021-09-10T14:33:25.324Z</updated>
    
    <content type="html"><![CDATA[<p>写在25岁生日前一周，发布于2021年9月10日——25岁生日时。</p><span id="more"></span><hr><p>到下周五我就要25岁了。</p><p>回想过去的25年，我人生中可以说得上是爱情的东西，有我直接或间接拒绝掉到2次可能的告白，还有一次我主动的追求，总计时长也不超过2个月。我可能是一个容易转换暗恋对象的人，从小学到现在也在脑海中飘过了很多的名字，有的现在也已忘却。但唯有她从高中起就一直在，一直占据我心里的那个空间，即使很少相见。</p><p>但随着我的头发越来越少，我对未来的爱情真的有点担心，不止一次地想到自己可能会孤独终老，我只剩下默默的无声的无力的哭泣，还告诉自己明天还是应该接受阳光。</p><p>人需要有梦想地活着，应该是对的。曾经想从事航空航天的梦想，直到现在，我也没忘记。但时光越来越向我追问，如果只有孤独的身影，甚至没有倾诉的对象，那梦想还真的有意义吗。</p><p>我现在似乎把所有的希望都寄托在她.xyt的身上，有时候我在想我这么自信能获得她的爱吗？我怀念她的身影，她的面庞，她的声音，她的笑容，和她一起肩并肩行走的感觉，我朦胧感觉到她在关注我，此刻，我只想知道，这不是幻觉。</p><p>难以置信随着时光的累积，情感在这一年，这几个月的时间给我带来了如此深厚的影响，我似乎每天都想为她而活下去，活的精彩，最终到她身边。我想我一天也等不下去了。</p><hr><p>后记</p><p>今天已经是9月10日，命运让我有些欣喜，我又重新坚定了希望，我要为了我们的未来，努力过好奔赴的每一天。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写在25岁生日前一周，发布于2021年9月10日——25岁生日时。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2021/09/09/hello-world/"/>
    <id>http://yoursite.com/2021/09/09/hello-world/</id>
    <published>2021-09-09T03:29:26.816Z</published>
    <updated>2021-09-09T03:29:26.816Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【统计学习方法】10-隐马尔可夫模型</title>
    <link href="http://yoursite.com/2021/06/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%8D%81/"/>
    <id>http://yoursite.com/2021/06/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%8D%81/</id>
    <published>2021-06-19T08:00:31.000Z</published>
    <updated>2021-06-19T08:07:23.351Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话介绍：关于时序过程中含有不可观测的过程时，从观测结果反推模型参数的问题。</strong></p><hr><p>隐马尔可夫模型（hidden Markov model， HMM）</p><ul><li>属于生成模型</li><li>描述由隐藏的马尔可夫链随机生成观测序列的过程</li></ul><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>隐马尔可夫模型两个过程：</p><ul><li>由隐马尔可夫链随机生成不可观测的状态随机序列——状态序列</li><li>每个状态生成一个观测，形成观测的随机序列——观测序列</li></ul><p>隐马尔可夫模型 $\lambda&#x3D;(A,B,\pi)$ 的三要素：</p><ul><li>初始状态概率向量 $\pi$</li><li>状态转移概率矩阵$A$</li><li>观测概率矩阵$B$</li></ul><p>前两个决定状态序列</p><p>最后一个决定观测序列</p><p>两个基本假设：</p><ul><li>【齐次马尔可夫性假设】隐马尔可夫链在任意时刻的状态，只与前一时刻状态有关，与其他时刻（包括当前时刻）均无关</li><li>【观测独立性假设】任意时刻的观测，只与当前时刻的状态有关，与其他均无关</li></ul><p>三个基本问题：</p><ul><li>概率计算问题：在给定模型下观测序列出现的概率</li><li>学习问题：已知观测序列，估计模型参数，使得观测序列概率最大（极大似然估计）</li><li>预测问题、解码问题：给定模型和观测序列，反求条件概率最大的状态序列</li></ul><h1 id="概率计算问题"><a href="#概率计算问题" class="headerlink" title="概率计算问题"></a>概率计算问题</h1><p><strong>目标</strong>：根据模型 $\lambda&#x3D;(A,B,\pi)$ ，和观测序列 $O&#x3D;(o_1,o_2,…,o_T)$ ，计算观测序列 $O$ 出现的概率 $P(O|\lambda)$。</p><p><strong>直接计算法</strong>：按概率公式直接计算【概念可行，计算不可行——计算量太大】</p><ul><li><p>前向概率：给定模型，到时刻 t 时，观测序列为某一特定序列，且 t 时刻状态为 i 的概率</p></li><li><p>后向概率：给定模型，在时刻 t 状态为 i 的条件下，从 t+1 到 T 的部分，观测序列为某一特定序列的概率</p></li></ul><p><strong>前向算法</strong>：（t+1）时刻的前向概率是可以从 t 时刻的前向概率根据递推公式得来的；这样每个时刻的计算利用了前一个时刻计算的N个结果，避免了重复计算。</p><p><strong>后向算法</strong>：计算 t 时刻的后向概率，只需要考虑（t+1）时刻所有N个状态的转移概率，从而得到递推公式。</p><p>可以由这前向概率和后向概率，可以计算一些比较特殊的概率：</p><ul><li>给定模型和观测，求时刻 t 处于 某个特定状态的概率</li><li>给定模型和观测，求时刻 t 处于 i 状态，t+1时刻处于 j 状态的概率</li><li>在观测下，某状态出现的期望值等</li></ul><h1 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h1><p>根据训练数据对学习进行分类：</p><ul><li>训练数据只包含观测序列和对应的状态序列——监督学习</li><li>训练数据只有观测序列——无监督学习</li></ul><p>目标：学习隐马尔可夫模型 $\lambda&#x3D;(A, B, \pi)$ 的参数</p><p><strong>监督学习方法</strong></p><p>利用极大似然估计法来估计隐马尔可夫模型的参数，具体方法：</p><ol><li>估计转移概率 $a_{ij}$ ：样本中 t 时刻为状态 i，t+1时刻为转移到状态 j 的频数为 $A_{ij}$，则 $\hat a_{ij}&#x3D;\frac{A_{ij}}{\Sigma^N_{j&#x3D;1}A_{ij}},i&#x3D;1,2,…,N; j&#x3D;1,2,…,N$<br>很好理解，就是当前状态 i 已经固定了，但是下一个状态 j 不确定，那就把所有都遍历一下作为基数。</li><li>估计观测概率 $b_j(k)$：样本中状态为 j 并观测为 k 的频数是 $B_{jk}$，则 $\hat b_{j}(k)&#x3D;\frac{B_{j}(k)}{\Sigma^M_{k&#x3D;1}B_{j}(k)}, j&#x3D;1,2,…,N; k&#x3D;1,2,…,M$</li><li>估计初始状态概率$\pi_i$：就是S个样本中初始状态为$q_i$的频率</li></ol><p>缺点：数据集需要标注</p><p><strong>无监督学习方法</strong> Baum-Welch算法（EM算法）</p><p>本方法是使用<strong>完全数据</strong>的对数似然函数，结合约束条件使用拉格朗日乘子法求出各项概率【结合第9章】</p><p>是EM算法在隐马尔可夫模型学习中的具体实现</p><h1 id="预测算法"><a href="#预测算法" class="headerlink" title="预测算法"></a>预测算法</h1><p>隐马尔可夫模型预测的两种算法：</p><ul><li>近似算法：在每个时刻选择在该时刻最有可能出现的状态，从而得到一个状态序列，将它作为预测的结果；<br>缺点是不能保证预测的状态序列整体式最有可能的状态序列</li><li>维特比算法（Viterbi algorithm）：用动态规划解隐马尔可夫模型预测问题，求概率最大路径；</li></ul><p>动态规划原理：如果最优路径在时刻 t 通过节点 $i_t$，那么该节点之后的路径必须是从该节点到末节点的最优路径。</p><p>根据该原理，如果从终结点 开始逐步递推，就可以得到最大概率的路径。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;一句话介绍：关于时序过程中含有不可观测的过程时，从观测结果反推模型参数的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;隐马尔可夫模型（hidden Markov model， HMM）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属于生成模型&lt;/li&gt;
&lt;li&gt;描述由隐藏的马尔可夫链随机生成观测序列的过程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法】9-EM算法及其推广</title>
    <link href="http://yoursite.com/2021/06/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%9D/"/>
    <id>http://yoursite.com/2021/06/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%9D/</id>
    <published>2021-06-19T07:09:53.000Z</published>
    <updated>2021-06-19T07:16:42.213Z</updated>
    
    <content type="html"><![CDATA[<p>一句话介绍：用于<strong>含有隐变量的概率模型参数的极大似然估计</strong>，是一种<strong>迭代算法</strong>，每次迭代有E步和M步两步，又称期望极大算法。</p><hr><p><strong>E：</strong>expectation</p><p><strong>M</strong>：maximization</p><p><strong>EM算法</strong>：用于<strong>含有隐变量的概率模型参数的极大似然估计</strong>，是一种<strong>迭代算法</strong>，每次迭代有E步和M步两步，又称期望极大算法。</p><span id="more"></span><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>观测变量 observable variable</li><li>隐变量 hidden variable</li><li>潜在变量 latent variable</li></ul><p>如果概率模型的变量全部是观测变量，可以使用给定数据，用极大似然估计，或者贝叶斯估计法估计模型参数；</p><p>如果概率模型的变量含有隐变量，则不能简单使用上述方法，EM方法为此而生。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul><li>观测随机变量的数据（不完全数据）</li><li>隐随机变量的数据</li></ul><p>两者连在一起称为完全数据。</p><h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><p><strong>体会</strong>一下什么样的问题可以使用EM方法：</p><p>一个掷硬币游戏，有A、B、C三枚硬币。先掷A，根据A的情况选择B或C；再掷选出的硬币，本次硬币的正反面决定结果（1或0）。</p><p>如果在整个过程中，我们能够观察最后的结果是1还是0，但是不能观察这个结果到底是B还是C掷出的，那么这里的B或C就是一个隐变量。</p><p>如果需要根据观测结果估计三个硬币正面出现的概率（也就是硬币模型参数），就可以使用EM方法。</p><h2 id="方法简述"><a href="#方法简述" class="headerlink" title="方法简述"></a>方法简述</h2><p>基础：模型参数的极大似然估计</p><p>首先，选取参数初值；（模型参数在这里就可以理解为硬币正面出现的概率）</p><p>然后，迭代计算参数估计值（这里的迭代，可以理解为通过上面的估计值，结合观测参数的计算，重新估计模型参数），直到收敛。</p><p><strong>【EM算法与初值的选择有关，不同初值可能得到不同的参数估计值】</strong></p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p><strong>EM算法的核心</strong>是Q函数：$Q(\theta,\theta^{(i)})&#x3D;E_Z[\log P(Y, Z|\theta)|Y, \theta^{(i)}]$</p><p>是在迭代步骤中出现的，是<strong>对数似然函数</strong> $\log P(Y,Z|\theta)$ 在给定<strong>观测数据 Y</strong> 和<strong>估计参数</strong> $\theta^{(i)}$ 下对<strong>未测量数据 Z</strong> 的<strong>条件概率分布</strong>的<strong>期望</strong>。</p><p><strong>【EM算法不能保证找到全局最优值】</strong></p><h1 id="EM算法的收敛性"><a href="#EM算法的收敛性" class="headerlink" title="EM算法的收敛性"></a>EM算法的收敛性</h1><p>一方面，EM算法关于对数似然函数序列是收敛的；</p><p>另一方面，EM算法关于参数估计序列是收敛的；</p><p><strong>可以保证参数估计序列收敛到对数似然函数序列的稳定点，但不能保证收敛到极大值点。</strong></p><p>常用方法是：选取不同初值尝试，对估计值比较选择最好的。</p><h1 id="EM算法在高斯混合模型学习中的应用"><a href="#EM算法在高斯混合模型学习中的应用" class="headerlink" title="EM算法在高斯混合模型学习中的应用"></a>EM算法在高斯混合模型学习中的应用</h1><p>高斯混合模型，可以理解为高斯分布的概率分布模型（在概统中，我们一般用 $\Phi(x)$ 代替了，查表解决问题，其实是有公式的，这里用的是公式)</p><p>总的来说，有以下几个步骤：</p><ul><li>确定隐变量，写出完全数据的对数似然函数</li><li>确定Q函数，开始迭代中的E步骤，计算期望</li><li>M步，求Q函数关于模型参数的极大值，求得新一轮迭代的模型参数【基本方法是求偏导数并令其为0】</li></ul><h1 id="EM算法的推广"><a href="#EM算法的推广" class="headerlink" title="EM算法的推广"></a>EM算法的推广</h1><p>F函数：$F(\tilde P,\theta)&#x3D;E_{\tilde P}[\log P(Y, Z|\theta)]+H(\tilde P)$</p><p>其中，$\tilde P(Z)$ 是Z的概率分布，H 是分布的熵</p><p>F函数的极大-极大算法，同EM算法是一致的。</p><p>GEM算法：大致来看和EM算法没有本质区别，但是在迭代过程中：</p><ul><li>EM算法希望直接找极大值</li><li>GEM算法2可以不直接找极大值，而是找相对大一点的值，不停迭代</li><li>GEM算法3则是采用条件极大化，固定某些条件，微调参数向量的一个分量，实现极大</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一句话介绍：用于&lt;strong&gt;含有隐变量的概率模型参数的极大似然估计&lt;/strong&gt;，是一种&lt;strong&gt;迭代算法&lt;/strong&gt;，每次迭代有E步和M步两步，又称期望极大算法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;E：&lt;/strong&gt;expectation&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M&lt;/strong&gt;：maximization&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EM算法&lt;/strong&gt;：用于&lt;strong&gt;含有隐变量的概率模型参数的极大似然估计&lt;/strong&gt;，是一种&lt;strong&gt;迭代算法&lt;/strong&gt;，每次迭代有E步和M步两步，又称期望极大算法。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法】8-提升方法</title>
    <link href="http://yoursite.com/2021/05/12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%85%AB/"/>
    <id>http://yoursite.com/2021/05/12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%85%AB/</id>
    <published>2021-05-12T02:27:25.000Z</published>
    <updated>2021-06-19T07:08:30.777Z</updated>
    
    <content type="html"><![CDATA[<p>一句话介绍：对加法模型，使用前向分布算法实现从弱分类器到强分类器的提升。</p><hr><h1 id="0-提升方法"><a href="#0-提升方法" class="headerlink" title="0 提升方法"></a>0 提升方法</h1><p>分类问题中，通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，可以提高分类的性能。</p><p>抽象一下：找一些比较粗糙的分类规则（弱学习方法、弱分类器）是相对容易的，那么可以从这些弱学习方法出发，将一系列弱分类器组合，构成一个强分类器。</p><h2 id="两个关键问题"><a href="#两个关键问题" class="headerlink" title="两个关键问题"></a>两个关键问题</h2><ul><li>在每一轮中如何改变训练数据的权值或概率分布</li><li>如何将弱分类器组合成强分类器</li></ul><span id="more"></span><h1 id="1-AdaBoost"><a href="#1-AdaBoost" class="headerlink" title="1 - AdaBoost"></a>1 - AdaBoost</h1><p>解决两个问题的方法：</p><ul><li>提高被前一轮弱分类器错误分类样本的权值 【这样就会收到后一轮弱分类器的更大关注】，同时，降低那些被正确分类样本的权值；</li><li>采取加权多数表决，加大分类误差小的弱分类器在表决中的权值。</li></ul><p>算法的简单理解：</p><p>在一开始，各训练数据的权值分布初始化较为均匀；</p><p>通过一轮计算，根据误分类情况，将误分类的实例的权值相加，得到基本分类器本轮的分类误差率</p><p>$e_m&#x3D;\Sigma_{G_m(x_i)\not&#x3D;y_i}w_{mi}$</p><p>更新基本分类器 $G_m(x)$ 的系数，也就是在最终分类器中的重要性，$\alpha_m&#x3D;\frac{1}{2}\log\frac{1-e_m}{e_m}$，特点是误差越大，这个系数值会越小<strong>【减小错误分类器的影响力】</strong></p><p>更新训练样本的权值分布，也就是下一轮中的训练数据的权值</p><p>$w_{m+1, i}&#x3D;\left { \begin{aligned} {\frac{w_{mi}}{Z_m}e^{-\alpha_m}, G_m(x_i)&#x3D;y_i \ \frac{w_{mi}}{Z_m}e^{\alpha_m}, G_m(x_i)\not&#x3D;y_i}\end{aligned} \right.$</p><p>特点是误差越大，这个权值会越大<strong>【加强对这样的样本的训练】</strong></p><p>要注意的是，每一轮求解得出的分类器并不是不断迭代的，而是把所有轮求解出的分类器组合起来（加起来是一种办法），得到最终的分类器</p><p>所以最终分类器的效果是各轮分类器的效果的加和和调整【有趣的是各分类器的权值之和并不为1】</p><h1 id="2-AdaBoost算法的训练误差分析"><a href="#2-AdaBoost算法的训练误差分析" class="headerlink" title="2 - AdaBoost算法的训练误差分析"></a>2 - AdaBoost算法的训练误差分析</h1><p>用数学方法能够证明以下几点：</p><ul><li>AdaBoost的训练误差有上界</li><li>可以在每一轮选取适当的基本分类器，使得训练误差下降更快</li><li>在一定条件下，AdaBoost的训练误差是以指数速率下降的</li></ul><h1 id="3-AdaBoost算法的解释"><a href="#3-AdaBoost算法的解释" class="headerlink" title="3 - AdaBoost算法的解释"></a>3 - AdaBoost算法的解释</h1><p>可以认为AdaBoost算法是：模型为加法模型、损失函数为指数函数、学习算法为前向分布算法 时的二分类学习方法</p><h2 id="前向分布算法"><a href="#前向分布算法" class="headerlink" title="前向分布算法"></a>前向分布算法</h2><p>前向分布算法是针对加法模型 $f(x)&#x3D;\Sigma^M_{m&#x3D;1}\beta_mb(x;\gamma_m)$</p><p>将复杂的优化问题，通过从前往后，每一步只学习一个基函数及其系数的方式，逐步逼近优化目标函数式，从而简化优化的复杂度</p><h1 id="4-提升树【和第5章相关】"><a href="#4-提升树【和第5章相关】" class="headerlink" title="4 - 提升树【和第5章相关】"></a>4 - 提升树【和第5章相关】</h1><p>以分类树或回归树作为基本分类器的提升方式</p><p>以决策树为基函数的提升方式——提升树</p><ul><li>分类问题决策树：二叉分类树</li><li>回归问题决策树：二叉回归树</li></ul><p>决策树的加法模型：$f_M(x)&#x3D;\Sigma_{m&#x3D;1}^MT(x;\Theta_m)$</p><p>采用前向分布算法，首先确定初始提升树：$f_0(x)&#x3D;0$</p><p>第m步的模型：$f_m(x)&#x3D;f_{m-1}(x)+T(x;\Theta_m)$</p><p>其中，$T(x;\Theta_m)$表示决策树，$\Theta_m$是决策树的参数，M 是决策树的个数</p><p>所以该算法就是通过经验风险极小化的方法确定下一棵决策树的参数</p><p>计算残差：$r_{mi}&#x3D;y_i-f_{m-1}(x_i), i&#x3D;1, 2,..,N$</p><p>拟合残差学习回归树，更新模型，并迭代。</p><ul><li><p>在实际的实现过程中，第一轮对实际值和预测值进行学习；第二轮使用第一轮模型结果与实际值的残差，以及新的残差预测值进行学习；…；最后，多轮的模型应该相加，得到最终的模型。</p></li><li><p><strong>也就是说</strong>，整个过程中，<strong>第一轮拟合实际值，然后后面每一轮进行优化调整拟合细节（残差、残差的残差）</strong>，最终加合起来实现最好的优化器</p></li></ul><p><strong>针对不同问题的提升树学习方法</strong>的主要区别在于损失函数：</p><ul><li>平方误差损失函数的回归问题</li><li>指数损失函数的分类问题</li><li>一般损失函数的一般决策问题</li></ul><h2 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h2><p>是针对一般损失函数的优化方法，利用了最速下降法</p><p><strong>关键</strong>：利用<strong>损失函数的负梯度在当前模型中的值</strong>，作为回归问题提升树算法中的<strong>残差</strong>的近似值，拟合回归树。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一句话介绍：对加法模型，使用前向分布算法实现从弱分类器到强分类器的提升。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;0-提升方法&quot;&gt;&lt;a href=&quot;#0-提升方法&quot; class=&quot;headerlink&quot; title=&quot;0 提升方法&quot;&gt;&lt;/a&gt;0 提升方法&lt;/h1&gt;&lt;p&gt;分类问题中，通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，可以提高分类的性能。&lt;/p&gt;
&lt;p&gt;抽象一下：找一些比较粗糙的分类规则（弱学习方法、弱分类器）是相对容易的，那么可以从这些弱学习方法出发，将一系列弱分类器组合，构成一个强分类器。&lt;/p&gt;
&lt;h2 id=&quot;两个关键问题&quot;&gt;&lt;a href=&quot;#两个关键问题&quot; class=&quot;headerlink&quot; title=&quot;两个关键问题&quot;&gt;&lt;/a&gt;两个关键问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在每一轮中如何改变训练数据的权值或概率分布&lt;/li&gt;
&lt;li&gt;如何将弱分类器组合成强分类器&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>春招-笔试分享</title>
    <link href="http://yoursite.com/2021/04/26/%E6%98%A5%E6%8B%9B-%E7%AC%94%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2021/04/26/%E6%98%A5%E6%8B%9B-%E7%AC%94%E8%AF%95%E5%88%86%E4%BA%AB/</id>
    <published>2021-04-26T02:42:49.000Z</published>
    <updated>2021-05-12T02:27:52.461Z</updated>
    
    <content type="html"><![CDATA[<p>字节跳动的笔试记录是最详细的，但是也是唯一一个没有成功的。</p><p>今天带来的一手笔试题目难度各异，分别来自美团、阿里和华为。总体来说，阿里的题目数据量大、用时紧张，很难完整得出结果；美团的题目较多，但上手也比较容易；华为题目虽然相对简单，但是输入输出的数据格式非常糟糕。</p><p>下面对部分留下记录的题目进行简单分析：</p><span id="more"></span><h1 id="1-阿里笔试"><a href="#1-阿里笔试" class="headerlink" title="1. 阿里笔试"></a>1. 阿里笔试</h1><p>比较难，关键感受：测试用例非常完整，很难通过用例，一个测试用例都没有过。</p><h2 id="1）牌游戏问题"><a href="#1）牌游戏问题" class="headerlink" title="1）牌游戏问题"></a>1）牌游戏问题</h2><p>题目描述：n副牌，每副有m张（就是1到m），每副牌中抽1张，问相加之和为k的抽取方案有多少种？</p><p>给出的测试例会有T组，需要一下子给出他们的结果。</p><p>这道题似乎在Leetcode上找到了近似的题目，ta的解决方法是<strong>概率</strong>的方法</p><h2 id="2）-零件优化问题"><a href="#2）-零件优化问题" class="headerlink" title="2） 零件优化问题"></a>2） 零件优化问题</h2><p>题目描述：n个零件，对每个零件进行一次空间 或 时间优化（二选一，且必选），每种优化带来的不稳定值不同</p><p>这些零件中，有的零件之间会有冲突，总计 m 条冲突，冲突零件不可组合</p><p>请找到最佳组合方案，要求不稳定值最小。</p><p>思路：这道题相比1）题其实可解性稍高，比如可以使用并查集的方式建立零件之间的联系（两种联系，一是冲突问题，二是不稳定值之和），然后寻找最小的不稳定值。</p><h2 id="其他笔试"><a href="#其他笔试" class="headerlink" title="其他笔试"></a>其他笔试</h2><p>在早期的阿里云笔试中，题目是二叉树的中序遍历问题</p><p>在一棵二叉搜索树中，找到第 k 小的数字</p><h1 id="2-美团笔试"><a href="#2-美团笔试" class="headerlink" title="2. 美团笔试"></a>2. 美团笔试</h1><p>一共5道题，难度适中，可解性比较高。</p><h2 id="1）积木问题"><a href="#1）积木问题" class="headerlink" title="1）积木问题"></a>1）积木问题</h2><p>题目描述：</p><p>共有n块积木，每个积木上写了一个数字（0-9之间的数字）。</p><p>可以任一将其中一块积木换成其他数字，希望更换后的数字串特点是：</p><p>1）回文最好</p><p>2）越小越好</p><p>不能回文，就越小越好。</p><p>输出：最佳的积木更换方案后的情况。</p><p>思路：</p><p>1）首先需要检查是不是回文，用双指针前后移动，观察到某一位是不是相同，如果不同，试图更换积木，看更换后是不是回文，仍然不是，那么特点1）无望，就换成更小的积木</p><p>2）直接从最高位开始，不是0的那一位换成0，就是最小的</p><p>现在看来，当时的解法有瑕疵，回文的检查做了两次，其实只需要一次就可以了，更换数字放在中间，然后继续检查就可以了</p><p>这道题过了72%的样子。</p><h2 id="2）打龙技能问题"><a href="#2）打龙技能问题" class="headerlink" title="2）打龙技能问题"></a>2）打龙技能问题</h2><p>题目描述：</p><p>在一个游戏中要打龙，有两种技能 1和2，分别需要消耗 c1 和 c2 点体力，使用任意一种技能都可以打败龙。</p><p>赢得游戏的要求是，不能连续输3局。</p><p>现在给出一串字符串，T和F，表示不用技能的情况下每局的输赢情况。</p><p>现在问，最少需要多少点体力，才能赢得游戏？</p><p>思路：</p><p>这道题的难度应该说很低了，贪心法。</p><p>就是从头开始遍历，输的次数累计到3，自然就要用一次技能，计算需要使用技能的最少数量；</p><p>两种技能中选择消耗体力比较少的那一种，就可以了。</p><p>这道题似乎是全过了。</p><h2 id="3）爬树问题"><a href="#3）爬树问题" class="headerlink" title="3）爬树问题"></a>3）爬树问题</h2><p>题目：有n棵树，高度分别为 $h_i$</p><p>现在要选择一棵树，作为分界点：</p><ul><li>所有奇数树给一队</li><li>所有偶数树给另一队</li></ul><p>注意：奇偶数是在去除选择的这棵树之后的顺序来计算的！！</p><p>要求：找到合适的位置，使得两队的高度应该一致，无法一致就返回false</p><p>思路：</p><p>这道题我用了前缀和的方法，首先遍历一遍所有树，记录到每一棵树的位置，前面的所有树中奇数和偶数树的高度。</p><p>然后遍历位置，以每个位置分界</p><p>所有奇数树：该位置前的奇数树+该位置后的偶数树</p><p>所有偶数树：该位置前的偶数树+该位置后的奇数树</p><p>这个题就是这个索引比较头大，最后似乎通过了82%</p><hr><p>还有两道题，题目已经不太记得了，通过率均为18%，进入面试环节。</p><h2 id="面试题目-大数加减法"><a href="#面试题目-大数加减法" class="headerlink" title="面试题目 - 大数加减法"></a>面试题目 - 大数加减法</h2><p>也就是计算器算法的实现</p><h1 id="3-华为笔试"><a href="#3-华为笔试" class="headerlink" title="3. 华为笔试"></a>3. 华为笔试</h1><h2 id="1）-球赛积分问题"><a href="#1）-球赛积分问题" class="headerlink" title="1） 球赛积分问题"></a>1） 球赛积分问题</h2><p>足球小组赛中，通常是两两进行两次比赛，分别当一次主场，然后赢方积3分，平则各积1分</p><p>给出一组比赛结果，记录了所有场次比赛的信息</p><p>其中球队名称为 a-z 的字母，不会超过26支球队</p><p>然后后面跟上比赛结果</p><p>输出要求：按照积分高低输出球队名，同积分则按照字母顺序</p><p>我的思路：</p><ol><li>本题用一个哈希表，或者字典就能很好解决积分计算的问题</li><li>最关键的算法是字典的排序，要按照value大小进行排序</li></ol><p>问题：</p><ol><li>本题在牛客网上进行时，还有一个问题是输入输出的格式问题，不是很规范，需要进行很多转换</li><li>字典的键的排序比较糟糕</li></ol><p>本题通过70%</p><h2 id="2）帽子问题"><a href="#2）帽子问题" class="headerlink" title="2）帽子问题"></a>2）帽子问题</h2><p>每个人知道自己的帽子颜色，和在场所有人的帽子颜色</p><p>现在给出一个数组，里面记录了部分人报告的数据，该数据表示在场人中帽子颜色和他相同的人的数量</p><p>比如在场有4个人戴了蓝色帽子，那么其中任一人被问时，回答都会是 3：表示还有3个人的帽子和自己颜色相同。</p><p>问：根据这个数组，在场最少有多少人。</p><p>这个逻辑问题的关键是：比如两个颜色的帽子数量是相同的，那么这两个群体中所有人回答的数量都是一样的，如果这两个群体中的人并没有被全部提问，那么我们就可以少算几个人了！</p><p>比如<code>2 2</code></p><p>有可能是 两个人颜色并不一样，但我们完全可以认为他们是一样的，这样全场最少就是3个人。</p><p>因此，本题的算法应该可以认为是贪心法，用数学方法解决：</p><p>用一个哈希表记录相同数字的数量，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">2</span><span class="comment"># 2个人答1</span></span><br><span class="line"><span class="number">2</span>: <span class="number">2</span><span class="comment"># 2个人答2</span></span><br><span class="line"><span class="number">3</span>: <span class="number">5</span><span class="comment"># 5个人答3</span></span><br></pre></td></tr></table></figure><p>那么，相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: <span class="number">2</span><span class="comment"># 二人同色，2人</span></span><br><span class="line"><span class="number">3</span>: <span class="number">2</span><span class="comment"># 三人同色，2人</span></span><br><span class="line"><span class="number">4</span>: <span class="number">5</span><span class="comment"># 四人同色，5人</span></span><br></pre></td></tr></table></figure><p>最少的情况就是：</p><p>$[\frac{记录数量}{同色人数}]_{取整}*同色人数$</p><p>比如：$[\frac{5}{4}]_{取整}<em>4&#x3D;2</em>4&#x3D;8$，这里取整要向上取整</p><p>本题全过。</p><h2 id="3）最少步数找到字符串"><a href="#3）最少步数找到字符串" class="headerlink" title="3）最少步数找到字符串"></a>3）最少步数找到字符串</h2><p>给出：一个长字符串、一个短字符串、在长字符串中的起始位置</p><p>要求：在长字符串的起始位置开始，可以向左或者向右开始找短字符串的头一个字符，然后按照顺序找下一个短字符串中的字符，找出总步数最少的那一种情况输出。</p><p>本题还是有一点难度的，就是说我应该怎么找最短的路径，而且本题中的长字符串是可以循环的。</p><p>结果：本题通过30%</p><h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><p>LeetCode - 11 装水的最大容器问题</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文主要是作者个人知识积累和记录，以便后续查看，如果能够帮助其他同学，将不胜荣幸。希望能够继续努力，夯实基础，在职业生涯大放异彩！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;字节跳动的笔试记录是最详细的，但是也是唯一一个没有成功的。&lt;/p&gt;
&lt;p&gt;今天带来的一手笔试题目难度各异，分别来自美团、阿里和华为。总体来说，阿里的题目数据量大、用时紧张，很难完整得出结果；美团的题目较多，但上手也比较容易；华为题目虽然相对简单，但是输入输出的数据格式非常糟糕。&lt;/p&gt;
&lt;p&gt;下面对部分留下记录的题目进行简单分析：&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法】7-SVM支持向量机</title>
    <link href="http://yoursite.com/2021/04/24/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B8%83/"/>
    <id>http://yoursite.com/2021/04/24/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B8%83/</id>
    <published>2021-04-24T02:08:14.000Z</published>
    <updated>2021-05-12T02:34:07.282Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话介绍</strong></p><p>支持向量机是一种分类模型，求解能够正确划分训练数据集并且几何间隔最大的分离超平面。</p><hr><h1 id="0-支持向量"><a href="#0-支持向量" class="headerlink" title="0.支持向量"></a>0.支持向量</h1><p>要理解什么是支持向量（support vector），首先需要理解以下几个概念：</p><p>如果我们有一堆数据（二维），在二维平面上分布如下图所示：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210424102729.jpg" alt="微信图片_20210424102729"></p><p>我们可以用一条直线将这堆数据分成两个部分：</p><p>【当这堆数据维数是<strong>3维</strong>，这条直线就成了<strong>平面</strong>；当数据<strong>维数更高</strong>，这条分隔线就成了<strong>超平面</strong>】以下统称超平面，数学表达为：</p><p>$w^<em>\cdot x + b^</em>&#x3D;0$</p><p>要说明的是，仅仅把这堆数据分离开，也许有无数个超平面可以做到；</p><p>我们做一些规范，最大几何间隔的分离超平面，是唯一且存在的。</p><p>很明显，分隔之后，有的点离这个超平面近，有的远，最近点到超平面的距离，称为<strong>间隔</strong>，这个最近的样本点的实例就被称为支持向量【本定义适用于线性可分情况下】。</p><p>支持向量在确定分离超平面中起决定性作用（不移动支持向量，分离超平面就不会变化），所以把这种分类模型称为支持向量机。</p><span id="more"></span><p>相关重要概念：</p><p><strong>类标记</strong>概念：可以理解为因变量，但是这个量更准确地说是观测值、实际值，而不是由函数计算出来的</p><p><strong>函数间隔</strong>：该点的类标记和超平面函数值的乘积$\hat \gamma_i&#x3D;y_i(w\cdot x_i+b)$【表示分类预测的正确性和确信度】</p><p><strong>几何间隔</strong>：规定$L||w||&#x3D;1$（L2范数）情况下的函数间隔$\gamma_i&#x3D;y_i(\frac{w}{||w||}\cdot x_i+\frac{b}{||w||})$【实例点到超平面的带符号的距离】</p><p><strong>硬间隔最大化</strong>：线性可分的训练数据集——线性可分支持向量机</p><p><strong>软间隔最大化</strong>：训练数据集近似线性可分——线性支持向量机</p><h1 id="1-线性可分支持向量机"><a href="#1-线性可分支持向量机" class="headerlink" title="1.线性可分支持向量机"></a>1.线性可分支持向量机</h1><p>找<strong>最大间隔分离超平面</strong>：该超平面对训练数据集的几何间隔至少应大于某个值；</p><p>凸优化问题 P116 与凸二次规划问题</p><h2 id="最大间隔法"><a href="#最大间隔法" class="headerlink" title="最大间隔法"></a>最大间隔法</h2><p>in：可分训练数据集，x 和对应的类标记 y</p><p>out：最大间隔分离超平面（参数 w 和 b），分类决策函数（$sign$函数）</p><h3 id="间隔边界"><a href="#间隔边界" class="headerlink" title="间隔边界"></a>间隔边界</h3><p>与最大间隔分离超平面相平行的平面中，有两个超平面 H1 和 H2 之间没有任何实例点，这两个超平面就是间隔边界，中间的距离就是间隔。</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/IMG_20201117_105233.jpg" alt="IMG_20201117_105233"></p><h3 id="线性可分支持向量机的对偶算法"><a href="#线性可分支持向量机的对偶算法" class="headerlink" title="线性可分支持向量机的对偶算法"></a>线性可分支持向量机的对偶算法</h3><p>使用拉格朗日乘子法进行问题的转化，注意我们的目标：要使间隔最大——也就是$||w||^2$尽可能小</p><p>分类决策函数：$f(x)&#x3D;sign(\Sigma_{i&#x3D;1}^N\alpha_i^<em>y_i(x\cdot x_i)+b^</em>)$只依赖于输入x和训练样本输入的内积</p><p>本方法中，将训练数据中对应于$\alpha^*_i&gt;0$的样本点称为支持向量【这里的是$\alpha_i$拉格朗日乘子】</p><blockquote><p>本方法核心思想是拉格朗日乘子法，在使用的过程中，将约束条件从几何间隔转化为了$\alpha_i$的约束</p></blockquote><h1 id="2-线性支持向量机"><a href="#2-线性支持向量机" class="headerlink" title="2.线性支持向量机"></a>2.线性支持向量机</h1><h2 id="训练样本线性不可分——软间隔最大化"><a href="#训练样本线性不可分——软间隔最大化" class="headerlink" title="训练样本线性不可分——软间隔最大化"></a>训练样本线性不可分——软间隔最大化</h2><p>其实主要是有少量的“特异点”（outlier），将这些点去除之后，剩下的样本就线性可分了。</p><p>我们并不能直接去除这些特异点，但是可以放宽标准，增加一个松弛变量，一来放宽限制，二来在目标函数中进行惩罚，确保误分类的样本尽量少。</p><blockquote><p>线性支持向量机包含线性可分支持向量机</p></blockquote><p>如果假设此处的分离超平面是$w^<em>\cdot x+b^</em>&#x3D;0$，那么 w 的解是唯一的，但是 b 的解可能不唯一，而是存在一个区间</p><p>下图表示软间隔的支持向量：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E8%BD%AF%E9%97%B4%E9%9A%94%E7%9A%84%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F.jpg" alt="软间隔的支持向量"></p><h2 id="合页损失函数"><a href="#合页损失函数" class="headerlink" title="合页损失函数"></a>合页损失函数</h2><p>在本问题中，还有一种以合页损失函数表示的目标函数：</p><p>$\Sigma_{i&#x3D;1}^N[1-y_i(w\cdot x_i+b)]_++\lambda||w||^2$</p><p>其中前半部分称为合页损失函数(hinge loss function)：$L(y(w\cdot x+b))&#x3D;[1-y(w\cdot x+b)]_+$</p><p>其中$[z]_+&#x3D;\left { \begin{aligned} z , z&gt;0 \ 0, z \leq 0\end{aligned} \right.$</p><p>该函数特性就是</p><ul><li>如果样本点被正确分类且函数间隔大于1，那么损失是0</li><li>其他情况下，损失是$1-y_i(w\cdot x_i+b)$</li></ul><p>下图中：</p><ul><li>左侧水平线是 0-1损失 的一部分【真正的二类分类问题】</li><li>虚线斜线是合页损失函数（不带1时）</li><li>实现是完整的合页损失函数，只有当确信度足够高时，损失才是0，要求更高</li></ul><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E5%90%88%E9%A1%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.jpg" alt="合页损失函数"></p><h1 id="3-非线性支持向量机与核函数"><a href="#3-非线性支持向量机与核函数" class="headerlink" title="3.非线性支持向量机与核函数"></a>3.非线性支持向量机与核函数</h1><p>非线性可分问题：如果能用一个超曲面将正负类正确分开，则称非线性可分问题</p><p>求解思路：进行非线性变换，将非线性问题变换为线性问题然后进行求解</p><h2 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h2><p>基本想法</p><ul><li>通过一个非线性变换将输入空间（欧式空间或者离散空间）对应于一个特征空间（希尔伯特空间）<br>使得输入空间中的超曲面模型对应于特征空间中的超平面模型</li><li>在特征空间中求解线性支持向量机</li></ul><h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>从输入空间 X 到 特征空间 H 的映射关系为$\phi(x)$</p><p>则输入空间中的两个量的核函数值应该是映射函数的内积$K(x,z)&#x3D;\phi(x)\cdot \phi(z)$，K 是核函数</p><p>给定核函数，特征空间和映射关系的取法不唯一</p><h2 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h2><p>只需要将线性支持向量机对偶形式中的内积换成核函数即可，当然实际计算过程过程麻烦了很多</p><h1 id="4-序列最小最优化方法"><a href="#4-序列最小最优化方法" class="headerlink" title="4.序列最小最优化方法"></a>4.序列最小最优化方法</h1><p>支持向量机的学习问题可以转化为求解凸二次规划问题，但样本容量较大时，算法会变得低效；</p><p>支持向量及的高效实现方法之一：<strong>序列最小最优化 SMO 算法</strong></p><p>分两步：</p><p>（1）选择变量的启发式方法，将原问题不断分解为子问题 </p><p>（2）求解两个变量二次规划的解析方法</p><p>直到所有变量满足KKT条件为止</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;一句话介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;支持向量机是一种分类模型，求解能够正确划分训练数据集并且几何间隔最大的分离超平面。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;0-支持向量&quot;&gt;&lt;a href=&quot;#0-支持向量&quot; class=&quot;headerlink&quot; title=&quot;0.支持向量&quot;&gt;&lt;/a&gt;0.支持向量&lt;/h1&gt;&lt;p&gt;要理解什么是支持向量（support vector），首先需要理解以下几个概念：&lt;/p&gt;
&lt;p&gt;如果我们有一堆数据（二维），在二维平面上分布如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210424102729.jpg&quot; alt=&quot;微信图片_20210424102729&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以用一条直线将这堆数据分成两个部分：&lt;/p&gt;
&lt;p&gt;【当这堆数据维数是&lt;strong&gt;3维&lt;/strong&gt;，这条直线就成了&lt;strong&gt;平面&lt;/strong&gt;；当数据&lt;strong&gt;维数更高&lt;/strong&gt;，这条分隔线就成了&lt;strong&gt;超平面&lt;/strong&gt;】以下统称超平面，数学表达为：&lt;/p&gt;
&lt;p&gt;$w^&lt;em&gt;\cdot x + b^&lt;/em&gt;&amp;#x3D;0$&lt;/p&gt;
&lt;p&gt;要说明的是，仅仅把这堆数据分离开，也许有无数个超平面可以做到；&lt;/p&gt;
&lt;p&gt;我们做一些规范，最大几何间隔的分离超平面，是唯一且存在的。&lt;/p&gt;
&lt;p&gt;很明显，分隔之后，有的点离这个超平面近，有的远，最近点到超平面的距离，称为&lt;strong&gt;间隔&lt;/strong&gt;，这个最近的样本点的实例就被称为支持向量【本定义适用于线性可分情况下】。&lt;/p&gt;
&lt;p&gt;支持向量在确定分离超平面中起决定性作用（不移动支持向量，分离超平面就不会变化），所以把这种分类模型称为支持向量机。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法】6-回归和最大熵</title>
    <link href="http://yoursite.com/2021/04/17/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%85%AD/"/>
    <id>http://yoursite.com/2021/04/17/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%85%AD/</id>
    <published>2021-04-17T01:36:13.000Z</published>
    <updated>2021-04-17T01:51:13.621Z</updated>
    
    <content type="html"><![CDATA[<p>一句话：本章提到两种应用了概率知识和最优化方法的对数线性数学模型。</p><hr><p>首先对本章知识进行<strong>定位</strong>：</p><ol><li>本章知识和前后联系都不是很大，但是 logistic 回归（sigmoid函数）确实十分常用的一个理论知识。</li><li>最大熵模型更是宏观地把回归和分类问题转换成最优化问题的数学模型。</li></ol><p><strong>本章公式极多，多为推导，在此大多数将不会列出，如果有兴趣，非常建议阅读原书。</strong></p><span id="more"></span><hr><h1 id="1-逻辑斯谛回归"><a href="#1-逻辑斯谛回归" class="headerlink" title="1.逻辑斯谛回归"></a>1.逻辑斯谛回归</h1><p>我们之前接触过 sigmoid 函数，有很多视频中也叫 logistic 函数&#x2F;回归等，原因大概就在本章。</p><h2 id="逻辑斯谛分布（logistic-distribution）"><a href="#逻辑斯谛分布（logistic-distribution）" class="headerlink" title="逻辑斯谛分布（logistic distribution）"></a>逻辑斯谛分布（logistic distribution）</h2><p>随机变量X如果满足：</p><p>​    分布函数：$F(x)&#x3D;\frac{1}{1+e^{-(x-\mu)&#x2F;\gamma}}$</p><p>​    概率密度函数：$f(x)&#x3D;\frac{e^{-(x-\mu)&#x2F;\gamma}}{\gamma(1+e^{-(x-\mu)&#x2F;\gamma})^2}$</p><p>那么$x$就满足逻辑斯谛分布。</p><p>(其中，$\mu$为位置参数，$\gamma &gt;0$为形状参数。)</p><p>分布特性：</p><p>​    分布函数呈S形曲线，以点$(\mu,\frac{1}{2})$中心对称。</p><p>​    概率密度函数，就是我们熟悉的——sigmoid函数的样子。</p><h2 id="二项逻辑斯谛回归模型"><a href="#二项逻辑斯谛回归模型" class="headerlink" title="二项逻辑斯谛回归模型"></a>二项逻辑斯谛回归模型</h2><p>【从分布上升到模型】</p><p>满足以下公式的条件概率分布就是二项逻辑斯谛回归模型：</p><p>$$P(Y&#x3D;1|x)&#x3D;\frac{exp(w\cdot x+b)}{1+exp(w\cdot x+b)}\ P(Y&#x3D;1|x)&#x3D;\frac{1}{1+exp(w\cdot x+b)}$$</p><p>根据该模型，可以比较两个条件概率值的大小，从而将 x 分到概率值比较大的类别 Y（1或0）中。</p><p>可以用<strong>极大似然估计法</strong>估计模型参数 w。</p><p>一个相关的知识概念：</p><p>​    几率（odds）：事件发生的概率 与 事件不发生的概率 的比值——$\frac{p}{1-p}$</p><p>​    对数几率（log odds）或 logit 函数：$logit(p)&#x3D;log\frac{p}{1-p}$ </p><h2 id="多项逻辑斯谛回归模型"><a href="#多项逻辑斯谛回归模型" class="headerlink" title="多项逻辑斯谛回归模型"></a>多项逻辑斯谛回归模型</h2><p>【模型推广】</p><p>$$P(Y&#x3D;k|x)&#x3D;\frac{exp(w_k\cdot x)}{1+exp(w_k\cdot x)}, k&#x3D;1,2,…,K-1\ P(Y&#x3D;K|x)&#x3D;\frac{1}{1+\Sigma_{k&#x3D;1}^{K-1}exp(w_k\cdot x)}$$</p><h1 id="2-最大熵模型"><a href="#2-最大熵模型" class="headerlink" title="2.最大熵模型"></a>2.最大熵模型</h1><p><strong>最大熵原理</strong>：（概率模型学习的准则）</p><p>​    <strong>在所有可能的概率模型分布中，熵最大的模型是最好的模型。</strong></p><p>​    或者描述为：在满足约束条件的模型集合中，熵最大的模型最好。</p><p>回忆第5章内容：</p><p>如果X的概率分布是P(X)，则<strong>熵</strong>为：$H(P)&#x3D;-\Sigma_xP(x)logP(x)$</p><p>熵的一个特性是：$0\leq H(P)\leq log|X|$</p><ol><li>其中，|X| 是 X 的取值的个数。</li><li>这个特性说明——熵有最大值（或者说有取值范围）。</li></ol><p><strong>熵取最大值的条件：</strong></p><ol><li>当且仅当 X 的分布是均匀分布时，熵最大。</li><li>在满足约束条件的情况下，把不确定的部分认为是“等可能”的，此时熵最大。</li></ol><p>举个栗子：</p><p>有两个约束条件</p><p>$$P(A)+P(B)&#x3D;\frac{3}{10}\ P(A)+P(B)+P(C)+P(D)+P(E)&#x3D;1$$</p><p>在缺少其他信息的情况下，可以认为：A 和 B 等概率，各为$\frac{3}{20}$，C、D和E 等概率，各为$\frac{7}{30}$</p><p><strong>最大熵模型：</strong></p><p>$$P_w(y|x)&#x3D;\frac{1}{Z_w(x)}exp(\Sigma_{i&#x3D;1}^nw_if_i(x,y))\Z_w(w)&#x3D;\Sigma_yexp(\Sigma_{i&#x3D;1}^nw_if_i(x,y))$$</p><p>​    其中，x 为输入，y 为输出， Zw 函数又叫规范化因子，fi 函数为任意实数值特征函数，w 是权值向量。</p><h1 id="3-模型学习"><a href="#3-模型学习" class="headerlink" title="3.模型学习"></a>3.模型学习</h1><p>书中使用了很大篇幅证明：最大熵模型学习中的<strong>对偶函数极大化</strong>等价于最大熵模型的极大似然估计（在此不搬运公式了）。</p><p>可以将模型学习总结如下：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0.png" alt="模型学习"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一句话：本章提到两种应用了概率知识和最优化方法的对数线性数学模型。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先对本章知识进行&lt;strong&gt;定位&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本章知识和前后联系都不是很大，但是 logistic 回归（sigmoid函数）确实十分常用的一个理论知识。&lt;/li&gt;
&lt;li&gt;最大熵模型更是宏观地把回归和分类问题转换成最优化问题的数学模型。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;本章公式极多，多为推导，在此大多数将不会列出，如果有兴趣，非常建议阅读原书。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（七）</title>
    <link href="http://yoursite.com/2021/03/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/"/>
    <id>http://yoursite.com/2021/03/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/</id>
    <published>2021-03-29T08:46:05.000Z</published>
    <updated>2021-04-24T02:11:13.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><!-- 链表 --></h1><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>这个题其实已经做过多次了，这次总结一下：</p><p>题目要求：给出一个链表的头节点，请反转整个链表，并且返回反转后的链表的头节点。</p><p>这个题用递归的方法简直是非常之妙，而且十分经典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNone:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">        last = self.reverse(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure><p>这个做法简直非常精妙，充分体现了递归方法中的关键：</p><p>1）找一个最简问题，解决它</p><p>2）充分理解并相信函数能解决你的问题</p><span id="more"></span><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><p>这道题要求的是 反转链表中的某一部分</p><p>比如给出 head，left，right，请反转从 left 到 right 的部分</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img"></p><p>根据前面做过的反转链表，这里的思路大概有两种：</p><ol><li>先反转 left 到 末尾，再反转 right 到末尾；但是这种方法仔细一想就是不可能的，因为第一次反转之后，末尾的元素到前面来了，要想再把它们翻转回去是不可能的。</li><li>只翻转 left 到 right 的部分，然后再拼接起来。</li></ol><p>第2种方法是可行的，但是需要考虑的问题有：</p><ol><li>要记录 left 的前一个节点 pre</li><li>要记录 right 的后一个节点 succ（successor）</li><li>pre 的 next 指向反转后的头节点</li><li>反转后的尾节点的 next 指向 succ</li></ol><p>可见是一个比较复杂的问题，应该怎么处理呢</p><hr><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>分为7个步骤：</p><p>1）在头节点前添加哑节点防止头节点变化，哑节点不能动</p><p>2）创建一个移动节点寻找左节点的上一个节点，其实也就找到了左节点</p><p>3）再创建一个移动节点到右节点，其实也就找到了右节点的下一个节点</p><p>4）截断中间部分</p><p>5）反转中间部分（用一个无返回值的函数进行操作）</p><p>6）重接中间部分</p><p>7）返回哑节点的下一个节点</p><blockquote><p>我的题解：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/guan-fang-jie-fa-pythonfu-xian-by-yue-wo-kebj/">官方解法-python复现</a></p></blockquote><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><!-- 单调栈、哨兵 --></h1><h2 id="84-柱状图中的最大的矩形"><a href="#84-柱状图中的最大的矩形" class="headerlink" title="84. 柱状图中的最大的矩形"></a>84. 柱状图中的最大的矩形</h2><p>问题描述：</p><p>给出一个柱形图（数组），数组中的元素表示柱的高度，现在需要在柱形图中找出一个能画出的最大的矩形，比如：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p><hr><p>先从暴力解法——枚举开始。</p><p>（1）枚举宽度【左右边界】</p><ol><li>左边界从0开始遍历</li><li>右边界从左边界开始遍历</li><li>高度取从左边界到右边界区间最矮高度</li><li>计算面积，记录最大面积</li></ol><p>这样一看，这个题的暴力方法其实也是很规矩的。</p><p>缺点是：时间复杂度在 O(N^2)，因为有循环套循环，而且占用内存也不小。</p><p>（2）枚举高度</p><p>这种方法的思想是先找定一个高度点，然后左右扩展确定边界【边界的特征是两边的高度将小于边界的高度】，最后计算出面积。</p><p>也就是扩展左右的柱子，高度均不能小于 h。</p><p>这个方法其实就是在找能够覆盖第 i 个柱子的最大矩形，可以参考：<a href="https://blog.csdn.net/Zolewit/article/details/88863970">84. 柱状图中最大的矩形&#x2F;C++</a></p><hr><p>题目有一些特点：</p><ol><li><p>借鉴枚举高度的方法，我们应该找到左右两侧 最近的 高度小于 h 的柱子。</p></li><li><p>一个结论和思想：</p><ol><li>如果两根柱子：<code>j0 &lt; j1</code>，<code>height[j0]&gt;height[j1]</code></li><li>那么对于 <code>j1</code> 之后的柱子，<code>j0</code>一定不是 最近的 小于 柱子高度的柱子。【至于高度大于它的，其实不重要】</li></ol></li></ol><p>第一个特点说明，我们要找的就是比当前柱子小的最近的柱子，包括左边和右边；</p><p>第二个特点说明，当我们找到这个最近的之后，远处的其实不重要了，比这个高的也不重要了【就可以删除了】</p><p>所以使用了 单调栈这样一个思路去求解这个问题</p><hr><p>使用单调栈：</p><p>我个人觉得这篇题解讲的很好：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/">暴力解法、栈（单调栈、哨兵技巧）</a></p><p>它讲明白了一件事情，就是栈顶元素删除之前做了什么：</p><ul><li>其实直到我们找到一个比较短的柱子时，我们才知道以上一个值为高度的矩形到这里结束了，一个面积就求出来了</li><li>然后后面的高度就会以现在这个短的为基准了</li></ul><p>总结一下，我们是怎么确定一个柱形的面积的：</p><ul><li>我们记录了下标，下标对应的高度</li><li>当我们发现这个下标比上一个下标矮的时候，好了，说明上一个下标对应的高度的矩形到头了，可以计算了</li><li>而上一个下标对应的高度的矩形，其实还要找一下左边界，什么时候左边界也比它小了，这个区间找到了，这个高度的矩形面积可以算了，这个高度就完全结束了</li></ul><p>上面说的这个过程可能需要 进行多次，直到左边没有高度 小于 当前的高度了</p><p>这个过程中，缓存数据是从左往右的，计算结果是从右往左的，所以就是后进的先出，这样的数据结构就是栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 先求一下总长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        <span class="comment"># 这是结果，记录面积</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 这个栈用来做单调栈，栈是用来记位置的，而不是记高度的</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对数组一次遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 遇到了下降的情况，开始出栈和计算了</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="comment"># 出栈，要计算面积了</span></span><br><span class="line">                cur_height = heights[stack.pop()]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 这个是？保证绝对单调吗？</span></span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> cur_height == heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 栈没有空，那么左右边界求一下</span></span><br><span class="line">                    cur_width = i - stack[-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 栈空了，那就是全长</span></span><br><span class="line">                    cur_width = i</span><br><span class="line">                <span class="comment"># 计算面积</span></span><br><span class="line">                area = <span class="built_in">max</span>(area, cur_height * cur_width)</span><br><span class="line">            <span class="comment"># 这是新的高度（可能是更高的，也可能是栈操作了一遍之后新加的高度）</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 数组遍历结束了，但是栈可能还没有清空</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur_height = heights[stack.pop()]</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> cur_height == heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 因为数组已经遍历结束了，这里留下来的高度就是从记录位置到尾部的了</span></span><br><span class="line">                cur_width = n - stack[-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_width = n</span><br><span class="line">            area = <span class="built_in">max</span>(area, cur_height * cur_width)</span><br><span class="line">            </span><br><span class="line">       <span class="keyword">return</span> area </span><br></pre></td></tr></table></figure><p>上面这种方法做了分类讨论：</p><ul><li>弹栈的时候，栈有可能是空的</li><li>遍历完成后，栈里还有元素</li></ul><p>解决方法：【<strong>哨兵方法</strong>】Sentinel</p><ul><li>数组两端加上两个 0：只要比 1 严格小就可以了<ul><li>左边的哨兵一定比数组中所有元素都小，绝对不会出栈</li><li>右边的哨兵一定比数组中所有元素都小，会让所有元素都出栈（除了左边的哨兵）</li></ul></li><li>这样就可以不用分类讨论了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 先向栈中放入哨兵</span></span><br><span class="line">        stack = [<span class="number">0</span>]</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">while</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                cur_height = heights[stack.pop()]</span><br><span class="line">                cur_width = i - stack[-<span class="number">1</span>] -<span class="number">1</span></span><br><span class="line">                area = <span class="built_in">max</span>(area, cur_height * cur_width)</span><br><span class="line">            <span class="comment"># 下面这一句为什么是在 while循环外的？</span></span><br><span class="line">            <span class="comment"># 这个地方不要担心 i 不满足要求，因为如果不满足要求，过不了上面的while循环</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure><p>居然一下子简洁了这么多，哨兵的作用真的很厉害</p><blockquote><p>python 实现栈的方法其实就是 list，栈顶就是 list 尾部</p></blockquote><blockquote><p>我想起有一个<strong>收集雨水</strong>的问题，其实有一定的联系，都是单调栈的问题</p><p>单调栈问题：739、469、42</p></blockquote><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><!-- 哈希表 --></h1><h2 id="1603-设计停车系统"><a href="#1603-设计停车系统" class="headerlink" title="1603. 设计停车系统"></a>1603. 设计停车系统</h2><p>题目描述：</p><ol><li>告诉了三种车位的数量：大、中、小车位各有几个</li><li>然后告诉车的类型：大、中、小车辆</li></ol><p>最后，问每辆车是不是有位置停，返回布尔值</p><p>而且这个问题就是先到先得，车位满了后面的就是 false</p><p>最简单的想法，直接3个 if 进行判断</p><p>稍微好一点的方法，可以使用一个哈希表进行3种车位的存储，这样搜索起来也比较快：内存消耗少了一点点，用时居然还是很高</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>描述：</p><p>数学中，括号是成对出现的，而且括号应该是 由内向外完整嵌套的，比如：</p><p><code>&#123;[()]&#125;</code> 就是有效的</p><p><code>&#123;[&#125;])</code> 方括号位置不对，圆括号少了一半就是无效的</p><p>现在就是给一个全是括号的字符串，检测是不是有效的</p><hr><p>这个题曾经看过了题解，记下了一个重要的方法：哈希表</p><p>用 左括号 做 key，右括号 做value</p><p>我自己想出以下步骤：</p><ol><li>遍历字符串<ol><li>如果是左括号<ol><li>新建一个 need 列表存储 需要的右括号</li></ol></li><li>如果是右括号，看是不是 need 中最后一个（最新需要的）右括号<ol><li>如果是，need 中最新的右括号扔掉【其实就是栈啊】</li><li>如果不是，直接 False</li></ol></li></ol></li><li>最后看 need 是不是空的<ol><li>如果是，返回 True</li><li>如果不是，返回 False</li></ol></li></ol><p>其中几个细节点：</p><ol><li>怎么样检查是不是左括号？<ol><li>方法一，需要一个左括号的列表</li><li>方法二，检查 括号是不是字典的一个 key：<code>if xxx in dict.keys():</code></li></ol></li></ol><h1 id="-3"><a href="#-3" class="headerlink" title=""></a><!-- Hot 100 问题 --></h1><h2 id="5-最长回文子串问题"><a href="#5-最长回文子串问题" class="headerlink" title="5. 最长回文子串问题"></a>5. 最长回文子串问题</h2><p>问题描述：</p><p>给一个字符串，请返回该字符串中最长的回文子串（串，应该是连续的）</p><hr><p>首先想到暴力解法：</p><p>枚举所有可能的字符串（的左右两边）</p><p>然后判断这个子串是不是回文的，并记录最长的回文子串</p><p>我的写法超时了，最大问题在于怎么判断是不是回文的，如果对于每一个可疑的子串都采用<code>双指针</code>的方法进行判断，那么肯定会超时，所以才需要用算法</p><hr><p>方法一：动态规划</p><p>从大的角度讲，枚举所有可能的子串是必要的，这个复杂度可能少不了</p><p>但是</p><ol><li>判断回文串的方法可以采用动态规划方法，如果 <code>[i+1, j-1]</code> 的子串是回文串，那么<code>[i, j] 且 s[i]==s[j]</code>的子串就是一个回文串，这样的判断方法比每一次都用双指针要好得多；</li><li>怎么样知道 <code>[i+1, j-1]</code> 的子串是不是回文串呢，这里就需要记录一定的信息了，怎么样既能记录开头，也能记录结尾，还能记录是不是回文串呢？<code>二维数组</code></li></ol><p>注意两种情况：</p><ol><li><code>[i, i]</code> 一定是回文的</li><li><code>[i, i+1]</code> 是不是回文的，要看 <code>s[i]</code> 和 <code>s[i+1]</code> 是不是相等</li></ol><p>官方解答中使用的遍历方法是按照 子串长度 和 起始位置 进行枚举，这种方法确实可以实现枚举，而且优点是对同一个长度的子串，可以使用一个简单的判断条件进行排除</p><hr><p>方法二：中心扩展</p><p>这个方法很有意思</p><p>回文串有两种：奇数形和偶数形</p><p>奇数形的中心应该是 <code>s[i] == s[i]</code></p><p>偶数形的中心应该是 <code>s[i] == s[i+1]</code></p><p>然后所有的回文串都是有这样的中心的，并且应该根据这个中心向两边进行扩展，所以我们的步骤就是：</p><ol><li>枚举中心，并检查奇数形和偶数形两种可能</li><li>向两边进行扩展，直到出现不对称的情况</li><li>返回最长长度</li></ol><p>这个方法其实时间复杂度还是 <code>O(n^2)</code>，因为少不了要向两边进行扩展</p><p>但是这个思路可能比较清晰</p><hr><p>细节一：原字符串长度为1</p><p>按照第二个思路进行尝试，部分错误，案例为：<code>a</code> ，结果输出为空</p><p>问题还是没有对一个字母，或者一个数字的情况做很好的处理</p><p>我的错误方法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    ...</span><br><span class="line">    ans = s[elft, right]</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>这样导致一个问题就是，如果 n &#x3D; 1，那么会直接跳过循环遍历，直接把空的 ans 导出了</p><p>官方的方法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    修改 start, end 的值</span><br><span class="line"><span class="keyword">return</span> s[start: end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>其实主要还是最后一句的功劳，就是把0，0的情况也考虑在内了</p><p>可以对我的方法进行一点点修改，保证不是空的就可以了</p><p><code>return s[0] if not ans else ans</code></p><p>细节二：索引相减 和 字符串长度不一定相等</p><p> <code>right - left</code> 和 <code>len()</code> 不是相等的，差了1</p><p>所以应该要 <code>right-left == len(ans)-1</code></p><p>但是如果要更新 <code>ans</code> 结果子串的时候，又应该是 <code>ans = s[left:right+1]</code>以免 right 字符没有加入到子串当中</p><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h2><p>输入：</p><p>两个字符串，s - 要匹配的字符串，p-正则表达式</p><p>正则表达式中会有三种值：</p><ul><li>字母，直接匹配，必须相等</li><li><code>.</code> 匹配任意一个单个字符</li><li><code>*</code> 匹配任意个前面的一个元素</li></ul><p>需要返回的是，是否能够进行匹配</p><hr><p>这个题的关键难点在 <code>.*</code> 表示可以匹配任意多个任意字符</p><p>如果正则表达式中这两个后面还有字符呢，那就会非常棘手</p><p>这类问题之前其实也有，就是有多种可能性的问题 —— 动态规划</p><hr><p>这道题做动态规划，最难的一点是怎么样把问题思考全面，还有就是初始化非常容易出错</p><p>动态规划思路：</p><ol><li><code>p[j] == s[i]</code> ，最方便，<code>dp[i][j] = dp[i-1][j-1]</code></li><li><code>p[j] == &#39;.&#39;</code>，也还可以，<code>dp[i][j] = dp[i-1][j-1]</code></li><li><code>p[j] == &#39;*&#39;</code>，比较麻烦，需要分两种情况<ol><li><code>p[j-1] != s[i]</code>，那么就是说 <code>*</code> 前面的字母也不匹配，那么直接<code>dp[i][j] = dp[i][j-2]</code></li><li><code>p[j-1] == &#39;.&#39;</code>或<code>p[j-1] == s[i]</code>，那么就要考虑匹配多少的问题呢，有两种情况，匹配了很多，或者一个都没有匹配&#x3D;&#x3D;【这里给出了一个很好的例子，比如 “###b”和“###b*”】&#x3D;&#x3D;<ol><li>匹配了很多 <code>dp[i][j] = dp[i-1][j]</code></li><li>一个都没有匹配 <code>dp[i][j] = dp[i][j-2]</code></li><li>以上两种情况，只要出现一种就可以了，所以是 or 的关系</li></ol></li></ol></li></ol><p>初始化问题：</p><ol><li>如果全部初始化为 False，那么不管怎么变，最后都是 False，所以一定要有Ture，但是又不能直接判断出某一个是True，所以方法有在 s 和 p 前面都加一个空格，然后定义第一个 <code>dp[0][0]=True</code></li><li><code>dp</code>矩阵是个二维矩阵，到底需要多大？而且它的索引又会和<code>s</code>和<code>p</code>的索引相关</li><li>如果 <code>p</code> 字符串并不能覆盖 <code>s</code>字符串呢？</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(s)</span><br><span class="line">        n = <span class="built_in">len</span>(p)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j-<span class="number">1</span>] ==<span class="string">&#x27;*&#x27;</span>: dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># i 指针，在 s 上滑动</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            r = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                c = j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> p[c] == s[r] <span class="keyword">or</span> p[c] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[c] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> p[c-<span class="number">1</span>] == s[r] <span class="keyword">or</span> p[c-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j-<span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><blockquote><p>最后参考内容：</p><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/">https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/</a></p></blockquote><h2 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11. 盛水最多的容器"></a>11. 盛水最多的容器</h2><p>是接雨水问题、柱状图中最大矩形问题的前序问题</p><p>这个相对比较简单一点</p><p>两个柱子之间有阻挡也没有关系</p><p>用双指针-左右指针进行收缩</p><p>如果左边高度比较低，就移动左边指针</p><p>如果右边高度比较低，就移动右边指针</p><p>但是这道题的耗时有点离谱，大家都是怎么刷时间的</p><h2 id="34-在排序数组中查找元素的第一个和最后一个位置-二分法"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-二分法" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置 - 二分法"></a>34. 在排序数组中查找元素的第一个和最后一个位置 - 二分法</h2><p>数组是有序的，给定一个target</p><p>查找 target 在数组中的位置</p><hr><p>这个题其实是看过算法的，但是二分法就是 细节魔鬼！</p><p>有一个非常好的题解：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/34po-shi-wu-hua-de-er-fen-cha-zhao-zan-men-yi-bu-y/">34.【朴实无华的二分查找】咱们一步一步来！</a></p><p>这篇文章中的思路非常好，在不会跑的时候，就先用走的。</p><p>二分法在本问题中的应用是：</p><ol><li>找到target的左边界</li><li>找到target的右边界</li></ol><p>整个流程是：</p><ol><li>找到target在区间中的左右边界：用二分法</li><li>对左右边界进行判断，决定最后输出情况</li></ol><hr><p>核心：怎样找到 target 的左右边界，注意细节</p><p>找左边界：</p><ol><li>left 取开头，right 取结尾，先把左边界的原始值设置为-2，如果根本就不需要进行下面的判断，左边界将为-2</li><li>循环，条件是 left &lt;&#x3D; right<ol><li>二分法，找中间位置 mid</li><li>如果 mid 位置数值 小于 target【说明左边界在 mid 的右边】，那就<ol><li>left 换到 mid+1 的位置</li></ol></li><li>如果 mid 位置数值 大于等于 target【说明左边界在 mid 的左边，但是具体在哪还不确定】<ol><li>right 换到 mid-1 的位置</li><li>把 左边界 也移到 right 的位置</li></ol></li></ol></li></ol><p>找右边界：【虽说左边和右边可以类比，但是细节真的还是不太一样】</p><ol><li>left 取开头，right 取结尾，先把右边界的原始值设置为-2，如果根本就不需要进行下面的判断，右边界将为-2【这一步基本相同】</li><li>循环，条件是 left &lt;&#x3D; right<ol><li>二分法，找中间位置 mid</li><li>如果 mid 位置数值 大于 target【说明右边界在 mid 的左边】<ol><li>right &#x3D; mid - 1</li></ol></li><li>如果 mid 位置数值 小于等于 target【说明左边界在 mid 的右边，但是具体在哪还不确定】<ol><li>先把left移过去，缩小区间，left &#x3D; mid + 1</li><li>把右边界也移过去，rightBorder &#x3D; left</li></ol></li></ol></li></ol><p>上面两个过程就把寻找左右边界的工作走完了，这样也比较清晰，但是里面到底是什么时候修改 left 或者 right，什么时候记录左右边界值，其实还是需要一点讲究的，需要注意一下！</p><p>接下来是判断，会有几种情况：</p><ol><li>最简单的肯定是有target，那么左右边界之间应该是不太一样的，返回 [leftBorder+1, rightBorder-1]</li><li>如果全部比 target 大，或者全部比 target 小呢？这个时候肯定会有一侧的边界为-2，就是没有变化过，所以也可以进行得出了【-1， -1】</li><li>其他情况，【-1， -1】</li></ol><p>可能最不容易判断的情况是 [1], target&#x3D;1的情况，其实这个时候，leftBorder为-1，rightBorder为2，所以是可以得出结论的【0，0】</p><h1 id="-4"><a href="#-4" class="headerlink" title=""></a><!-- ASCII --></h1><h2 id="804-唯一摩尔斯密码词"><a href="#804-唯一摩尔斯密码词" class="headerlink" title="804. 唯一摩尔斯密码词"></a>804. 唯一摩尔斯密码词</h2><p>这个问题是说，给了一个写有多个词的 list</p><p>根据摩尔斯密码分别进行转化，然后判断这些词的摩尔斯密码中有没有相同的</p><p>返回的是不相同的摩尔斯密码的数量</p><hr><p>补充知识：</p><h3 id="python-与-ASCII码"><a href="#python-与-ASCII码" class="headerlink" title="python 与 ASCII码"></a>python 与 ASCII码</h3><p>这道题给的是小写字母</p><p>密码本也是一个list，怎么样进行检索</p><p>小写字母的 ASCII 码是 97-122</p><p>大写字母的 ASCII 码是 65-90</p><p>数字的 ASCII 码是 48-57</p><p>可以使用 <code>ord(str)</code> 函数将字符转换为相应的 ASCII 码</p><p>还可以使用 <code>chr(int)</code> 将 ASCII 码转换为相应的字符</p><p>还可以直接使用 <code>ord(x) - ord(&#39;a&#39;)</code> ，这样即使不知道 a 的ASCII 码是多少也可以进行使用</p><hr><p>第一步，获得所有单词的摩尔斯密码串：</p><p>本题使用就这样使用</p><p><code>ord(str)-97</code> 就是这个小写字母在密码本中的索引值了</p><p>获得摩尔斯密码串是比较容易的</p><p>第二步，分析这些密码穿是不是又重复的：</p><ul><li>我用了 set() 集合，主要是存储和查询</li><li>官方用了哈希表进行存储，其实差不多</li></ul><hr><p>再补充知识：</p><h3 id="python中的集合"><a href="#python中的集合" class="headerlink" title="python中的集合"></a>python中的集合</h3><p>创建一个集合，可以用</p><p><code>B = &#123;a, b, &#39;c&#39;&#125;</code> 这样的形式</p><p>但是如果创建 空集合，必须是 <code>A = set()</code>， 如果是 <code>&#123;&#125;</code> 就成了创建空的字典了</p><p>增加元素：<code>add</code></p><p>将元素拆分成一个一个字符再添加进集合：<code>update</code></p><p>删除某个元素：</p><ul><li><code>remove</code>，不存在会报错</li><li><code>discard</code>， 不存在也不报错</li><li><code>pop</code>，删除并返回【注意是任意元素】</li><li><code>clear</code>，清空集合</li></ul><p>集合与集合之间可以进行数学运算：交并包含等关系</p><hr><p>本期十题就到这里，接下来将会主攻 LeetCode Hot 100 问题！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;!-- 链表 --&gt;&lt;/h1&gt;&lt;h2 id=&quot;206-反转链表&quot;&gt;&lt;a href=&quot;#206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;206. 反转链表&quot;&gt;&lt;/a&gt;206. 反转链表&lt;/h2&gt;&lt;p&gt;这个题其实已经做过多次了，这次总结一下：&lt;/p&gt;
&lt;p&gt;题目要求：给出一个链表的头节点，请反转整个链表，并且返回反转后的链表的头节点。&lt;/p&gt;
&lt;p&gt;这个题用递归的方法简直是非常之妙，而且十分经典。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, val=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;=&lt;span class=&quot;literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.val = val&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reverse&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, head: ListNode&lt;/span&gt;) -&amp;gt; ListNone:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; head &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; head.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; head&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        last = self.reverse(head.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt; = head&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head.&lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; last&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这个做法简直非常精妙，充分体现了递归方法中的关键：&lt;/p&gt;
&lt;p&gt;1）找一个最简问题，解决它&lt;/p&gt;
&lt;p&gt;2）充分理解并相信函数能解决你的问题&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="单调栈" scheme="http://yoursite.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="hot100" scheme="http://yoursite.com/tags/hot100/"/>
    
    <category term="ascii" scheme="http://yoursite.com/tags/ascii/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（六）</title>
    <link href="http://yoursite.com/2021/03/18/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
    <id>http://yoursite.com/2021/03/18/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/</id>
    <published>2021-03-18T01:47:17.000Z</published>
    <updated>2021-03-18T01:50:09.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><!-- 双指针 --></h1><h2 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a>424. 替换后的最长重复字符</h2><p>输入：字符串 s，全部是大写字母； 整数 k</p><p>要求：最多可以将字符串s中的任意 k 个字符进行替换</p><p>输出：最长重复字符的数量</p><hr><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>官方题解的方法确实很妙：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103753750.png" alt="image-20210202103753750"></p><p>如果该数值大于 k ，自然是不符合题意，那么右指针移动，左指针也移动：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103935966.png" alt="image-20210202103935966"></p><p>如果数值小于等于 k，那么说明符合题意，右指针移动，左指针不用移动：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202104027261.png" alt="image-20210202104027261"></p><p>右指针 - 左指针 就是最长重复子字符串的长度</p><p><strong>问题在于，怎么计算区间内非重复字符的数量？</strong></p><span id="more"></span><p>从代码来看，每次移动右指针后，都是以右指针的新字符作为标准，认为该字符就是最多的字符</p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/">https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/</a></p><p>该回答中的第二个小问题似乎回答了这一点</p></blockquote><p>如果右边界读到了移出左边界的字符，那么最长子串得以被正确维护</p><p>如果右边界不是移出左边界的字符，要让子串更长，总长度肯定要比之前的值还要长，也不会错过最优解</p><p>这个回答还是稍微有点拐弯。</p><blockquote><p>还有一个细节，就是再移动左端点的时候，当然也会把左端点排除出去</p><p>也就是说永远只统计区间内各数值的情况</p></blockquote><p><strong>此外，如何更新最长子串长度值maxCount？</strong></p><p>这要对比右端点的重复情况与当前最大子串长度</p><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>输入：一个整数数组，表示的是一些柱子的高度</p><p>要求：如果两根高柱子之间有矮柱子，或者有空隙，那么就可以存储雨水</p><p>输出：总共能够存储的雨水的最大量是多少</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/rainwatertrap.png" alt="rainwatertrap"></p><p><strong>本质</strong>：</p><p>对于每一个位置，需要知道该位置左边的最高高度，和右边的最高高度，像木桶原理一样决定了当前位置能够存储的水量</p><p><strong>暴力解法</strong>：</p><p>每到一个位置，进行遍历</p><p><strong>稍微优化</strong>：</p><p>那就是先通过遍历的方法记录每一个位置左侧的最大值，反向遍历记录每一个位置右侧的最大值</p><p>如果该位置确实有空间，就可以计算出可以增加的水量</p><p><strong>双指针方法</strong>：</p><p>这个方法确实很妙</p><p>（1）其实决定一个位置水量的，是最短的木板，比如说一个位置的左右都有高木板，近处的木板可能比远处还要高，但是这其实并不是很影响此处的存水量</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210204114211048.png" alt="image-20210204114211048"></p><p>比如上面这张图的位置5：右侧，7位置可能比位置10还要高，但是从位置10就能看出，5位置至少可以存放2个单位的雨水</p><p>（2）边界处的存水量，其实只需要一个短边就能判断</p><p>比如上面的图片，left位置能不能存放雨水，我们可以简单比较一下 leftmax 和 rightmax，发现 leftmax 更小，那么leftmax就是影响更大的“短板”——minVal</p><p>而且因为这个短板更靠近左边，所以对 left 位置影响更大，需要考虑left位置的情况，而不需要考虑 right 位置</p><blockquote><p>关键因素是，在考虑left位置的时候也需要对leftmax进行调整</p><p>如果这个时候考虑 right 位置，那么可能需要 rightmax 的值，这是不太明智的（太远了）</p></blockquote><p>所以这样，每一次移动时：</p><p>我们需要对比左右两端，找出影响比较大的短板；</p><p>找出短板影响比较严重的一端（左还是右），在这一端对比短板大小和当前值的大小，看能不能存储雨水；</p><p>不管能不能存储雨水，我们都需要对 当前端的max值（leftmax或者rightmax）进行更新，并且移动端点；</p><p>最后当两个端点移动到中间的时候，就说明这一次遍历结束了，获得了想要的结果。</p><h2 id="19-删除链表中的倒数第N个结点"><a href="#19-删除链表中的倒数第N个结点" class="headerlink" title="19. 删除链表中的倒数第N个结点"></a>19. 删除链表中的倒数第N个结点</h2><p>目标有2：</p><ul><li>删除倒数第N个结点【单向链表，不太可能反向进行遍历】</li><li>返回头节点【如果去掉的就是头节点，所以不能直接把原来的头节点返回】</li></ul><p>要求：</p><ul><li>只扫描一次</li></ul><p>问题是：单向链表，怎么样实现只扫描一次呢？</p><blockquote><p>没想到，这也是一个双指针的问题</p></blockquote><p>使用两个指针，一个快，一个慢</p><p>或者说保持它们之间的距离 为 n-1【n代表要删除的节点的倒数顺序号】</p><p>那么当 一个节点移动到末尾的时候，另一个节点就移动到要删除的倒数第n个节点上了！【妙啊】</p><p>为了更好地删除，还可以添加 <strong>哑结点</strong> 【也就是在head前的节点，指向head，这个方法确实很常用】，这样的话第二个节点就可以指向要删除的节点的前一个节点</p><hr><p>还有一个更绝的解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       head-&gt;next = <span class="built_in">removeNthFromEnd</span>(head-&gt;next,n);</span><br><span class="line">       cur++;</span><br><span class="line">       <span class="keyword">if</span>(n==cur) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我现在看懂了</p><p>单向链表确实没有办法实现倒序的遍历</p><p>但是上面这个的做法就是每次到底，到底一次，cur+1，所以就相当于是实现了一个倒序的遍历，只不过递归套循环，时间上可能不占优势</p><hr><p>传统方法是</p><p>先对链表遍历一遍确定总长度</p><p>然后再遍历链表，删除要删的那个节点就好了</p><hr><p>按照以下几个步骤，应该默写出代码：</p><p>（1）定义一个新的头节点【其实是哑节点】</p><p>（2）定义两个指针，第一个动起来，直到两者间距达到要求</p><p>（3）两个指针都动起来，直到第一个指针到结尾了</p><p>（4）链表的删除就是，指向删除元素的下一个元素，那么被删除的元素自然就没有了</p><p>（3）最后还要把新增的节点删除掉</p><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p>输入：一个数组，其中只有三种整数：0，1，2</p><p>要求：进行排序，原地排序，最终结果应该是 所有 0 在最前面，然后是 所有的1，最后是所有的2</p><p>那么首先上来就能找到的一个想法是：</p><ul><li>找到0就放到最开头</li><li>找到2就放到结尾</li></ul><p>这不就解决了排序的问题了</p><p>但是问题是会多用空间</p><p>所以有两个方法：</p><h3 id="单指针"><a href="#单指针" class="headerlink" title="单指针"></a>单指针</h3><p>这个方法虽然需要遍历两遍，但是是基础思路，很值得学习</p><p>我们设定一个 str 指针，指向所谓的开头</p><p>然后从 i &#x3D; 0 开始遍历数组，如果找到了 0，那么就和开头 str 进行交换，然后 str +1，这样就能保证 比str 小的部分都是0 了</p><p>然后再遍历一遍，这次找1，str不要变，让str-1到xx之前都是1，就完成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">    <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">        swap(nums, i, <span class="built_in">str</span>)</span><br><span class="line">        <span class="built_in">str</span> += <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">i = <span class="built_in">str</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">    <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">        swap(nums, i, <span class="built_in">str</span>)</span><br><span class="line">        <span class="built_in">str</span> += <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span>    </span><br></pre></td></tr></table></figure><p>注意细节： 第二次遍历，还是要从 str 开始，这一位并没有完成排序</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211647039.png" alt="image-20210311211647039"></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>接下来是双指针，只需要遍历一次</p><p>这是我第一次再做题的过程中主动想到双指针</p><p>但是又放弃了</p><p>接着上面的方法，如果我们有两个指针，一个 p0 指向开头，一个 p2 指向结尾</p><p>然后，找到 0 就插入到开头位置，找到 2 就插入到结尾的位置，这样就达到了我们想要的效果</p><p>但是：</p><p>和结尾换位置一定要小心，比如我们找到了 2， 和结尾换了位置，原本结尾这个数值换到了 i 的位置</p><p>如果直接让 i+1，那么这一个数值就不会再被计算了！！！！</p><p>所以，必须要让 新的 i 位数值，继续和新的结尾（str-1，也变化了）比较</p><p>直到找到 数值的正确位置为止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p0, p2 = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= p2:</span><br><span class="line">            <span class="keyword">while</span> i &lt;= p2 <span class="keyword">and</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 对 nums[i] 需要不停交换</span></span><br><span class="line">                nums = self.swap(nums, i, p2)</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums = self.swap(nums, i, p0)</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">self, nums, i, j</span>):</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211733805.png" alt="image-20210311211733805"></p><h2 id="60-第k个排列"><a href="#60-第k个排列" class="headerlink" title="60. 第k个排列"></a>60. 第k个排列</h2><p>给出一个数字n，那么从1到n的数字，拍成一个含有n个数字的数字，有$n!$ 种排列情况【按照大小顺序排列的】</p><p>【题目中限定了n:1-9】</p><p>输出第k个排列</p><hr><p>这是一个数学问题</p><p>比如说如果我知道了</p><p>$n!,(n-1)!…2!,1!$</p><p>那么是不是一定可以解决这个问题？</p><p><code>k/(n!)</code> 是本位的大小，余数是剩下的数量，当 n 比较大的时候，这种除法还是比较麻烦的 </p><p>然后 $(n-1)!&#x3D;n!&#x2F;n$ 这样，计算也不会太复杂</p><hr><p>看答案题解，有点妙：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">valid = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    order -= valid[j]</span><br><span class="line">    <span class="keyword">if</span> order == <span class="number">0</span>:</span><br><span class="line">        ans.append(<span class="built_in">str</span>(j))</span><br><span class="line">        valid[j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>这里的order就是我说的计算出来的本位的大小，但是不是直接就是我们要的数字了，而是剩下的数字里面按顺序的一位数字</p><p>这里的方法是使用了valid数组做连接，如果某一个数字已经被用了，那么valid那一位就是0，这样的话，order就会滑过该数字，就完美地实现了不重复取数的想法</p><p>是非常妙，但是这个算法也有点难以想出来</p><hr><p>最后一点细节：</p><ul><li>其实这道题并不需要 n的阶乘，只需要 n-1 的阶乘</li><li>为什么 k 要减 1 ？<ul><li>因为第k个排列的首位数字是 $a_1 &#x3D; \frac{k-1}{(n-1)!}+1$</li></ul></li></ul><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><!-- 分治 --></h1><h2 id="215-数组中第K个最大的元素"><a href="#215-数组中第K个最大的元素" class="headerlink" title="215. 数组中第K个最大的元素"></a>215. 数组中第K个最大的元素</h2><p>复习</p><p>欣赏官方给出的java语言的题解，主要是学习 分治思想的应用：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">数组中的第K个最大元素-官方题解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(findKthLargest) --&gt; B(quickSelect)</span><br><span class="line">B --&gt; C1(randomPartition)</span><br><span class="line">B --&gt; B</span><br><span class="line">C1 --&gt; D1(partition)</span><br><span class="line">C1 --&gt; D2(swap)</span><br><span class="line">D1 --&gt; D2</span><br><span class="line">C1 --&gt; D3(random.nextInt)</span><br></pre></td></tr></table></figure><p>主函数：<code>findKthLargest()</code> </p><ul><li>直接调用 快速排序 函数</li></ul><p>快速排序函数：<code>quickselect()</code> 参数比较多</p><ul><li>a - 待排序的数组</li><li>l - 左侧个数</li><li>r - 右侧个数</li><li>index ： len -k 就是说我们现在要找的数值，它的索引应该是 len-k</li></ul><p>该函数调用了 <code>randomPartition()</code> 函数：作用是</p><ul><li>首先 调用 <code>random.nextInt(x)</code> 生成一个范围在 0-x 内的任意正整数<ul><li>这里使用的方法是 <code>i = random.nextInt(r-l+1)+l</code></li><li>这里 <code>r = len -1</code>，那么这个 random 最后就是大于 l 的一个随机数值</li><li>也就是说这里随机选择呢右侧的一个 位置</li></ul></li><li>然后 <code>swap(a, i, r)</code> 就是把 <code>a[i]</code> 和 <code>a[r]</code> 互相调换位置<ul><li>注意这里，i 比 l 要大，一定在当前值的右边</li><li>而 r 可能是从 len -1 开始进行计算的</li></ul></li><li>接下来交给 <code>partition</code> 函数</li></ul><p>说实在的，这个官方的题解一点都不容易看懂</p><hr><p>还是看一下第三方的题解：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</a></p><p>这个清晰多了</p><p>主代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> index = patition(nums, left, right);</span><br><span class="line">    <span class="keyword">if</span> (index == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target)&#123;</span><br><span class="line">        left = index + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        right = index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常契合思想，那就是如果索引小了，那就查看右边，如果索引大了，就看左边</p><p>下来关键就是看这个 partition 函数，它的作用是给 nums 做一个排序，最后返回想要的 索引值</p><p>这个函数其实是对 [left, right] 区间的nums 进行操作</p><p>所以首先 找一个标准数 pivot， 比如 nums[left]，索引也放过来</p><p>然后 从 left 开始遍历，看 nums[i] 有没有比 left 小的</p><p>如果比 left 小，那肯定要把这个 nums[i] 和 nums[left] 交换一下了</p><p><strong>但是，这个程序巧妙的地方是</strong> </p><p>没有直接把 nums[left] 换掉</p><p>而是把 nums[left] 先排除在外，然后 把小的放在前面，大的放在后面，找到了一个中间位置 j，最后直接把 nums[j] 和 nums[left] 换一下就可以</p><p>就是说 [left+1, j] 都比 nums[left] 小了，(j, i] 都比 nums[left] 大，那么这个时候，就可以把 j 和 left 换一下，因为不会影响 j 位置处成功分割了左右两边，我们要的也是 这个位置 j </p><blockquote><p>注意这个地方， j++ 和 j +&#x3D; 1 是不一样的</p><ul><li>后面这个会直接运算，然后改变了 j 的值</li><li>但是 j++ 是先用，再改变，所以暂时还没有改变</li></ul></blockquote><p>接下来，后面说了一个问题</p><p>最好是随机初始化 我们的 标准数 pivot，否则极端测试用例可能会很耗时间</p><p>一个方法是，随机交换 第一个元素和后面的任意元素</p><blockquote><p>怪不得官方题解 上来就是一个随机交换，搞得莫名其妙</p><p>现在再回头看官方题解，就会发现其实是一样的了</p></blockquote><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><!-- 贪心 --></h1><h2 id="984-不含AAA或BBB的字符串"><a href="#984-不含AAA或BBB的字符串" class="headerlink" title="984. 不含AAA或BBB的字符串"></a>984. 不含AAA或BBB的字符串</h2><p>输入：a 的数量m，b 的数量n</p><p>要求：写一个字符串，其中有 m个a和n个b，但是不能出现连续 3个a，或者 3个b</p><hr><p>我自己的思路：</p><p>我曾在脑海中冒出过以下想法：</p><p>哈希表-斗地主问题 —— 发现问题在于不能顾头不顾尾</p><p>贪心算法 —— 想先找出所有的对a，然后往里面插入 b【超时了】</p><p>动态规划，不知道是不是</p><p>还想了双指针，但是不行</p><p>总的来说，贪心应该是的，但是应该怎么贪心</p><hr><p>按我说的贪心算法：【首先假设 a 比 b 多】</p><p>先找出所有的对a：double_a &#x3D; a &#x2F;&#x2F; 2，余数 res_a 就是剩下的a【就是0或者1】</p><p>然后给b的位置就是：double_a + res_a</p><p>然后对b的数量是：double_b &#x3D; b % (a_block - 1)</p><p>最后剩下的就是单个的b</p><p>【超时了】</p><blockquote><p>这种方法可以称之为 插空法</p><p><a href="https://leetcode-cn.com/problems/string-without-aaa-or-bbb/solution/tan-xin-cha-kong-by-zhang191031/">贪心+插空</a></p><p>但是插孔的具体实现略有不同</p></blockquote><hr><p>姑且不说这个方法是不是正确的</p><p>其中一点确实是解题的关键： 找 a 和 b 中比较多的</p><p>但是我只找了一次</p><hr><h3 id="官方题解-1"><a href="#官方题解-1" class="headerlink" title="官方题解"></a>官方题解</h3><p>（1）定调： 贪心算法</p><p>但是，下一个写入的字母应该是当前所剩最多的待写字母，除非前两个都是它了，才改用另一个字母</p><p>（2）确实使用 list，最后转 str</p><p>（3）我们说写a还是b看谁更多，怎么样知道是 a 多还是 b 多呢？其实不一定要知道 a，b 的数量，只要知道下一个 写 a 还是写 b 就好了</p><p>【所以就是来判断下一个是不是要写a】</p><p>比如这一句：<code>writeA = ans[-1]==&#39;b&#39;</code></p><p>如果<code>ans[-1] </code>是 b，那么这个writeA就是true了，就表示确实要写A</p><p>还有：<code>writeA = A &gt;= B</code> </p><p>就是说，如果 A 比较多，那么就写 A</p><p>（4）一个大问题，不要把 b 和bb，a和aa 分开思考</p><p>把 两个 a看成和一个 a 是不一样的情况，是一种错误的想法，容易走上面向过程</p><p>而不是面向对象的道路</p><p>这样一来就简单多了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strWithout3a3b</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> a <span class="keyword">or</span> b:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ans) &gt;= <span class="number">2</span> <span class="keyword">and</span> ans[-<span class="number">1</span>] == ans[-<span class="number">2</span>]:</span><br><span class="line">                writeA = ans[-<span class="number">1</span>] == <span class="string">&#x27;b&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                writeA = a &gt;= b</span><br><span class="line"><span class="comment"># 根据是不是 写a，来进行填写</span></span><br><span class="line">            <span class="keyword">if</span> writeA:</span><br><span class="line">                a -= <span class="number">1</span></span><br><span class="line">                ans.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">                ans.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans)</span><br></pre></td></tr></table></figure><h2 id="999-可以被一步捕获的棋子数"><a href="#999-可以被一步捕获的棋子数" class="headerlink" title="999. 可以被一步捕获的棋子数"></a>999. 可以被一步捕获的棋子数</h2><p>这道题虽然是涉及二维数组，但是确实是一道简单题</p><p>问题描述：</p><p>国际象棋棋盘</p><p>R - 白车（只有一个），B - 白象（可能有），p - 黑卒（可能有）</p><p>白车可以四个方向移动：</p><ul><li>如果遇到 黑卒，可以吃掉，然后停止</li><li>如果遇到 白象，停止</li><li>如果遇到 边界，停止</li></ul><p>如果给了一张棋盘，请问在该棋盘上，可以被一步捕获的棋子有多少</p><hr><p>分析，贪心法</p><p>首先要找到白色的车 - R</p><p>似乎没有什么好办法，就是遍历，最糟糕的情况 O(N)</p><p>然后分别遍历四个方向，每个方向一直到底：</p><ul><li>如果 到边了，返回</li><li>如果 到B了，返回</li><li>如果 到p了，加1，返回</li></ul><p>这里面的四方向遍历方法是我之前学到的，这样可以重用一部分代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置一个代表四个方向的数组</span></span><br><span class="line"><span class="comment"># 方法1：直接设置表达式，这样其实不容易继续</span></span><br><span class="line">dirc = [[i+<span class="number">1</span>, j], [i-<span class="number">1</span>, j], [i, j+<span class="number">1</span>], [i, j-<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 方法2：设置步长，这个方法更好</span></span><br><span class="line">dirc = [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dirc)):</span><br><span class="line">    x += dirc[k][<span class="number">0</span>]</span><br><span class="line">    y += dirc[k][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>这样就实现了四个方向的遍历</p><p>接下来的判断过程其实比较容易，注意一个细节即可：如果遇到 黑卒-p，加 1 后也是需要进行返回的，否则会有问题</p><hr><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a>59. 螺旋矩阵 II</h2><p>题目描述：</p><p>给一个正整数 n，可以用 1 到 n^2的所有元素，填满一个 nxn 的正方形矩阵</p><p>要求：</p><p>填满的顺序应该是螺旋的，比如：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="matrix_img"></p><hr><p>贪心法：四方向 - 碰壁法</p><p>碰壁，改变移动方向</p><p>设置了四个方向的移动模式，这一点和 999 题（上面一题）是完全相同的</p><p>也需要进行模式切换，但是问题是什么时候需要切换模式呢？</p><hr><p>方法一：贪心</p><ul><li>到边界需要切换</li><li>原本要去的下一个位置有数字了需要进行切换</li></ul><p>怎么样检测是不是到了边界？</p><ul><li>现在的位置到了 n-1 ，说明是一个边界</li><li>下一个位置到了 n，说明是一个边界</li></ul><p>怎么样检测下一个位置是不是0？</p><ul><li>首先要按照原来的模式求出下一个位置的坐标</li><li>然后看下一个位置是不是0</li></ul><p>这样一来，就需要先用一个假的位置 next_i，next_j先求一边下一个位置的坐标，并且同时判断是不是超出了边界，是不是0，好的一点是，这样可以直接进行模式的判断和修改</p><p>然后最后再对真正的位置 i，j 进行修改</p><hr><p>方法二：数学</p><p>观察一下可以发现，每次进行模式的切换需要走过的长度是：</p><p>n, n-1, n-1, n-2, n-2,  n-3,  n-3, n-4, …, 2, 2, 1.</p><p>除了头和尾，其他位置都是需要走两个相同的长度</p><p>这个其实也是可以用循环去实现出来的</p><p>比如说，可以先出一个循环，能够写出上面的数组</p><p>此时，什么时候需要转换模式？</p><ul><li>当每一条边写的数字的数量达到了数组中对应位置的数字，就说明这条边写完了，需要写下一条了</li></ul><p>这种方法不需要判断下一个位置是不是满了，只需要计数，还是会占一点时间，但是空间上可能会小一点点</p><h1 id="-3"><a href="#-3" class="headerlink" title=""></a><!-- 递归 --></h1><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h2><p>给你一棵二叉树的根节点 root，求出该树的节点个数</p><p>比如：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p><p>输入： root &#x3D; [1, 2, 3, 4, 5, 6]</p><p>输出：6</p><p>这个题的输入是 TreeNode，所以不能按照普通的数组进行对待</p><p>按照正常的递归方法，非常简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">1</span> + self.countNodes(root.left) + self.countNodes(root.right)</span><br></pre></td></tr></table></figure><p>只有2行代码</p><p>如果 root 是空，说明到底了，返回0</p><p>如果不是空，自身是一个节点 +1，然后计算左子树和右子树</p><p>完美通过</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210316194121543.png" alt="image-20210316194121543"></p><p>递归的空间占的大了一点，但是耗时还可以</p><hr><p>观看题解：</p><ol><li>对于没有约束的二叉树，递归当然是没有问题的</li><li>但是本题说的是 <strong>完全二叉树</strong></li></ol><p><strong>完全二叉树</strong></p><p>特点：叶子节点只出现在最后两层，最后一层如果不满，则叶子节点只在最左侧，或者是空树</p><p>如果是<strong>满二叉树</strong>，那么总节点数 &#x3D;  2*h -1，h 是层数</p><p>所以完全二叉树最好是利用好结构特点</p><hr><p>本次更新距离上次更新比较久，期间经过一系列的算法学习，有了一定的认识和进步，LeetCode刷题数量也已经达到了77题，目前正处于春招当中，继续加油吧！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;!-- 双指针 --&gt;&lt;/h1&gt;&lt;h2 id=&quot;424-替换后的最长重复字符&quot;&gt;&lt;a href=&quot;#424-替换后的最长重复字符&quot; class=&quot;headerlink&quot; title=&quot;424. 替换后的最长重复字符&quot;&gt;&lt;/a&gt;424. 替换后的最长重复字符&lt;/h2&gt;&lt;p&gt;输入：字符串 s，全部是大写字母； 整数 k&lt;/p&gt;
&lt;p&gt;要求：最多可以将字符串s中的任意 k 个字符进行替换&lt;/p&gt;
&lt;p&gt;输出：最长重复字符的数量&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;官方题解&quot;&gt;&lt;a href=&quot;#官方题解&quot; class=&quot;headerlink&quot; title=&quot;官方题解&quot;&gt;&lt;/a&gt;官方题解&lt;/h3&gt;&lt;p&gt;官方题解的方法确实很妙：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103753750.png&quot; alt=&quot;image-20210202103753750&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果该数值大于 k ，自然是不符合题意，那么右指针移动，左指针也移动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103935966.png&quot; alt=&quot;image-20210202103935966&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果数值小于等于 k，那么说明符合题意，右指针移动，左指针不用移动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202104027261.png&quot; alt=&quot;image-20210202104027261&quot;&gt;&lt;/p&gt;
&lt;p&gt;右指针 - 左指针 就是最长重复子字符串的长度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题在于，怎么计算区间内非重复字符的数量？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>春招-字节笔试</title>
    <link href="http://yoursite.com/2021/03/14/%E6%98%A5%E6%8B%9B-%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2021/03/14/%E6%98%A5%E6%8B%9B-%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95/</id>
    <published>2021-03-14T13:36:38.000Z</published>
    <updated>2021-03-18T01:52:00.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h1><p>平台：牛客网</p><p>特点：</p><ol><li>标准 sys 输入和输出，给输入和输出的范例，主要是多行输入和单行输出</li><li>可以自测，可以print</li></ol><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>总共有四道题目</p><h2 id="1）环形数组-找座位问题"><a href="#1）环形数组-找座位问题" class="headerlink" title="1）环形数组 - 找座位问题"></a>1）环形数组 - 找座位问题</h2><p>给出一个环形数组，其中全部为 0 或 1</p><p>请找到一个 0，它距离两侧的 1 应该最远</p><span id="more"></span><p>比如：</p><p>【0 0 0 0 0 1 0 0】</p><p>那么 应该是在索引2的位置放1，距离最远，最远距离为 4</p><p>分析：</p><p>其实就是找两个 1 之间最大距离，或者说 连续 0 的最多数量</p><p>我的方法就是找 两个 1 之间的最大距离</p><p>而且，为了满足环形要求，直接在现在的数组后面续上一个数组</p><p>这样遍历一遍，就能解决问题了</p><p>【本题全部测试用例通过，10分】</p><h2 id="2）多叉树寻根问题"><a href="#2）多叉树寻根问题" class="headerlink" title="2）多叉树寻根问题"></a>2）多叉树寻根问题</h2><p>问题描述：</p><p>一个初代病毒 T 可以分裂出多个子代病毒</p><p>子代病毒还可以继续分裂</p><p>原病毒是无致命性的，但是分裂和遗传的过程中可能会有致命性</p><p>如果已知某几个病毒是有致命性的，请找出它们的最近的共同根节点</p><p>输入的写法【多行输入】：</p><p>N 个病毒，R 条分裂</p><p>M个致病：编号依次是</p><p>分裂关系1：亲代、子代数量、子代编号</p><p>分裂关系2：亲代、子代数量、子代编号</p><p>分析：</p><p>其实本题充分描绘了一颗多叉树的全貌，但是问题是：</p><p>（1）如何进行还原</p><p>（2）怎么样找最近的</p><p>我首先想到的就是 Union-find 并查集的方法，一个建图的问题</p><p>复习一下：并查集问题涉及以下几个步骤：</p><p>union - 建图</p><p>connected - 判断是不是连通</p><p>count - 用于计数（对于岛屿问题可以使用）</p><p>在建图和判断连通的过程中，会使用 find 函数寻找根节点</p><p>那么本题中虽然有非常明确的多叉树结构，但是还不需要把全图建好，重要的是根据 find 函数寻找到根节点</p><p>所以我的方法就是根据所给树的信息建立 parents 的表单</p><blockquote><p>因为输入信息中 父 - 子 节点的关系十分明确，可以直接对子节点存储 parent 的情况</p></blockquote><p>然后就是比较 各致命病毒 的父节点，什么是否是一样的？</p><ul><li>这个问题有点难，我想的可能不够完整</li></ul><p>我的想法是：</p><p>由于该树中，其实大小是有一定的顺序的，是一颗二叉搜索树</p><p>致命病毒id 也是有顺序的，可以根据最小的节点为标准</p><p>如果别的病毒的父节点 id &gt; 该节点的父节点 id，那么其他病毒就找父节点，然后再比较父节点</p><p>只有 别的病毒的父节点 id &lt; 该节点的父节点 id 时，才会找该节点的父节点 id</p><hr><p>几点说明：</p><p>共同父节点是一定存在的，怎么说 0 也是共节点</p><p>但是要找的是最近的</p><p>【结果，本题通过了 70% 的测试用例， 本题30分】</p><h2 id="3）破解机关问题-环形数组"><a href="#3）破解机关问题-环形数组" class="headerlink" title="3）破解机关问题 - 环形数组"></a>3）破解机关问题 - 环形数组</h2><p>这个问题很有意思，我也想问</p><p>比如原神中有多个火柱子，初始状态有亮 - 1，有灭 - 0</p><p>请问怎么样用最少的次数将所有的火柱子都点亮，如果不能全部点亮，就返回 -1</p><p>举例：</p><p>10</p><p>0 1 1 0 0 0 1 0 0 1</p><p>最后应该是 4次就可以将所有火柱子点亮</p><p>分析：</p><p>我的方法应该是贪心算法</p><p>只要遇到0，那么下一个柱子就点亮，这样会同时影响 i, i+1, i+2三个柱子的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f[i] == <span class="number">0</span>:</span><br><span class="line">    f[i] = <span class="number">1</span></span><br><span class="line">    f[i+<span class="number">1</span>] = <span class="built_in">int</span>(f[i+<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">    f[i+<span class="number">2</span>] = <span class="built_in">int</span>(f[i+<span class="number">2</span>]==<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>个人觉得这个地方的逻辑判断做的还可以：</p><p>如果 <code>f[i+1]=1</code>，那么，就会变成 false - 0</p><p>如果 <code>f[i+1]=0</code>，那么，就会变成 true - 1</p><p>相当于是与 0 异或</p><p>按照这种方法前面都好说，但是当 i &#x3D; n - 2的时候， i + 2 &#x3D; n，会超出索引</p><p>由于这是一个环形，所以需要把第一个柱子续在后面，一个即可【应该吧】</p><p>我当时的判断条件是：当 i &#x3D; n - 1时，如果 f[i] &#x3D; 0，那么就判断 false</p><p>但是现在看来还是不太对</p><p>因为 i &#x3D; n - 2的时候， i + 2 &#x3D; n，会改掉第一个柱子的值，这样还是不太对</p><p>应该是 i &#x3D; n - 2 的时候，如果 f [i] &#x3D; 0，那么其实就是 false 了</p><p>【本题最好的通过情况是 37.5% ， 本题30分】</p><hr><p>而且这个方法对很多问题的算法并不是最佳的，比如：</p><p>4</p><p>0 0 1 0</p><p>很显然一次就够了，但是按算法，会是 false</p><h2 id="4）棋盘游戏问题"><a href="#4）棋盘游戏问题" class="headerlink" title="4）棋盘游戏问题"></a>4）棋盘游戏问题</h2><p>这类几何拓扑的问题，一看到就想放弃，确实不擅长做，主要是觉得二维进行遍历和存储的时候很麻烦</p><p>问题描述：</p><p>给一个 n * m 的棋盘，以及棋盘的状态（有的位置是空的<code>·</code>，有的非空 <code>#</code>）</p><p>有若干 1 * 2 的棋子可以进行填充</p><p>问是不是可以用棋子将棋盘填满，<strong>而且填法唯一</strong>，返回唯一填法</p><p>如果不是，就返回 -1</p><hr><p>其实如果是唯一 填法，那么填起来应该也不会太难</p><p>我们可以看几个案例：</p><p>（1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· ·</span><br><span class="line"></span><br><span class="line">· ·</span><br></pre></td></tr></table></figure><p>这是 2x2 的棋盘，有两种方式可以填满，所以不是唯一的</p><p>那么是不是说只要有这样的位置，就可以断定填不满了呢？不是</p><p>（2）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· · <span class="comment">#</span></span><br><span class="line">· · ·</span><br><span class="line">· <span class="comment"># #</span></span><br></pre></td></tr></table></figure><p>这是有唯一解的，唯一解为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; &gt; <span class="comment">#</span></span><br><span class="line">^ &lt; &gt;</span><br><span class="line">v <span class="comment"># #</span></span><br></pre></td></tr></table></figure><p>其中 <code>&lt; &gt;</code> 表示横着放的棋子，<code>^ v</code> 表示竖着放的棋子</p><p>经过和同学的讨论，大家认为是这样，可以从头开始遍历，但是需要深度优先</p><p>比如从左上角开始遍历：</p><ul><li>可能有两种放置方法，可以任选一种【任选也说明了多叉树的分支，这肯定要用回溯算法进行回调的，复杂度比较高】<ul><li>但是最好有顺序，比如优先 横放，次之 竖放</li></ul></li><li>然后选择没有被占领的一个空格，看是不是可以放下棋子<ul><li>如果放不下，这条路肯定走不通了，就要返回了</li><li>如果可以放下，那么继续选择旁边没有被占领的空格，遍历</li></ul></li><li>如果没有上面说的空格，那么就按照竖列，遍历到底<ul><li>如果没有返回 false，肯定需要遍历完整个棋盘</li></ul></li></ul><p>这个问题里面，如果有很多种解法，那么至少需要找到两组成功的解法，才能说明 false</p><p>否则需要一直找下去，找不到成功解法才 false</p><p>还是应该找一种能判断 false 的方法</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;体验&quot;&gt;&lt;a href=&quot;#体验&quot; class=&quot;headerlink&quot; title=&quot;体验&quot;&gt;&lt;/a&gt;体验&lt;/h1&gt;&lt;p&gt;平台：牛客网&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标准 sys 输入和输出，给输入和输出的范例，主要是多行输入和单行输出&lt;/li&gt;
&lt;li&gt;可以自测，可以print&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;总共有四道题目&lt;/p&gt;
&lt;h2 id=&quot;1）环形数组-找座位问题&quot;&gt;&lt;a href=&quot;#1）环形数组-找座位问题&quot; class=&quot;headerlink&quot; title=&quot;1）环形数组 - 找座位问题&quot;&gt;&lt;/a&gt;1）环形数组 - 找座位问题&lt;/h2&gt;&lt;p&gt;给出一个环形数组，其中全部为 0 或 1&lt;/p&gt;
&lt;p&gt;请找到一个 0，它距离两侧的 1 应该最远&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="bytedance" scheme="http://yoursite.com/tags/bytedance/"/>
    
    <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据库-SQL语言</title>
    <link href="http://yoursite.com/2021/03/03/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2021/03/03/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E8%AF%AD%E8%A8%80/</id>
    <published>2021-03-03T08:33:27.000Z</published>
    <updated>2021-03-03T08:43:15.846Z</updated>
    
    <content type="html"><![CDATA[<p>怎么样建立起一个数据仓库的</p><ul><li>肯定不是说把 csv 数据导入 mysql 这么简单，确实就像 布迩 说的，我这个算是别人建好的数据仓库</li><li>那么究竟怎样才是自己建立数据仓库呢？</li></ul><p>csv 文件导入 MySQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load data infile &#x27;F:/MySqlData/test1.csv&#x27; -- CSV文件存放路径</span><br><span class="line">into table student -- 要将数据导入的表名</span><br><span class="line">fields terminated by &#x27;列的分隔符&#x27; optionally enclosed by &#x27;&quot;&#x27; escaped by &#x27;&quot;&#x27;</span><br><span class="line">lines terminated by &#x27;\r\n&#x27; -- 回车换行符;</span><br></pre></td></tr></table></figure><p>如果是linux下生成的文件，就是 <code>\n</code> 结尾</p><p>注意：这个东西很有可能会出现各种的报错，需要修改配置文件等内容</p><span id="more"></span><blockquote><p>参考：<a href="https://www.cnblogs.com/yoyotl/p/9858587.html">将csv的数据导入mysql</a></p></blockquote><p>语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student;</span><br></pre></td></tr></table></figure><blockquote><p>怎么样构建一个数据仓库</p><p>数据库索引的原则</p><p>数据库面试常见的问题</p><p>数据库面经找一找</p></blockquote><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>Structured Query Language 结构化查询语言</p><p>RDBMS 关系数据库管理系统</p><p><code>use database;</code> 选择数据库</p><p><code>set names utf8;</code> 设置使用的字符集</p><blockquote><p>SQL 对大小写不敏感</p><p>分号是分隔SQL语句的标准方法</p></blockquote><p><code>CREATE DATABASE</code> 创建新的数据库</p><p><code>ALTER DATABASE</code> 修改数据库</p><p><code>UPDATE</code> 更新数据库中的数据</p><p><code>DELETE</code> 删除数据库中的数据</p><p><code>INSERT INTO</code> 向数据库中插入新数据</p><hr><p><code>CREATE TABLE</code> 创建新表</p><p><code>ALTER TABLE</code> 变更（改变）数据库表</p><p><code>DROP TABLE</code> 删除表</p><hr><p><code>CREATE INDEX</code> 创建索引（搜索键）</p><p><code>DROP INDEX</code> 删除索引</p><blockquote><p>数据库 database 和 表 table 的区别</p><p>SQL 和 MySQL 的关系</p><p>SQL 有很多种，包括 SQL Sever&#x2F;MS Access, MySQL, Oracle，SQL是语言，MySQL 是一种数据库软件</p></blockquote><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建数据库</p><p><code>CREATE DATABASE db_name</code></p><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">ID <span class="type">int</span>,</span><br><span class="line">Name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后可以使用 <code>INSERT INTO</code> 向表中插入数据</p><p>可以对数据表内容进行约束，保证合规：</p><p>创建表时可以针对列进行内容的约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">ID <span class="type">int</span> constraint_name AUTO INCREMENT,</span><br><span class="line">Name <span class="type">varchar</span>(<span class="number">255</span>) constraint_name,</span><br><span class="line">Address <span class="type">varchar</span>(<span class="number">255</span>) constraint_name,</span><br><span class="line">City <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> ‘Sandnes’,</span><br><span class="line"><span class="keyword">UNIQUE</span> (ID),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (Name),</span><br><span class="line"><span class="keyword">CHECK</span> (ID<span class="operator">&gt;</span><span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里写的 <code>constraint_name</code> 可以是：</p><ul><li>NOT NULL  -  不能存储 NULL 值；再修改 为 “NULL”就可以存储 NULL 值了</li><li>UNIQUE - 为列或者多个列提供唯一性的保证，一个表可以有多个，mysql需要单独在最后声明 <code>UNIQUE (P_Id)</code></li><li>PRIMARY KEY - 为列或者多个列提供唯一性的保证，但是每个表只能有一个</li><li>FOREIGN KEY - 保护表直接的连接，可能有某个列是两个表之间的连接外键</li><li>CHECK - 限制列中值的范围</li><li>DEFAULT - 向列中插入默认值</li></ul><p>如果表已经建立好了，可以使用</p><p> <code>ALTER TABLE table_name MODIFY column_name type constrain_name;</code></p><p>这些约束也可以删除，要使用 <code>ALTER TABLE table_name xxx constrain_name</code> 语句</p><p>其中xxx 位置：</p><ul><li>NOT NULL 用 MODIFY</li><li>UNIQUE 用 DROP</li><li>PRIMARY 用 DROP</li><li>FOREIGN 用 DROP</li><li>CHECK 用 DROP</li><li>DEFAULT 用 DROP</li></ul><p><code>AUTO INCREMENT</code> 字段，每次插入新记录时，会自动地创建主键字段的值 </p><p>比如上面的例子中，ID就是这样的字段，默认开始值是1（也可以自己设置起始值），每条新纪录递增1</p><p>这样的话，向表中添加数据时，不需要为 ID 字段规定值（会自动生成）</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>为了更快地查找数据，可以创建索引</p><blockquote><p>但是索引是看不到的！</p></blockquote><p>更新一个包含索引的表更花时间</p><p>一般只在最常搜索的列创建索引</p><p><code>CREATE INDEX index_name ON table_name (column_name)</code> 创建简单索引，可以使用重复的值</p><p><code>CREATE UNIQUE INDEX index_name ON table_name (column_name)</code> 创建唯一索引，不能使用重复的值（两个行不能索引值相同）</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p><code>SELECT * FROM database;</code> 读取数据表的信息</p><ul><li><code>*</code> 表示全部</li><li><code>*</code> 的位置可以被替换为一个或者多个列的 列名，多个列名之间用 <code>,</code> 进行区分</li><li>结果会存储在一个<strong>结果表</strong>中 —— <strong>结果集</strong></li></ul><p>上面的搜索中一个列可能会包含多个重复值，可以用</p><p><code>SELECT DISTINCT * FROM table_name;</code> 就会只取出要选的那一列中不重复的值</p><p>要选取前多少个数据，使用到  <code>TOP</code> 语句，但是这个语句在不同的sql 语言种是不一样的，以 MySQL 为例，使用 <code>LIMIT</code> 进行限定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT number;</span><br></pre></td></tr></table></figure><p>可以选择满足条件的前 number 条记录</p><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="operator">=</span> value1</span><br><span class="line"><span class="keyword">AND</span> column_name <span class="operator">&gt;</span> value2</span><br></pre></td></tr></table></figure><p>如果 value 是数值，不用引号</p><p>如果 value 是文本值，要用引号</p><p>WHERE 子句中的运算符</p><ul><li>&#x3D; 等于</li><li>&lt;&gt; 不等于</li><li>BETWEEN 在某个范围内 <code>BETWEEN value1 AND value2</code><ul><li>介于 value1 和 value2 之间</li><li>也可以添加 <code>NOT</code> 表示不在某个区间，比如 <code>NOT BETWEEN xxx</code></li><li>value1 和 value2 可以都是数字，<strong>也可以是字母</strong>，还可以是日期date（<code>2016-05-10</code> 之类的）</li><li>MySQL中，BETWEEN 区间 是<strong>包括两个边界的值</strong>的！ NOT BETWEEN 就不包括两个边界的值了</li></ul></li><li>LIKE 搜索某种模式 <code>LIKE pattern</code> <ul><li>这个指定模式是用通配符来进行设定的</li><li>比如 <code>G%</code>  表示以 G 开头的字符值</li><li>还可以使用  <code>NOT LIKE pattern</code> 排除某个模式</li></ul></li><li>IN 指定针对某个列的多个可能值<ul><li>使用在指向比较明确的场合</li><li>比如 <code>WHERE column_name IN (value1, value2, ...)</code></li><li>那么该 column 的值一定要在指定的 value 中</li><li>IN 和 &#x3D; 的区别是，IN 可以规定多个值，&#x3D; 只能规定一个值，可以互相转换，使用 <code>OR</code></li></ul></li></ul><blockquote><p>通配符</p><ul><li><code>%</code> 替代0-n个字符</li><li><code>-</code> 替代 1 个字符</li></ul><p>正则表达式</p><p><code>REGEXP &#39;pattern&#39;</code>和 <code>NOT REGEXP</code></p><p>（或者<code>RLIKE</code>和 <code>NOTRLIKE</code>）</p><p>例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name REGEXP <span class="string">&#x27;^[A-H]&#x27;</span></span><br></pre></td></tr></table></figure><p>表示的是以A到H 开头的字符</p><p><code>REGEXP &#39;^[^A-H]&#39;</code> 表示的是，不以A到H开头的字符</p></blockquote><p>子句</p><p><code>AND</code>  两个条件都成立，才会显示一条记录</p><p><code>OR</code> 两个条件有一个成立，就会显示一条记录</p><p>这两个符号可以结合起来，还可以加括号，这样构成复杂语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><code>ORDER BY</code> 对结果集按照某个列（或者某几个列）进行排序</p><p><code>DESC</code> 是按照降序排序</p><blockquote><p>如果按照多个列进行排序</p><p>先按照第一列，然后按照第二个列，两个列都会考虑</p><p>比如</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210302223234109.png" alt="image-20210302223234109"></p></blockquote><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, column3)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3,...);</span><br></pre></td></tr></table></figure><p><code>INSERT INTO</code></p><p>可以用来插入一个新行的数据</p><p>也可以指定某几个列插入数值，没有说到的列就是0</p><blockquote><p>列表的第一列是“id”</p><p>“id”会自动更新</p></blockquote><p>【MySQL不支持】<code>SELECT INSERT INTO</code>用来从一个表中复制数据（行），然后把数据插入到另一个新表【这个表原本不存在】中</p><p>【MySQL 支持】<code>INSERT INTO ... SELECT</code> 也是用来从一个表中复制数据（行），然后插入到一个已存在的表中【这个被插入的表中已经存在的行不会受影响】</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line">(column_names)</span><br><span class="line"><span class="keyword">SELECT</span> column_names</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure><p><code>ALTER TABLE</code> 添加、删除、修改列</p><p><code>ALTER TABLE table_name ADD column_name datatype</code>  添加列</p><p>删除，alter … drop</p><p>修改表中数据的类型  alter … modify </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line"><span class="keyword">SET</span> column1<span class="operator">=</span>value1, column2<span class="operator">=</span>value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><p><code>UPDATE</code> 语句可以用来更新表中的记录</p><p>注意一定要使用 <code>WHERE</code> 语句来限定需要更新的记录，要不然，所有记录都会被更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><p><code>DELETE</code> 语句用来删除表中的记录（行）</p><p>注意要使用 <code>WHERE</code> 语句限定需要删除的记录，否则所有记录会被删除</p><blockquote><p>删库跑路</p><p><code>DELETE * FROM table_name;</code></p><p>或者 <code>DELETE FROM table_name;</code> 会删除全部行</p></blockquote><p><code>DROP</code> 可以用来删除 索引、表和数据库</p><p><code>ALTER TABLE table_name DROP INDEX index_name</code>  删除表中的索引</p><p><code>DROP TABLE table_name</code> 删除表</p><p><code>DROP DATABASE db_name</code> 删除数据库</p><p><code>TRUNCATE TABLE table_name</code> 删除表内数据，但不删除表本身</p><h3 id="起别名-AS"><a href="#起别名-AS" class="headerlink" title="起别名 AS"></a>起别名 AS</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name <span class="keyword">FROM</span> table_name;  <span class="comment">-- 给列起别名</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name;  <span class="comment">-- 给表起别名</span></span><br></pre></td></tr></table></figure><p>多个列需要分别 AS</p><p><code>CONCAT (column1, column2) AS column3</code> 可以将多个列结合在一起，创建一个 column3 的别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, CONCAT(url, <span class="string">&#x27;,&#x27;</span>, alexa, <span class="string">&#x27;,&#x27;</span>, conntry) <span class="keyword">AS</span> site_info <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>起别名对于在多个表中进行混合查询比较有利，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> w.name, w.url, a.count, a.data</span><br><span class="line"><span class="keyword">FROM</span> Websites <span class="keyword">AS</span> w, access_log <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> a.site_id<span class="operator">=</span>w.id <span class="keyword">and</span> w.name<span class="operator">=</span>&quot;菜鸟教程&quot;</span><br></pre></td></tr></table></figure><p>总结来说，别名的好处就是：</p><ul><li>查询多个表</li><li>查询中使用了函数</li><li>列名称很长</li><li>多列结合</li></ul><p>比较方便</p><blockquote><p>如果在多个表中进行查询，不同表中的列名需要添加各自的前缀</p></blockquote><h3 id="多表合并"><a href="#多表合并" class="headerlink" title="多表合并"></a>多表合并</h3><p>SQL join 用于把来自两个或者多个表的行结合起来</p><p>主要分四类</p><ul><li>LEFT JOIN - 即使右表没有匹配，也会从左表返回行</li><li>RIGHT JOIN - 即使左表没有匹配，也会从右表返回行</li><li>INNER JOIN - 在表中存在至少一个匹配时返回行【比如表A的行，在表B中没有匹配，那么这些行就不会列出】</li><li>FULL JOIN - 只要一个表存在匹配，就返回行 &#x3D;&#x3D;但是MySQL中不支持 FULL OUTER JOIN&#x3D;&#x3D;</li></ul><p>但是具体还有方法，总共有7种相关的用法</p><p>最常见：<code>INNER JOIN</code> 从多个表中返回满足JOIN条件的所有行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> w.id, w.name, a.count, a.date</span><br><span class="line"><span class="keyword">FROM</span> Websites <span class="keyword">as</span> w</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> access_log <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">ON</span> w.id<span class="operator">=</span>a.site_id;</span><br></pre></td></tr></table></figure><p>ON  后面会跟随连接的条件【也就是说，两个表是通过这个参数列连起来的】</p><p>最后返回的结果集中，将只包含所搜寻的四个参数：w.id, w.name, a.count, a.date</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> w.name, a.count, a.date</span><br><span class="line"><span class="keyword">FROM</span> Websites <span class="keyword">as</span> w</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> access_log <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">ON</span> w.id<span class="operator">=</span>a.site_id</span><br><span class="line">ORDERED <span class="keyword">BY</span> a.count <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>即使 表 a（access） 中没有与 w.id 相同的 site_id， 那么 w.id 所在的数据还是会存在于结果中</p><p>这个时候，这一行里面没有的元素就会用 <code>NULL</code> 来填充</p><p><code>RIGHT JOIN</code> 是相似的</p><p><code>UNION</code> 操作符：合并多个 SELECT 语句的结果集</p><p>有两种用法：</p><p>第一种是 <code>UNION</code>，那么不会保留重复值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> country <span class="keyword">FROM</span> apps</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country;</span><br></pre></td></tr></table></figure><p>另一种是 <code>UNION ALL</code>，会保留重复值</p><p>还可以在加上 <code>WHERE</code> 等语句 再进行筛选</p><blockquote><p><code>WHERE</code> 语句一般加在 <code>ORDER BY</code> 前面</p></blockquote><h3 id="视图（VIEWS）"><a href="#视图（VIEWS）" class="headerlink" title="视图（VIEWS）"></a>视图（VIEWS）</h3><p>视图 - 可视化的表</p><p>感觉很像是从表中选择了部分数据，不是特别具体</p><p>似乎 Northwind 样本数据库使用的比较多</p><h3 id="MySQL-中的时间-Dates"><a href="#MySQL-中的时间-Dates" class="headerlink" title="MySQL 中的时间 Dates"></a>MySQL 中的时间 Dates</h3><p>有一些内建时间函数，可以参考：<a href="https://runoob.com/sql/sql-dates.html">https://runoob.com/sql/sql-dates.html</a></p><p>比如 NOW() 返回当前的时间和日期 - 分为两个部分 CURDATE() 是当前的日期，CURTIME() 是当前的时间</p><p>可以使用 <code>DATA_FORMATE(date, format)</code> 函数来指定 想要的显示 日期&#x2F;时间数据的格式，format 部分就是正则式</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>NULL - 遗漏的未知数值，不是0，不能和0比较</p><p>要选用 为 NULL 的数值，应该用 <code>WHERE column_name IS NULL</code></p><p>不选用，则是 <code>IS NOT NULL</code></p><p>MySQL 中还有 <code>IFNULL(column_name, 0)</code>函数，用来处理，如果这个值是 NULL，那么就会转化为0</p><p>或者 <code>COALESCE(column_name, 0)</code> 函数，如果是NULL，转为0</p><p>SQL中常用的数据类型，以Mysql为例子：</p><ul><li>int</li><li>float</li><li>Char - 也就是 string，最多255，固定长度</li><li>Varchar - 也就是string（variable）一类的， 可变长度，最多255</li><li>blob或者 text - 也就是 binary object</li></ul><p>每种具体的数据库里面可能是不太一样的</p><p>Mysql中主要三类</p><ul><li>Text 类型，也分 tiny、medium、long的</li><li>number 类型，分 tiny、small、medium、big、float、double等</li><li>date 类型，分日期的、日期时间的、时间戳（timestamp）、年的</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释方法：</p><ul><li><code>–</code> 单行注释，两个 - ，加一个空格</li><li><code>#</code> 单行注释</li><li><code>/* */</code> 多行注释</li></ul><blockquote><p>自检查：<a href="https://blog.csdn.net/hundan_520520/article/details/54881208?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=1328593.8838.16147378952884227&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">SQL数据库面试题以及答案（50例题）</a></p></blockquote><h2 id="常用原则"><a href="#常用原则" class="headerlink" title="常用原则"></a>常用原则</h2><blockquote><p>参考：<a href="https://blog.csdn.net/qq_22222499/article/details/79060495">数据库常见面试题（附答案）</a></p></blockquote><p>基本表的性质【事务四大特征】</p><ul><li>原子性：要么执行，要么不执行</li><li>隔离性：所有操作全部执行完以前，其他会话不能看到过程</li><li>一致性：事务前后，数据总额一致</li><li>持久性：一旦事务提交，对数据的改变是永久的</li></ul><p>索引分类（5种），索引失效条件</p><ul><li>普通索引：最基本的索引，没有任何限制</li><li>唯一索引：索引列的值必须唯一，可以空值</li><li>主键索引：唯一索引，不允许空值</li><li>全文索引：耗时耗空间</li><li>组合索引：提高效率，遵循“最左前缀”原则</li></ul><p>关于数据库有几种索引</p><ul><li>按索引列的唯一性，可以分为唯一索引和非唯一索引</li><li>按索引列的个数：单列索引和符合索引</li><li>按索引列的物理组织方式：B树索引、位图索引、反向键索引、函数索引、删除索引、重建索引</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;怎么样建立起一个数据仓库的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;肯定不是说把 csv 数据导入 mysql 这么简单，确实就像 布迩 说的，我这个算是别人建好的数据仓库&lt;/li&gt;
&lt;li&gt;那么究竟怎样才是自己建立数据仓库呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;csv 文件导入 MySQL：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;load data infile &amp;#x27;F:/MySqlData/test1.csv&amp;#x27; -- CSV文件存放路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;into table student -- 要将数据导入的表名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fields terminated by &amp;#x27;列的分隔符&amp;#x27; optionally enclosed by &amp;#x27;&amp;quot;&amp;#x27; escaped by &amp;#x27;&amp;quot;&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lines terminated by &amp;#x27;\r\n&amp;#x27; -- 回车换行符;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果是linux下生成的文件，就是 &lt;code&gt;\n&lt;/code&gt; 结尾&lt;/p&gt;
&lt;p&gt;注意：这个东西很有可能会出现各种的报错，需要修改配置文件等内容&lt;/p&gt;</summary>
    
    
    
    <category term="Data Analysis" scheme="http://yoursite.com/categories/Data-Analysis/"/>
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
    <category term="DataBases" scheme="http://yoursite.com/tags/DataBases/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（五）</title>
    <link href="http://yoursite.com/2021/02/02/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <id>http://yoursite.com/2021/02/02/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/</id>
    <published>2021-02-02T03:58:49.000Z</published>
    <updated>2021-03-03T08:43:37.213Z</updated>
    
    <content type="html"><![CDATA[<p>每期10题，上一期参见<a href="https://sunyoe.github.io/2021/01/12/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/">LeetCode刷题笔记（四）</a>。</p><p>本期内容紧贴2021年1月leetcode每日一题，本月主要内容是并查集（包括深度优先或广度优先）及双指针，包括在周赛中也遇到双指针题目，需要重点考虑。</p><h2 id="1018-可被5整除的二进制前缀"><a href="#1018-可被5整除的二进制前缀" class="headerlink" title="1018. 可被5整除的二进制前缀"></a>1018. 可被5整除的二进制前缀</h2><p>输入：整数列表 - 只有 0 和 1</p><p>输出：布尔列表 - 只有 false 和 true</p><p>要求：依次选择整数列表中 从 第0位到第i位的所有数字，这是一个二进制数字，如果可以被5整除，那么布尔列表的第 i 位为true，否则为false。</p><span id="more"></span><hr><h3 id="自我解读"><a href="#自我解读" class="headerlink" title="自我解读"></a>自我解读</h3><p>方案：</p><p>（1）先获得十进制数字</p><p>由于本身就是列表，确实要稍微容易一点</p><p>$num_{10} &#x3D; num_2[-1] * 1 + num_2[-2] * 2 +…+num_2[-i] * 2^{i-1}$</p><p>但是如果每次都是从头开始计算，2的幂需要计算，空间占用会比较多</p><p>（2）能不能被 5 整除其实最关键的就是看最后一位，5或者0就可以</p><p>观察一下：1，2，4，8，16，32，64，128，256，…，已经有规律了</p><table><thead><tr><th>阶数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>最后一位</td><td>1</td><td>2</td><td>4</td><td>8</td><td>6</td></tr><tr><td><strong>阶数</strong></td><td></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td><td><strong>8</strong></td></tr><tr><td>最后一位</td><td></td><td>2</td><td>4</td><td>8</td><td>6</td></tr></tbody></table><p>那么能够产生被5整除的情况：</p><ul><li><input checked="" disabled="" type="checkbox"> 1 + 4：索引0 + 索引2+4n</li><li><input checked="" disabled="" type="checkbox"> 2 + 8：索引1+4n + 索引3+4n</li><li><input checked="" disabled="" type="checkbox"> 4 + 6：索引2+4n + 索引4+4n</li></ul><p>对以上组合的对数进行计算，只要能配好对，那就可以整除</p><p>我觉的这个思路就好很多，尤其对一些比较长的数字会比较好</p><p>存在几个问题：</p><p>（1）那么问题是到底要怎么样进行遍历呢：比如我可以判断 2+4n 有没有超过 len</p><p>（2）能不能利用前面的数据判断当前的情况？其实应该是可以的，每次应该计算出下一位需要几，如果是那么就是true，如果不是那么就是false；这样形成一个动态规划</p><p>比如说刚开始形成3个存储数字A1，A2，B1，B2，C1</p><ul><li>开始，如果索引0是1，A1+1</li><li>如果索引2+4n是1，A2+1</li><li>如果索引1+4n是1，B1+1</li><li>如果索引3+4n是1，B2+1</li><li>如果索引4+4n是1，C1+1</li></ul><p>最后判断：A1+C1 &#x3D;&#x3D; A2，B1 &#x3D;&#x3D; B2，这样又会出现一个问题，如果刚好是 22222，那么也是可以的，这样是1+4n为奇数</p><p>注意，0对数值大小完全没有影响</p><p>（3）新方案，设一个数值Res，直接遍历字符串，然后</p><ul><li>索引0是1，Res+1</li><li>索引1+4n是1，每个+2</li><li>索引2+4n是1，每个+4</li><li>索引3+4n是1，每个+8</li><li>索引4n是1，每个+6</li></ul><p>最后，如果Res可以被5整除，那么就是true，如果不是那就不行</p><p>然后，每次是在结尾增加了一位数字</p><ul><li><p>索引0 -》索引1，Res+1</p></li><li><p>索引1+4n -》 索引2+4n，每个+2</p></li><li><p>索引2+4n -》 索引 3+4n，每个+4</p></li><li><p>索引3+4n -》 索引 4n，每个-2</p></li><li><p>索引4n -》 索引1+4n，每个-4</p></li></ul><p>确实是可以进行抵消的，但问题是前面各索引有1有0需要计数吗？</p><p>也就是说我只统计各索引的次数，然后每次把这些数字进行移动（轮换）</p><hr><h3 id="观察题解"><a href="#观察题解" class="headerlink" title="观察题解"></a>观察题解</h3><p>官方题解</p><p>从二进制到十进制数字的特点是：$N_i &#x3D; N_{i-1} \times 2 +A[i]$</p><p>每添加一位数字，计算余数，看能不能被5整除就可以了，这个方法也不错，还很简单</p><p>相对来说，我的方法还是复杂了，惭愧！</p><h1 id=""><a href="#" class="headerlink" title=""></a><!--并查集系列--></h1><h2 id="947-移除最多的同行或同列石头-并查集"><a href="#947-移除最多的同行或同列石头-并查集" class="headerlink" title="947. 移除最多的同行或同列石头 - 并查集"></a>947. 移除最多的同行或同列石头 - 并查集</h2><p>输入：二维整数数组，每个子数组只有两个整数元素，相当于坐标</p><p>输出：一个整数</p><p>要求：同行（第一个元素相同），或者同列（第二个元素相同）的子数组只能保留一个，最后输出的就是要去除的子数组的数量</p><hr><h3 id="自我解读-1"><a href="#自我解读-1" class="headerlink" title="自我解读"></a>自我解读</h3><p>遍历数组，如果行号是新的，行号list新增一个</p><p>如果列号是新的，列号list新增一个</p><p>遇到新的子数组，检查行号是不是在行号list中，是，del+1，直接下一个</p><p>否，检查列号是不是在列号list中，是，del+1，直接下一个</p><p>否，下一个，过</p><blockquote><p>但是，题目中要求是：&#x3D;&#x3D;可以移除的石子的最大数量&#x3D;&#x3D;</p></blockquote><p>比如示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = <span class="comment">[<span class="comment">[0,0]</span>,<span class="comment">[0,1]</span>,<span class="comment">[1,0]</span>,<span class="comment">[1,2]</span>,<span class="comment">[2,1]</span>,<span class="comment">[2,2]</span>]</span></span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>如果按照我的思路，先记录了【0，0】，那么会去掉【0，1】【1，0】，但是不会取消【1，2】</p><p>但是实际答案说的却是：先移除【2，2】，因为它和【2，1】同行了，。。。最后就只剩下了【0，0】，就像是后来的先移除，这样一定是移除最多的吗？</p><p>另一个问题：所有输入一定是一行一行进行展示的吗，这样的话岂不是要简单一点</p><blockquote><p>既然需要最大移除数量，那么就要把移除的石子的两个坐标也加入到list中，这样一定是最大的吗？</p></blockquote><p>还是存在一点问题的：</p><p>例如一个输入：<code>[[0,1],[1,0],[1,1]]</code>，最多可以移除两个石子，但是按照上面的算法却只能去除一个石子</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210115142425858.png" alt="image-20210115142425858"></p><p>类似的，其实这样一个三角结构，会决定到底应该怎么样进行移除</p><p>我们如果是从前往后，那么就只能移除1个，但是如果从后往前，就可以移除两个，同样，反过来也是一样的</p><blockquote><p>新增案例：<code>[[0,1],[1,2],[1,3],[3,3],[2,3],[0,2]]</code></p></blockquote><p>这个案例说明了，子数组并不是按顺序的，如果不按顺序来进行排列</p><p>就有可能导致少删除一个</p><hr><h3 id="阅读题解"><a href="#阅读题解" class="headerlink" title="阅读题解"></a>阅读题解</h3><p>横坐标相同、或者纵坐标相同，那么就形成了一条边，有联系的边构成了一个连通图</p><p>&#x3D;&#x3D;<strong>一定可以把一个连通图里的所有顶点根据该规则删到只剩下一个顶点</strong>&#x3D;&#x3D;</p><p>原因是：连通图中，可以通过<strong>遍历</strong>方式遍历到该连通图中的所有顶点，按照遍历的逆向顺序移除石头就可以只剩下一块石头</p><p>所以，题目的结果 &#x3D; 石头总数 - 极大连通子图（连通块或连通分量）的个数（连通块的数量&#x3D;最后剩下的石头的数量）</p><p>并查集里的元素是描述 横坐表和纵坐标的数值</p><p>遍历数组，每个元素的横坐表和纵坐标在并查集中进行合并</p><blockquote><p>合并：所有横坐标 为x的石头和所有纵坐标 为y的石头都属于同一个连通分量</p></blockquote><p>那么在并查集内部，我们要如何区分横纵坐标？</p><p>石头的位置是 数组，并查集底层是一维，怎么样在并查集中区分横纵坐标</p><p>方法是扩大坐标区间，比如题目说 $0&lt;&#x3D;x_i,y_i&lt;&#x3D;10^4$，那么就可以操作：$横坐标 \pm 10001 $，从而超越原来的区间，保证不会重复</p><p>&#x3D;&#x3D;<strong>问题是怎么合并</strong>？&#x3D;&#x3D;</p><p>（1）第一种方法：需要<strong>枚举计算任意两点间的连通性</strong>，可以使用深度优先或者广度优先搜索的方法进行计算</p><p><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/yi-chu-zui-duo-de-tong-xing-huo-tong-lie-m50r/">官方题解</a>的python3代码中使用了<code>edge=collections.defaultdict(list)</code>来作为存储单元，用于建图，也就是通过枚举找到了<strong>所有</strong>相互关联的边</p><p>但是到了深度优先搜索这里，看上去还是使用了一些库吗？<code>vis.add(x)</code>，但是vis并没有进行定义，也有可能是定义的晚了（在下方，函数调用前有一个定义<code>vis=set()</code>）？我个人觉得这个写法很糟糕，也许是和下面的代码进行了联动，但是展示出来的效果却非常差</p><p>（2）第二种方法：</p><p>上面的方法需要循环套循环进行元素的遍历完成建图，还是有一点麻烦了。</p><p>任意两点之间直接相连或间接相连其实都是可以的，我们只关注两点之间的连通性。</p><p>该方法说对于拥有k个石子的任意一行或者一列，都使用 k-1 条边进行连接</p><p>所以方法就是：</p><ol><li>先用哈希表存储每一行或每一列所拥有的石子，对纵坐标加了10000，以区分横纵坐标</li><li>然后分别处理每一行或每一列的连通属性</li></ol><p>非官方题解：</p><p><strong>大多数方法建立了一个专门的&#x3D;&#x3D;class（class UnionFind）&#x3D;&#x3D;来归纳并查集的方法，然后对该类中的方法进行调用</strong></p><hr><p>终于找到一个可能比较容易理解的算法了</p><p>参考：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/pythonbing-cha-ji-onlogm94om19-by-jasonc-3uv7/">Python,并查集, O(nlogm)94%,O(m)19%</a></p><p>仍然保留了两个关键：</p><ul><li>答案 &#x3D; 石头总数 - 连通块的数量</li><li>纵坐标+10000，&#x3D;&#x3D;<strong>这样就可以把坐标也看成edges了！</strong>&#x3D;&#x3D;</li></ul><p>这里举了例子：</p><p><code>[[0,0],[1,1],[1,2]]=&gt;[[0,10000],[1,10001],[1,10002]]</code></p><p>这里（1）思考为5个nodes：<code>0,10000,1,10001,10002</code></p><p>（2）把<code>[0,10000]</code>视为 node 0和node 10000有edge连通，其他类似，这样就好理解为什么<code>+10000</code>能方便求解了</p><p>然后转化为了熟悉的图并查集问题，遍历所有edges，找出所有连通组</p><blockquote><p>步骤一：给所有纵坐标+10000</p></blockquote><p>还是比较容易的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> stone <span class="keyword">in</span> stones:</span><br><span class="line">    stone[-<span class="number">1</span>] += <span class="number">10000</span></span><br></pre></td></tr></table></figure><blockquote><p>步骤二：如何遍历所有的edges，找出所有连通组？</p></blockquote><p>代码中建立了一个字典吗？还是set？</p><p><code>dus=&#123;s+i*10000:s+i*10000 for stone in stones for i, s in enumerate(stone)&#125;</code></p><p>遍历每一个石头，i 是第几个，s是坐标值啊，s+i*10000?这个我就不太理解了，是原来的意思吗</p><p>神奇，我尝试了一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = [[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dus = &#123;k+i*<span class="number">10000</span>:k+i*<span class="number">10000</span> <span class="keyword">for</span> s <span class="keyword">in</span> ss <span class="keyword">for</span> i, k <span class="keyword">in</span> <span class="built_in">enumerate</span>(s)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dus</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">10000</span>: <span class="number">10000</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">10001</span>: <span class="number">10001</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">10002</span>: <span class="number">10002</span>&#125;</span><br></pre></td></tr></table></figure><p>没想到真的能出这样的结果</p><p>当我打下下面的代码的时候，发现了问题所在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(k)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这是因为 enumerate 针对的是stone，而不是stones！</p><p>每个stone只有两个元素，所以 i 只有0 或1，而k就是横坐标或者纵坐标</p><p>所以每个横坐标对应0，不会加10000，每个纵坐标对应1，会加10000，就区分开来了，而且使用的是字典，会自动去重！</p><p>【妙啊】</p><p>然后定义了一个find函数：</p><ul><li>输入是 i</li><li>如果 字典中 i 对应的位置不是 i<ul><li>那么继续find（字典中 i 对应的数值），并赋值给 字典中 i 的位置</li></ul></li><li>返回 字典中 i 对应的数值</li></ul><blockquote><p>需要观察一下</p><p>比如说 字典 bus &#x3D; {1:1, 2:2, 0:0}</p><p>dus[0] &#x3D; 0肯定的</p><hr><p>如果 字典 bus &#x3D; {1:2, 2:1, 0:1}</p><p>dus[0] &#x3D; 1，不等于0</p><p>那么我们再找 find(dus[0]) &#x3D; find(1)</p><p>find(1)中，dus[1]  &#x3D; 2，也不等于 1，再找find(2)</p><p>find(2)中，dus[2] &#x3D; 1，也不等于 2，再找find(1)不停循环</p><hr><p>也就是说不停找，直到找到字典中 key和value一样的值？</p></blockquote><p>然后遍历stones，如果横坐标在字典中，而且横坐标对应的值不等于纵坐标对应的值【这有可能相等吗】</p><ul><li>那么，字典中横坐标对应的位置，value等于纵坐标+10000对应的数值</li></ul><blockquote><p>举个例子</p><p><code>stones = [[0,0], [0,1], [0,2]]</code></p><p>那么</p><p><code>dus=&#123;0:0, 10000:10000, 10001:10001, 10002:10002&#125;</code></p><ul><li><p>首次循环：0 在dus，find(0) &#x3D; 0 !&#x3D; find(0+10000)&#x3D;10000【是否存在】</p><ul><li>所以 dus[find(0)] &#x3D; dus[0] &#x3D; find(0+10000) &#x3D; 10000</li><li><code>dus=&#123;0:10000, 10000:10000, 10001:10001, 10002:10002&#125;</code></li></ul></li><li><p>下一个循环：0 在dus，find(0)中，dus[0] &#x3D; 10000 !&#x3D; 0了，找find(10000) &#x3D; 10000，赋值给 dus[0]，最后输出10000 !&#x3D; find(10001) &#x3D; 10001</p><ul><li>所以 dus[find(0)] &#x3D; dus[10000] &#x3D; find(10001) &#x3D; 10001</li><li><code>dus=&#123;0:10000, 10000:10001, 10001:10001, 10002:10002&#125;</code></li></ul></li><li><p>下一个循环：0 在dus，find(0)中，dus[0] &#x3D; 10000 !&#x3D; 0了，找find(10000) &#x3D; 10001 !&#x3D; 10000，再找find(10001)&#x3D;10001，赋值给 dus[0]，最后输出10001 !&#x3D; find(10002) &#x3D; 10002</p><ul><li>所以dus[find(0)] &#x3D; dus[10001] &#x3D; find(10002) &#x3D; 10002</li><li><code>dus=&#123;0:10000, 10000:10001, 10001:10002, 10002:10002&#125;</code></li></ul></li></ul></blockquote><p>然后，需要再来一个循环：</p><p>对dus字典中的每一个值进行遍历：</p><p><code>for k in dus: print(k)</code></p><p>这里要注意，输出的只有 字典dus 的键 key，而没有value值</p><blockquote><p>紧接着上面的注释</p><p>现在，find(0) &#x3D; find(10000) &#x3D; find(10001) &#x3D; find(10002) &#x3D; 10002</p><p>所以，最后的字典是：</p><p><code>dus=&#123;0:10002, 10000:10002, 10001:10002, 10002:10002&#125;</code></p></blockquote><p>最后一步，<code>set(dus.values())</code></p><p>应该是取字典 dus 的所有值 values，然后生成集合 set，会去重，再计算集合的长度就是连通域的数量了</p><p>简直是太妙了！！！</p><p>其实find函数就是寻找最高节点的过程；</p><p>而第一个循环的意义就是把横坐标的指向改变，也就是添加连通边edge，建图的过程</p><h2 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a>1584. 连接所有点的最小费用</h2><p>输入：二维整数数组，每个子数组有两个整数，表示坐标点</p><p>输出：整数，表示将所有点连接起来的最小总费用</p><p>要求：任意两点之间有且仅有一条简单路径，总路径长度和要最小</p><hr><p>果然，又是一个图论的问题</p><p>比如说我们要建图，每个点要连接到最近的一个点</p><p>但是如果两个点互相是最近的点呢 - 构成了一个孤立的群，两个群之间找一个最短的边即可</p><p>如果 A 周围最近的是 B，B 周围最近的是 C，C 周围最近的会不会是 A？不会，一定不是 A</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210119161038414.png" alt="image-20210119161038414"></p><p>不然的话，离 A 最近的就不是 B 了</p><p>又是一个并查集的问题</p><hr><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>满足任意两点之间有且仅有一条简单路径，只有 树结构 - tree</p><p>该树 &#x3D; 给定图的生成树，总权值最小的生成树，成为最小生成树</p><p>经典算法：Kruskal 算法</p><ol><li>图中所有边按照长度的由小到大进行排序，等长边任意顺序</li><li>从前往后（也就是从小到大）扫描排序后的边，如果扫描到的边 <strong>连接了两个相异的连通块</strong>，则将它插入图中</li><li>最后得到的图就是最小生成树</li></ol><p>所以现在的问题是 key <strong>应该取edge的两个端点</strong>，还是<strong>选择edge 的边长</strong></p><p>第一步：建立一个字典，字典的所有value就是list</p><p><code>rec = collections.defaultdict(list)</code> ，表示建立了一个具有默认值的字典，默认值是list</p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><!--数组系列--></h1><h2 id="56-合并区间-数组"><a href="#56-合并区间-数组" class="headerlink" title="56. 合并区间 - 数组"></a>56. 合并区间 - 数组</h2><p>输入：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端</p><p>输出：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端</p><p>要求：输入数组可能会有重叠，将重叠的两个区间进行合并，输出区间不能有重叠</p><hr><p>我曾想到过一个方法，类似做直方图</p><ul><li>先新建了一个字典，默认为0</li><li>然后遍历所有的区间，有这个区间，那就在这个区间内将所有的数字对应在字典中的value +1</li><li>最后取出所有有数字的key值，再取start和end进行集合</li></ul><p>问题是遇到了一个样例：</p><p><code>[[1,4],[5,6]]</code></p><p>如果直接进行直方图，那么一定会得到 <code>[[1,6]]</code></p><p>但是实际上这两个区间并没有重叠</p><p>原有代码;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="comment"># 先建立一个字典，对每一个key的默认值是int类型</span></span><br><span class="line">        merge_dict = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        merge_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            start, end = interval[<span class="number">0</span>], interval[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end+<span class="number">1</span>):</span><br><span class="line">                merge_dict[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        max_key = <span class="built_in">max</span>(merge_dict.keys())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_key+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> start <span class="keyword">and</span> merge_dict[i]:</span><br><span class="line">                start = i</span><br><span class="line">            <span class="keyword">if</span> start:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> merge_dict[i]:</span><br><span class="line">                    merge_list.append([start, i-<span class="number">1</span>])</span><br><span class="line">                    start = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> i == max_key:</span><br><span class="line">                    merge_list.append([start, i])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> merge_list</span><br></pre></td></tr></table></figure><h3 id="官方题解-1"><a href="#官方题解-1" class="headerlink" title="官方题解"></a>官方题解</h3><p><strong>排序方法</strong></p><p>如果按照区间的左端点进行排序，在排序后：</p><p>&#x3D;&#x3D;<strong>可以合并的区间一定是连续的</strong>&#x3D;&#x3D;</p><blockquote><p>官方证明中举例是： a[i], a[j], a[k]，a[i]和a[k] 能合并，但是 a[i] 和 a[j], a[j] 和 a[k]均不能合并</p><p>但是我自己举了一个例子：<code>[1,10],[2,5],[10,11]</code>，这个例子明显不满足上面说的 <code>a[i]</code>和<code>a[j]</code>也不能合并的条件，所以其实并不满足题意</p></blockquote><p>用 merged 区间表示最后需要输出的多维列表，先将第一个列表存储到区间中：</p><p>遍历所有区间</p><ul><li>左端点在上一个区间的右端点后<ul><li>是，表示不重合，那么加入输出数组</li><li>否，表示重合，那么需要更新右端点</li></ul></li></ul><p>第一步：排序，怎样按照第一个元素的大小进行排序？</p><p><code>list.sort()</code>方法的使用</p><p><code>list.sort(key=lambda x: x[0])</code>就可以根据第一个元素的大小进行排序</p><blockquote><p>排序保证了后一个区间的起始点不会小于前一个区间的起始点，所以只需要比较尾巴，不用比较头了</p></blockquote><p>第二步：遍历，进行对比</p><p>&#x3D;&#x3D;本方法的独特性在于，直接与上一个区间进行对比，而不需要再对前面的区间进行对比了&#x3D;&#x3D;</p><p>比如上面的区间对比完了之后已经存储在 <code>merged</code> 里面了，那么现在最新的一个区间，只需要和 <code>meged[-1]</code>进行对比，就可以了，而不需要从 <code>merged[0] </code>开始进行对比</p><p>最后的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        merged = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> merged[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">                merged.append(interval)</span><br><span class="line">            <span class="keyword">elif</span> merged[-<span class="number">1</span>][<span class="number">1</span>] &gt;= interval[<span class="number">0</span>]:</span><br><span class="line">                merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure><h2 id="154-offer-11-旋转数组的最小数字"><a href="#154-offer-11-旋转数组的最小数字" class="headerlink" title="154-offer 11 旋转数组的最小数字"></a>154-offer 11 旋转数组的最小数字</h2><p>二分查找方法</p><p>首先说明旋转数组是指能旋转一次就变成升序数组的数组</p><p>所以特点就是，原来的数组是升序排列的</p><p>当旋转一次后，其排列规律是：</p><p><img src="https://assets.leetcode-cn.com/solution-static/jianzhi_11/1.png" alt="fig1"></p><p>最小值右侧的元素都是小于等于右边界点的</p><p>最小值左侧的元素都是大于等于左边界点的</p><p>可以利用以上的性质从而缩小最小值所在的区间</p><p>有一种情况是中间某个点的数值大小 等于 边界点</p><p><img src="https://assets.leetcode-cn.com/solution-static/jianzhi_11/4.png" alt="fig4"></p><p>那么这个时候不能简单说明该点左侧或者右侧是区间，而应该调整边界点（边界点一定是满足降序要求的，从而找出区间）</p><h2 id="面试题04-二维数组中的查找"><a href="#面试题04-二维数组中的查找" class="headerlink" title="面试题04.二维数组中的查找"></a>面试题04.二维数组中的查找</h2><p>一个二维数组，每一列从上到下递增，每一行从左到右递增</p><p>请在该数组中找某一个数值时候存在，当存在时返回 True，不存在 返回 False</p><p>暴力方法，直接查找</p><p>线性查找，比如从数组的左下角开始查找，如果比target大，那么行数 -1，如果比 target 小，那么列数 +1</p><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><p>输入：一个递增数组</p><p>输出：最长连续递增子数组的长度</p><p>非常的明白，就是贪心法把最长的找出来</p><p>可能会遇到两个问题：</p><p>（1）怎么处理末尾的问题，到末尾，一方面要继续比较是不是递增序列，另一方面还要把当前的子序列输入进结果</p><p>（2）怎么样重置，重置为0是不好的，应该重置为1</p><p>所以我的代码是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        len_list = []</span><br><span class="line">        len_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> i:</span><br><span class="line">                len_max += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                len_max += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                len_list.append(len_max)</span><br><span class="line">                len_max = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                len_list.append(len_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> len_list <span class="keyword">else</span> <span class="built_in">max</span>(len_list) </span><br></pre></td></tr></table></figure><p>而官方的代码是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt;= nums[i - <span class="number">1</span>]:</span><br><span class="line">                start = i</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>每次计算的过程中都在更新最大值，这样能够减少对空间的使用</p><p>其次记录的并不是递增序列的长度，而是起始位置，这样也可以减少空间的消耗，只有在变小的时候才会更新起始位置</p><h1 id="-2"><a href="#-2" class="headerlink" title=""></a><!--双指针系列--></h1><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>本次周赛的过程中，遇到这类问题，找到四个数字构成定积元组一类的问题，怎么样减小时间复杂度？</p><p>发现15、16、18三道题都是这样的问题，看来需要进行一个专题的解决。</p><p>相似题目：两数之和、最接近的三数之和、四数之和、较小的三数之和</p><p>标签：数组，双指针</p><hr><p>输入：一个整数数组</p><p>输出：二维整数数组，每个子数组中有3个数字，和为0</p><p>要求：</p><ul><li>找出所给整数数组中和为0的所有组合</li><li>组合不能重复</li><li>所给整数数组中的数字是有可能重复的</li></ul><hr><p>在示例中出现了一种情况，如果本身数字比较少，少于3个，直接可以返回结果为空</p><p>如果数字在3个以上，那也只好进行遍历了，找到所有组合，这样的话，一定需要 $O(n^3)$</p><p>提示：</p><ol><li>如果能固定一个数字，那么就变成了一个“两数之和”的问题了</li><li>在两数之和问题中，如果我们固定一个数组，我们就需要扫描整个数组，找最后一个数字是不是存在，可不可以<strong>修改这个数组</strong>从而让这个查找变得更快呢？</li><li>或者在不改变数组的情况下，我们呢是不是可以<strong>通过使用额外空间 的方法</strong>，比如哈希表来加速搜索</li></ol><p>我直接用遍历的方法进行计算，遇到一个问题：可能会出现相同的元组</p><p>例如：<code>nums=[-1,0,1,2,-1,-4]</code></p><p>如果从头开始遍历，可能有 <code>[-1,0,1]</code>，然后又会遇到<code>[0,1,-1]</code>，这两个元组会重复（如果是list确实不重复），但是<code>[-1,-1,2]</code>又是可以的</p><h3 id="官方题解-2"><a href="#官方题解-2" class="headerlink" title="官方题解"></a>官方题解</h3><ol><li><p>用排序避免重复答案</p></li><li><p>所谓双指针的方法是说：一个头指针，一个尾指针，如果和比较小，移动头指针，如果和比较大，移动尾指针，直到找到值</p></li></ol><p>但即使如此，还没有完全解决问题，比如 <code>[0,0,0,0]</code>，也只能出一个结果 <code>[0,0,0]</code>，但是如果只是进行移动，而没有进行判断，最后会出两个<code>[0,0,0]</code></p><p>实际题解中用了一些细节来解决各种问题：</p><ol><li>如果这次的首位数字和上一次的首位数字相同，直接跳过</li><li>第二个元素虽说是左指针，但是也可以用for循环</li><li>这次的第二个元素也应该和上一次的第二个数字不同，也就是所找一个全新的第二个数字</li><li>只移动右指针即可</li></ol><p>官方代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            third = n - <span class="number">1</span></span><br><span class="line">            target = -nums[first]</span><br><span class="line">            <span class="comment"># 枚举 b</span></span><br><span class="line">            <span class="keyword">for</span> second <span class="keyword">in</span> <span class="built_in">range</span>(first + <span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> second &gt; first + <span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> second &lt; third <span class="keyword">and</span> nums[second] + nums[third] &gt; target:</span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment"># 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> second == third:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[second] + nums[third] == target:</span><br><span class="line">                    ans.append([nums[first], nums[second], nums[third]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/3<span class="built_in">sum</span>/solution/san-shu-zhi-he-by-leetcode-solution/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>我的错误代码（时间会比较长）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 排序，以免重复</span></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历第一个数字 A</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 确保在i循环中，该数字不会重复</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历第二个数字 B，正着遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="comment"># 确保在j循环里面，该遍历数字是不会重复的</span></span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                target = - nums[i] - nums[j]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 第三个数字，从尾部遍历</span></span><br><span class="line">                k = n-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j&lt;k <span class="keyword">and</span> nums[k]&gt;target:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j == k:</span><br><span class="line">                    <span class="comment"># 说明到头了，这个循环结束了</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> target==nums[k]:</span><br><span class="line">                    result.append([nums[i],nums[j],nums[k]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>关键的原因请看第22行： <code>k=n-1</code>这行代码如果放在 <code>j</code>循环中，那么就跟3个循环是一样的！！</p><p>如果放在 <code>j</code>循环的外面，立马就不一样了，j 增加， k并没有每次都归 （n-1），这样就减少了一次循环，这是非常重要的！</p><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>输入：整数数组 nums，整数target</p><p>输出：整数</p><p>要求：在nums中找3个数字，其和与target最接近，输出的整数即为该和，假设只有一个答案</p><hr><p>那么这一次，我们需要记录最小的和，也就是差值最小的和，然后每次去比较差值，如果没有更小的了，那就是它了</p><p>还是双指针</p><p>先要做一个排序</p><p>第一个数字遍历</p><ul><li>开头取一个，结尾取一个</li><li>如果大了，结尾小一位，如果小了，开头就要加一位，最终会有一个最接近的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">len</span>:</span><br><span class="line">    first_num = <span class="built_in">list</span>[i]</span><br><span class="line">    k = n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i+<span class="number">1</span>:<span class="built_in">len</span>:</span><br><span class="line">        second_num = <span class="built_in">list</span>[j]</span><br><span class="line">        <span class="built_in">sum</span> = first_num + second_num</span><br><span class="line">        sum_des = target - <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">list</span>[k] &gt; sum_des:</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">sum</span> += second_num + third_num</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>但是此时的比较方案和上面又不太一样了，如果 k减到最后已经比最后的差值小了，再升 j 还是小</p><p>没关系，我们可以额外使用一个变量，用来比较和存储比较小的差值</p><p>本题的三个数字是不是还需要像上面的题一样避免重复？</p><ul><li>i 不变的情况下，确实 j 不用再重复了</li><li>i 如果重复呢，确实也不用，所以 i 最好也不要重复了</li></ul><hr><h3 id="官方题解-3"><a href="#官方题解-3" class="headerlink" title="官方题解"></a>官方题解</h3><ol><li><p>本题和15题不一样的地方在于，本题要的是最小差距，而不是枚举所有的最小差距的取值</p></li><li><p>双指针既可以用之前的双循环的方式进行书写，也可以使用真的双指针，两个索引的方式进行书写</p></li><li><p>初始化 最佳答案的方法是，直接赋值，赋一个很大的值，比如1e7</p></li></ol><p>最后完成的代码是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 首先排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        len_num = <span class="built_in">len</span>(nums)</span><br><span class="line">        min_tar = <span class="number">1e7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一个数字的索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_num):</span><br><span class="line">            <span class="comment"># 防止重复</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 第二个数字的索引</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第三个数字的索引</span></span><br><span class="line">            k = len_num - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                sum_three = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> sum_three &gt; target:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum_three == target:</span><br><span class="line">                    <span class="keyword">return</span> sum_three</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(sum_three - target) &lt; <span class="built_in">abs</span>(min_tar - target):</span><br><span class="line">                    min_tar = sum_three</span><br><span class="line">        <span class="keyword">return</span> min_tar</span><br></pre></td></tr></table></figure><p>相比官方答案有一点偷懒的地方就是更改 j和k 的时候是直接改，并没有去检查一下修改后的实际数值和修改前的有什么区别，这样其实不太好，确实会重复计算。</p><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h2><p>输入：整数数组nums，目标值 target</p><p>输出：二维数组</p><p>判断nums中是否存在 a,b,c,d，满足 $a+b+c+d&#x3D;target$，找出所有满足的组合（不能重复）</p><hr><p>本题看上去还是用双指针的方法进行解决</p><p><strong>第一种遍历方法：固定1、2、4，然后让第3位数字遍历</strong></p><p>先排序</p><p>第一个数字 i 直接循环</p><p>第二个数字 j从 i+1 开始递增</p><p>最后一个数字 从 n-1 开始递减</p><p>然后第三个数字 就要在 j 到 k 之间进行遍历</p><p>要注意的是，这一次，j和k的遍历都不能重复了，要保证是不同的</p><blockquote><p>之前的问题中，实现这一目标，有两种方法：</p><ol><li><p>循环用 for，然后在循环体中添加判断 当相同的时候就continue</p></li><li><p>循环用 while，循环体中直接判断，判断结束后直接修改索引（第二种方法可能看起来比较容易，实际上两个方法可能消耗的时间差不多）</p><p>这种方法的不足之处是，需要修改的时候，考虑的会比较多</p><p>而且使用while比较的时候似乎需要考虑会不会超出索引边界</p></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">if</span> a == last_a:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    j = a+<span class="number">1</span></span><br><span class="line">    k = <span class="built_in">len</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;k-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span> j-&gt;k:</span><br><span class="line">        <span class="keyword">if</span> a+j+c+k == target:</span><br><span class="line">            result.append(this_group)</span><br><span class="line">        <span class="comment"># 该怎样控制 j 和 k 的增减产生双指针的效果呢？        </span></span><br></pre></td></tr></table></figure><p><strong>在写上面那种方法的时候突然想到，如果我们先固定1，2，那么3，4不就是一个新的双指针了吗？而且这种方法看起来更可靠</strong></p><p>但是同样需要注意，2可以和1重复，但是2和之前的2不要重复，1和之前的1也不要重复，3也不要重复</p><p>出现的问题是在运行过程中，不是<strong>超出了时间限制</strong>，就是<strong>超出了内存限制</strong></p><p>哦，我忘了一件事，就是在 &#x3D;&#x3D;等于target的时候，也需要进行移动&#x3D;&#x3D;，不然就出不去了</p><h3 id="官方题解-4"><a href="#官方题解-4" class="headerlink" title="官方题解"></a>官方题解</h3><p>阅读官方的代码，发现了几个有意思的点：</p><ol><li><p>第一个数字的索引区间是 0到 n-3</p></li><li><p>第二个数字的索引区间是 i+1 到 n-2，还使用了 j&gt;i+1 保证满足j的区间正确</p></li><li><p>还有就是一些比较基础的判断：</p><ul><li>i,i+1,i+2,i+3 这样四个数字加起来如果都比target大，就不用再循环了</li><li>i，n-1，n-2，n-3这样四个数字加起来如果比 target小，那也不用循环了</li><li>i，j，j+1，j+2，这样四个数字加起来比 target 大，本轮（第二层循环）可以结束了</li><li>i，j，n-1，n-2，这样四个数字加起来比target 小，本轮（第二层循环）可以结束了</li></ul></li><li><p>最后在修改 左右区间的时候</p><ol><li>只有&#x3D;target的情况下，修改区间才需要判断是不是和之前的相等</li><li>不等于target，那就直接更改左右边界，不用判断和之前的是不是重复</li></ol></li><li><p>还有很有意思的地方：</p><ol><li><p>官方题解中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">    left += <span class="number">1</span></span><br><span class="line">left += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>因为是和右侧对比，所以可以先对比，最后再 +1</p></li><li><p>我刚开始的方法是，先+1，然后再和左侧进行对比</p></li><li><p>应该说两者还是有一些细节上的不同的</p></li></ol></li></ol><p>果然，使用基础判断条件能够极大减少判断时间！</p><p>再把 和的计算结果保存下来，又能节省一点时间（毕竟后面多次用到了计算出来的和）</p><h1 id="小岛问题-DFS练习"><a href="#小岛问题-DFS练习" class="headerlink" title="小岛问题 - DFS练习"></a>小岛问题 - DFS练习</h1><p>参考：<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/island.md">小岛问题  - DFS子专题</a></p><p>深度优先遍历的方法</p><p>经典方法：（四联通）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i,j</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i或j 出界: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (i,j)已经遍历过: <span class="keyword">return</span></span><br><span class="line">    temp = board[i][j]</span><br><span class="line">    <span class="comment"># 将（i，j）添加到已经遍历过的列表中</span></span><br><span class="line">    seen.add((i,j))</span><br><span class="line">    <span class="comment"># 按照四连通，分别对上下左右四个方向进行递归遍历</span></span><br><span class="line">    dfs(i+<span class="number">1</span>, j)</span><br><span class="line">    dfs(i-<span class="number">1</span>, j)    </span><br><span class="line">    dfs(i, j+<span class="number">1</span>)    </span><br><span class="line">    dfs(i, j-<span class="number">1</span>)    </span><br><span class="line">    <span class="comment"># 撤销标记</span></span><br><span class="line">    seen.remove((i,j))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用算法：单点搜索</span></span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 多点搜索</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        dfs(i, j)</span><br></pre></td></tr></table></figure><p>这种方法的标记是专门用了一个列表来存放遍历过的点</p><p>还有一种标记方法是原地标记，比如直接把遍历过的点的values变成 -1</p><p>参考：<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/DFS.md">深度优先遍历</a></p><p>Depth-First-Search 深度优先搜索算法，遍历或搜索树或图的算法</p><ul><li>沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</li><li>当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。</li><li>这一过程一直进行到已发现从源节点可达的所有节点为止。</li><li>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</li><li>属于<strong>盲目搜索</strong>。（对应启发式搜索，有目的地搜索）</li></ul><p>DFS是图论中的经典算法，和图、拓扑排序密切相关</p><p>对于树的题目，基本上都可以使用DFS来解决</p><p>DFS通常可以基于递归来做，因此算法会更简洁</p><h1 id="并查集练习"><a href="#并查集练习" class="headerlink" title="并查集练习"></a>并查集练习</h1><p>有个同学这样进行描述：<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md">并查集 union-find</a></p><p>一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。</p><p>有一个联合-查找算法（Union-find Algorithm），两个操作：</p><ul><li>find：确定元素属于哪一个子集【建图和压缩路径】</li><li>union：将两个子集合并成同一个集合</li></ul><p>不带权并查集</p><p>带权并查集</p><p>以下对无权并查集的基本类进行研究：</p><p>class UF：</p><p>初始化函数：</p><p>（1）建立一个字典parent表示父元素的集合</p><p>（2）建立一个整数cnt，用于记录？</p><p>查找（find）：</p><ul><li>如果不在父集合中<ul><li>cnt +1</li><li>父集合中添加元素</li></ul></li></ul><p>集合（union）：</p><ul><li>调用连通判断函数（connected）检测 两个元素是不是连通的</li></ul><p>连通（connected）：</p><ul><li>通过 find 函数判断两个元素的find值是不是相等</li></ul><p>说真的这个class包括里面的函数不是很好理解</p><h1 id="字典的使用"><a href="#字典的使用" class="headerlink" title="字典的使用"></a>字典的使用</h1><h2 id="使用-collections-defaultdict-建立字典"><a href="#使用-collections-defaultdict-建立字典" class="headerlink" title="使用 collections.defaultdict() 建立字典"></a>使用 collections.defaultdict() 建立字典</h2><p><code>collections.defaultdict()</code>为字典提供默认值，以免字典中Key不存在的时候引发<code>KeyError</code>的异常</p><p>这是一种&#x3D;&#x3D;提供了默认值的字典&#x3D;&#x3D;</p><p>该函数返回一个类似字典的对象</p><p><code>defaultdict</code> 是 Python 内建字典类（dict）的一个子类</p><p><code>rec = collections.defaultdict(list)</code> </p><p>那么在调用的时候，使用<code>rec.items</code> 可以比较完整地调用key和values的值对，也可以通过 <code>rec.values()</code>调用所有的values，这样不会包括 keys</p><p>参考：</p><ul><li><p><a href="https://blog.csdn.net/clearlove100/article/details/111028876">collections.defaultdict() 和 dict.values()与*dict.values() 的区别</a></p></li><li><p><a href="https://blog.csdn.net/weixin_44110891/article/details/89575020">默认字典collections.defaultdict()的使用</a></p></li></ul><p><strong>该博客中说，key 值可以自定义，value 的类型与括号中设置类型先沟通，比如括号中是list，那么最后的键值对的值就是list</strong></p><h2 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h2><p>如果 字典的 value是<code>list</code>：可以 <code>rec[k].append(v)</code></p><p>如果 字典的 value是<code>set</code>：可以 <code>rec[k].add(v)</code></p><p>如果 字典的 value是<code>int</code>：可以 <code>rec[k]+=1</code></p><h1 id="list-sort-综合排序方法"><a href="#list-sort-综合排序方法" class="headerlink" title="list.sort()综合排序方法"></a>list.sort()综合排序方法</h1><p><code>list.sort(cmp, key, reverse)</code></p><ul><li>cmp - 使用该参数的方法进行排序</li><li>key - 每个列表中用来进行比较的元素，可以取自于可迭代对象中，指定可迭代对象中的一个元素进行排序</li><li>reverse - 降序标志，默认是false升序</li></ul><p>比如如果需要对列表的第一个元素进行比较，可以这样进行使用：</p><p><code>list.sort(key = lambda x: x[0])</code></p><hr><p>OK，本期的解题就是这些，并查集其实理解还不够深入，深度优先和广度优先将是一个大的领域，接下来需要重点关注！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每期10题，上一期参见&lt;a href=&quot;https://sunyoe.github.io/2021/01/12/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/&quot;&gt;LeetCode刷题笔记（四）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本期内容紧贴2021年1月leetcode每日一题，本月主要内容是并查集（包括深度优先或广度优先）及双指针，包括在周赛中也遇到双指针题目，需要重点考虑。&lt;/p&gt;
&lt;h2 id=&quot;1018-可被5整除的二进制前缀&quot;&gt;&lt;a href=&quot;#1018-可被5整除的二进制前缀&quot; class=&quot;headerlink&quot; title=&quot;1018. 可被5整除的二进制前缀&quot;&gt;&lt;/a&gt;1018. 可被5整除的二进制前缀&lt;/h2&gt;&lt;p&gt;输入：整数列表 - 只有 0 和 1&lt;/p&gt;
&lt;p&gt;输出：布尔列表 - 只有 false 和 true&lt;/p&gt;
&lt;p&gt;要求：依次选择整数列表中 从 第0位到第i位的所有数字，这是一个二进制数字，如果可以被5整除，那么布尔列表的第 i 位为true，否则为false。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法】5-决策树</title>
    <link href="http://yoursite.com/2021/01/28/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%BA%94/"/>
    <id>http://yoursite.com/2021/01/28/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%BA%94/</id>
    <published>2021-01-28T06:45:45.000Z</published>
    <updated>2021-01-28T07:24:25.449Z</updated>
    
    <content type="html"><![CDATA[<p>一句话解释：主要针对分类问题，对已有数据，根据各个特征的表现情况进行二分类（或多分类），从而形成一个像树一样的分类结构。</p><hr><p>这一部分公式比较多，配合例题进行理解。</p><span id="more"></span><h1 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h1><p>一个决策树，大概就是像下图一样的一个结构：</p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树模型.jpg" alt="决策树模型" style="zoom: 25%;" /><p>如果学习过数据结构，你可能很快反映出，这不就是“树”结构吗？我感觉差不多就是这样，一个二分类或者多分类的树结构，遇到分叉点就是做选择题。</p><p>一般分三个步骤：<strong>特征选择，树的生成，树的剪枝</strong>，常用于分类问题。</p><h1 id="5-2-特征选择"><a href="#5-2-特征选择" class="headerlink" title="5.2 特征选择"></a>5.2 特征选择</h1><h2 id="为什么要选择特征？"><a href="#为什么要选择特征？" class="headerlink" title="为什么要选择特征？"></a>为什么要选择特征？</h2><p>因为特征很多，从不同特征开始分类，得到的树的效果可能不一样。</p><h2 id="选择特征"><a href="#选择特征" class="headerlink" title="选择特征"></a>选择特征</h2><p>我们怎么知道哪个特征更适合分类呢？或者说怎样来判断一个特征是不是适合分类呢？</p><p>用<strong>信息增益</strong>来判断。</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>$H(X)&#x3D;-\Sigma^n_{i&#x3D;1}p_ilogp_i$ 也可以记作 <strong>H(p)</strong></p><p>其中，X是取有限值的离散随机变量，概率分布为$P(x&#x3D;x_i)&#x3D;p_i,i&#x3D;1,2,…,n$，<strong>当 $p_i$ 为 0 时，log 0 &#x3D; 0.</strong></p><p>意义：<strong>熵越大，随机变量的不确定性越大。也就是说，熵是用来衡量随机变量的不确定性的！</strong></p><h3 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h3><p>$H(Y|X)&#x3D;\Sigma^n_{i&#x3D;1}p_iH(Y|X&#x3D;x_i)$  </p><p><strong>表示的是，在已知X的条件下，Y的不确定性。</strong></p><h3 id="经验熵与经验条件熵"><a href="#经验熵与经验条件熵" class="headerlink" title="经验熵与经验条件熵"></a>经验熵与经验条件熵</h3><p>如果概率 Pi 是由数据估计（特别是极大似然估计）得到的，所对应的熵和条件熵就是经验熵和经验条件熵。</p><h3 id="互信息（也就是信息增益）"><a href="#互信息（也就是信息增益）" class="headerlink" title="互信息（也就是信息增益）"></a>互信息（也就是信息增益）</h3><p>熵与条件熵的差值。</p><p>该差值表示了<strong>不确定性减少的程度</strong>，减少越多就说明这个“条件”适合进行分类。</p><p><strong>因此，信息增益大的特征具有更强的分类能力。</strong></p><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p><strong>输入：</strong>训练数据集D和特征A</p><p><strong>对数据集的处理：</strong></p><ol><li>$|D|$表示样本容量</li><li>有 $K $个类别，分别为$C_k$，每个类别中的样本个数为 $|C_k|$</li><li>根据特征 A 可以将 D 划分为 n 个子集，分别为 $D_i$，$D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$</li></ol><p><strong>输出：</strong>特征A对训练数据集D的信息增益 $g(D,A)$</p><p><strong>步骤：</strong></p><ol><li><p>计算数据集 D 的经验熵 H(D)</p><p>$H(D)&#x3D;-\Sigma^K_{k&#x3D;1}\frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}$ </p></li><li><p>计算特征A对数据机D的经验条件熵 H(D|A)</p><p> $H(D|A)&#x3D;\Sigma^n_{i&#x3D;1}\frac{|D_i|}{|D|}H(D_i)&#x3D;-\Sigma^n_{i&#x3D;1}\frac{|D_i|}{|D|}\Sigma^K_{i&#x3D;1}\frac{|D_{ik}|}{|D_i|}log_2\frac{|D_{ik}|}{D_i}$</p></li><li><p>计算信息增益</p><p>$g(D,A)&#x3D;H(D)-H(D|A)$</p></li></ol><p>简单实用，但是<strong>缺点</strong>是：偏向于选择<strong>取值较多的特征。</strong></p><h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><p>使用<strong>信息增益比</strong></p><p><strong>信息增益比</strong>是信息增益与熵的比值。</p><p>信息增益比$g_R(D,A)&#x3D;\frac{g(D,A)}{H_A(D)}$</p><p>其中$H_A(D)&#x3D;-\Sigma^n_{i&#x3D;1}\frac{|D_i|}{|D|}log_2{|D_i|}{|D|}$，<strong>和前面的经验条件熵 H(D|A) 还是有点不一样的！</strong></p><h1 id="5-3-决策树的生成"><a href="#5-3-决策树的生成" class="headerlink" title="5.3 决策树的生成"></a>5.3 决策树的生成</h1><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><p>上面的内容只是选择了一个最优的特征值，大概相当于找到了一个比较好的根节点，但是还没有生成决策树。</p><p>使用下面的算法生成决策树：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/ID3%E7%AE%97%E6%B3%95.png" alt="ID3算法"></p><p><strong>缺点：容易过拟合</strong></p><p>C4.5算法</p><p>不同之处：选择<strong>信息增益比</strong>来选择特征。并不比ID3算法强多少。</p><h1 id="5-4-决策树的剪枝"><a href="#5-4-决策树的剪枝" class="headerlink" title="5.4 决策树的剪枝"></a>5.4 决策树的剪枝</h1><p>剪枝就是让决策树的枝干少一点——这样鲁棒性更好。</p><p>是减小过拟合的一种方法。</p><p>一般方法是引入<strong>损失函数</strong>，衡量剪枝前后的效果（也就是比较剪枝前后的损失函数），选择损失函数最小的方式生成决策树。</p><p>决策树的损失函数：</p><p>$C_\alpha(T)&#x3D;\Sigma^{|T|}_{t&#x3D;1}N_tH_t(T)+\alpha|T|$</p><p>代入经验熵$H_t(T)&#x3D;-\Sigma_k\frac{N_{tk}}{N_t}log\frac{N_{tk}}{N_t}$即可。</p><p>其中$\alpha$的作用是：</p><ul><li>$\alpha$越大，促使选择简单模型</li><li>$\alpha$越小，促使选择复杂模型</li><li>$\alpha$为0，不考虑模型复杂度</li></ul><p>$|T|$表示模型复杂度。</p><h1 id="5-5-CART算法"><a href="#5-5-CART算法" class="headerlink" title="5.5 CART算法"></a>5.5 CART算法</h1><p>分类与回归树（classsification and regression tree）</p><p>本方法不细讲了，主要思想其实很相近，只是完整地提出了从特征选择、决策树生成到剪枝的全过程，并且<strong>只使用二叉树（不管有几个选择）</strong>，所以泛化程度可能更好！</p><p>生成：递归地构建<strong>二叉决策树</strong></p><p>如何对输入空间进行划分</p><p>特征选择：使用<strong>基尼指数</strong>最小化原则</p><p>最小二乘回归树生成算法</p><p><strong>其实本方法和前面的算法在逻辑上有相似之处，但是最大的不同是，这里的每一个子树都是二叉树。</strong></p><hr><h1 id="举个栗子！"><a href="#举个栗子！" class="headerlink" title="举个栗子！"></a>举个栗子！</h1><p><strong>下面是一个贷款申请的训练数据，我们先关注最后一栏，类别——就是是否同意贷款。</strong></p><table><thead><tr><th align="left">ID</th><th align="left">年龄</th><th align="left">有工作</th><th align="left">有自己的房子</th><th align="left">信贷情况</th><th align="left">类别</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">青年</td><td align="left">否</td><td align="left">否</td><td align="left">一般</td><td align="left">否</td></tr><tr><td align="left">2</td><td align="left">青年</td><td align="left">否</td><td align="left">否</td><td align="left">好</td><td align="left">否</td></tr><tr><td align="left">3</td><td align="left">青年</td><td align="left">是</td><td align="left">否</td><td align="left">好</td><td align="left">是</td></tr><tr><td align="left">4</td><td align="left">青年</td><td align="left">是</td><td align="left">是</td><td align="left">一般</td><td align="left">是</td></tr><tr><td align="left">5</td><td align="left">青年</td><td align="left">否</td><td align="left">否</td><td align="left">一般</td><td align="left">否</td></tr><tr><td align="left">6</td><td align="left">中年</td><td align="left">否</td><td align="left">否</td><td align="left">一般</td><td align="left">否</td></tr><tr><td align="left">7</td><td align="left">中年</td><td align="left">否</td><td align="left">否</td><td align="left">好</td><td align="left">否</td></tr><tr><td align="left">8</td><td align="left">中年</td><td align="left">是</td><td align="left">是</td><td align="left">好</td><td align="left">是</td></tr><tr><td align="left">9</td><td align="left">中年</td><td align="left">否</td><td align="left">是</td><td align="left">非常好</td><td align="left">是</td></tr><tr><td align="left">10</td><td align="left">中年</td><td align="left">否</td><td align="left">是</td><td align="left">非常好</td><td align="left">是</td></tr><tr><td align="left">11</td><td align="left">老年</td><td align="left">否</td><td align="left">是</td><td align="left">非常好</td><td align="left">是</td></tr><tr><td align="left">12</td><td align="left">老年</td><td align="left">否</td><td align="left">是</td><td align="left">好</td><td align="left">是</td></tr><tr><td align="left">13</td><td align="left">老年</td><td align="left">是</td><td align="left">否</td><td align="left">好</td><td align="left">是</td></tr><tr><td align="left">14</td><td align="left">老年</td><td align="left">是</td><td align="left">否</td><td align="left">非常好</td><td align="left">是</td></tr><tr><td align="left">15</td><td align="left">老年</td><td align="left">否</td><td align="left">否</td><td align="left">一般</td><td align="left">否</td></tr></tbody></table><p><strong>OK，根据上面这个表格，如果给你一个新的数据，你怎样判断是不是要贷款给ta呢？</strong></p><p>一步步来进行：</p><p>首先可以看到特征比较多，从不同特征开始可以形成不同的决策树。</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E5%9B%BE-%E4%B8%8D%E5%90%8C%E7%89%B9%E5%BE%81%E5%86%B3%E5%AE%9A%E7%9A%84%E4%B8%8D%E5%90%8C%E5%86%B3%E7%AD%96%E6%95%B0.png" alt="图-不同特征决定的不同决策数"></p><p>经验熵$H(D)&#x3D;-\frac{9}{15}log_2\frac{9}{15}-\frac{6}{15}log_2\frac{6}{15}&#x3D;0.971$计算<strong>信息增益：</strong></p><p>（1）条件经验熵：$D_1,D_2,D_3$分别是$D$中$A_1$(年龄)取值为青年、中年和老年的样本子集。</p><p>$H(D_1)&#x3D;-\frac{2}{5}log_2\frac{2}{5}-\frac{3}{5}log_2\frac{3}{5} \ H(D_2)&#x3D;-\frac{3}{5}log_2\frac{3}{5}-\frac{2}{5}log_2\frac{2}{5} \ H(D_3)&#x3D;-\frac{4}{5}log_2\frac{4}{5}-\frac{1}{5}log_2\frac{1}{5}$</p><p>（2）分别以$A_1,A_2,A_3,A_4$ 表示年龄、有工作、有自己的房子和信贷情况<strong>四个特征</strong>，计算信息增益：</p><p>$g(D,A_1)&#x3D;H(D)-[\frac{5}{15}H(D_1)+\frac{5}{15}H(D_2)+\frac{5}{15}H(D_3)]&#x3D;0.971-0.888&#x3D;0.083$</p><p><strong>还没有完，这只是一个分类的信息增益！！</strong> </p><p><strong>如果想要计算其他四个分类，还得重新计算条件经验熵，然后计算信息增益：</strong></p><p>关于<strong>A2</strong>的信息增益：</p><p>首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_2)&#x3D;H(D)-[\frac{5}{15}H(D_1)+\frac{5}{15}H(D_2)]&#x3D;0.324$</p><p>关于<strong>A3</strong>的信息增益：</p><p>首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_1)&#x3D;H(D)-[\frac{6}{15}H(D_1)+\frac{9}{15}H(D_2)]&#x3D;0.420$</p><p>关于<strong>A4</strong>的信息增益：</p><p>首先有三个子集，计算$H(D_1),H(D_2),H(D_3)$，然后计算信息增益：$g(D,A_1)&#x3D;0.363$</p><p><strong>根据信息增益的比较，特征$A_3$（有自己的房子）的信息增益最大，所以选择特征$A_3$作为最优特征</strong>。</p><p>首先选取特征$A_3$作为根结点；然后$A_3$把数据集划分为两个子集$D_1$（表示有房子）和$D_2$（表示没有房子）。</p><p>分别观察：</p><p>（1）$D_1$只有同一类的样本点，所以是一个叶节点，标记为“是”。</p><p>（2）$D_2$需要对其它三个特征$A_1,A_2,A_4$中选择新的特征：计算信息增益：$g(D_2,A_1)&#x3D;H(D_2)-H(D_2|A_1)&#x3D;0.918-0.667&#x3D;0.251\ g(D_2,A_2)&#x3D;H(D_2)-H(D_2|A_2)&#x3D;0.918\ g(D_2,A_4)&#x3D;H(D_2)-H(D_2|A_4)&#x3D;0.474$</p><p>信息增益最大的是$A_2$，所以$A_2$（有工作）成为一个子结点，然后再分支……计算，直到全部分类完毕。</p><p><strong>本题比较巧，由$A_2$分类后，全部元素已经分类完毕了。</strong>例如，通过以上计算以后，我们得到的决策树就是：</p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90.png" alt="决策树的生成"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一句话解释：主要针对分类问题，对已有数据，根据各个特征的表现情况进行二分类（或多分类），从而形成一个像树一样的分类结构。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这一部分公式比较多，配合例题进行理解。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法】4-朴素贝叶斯法分类</title>
    <link href="http://yoursite.com/2021/01/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%9B%9B/"/>
    <id>http://yoursite.com/2021/01/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%9B%9B/</id>
    <published>2021-01-27T02:26:35.000Z</published>
    <updated>2021-01-28T07:23:51.059Z</updated>
    
    <content type="html"><![CDATA[<p>一句话介绍：对给定的输入x，结合贝叶斯概率理论，通过学习到的模型，将<strong>后验概率最大的类</strong>作为x的类输出。</p><hr><p>最好学习过贝叶斯估计方法。</p><p>在本科阶段的<strong>概率论</strong>或研究生阶段的<strong>数理统计</strong>中，都有对贝叶斯估计方法的介绍，与其他估计方法的最大不同是——加入了<strong>先验估计</strong>概念。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>部分公式：</p><ul><li><strong>先验概率分布$P(Y&#x3D;c_k),k&#x3D;1,2,…,K$</strong></li><li><strong>条件概率分布</strong>$P(X&#x3D;x|Y&#x3D;c_k)&#x3D;P(X^{(1)}&#x3D;x^{(1)},…,X^{(n)}&#x3D;x^{(n)}|Y&#x3D;c_k),k&#x3D;1,2,…,K$</li><li><strong>后验概率分布（贝叶斯定理）$P(Y&#x3D;c_k|X&#x3D;x)&#x3D;\frac{P(X&#x3D;x|Y&#x3D;c_k)P(Y&#x3D;c_k)}{\Sigma_k P(X&#x3D;x|Y&#x3D;c_k)P(Y&#x3D;c_k)}$</strong></li></ul><p><strong>补充一个忽略了很久的知识点：</strong></p><p><strong>arg max(f(x)) 函数：</strong>得到的结果是使得 f(x)取得最大值所对应的变量点x(或x的集合)。arg即argument，自变量。</p><span id="more"></span><p>首先有一个<strong>训练数据集</strong>$T&#x3D;{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，是由<strong>X</strong>和<strong>Y</strong>的联合概率分布$P(X,Y)$独立同分布产生。</p><p> <strong>【需要注意的是，这个联合概率分布是用朴素贝叶斯法训练出来的】</strong></p><p>在朴素贝叶斯法中，对条件概率分布做了<strong>条件独立性的假设：</strong></p><p>$P(X&#x3D;x|Y&#x3D;c_k) &#x3D; P(X^{(1)}&#x3D;x^{(1)},…,X^{(n)}&#x3D;x^{(n)}|Y&#x3D;c_k) &#x3D; \prod_{j&#x3D;1}^n P(X^{(j)}&#x3D;x^{(j)}|Y&#x3D;c_k)$</p><p>那么，朴素贝叶斯法分类的基本公式就是</p><p>$P(Y&#x3D;c_k|X&#x3D;x)&#x3D;\frac{P(Y&#x3D;c_k)\prod_j P(X^{(j)}&#x3D;x^{(j)}|Y&#x3D;c_k)}{\Sigma_k P(Y&#x3D;c_k)\prod_j P(X^{(j)}&#x3D;x^{(j)}|Y&#x3D;c_k)},k&#x3D;1,2,…,K$</p><p><strong>分母都是相同的，只考虑分子即可，</strong>选择分子最大的那个就是概率最大的，也就是后验概率最大的类了：</p><p>$y&#x3D;arg\ max_{c_k}{P(Y&#x3D;c_k)\prod^n_{j&#x3D;1} P(X^{(j)}&#x3D;x^{(j)}|Y&#x3D;c_k)}$</p><hr><p>以上内容确实就是<strong>朴素贝叶斯学习和分类算法</strong>的全部了，但是想必还是不太好理解。</p><p>一方面，<strong>先验分布和条件分布假设</strong>可能需要使用极大似然估计的方法求取，或者使用贝叶斯估计的方法求取，这又是好几个公式。</p><p>另一方面，还不如直接看一个例子！</p><hr><h1 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子!"></a>举个栗子!</h1><p>我们有一个训练数据集：</p><table><thead><tr><th align="left"></th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">10</th><th align="left">11</th><th align="left">12</th><th align="left">13</th><th align="left">1</th><th align="left"></th></tr></thead><tbody><tr><td align="left">$X^{(1)}$</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">2</td><td align="left">2</td><td align="left">2</td><td align="left">2</td><td align="left">2</td><td align="left">3</td><td align="left">3</td><td align="left">3</td><td align="left">3</td><td align="left">3</td></tr><tr><td align="left">$X^{(2)}$</td><td align="left">$S$</td><td align="left">$M$</td><td align="left">$M$</td><td align="left">$S$</td><td align="left">$S$</td><td align="left">$S$</td><td align="left">$M$</td><td align="left">$M$</td><td align="left">$L$</td><td align="left">$L$</td><td align="left">$L$</td><td align="left">$M$</td><td align="left">$M$</td><td align="left">$L$</td><td align="left">$L$</td></tr><tr><td align="left">$Y$</td><td align="left">-1</td><td align="left">-1</td><td align="left">1</td><td align="left">1</td><td align="left">-1</td><td align="left">-1</td><td align="left">-1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">-1</td></tr></tbody></table><p>这个数据集是什么意思呢？</p><p>$X^{(1)}$和$X^{(2)}$是特征。</p><ul><li>$X^{(1)}$ 取值集合是$A_1&#x3D;{1,2,3}$</li><li>$X^{(2)}$ 取值集合是$A_2&#x3D;{S,M,L}$</li></ul><p>$Y$ 就是类标记了，两个类，1和-1.</p><p><strong>现在的目的是，学习一个朴素贝叶斯分类器，并且确定 $x&#x3D;(2,S)^T$ 的类标记 $y$ 是多少？</strong></p><p>开始计算一堆概率：</p><p>$P(Y&#x3D;1)&#x3D;\frac{9}{15},P(Y&#x3D;-1)&#x3D;\frac{6}{15}$</p><p>$P(X^{(1)}&#x3D;1|Y&#x3D;1)&#x3D;\frac{2}{9},P(X^{(1)}&#x3D;2|Y&#x3D;1)&#x3D;\frac{3}{9},P(X^{(1)}&#x3D;3|Y&#x3D;1)&#x3D;\frac{4}{9}$</p><p>其实还是挺好算的，就是有点多，要把先验概率和条件概率全部算完：</p><p>$P(X^{(2)}&#x3D;S|Y&#x3D;1)&#x3D;\frac{1}{9},P(X^{(2)}&#x3D;M|Y&#x3D;1)&#x3D;\frac{4}{9},P(X^{(2)}&#x3D;L|Y&#x3D;1)&#x3D;\frac{4}{9}$</p><p>$P(X^{(1)}&#x3D;1|Y&#x3D;-1)&#x3D;\frac{3}{6},P(X^{(1)}&#x3D;2|Y&#x3D;-1)&#x3D;\frac{2}{6},P(X^{(1)}&#x3D;3|Y&#x3D;-1)&#x3D;\frac{1}{6}$</p><p>$P(X^{(2)}&#x3D;S|Y&#x3D;-1)&#x3D;\frac{3}{6},P(X^{(2)}&#x3D;M|Y&#x3D;-1)&#x3D;\frac{2}{6},P(X^{(2)}&#x3D;L|Y&#x3D;-1)&#x3D;\frac{1}{6}$</p><p>那么接下来根据<strong>朴素贝叶斯分类</strong>的<strong>基本公式</strong>，我们就是要看**$x&#x3D;(2,S)^T$的后验概率在哪一类（y&#x3D;1还是-1）的条件下更大，<strong>我们</strong>只计算分子即可：**</p><p><strong>这里很明显，目标的特征是：$X^{(1)}&#x3D;2,X^{(2)}&#x3D;S$</strong></p><p>​    $P(Y&#x3D;1)P(X^{(1)}&#x3D;2|Y&#x3D;1)P(X^{(2)}&#x3D;S|Y&#x3D;1)&#x3D;\frac{9}{15} \cdot \frac{3}{9}\cdot\frac{4}{9}&#x3D;\frac{1}{45}$</p><p>​    $P(Y&#x3D;-1)P(X^{(1)}&#x3D;2|Y&#x3D;-1)P(X^{(2)}&#x3D;S|Y&#x3D;-1)&#x3D;\frac{6}{15} \cdot \frac{2}{6}\cdot\frac{3}{6}&#x3D;\frac{1}{15}$</p><p><strong>经过计算，Y&#x3D;-1的情况概率更大，所以y&#x3D;-1.</strong></p><p>非常典型的贝叶斯概率估计。</p><p>这一页的公式确实打的很费劲。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一句话介绍：对给定的输入x，结合贝叶斯概率理论，通过学习到的模型，将&lt;strong&gt;后验概率最大的类&lt;/strong&gt;作为x的类输出。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最好学习过贝叶斯估计方法。&lt;/p&gt;
&lt;p&gt;在本科阶段的&lt;strong&gt;概率论&lt;/strong&gt;或研究生阶段的&lt;strong&gt;数理统计&lt;/strong&gt;中，都有对贝叶斯估计方法的介绍，与其他估计方法的最大不同是——加入了&lt;strong&gt;先验估计&lt;/strong&gt;概念。&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;部分公式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;先验概率分布$P(Y&amp;#x3D;c_k),k&amp;#x3D;1,2,…,K$&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件概率分布&lt;/strong&gt;$P(X&amp;#x3D;x|Y&amp;#x3D;c_k)&amp;#x3D;P(X^{(1)}&amp;#x3D;x^{(1)},…,X^{(n)}&amp;#x3D;x^{(n)}|Y&amp;#x3D;c_k),k&amp;#x3D;1,2,…,K$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后验概率分布（贝叶斯定理）$P(Y&amp;#x3D;c_k|X&amp;#x3D;x)&amp;#x3D;\frac{P(X&amp;#x3D;x|Y&amp;#x3D;c_k)P(Y&amp;#x3D;c_k)}{\Sigma_k P(X&amp;#x3D;x|Y&amp;#x3D;c_k)P(Y&amp;#x3D;c_k)}$&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;补充一个忽略了很久的知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;arg max(f(x)) 函数：&lt;/strong&gt;得到的结果是使得 f(x)取得最大值所对应的变量点x(或x的集合)。arg即argument，自变量。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法】3-k近邻算法</title>
    <link href="http://yoursite.com/2021/01/26/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B8%89/"/>
    <id>http://yoursite.com/2021/01/26/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B8%89/</id>
    <published>2021-01-26T02:42:00.000Z</published>
    <updated>2021-01-26T06:12:56.434Z</updated>
    
    <content type="html"><![CDATA[<p>一句话解释：在大样本中，找距离目标点最近的k个点。</p><hr><h1 id="什么是K近邻算法"><a href="#什么是K近邻算法" class="headerlink" title="什么是K近邻算法"></a>什么是K近邻算法</h1><h2 id="对两个实例点之间的距离进行度量"><a href="#对两个实例点之间的距离进行度量" class="headerlink" title="对两个实例点之间的距离进行度量"></a>对两个实例点之间的距离进行度量</h2><ol><li>其实就是使用了范数，不同范数对应的距离度量下的最近邻点不同</li><li>可以简单理解为计算两个点之间的距离</li></ol><span id="more"></span><h2 id="K值是什么"><a href="#K值是什么" class="headerlink" title="K值是什么"></a>K值是什么</h2><ol><li><p>在训练集T中找到与目标点 x 最邻近的 k 个点</p><ol><li>k越小，模型复杂度越高，容易过拟合（因为一个点很有可能是噪声）</li></ol></li><li><p>k越大，可以减少学习的估计误差，但是也会导致学习的近似误差增大，本来不相似的东西也会被认为属于比较邻近的集合</p></li><li><p>一般来说，k值是一个比较小的数值</p></li><li><p>采用交叉验证法来选择最优的k值</p></li></ol><h2 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h2><ol><li>多数表决规则<ol><li>由k个最邻近的点中的多数来决定该点所属的类</li></ol></li><li>衡量分的对不对？<ol><li>误分类概念，要使误分类概率最小</li></ol></li></ol><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200303164303.jpg" alt="微信图片_20200303164303"></p><h1 id="怎么实现这个算法呢？"><a href="#怎么实现这个算法呢？" class="headerlink" title="怎么实现这个算法呢？"></a>怎么实现这个算法呢？</h1><ol><li>老老实实计算<strong>每一个点与目标点之间的距离</strong>？<br>那要是训练集非常大，岂不是非常<strong>耗时费力</strong>？</li><li>所以要使用<strong>kd树方法——对k维空间中的点进行存储以便对其进行快速检索的树形数据结构。</strong></li></ol><h2 id="kd树方法"><a href="#kd树方法" class="headerlink" title="kd树方法"></a>kd树方法</h2><p><strong>关键两点，一个是构造，另一个是搜索</strong></p><ol><li>树方法实质<ol><li>管他什么树方法，说白了就是<strong>不断分割；</strong></li><li>刚开始整个区域，包含全部点，分一下，各区域点就少了很多，分啊分，最后的小区域点就非常少了，这样搜索效率会提高很多；</li><li>实施起来可能和这个简单的说法略有不同，用到了坐标的中位数，形成的树中存储的是点的坐标。</li></ol></li><li>如何理解这个树形结构<ol><li>要注意，这个树不是说每个实例点是一个树枝，而是数据集划分空间才是树枝；</li><li>也就是说刚才是整个数据集——这就是根结点，然后这个数据集分了两部分，就是两个子区域，分别是一个节点……分啊分，某个小区域里面没有实例点了，这个小区域就是树的末端了（叶结点）。</li></ol></li><li>搜索方法<ol><li>先从叶结点开始检查，然后回退检查父结点和父结点的其他子结点；</li><li>我们假设一下，有个叶结点比较近，那这个叶结点肯定是目标结点的一个近邻了，然后看一下父结点，结果发现比它还近，然后再回退父结点和父结点的其他子结点，找啊找，直到检索到根结点，就找到了最近的点。要是父结点并不近，那么肯定，这个点就算是最近的了。</li></ol></li></ol><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200303164339.jpg" alt="微信图片_20200303164338"></p><p><img src="https://typoraim.oss-cn-shanghai.aliyuncs.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200303164418.jpg" alt="微信图片_20200303164418"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一句话解释：在大样本中，找距离目标点最近的k个点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;什么是K近邻算法&quot;&gt;&lt;a href=&quot;#什么是K近邻算法&quot; class=&quot;headerlink&quot; title=&quot;什么是K近邻算法&quot;&gt;&lt;/a&gt;什么是K近邻算法&lt;/h1&gt;&lt;h2 id=&quot;对两个实例点之间的距离进行度量&quot;&gt;&lt;a href=&quot;#对两个实例点之间的距离进行度量&quot; class=&quot;headerlink&quot; title=&quot;对两个实例点之间的距离进行度量&quot;&gt;&lt;/a&gt;对两个实例点之间的距离进行度量&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;其实就是使用了范数，不同范数对应的距离度量下的最近邻点不同&lt;/li&gt;
&lt;li&gt;可以简单理解为计算两个点之间的距离&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
