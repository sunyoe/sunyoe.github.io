{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/ayer/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/ayer/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.css","path":"dist/main.css","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.js","path":"dist/main.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.png","path":"images/ayer.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/forkme.png","path":"images/forkme.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/sponsor.jpg","path":"images/sponsor.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom1.js","path":"js/clickBoom1.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom2.js","path":"js/clickBoom2.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/dz.js","path":"js/dz.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/mouse.cur","path":"images/mouse.cur","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/404.jpg","path":"images/404.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/ayer/.gitignore","hash":"b253f9829edcd1cf2a1fff279de3091e987dce6e","modified":1595749812708},{"_id":"themes/ayer/.postcssrc","hash":"c171a60205840e3dcd3825d5bbb6b2d19d48ee76","modified":1595749812709},{"_id":"themes/ayer/.travis.yml","hash":"5acc6f203681ce88bc2dbb0f86e0b3dd32a243a0","modified":1595749812709},{"_id":"themes/ayer/_config.yml","hash":"5d6fc32029ceac265145407140f7ce2808d9f9d2","modified":1611628147613},{"_id":"themes/ayer/.stylintrc","hash":"eec4e824067be1a223745ca426aa367c8d482673","modified":1595749812709},{"_id":"themes/ayer/LICENSE","hash":"d7308ddbd63bf372429401e188a906c52622f62e","modified":1595749812710},{"_id":"source/_posts/InfluxDB数据库-入门.md","hash":"614621ca637026aa5e16daf316ffedddb3624f60","modified":1611641801096},{"_id":"source/_posts/InfluxDB数据库-基础.md","hash":"a1b3909ba3a7a57ca3b4c24567ba8fbd3c07f04e","modified":1611641773966},{"_id":"source/_posts/InfluxDB数据库-简单使用.md","hash":"f0df39c842fc085c23a8645796925c0b72ed2099","modified":1611641790996},{"_id":"source/_posts/LeetCode刷题笔记一.md","hash":"3e8e04e0208e6293e580e75008595b282d8732b9","modified":1611642053419},{"_id":"source/_posts/LeetCode刷题笔记七.md","hash":"ab2272519bb3dbadcd41f0bfb18a2fbd0416a168","modified":1619230273851},{"_id":"source/_posts/LeetCode刷题笔记三.md","hash":"ac09f367ef1413a1240f4c457a5adc355124254f","modified":1611641841418},{"_id":"source/_posts/LeetCode刷题笔记二.md","hash":"bf3ce01ddbbbae609d50608476be01e859c5459b","modified":1611641822652},{"_id":"source/_posts/LeetCode刷题笔记五.md","hash":"3b86f4bedc3e7fefa11ca76886a05bc4ee6a469f","modified":1614761017213},{"_id":"source/_posts/LeetCode刷题笔记六.md","hash":"ae802ba6c470ea55d35dfa215d31b858008d152f","modified":1616032209906},{"_id":"source/_posts/LeetCode刷题笔记四.md","hash":"d6c872a3c79b7dc44cc59baaa7e47a185b74dec6","modified":1611641851855},{"_id":"source/_posts/OpenCV常用方法.md","hash":"aad414a3635b8c583bc7103347ebc8a96d2751a5","modified":1611642089789},{"_id":"source/_posts/PyTorch-学习篇2.md","hash":"b0a9853af2b61f559f7d8db2c1fa5703b889605d","modified":1611642115641},{"_id":"source/_posts/PyTorch学习篇-1.md","hash":"04547eed7501d37ca095f12894d13907ded3e973","modified":1611642098878},{"_id":"source/_posts/ROS-安装篇.md","hash":"0123e4f63f655a896bc98a614b0604b513604b8c","modified":1611642126896},{"_id":"source/_posts/VisualStudio Code学习.md","hash":"1b6801838008aec04cd1eb59bed6aa0fc9546861","modified":1611642137662},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1595745442037},{"_id":"source/_posts/华为云无人车参赛笔记一.md","hash":"20203e9f13af3664703564f0b6b3b341b2afc958","modified":1611642169821},{"_id":"source/_posts/华为云无人车参赛笔记三.md","hash":"ecd2ba07c4abfbc71bb46dedd7dee1e95ca397f0","modified":1611642157442},{"_id":"source/_posts/华为云无人车参赛笔记二.md","hash":"ef5a001f865baa0351f181696740733a688bee95","modified":1611642148592},{"_id":"source/_posts/思维工具-幕布.md","hash":"1ed40a3723b794ccbbb502296891b330f5247034","modified":1611642298618},{"_id":"source/_posts/我的第一篇博客文章.md","hash":"7397a78a4e3261801e21db712003c3ea1134c66f","modified":1611642353451},{"_id":"source/_posts/数据-bookmarks的转化.md","hash":"04d9694b7e6301bfa667d2729a14094d489ec911","modified":1611642203277},{"_id":"source/_posts/数据-词云分析初探.md","hash":"27cc6571e6317f4790a71255a50e8c8316e6fca6","modified":1611642230737},{"_id":"source/_posts/数据处理体验.md","hash":"340fb175e63e4fd4d9b14773e4f115207096666c","modified":1611642212536},{"_id":"source/_posts/数据库-SQL语言.md","hash":"a55bb7eb182440d0b3ec25e05cea12f7cbec826b","modified":1614760995846},{"_id":"source/_posts/数据库-mysql语言基础.md","hash":"4b3950e59ec62a4ed2432738e0f345d2d77e5e10","modified":1614760651361},{"_id":"source/_posts/春招-字节笔试.md","hash":"d4ee670e1c1af7629b1197348f7ea9b3e8dd90f2","modified":1616032320215},{"_id":"source/_posts/机器学习-常见知识梳理一.md","hash":"227ba5d49d0792481623694e19788b9a5c992997","modified":1611642191478},{"_id":"source/_posts/机器学习-常见知识梳理二.md","hash":"e1f7d9f096c030b0d572a49a3f620fb524553ef7","modified":1611642184167},{"_id":"source/_posts/统计学习方法一.md","hash":"cf34d0512fc0eea503aac841901e1120c0fb1b71","modified":1611641729218},{"_id":"source/_posts/统计学习方法七.md","hash":"8900861a6d3e8688826bd3c780bfbe0f0246f5d2","modified":1619232743395},{"_id":"source/_posts/统计学习方法三.md","hash":"9cc1df3e67d9c01c6dba93d6839941481815bf06","modified":1611641576434},{"_id":"source/_posts/统计学习方法二.md","hash":"a5fcfa70f7cf7bd93efc55578a7751a7c8c7dc4f","modified":1611819003602},{"_id":"source/about-me/index.md","hash":"f160a8ac1a20d4274e386533e7c2efffa5528d8f","modified":1604908616526},{"_id":"source/_posts/统计学习方法五.md","hash":"4d5ee4c5176683b9cc414574547c4e12899d4c26","modified":1611818665449},{"_id":"source/_posts/统计学习方法六.md","hash":"915ea1d22a598dbc1b7e51c5d304a11116d9ec72","modified":1618624273621},{"_id":"source/_posts/统计学习方法四.md","hash":"14ae9e2942590c92fc3e94426ebc4defc6071ed4","modified":1611818631059},{"_id":"themes/ayer/.github/FUNDING.yml","hash":"49e772bb69fec01a4a7bf9d440a28069f3df7970","modified":1595749812707},{"_id":"themes/ayer/.github/config.yml","hash":"d786334df2ea7feca64d07e573055c3452843f8a","modified":1595749812708},{"_id":"source/categories/index.md","hash":"0ae5a83f4d9f8e55c9b8f1f84138b83ea90815fa","modified":1595815292684},{"_id":"source/tags/index.md","hash":"4767c7493033a7d163a4e9a71395c985779c5c05","modified":1595815338222},{"_id":"themes/ayer/languages/de.yml","hash":"d12bd7ebee4772e9f982a760eb7512506c7f2bb5","modified":1595749812711},{"_id":"themes/ayer/languages/default.yml","hash":"217d6347d560eeb47f09def61c545f27b40f672d","modified":1595749812711},{"_id":"themes/ayer/languages/en.yml","hash":"217d6347d560eeb47f09def61c545f27b40f672d","modified":1595749812712},{"_id":"themes/ayer/languages/es.yml","hash":"c85f8dba8ae7b3a5e57cdfa617f5884b9d0b8a89","modified":1595749812712},{"_id":"themes/ayer/languages/fr.yml","hash":"0626e3949158af713f5b80ea490c8316b89479fc","modified":1595749812712},{"_id":"themes/ayer/languages/ja.yml","hash":"86a9d614d96beb9a6e514b155c024bc8964b1160","modified":1595749812712},{"_id":"themes/ayer/languages/ko.yml","hash":"1eb9f1f456bad2833651b2bc256178aedb806df2","modified":1595749812713},{"_id":"themes/ayer/languages/nl.yml","hash":"f9200f7837f5d91d21cd220d698393247249b2a4","modified":1595749812713},{"_id":"themes/ayer/languages/no.yml","hash":"a9c8d5d981a17c1091b892f5dbbbfcbae65b806e","modified":1595749812713},{"_id":"themes/ayer/languages/pt.yml","hash":"c46d632ac39abe213506f64ebfeea96bc13913a3","modified":1595749812713},{"_id":"themes/ayer/languages/ru.yml","hash":"2586cc5b7a1d6db96ab00ea6d83e663e591270a3","modified":1595749812713},{"_id":"themes/ayer/languages/vi.yml","hash":"2303f9ba6f2424eede332fe06f84256f807ff4f5","modified":1595749812714},{"_id":"themes/ayer/languages/zh-Hans.yml","hash":"c49e4abdf60740b891f252ce24e37a272a512d4d","modified":1595817226500},{"_id":"themes/ayer/languages/zh-TW.yml","hash":"00f7146f64bef1a4d0fc974c59975786c4e08f60","modified":1595749812714},{"_id":"themes/ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1595749812724},{"_id":"themes/ayer/layout/categories.ejs","hash":"b2deae0c31dd7fbf42a124db1b4c8c28d435c8e5","modified":1595749812724},{"_id":"themes/ayer/layout/index.ejs","hash":"c40a98c0a6f55c27959e44c9e8e4f2619fc2ad3f","modified":1595749812724},{"_id":"themes/ayer/layout/layout.ejs","hash":"363fd530b1a455992f93ff7163518d30413caadd","modified":1595749812724},{"_id":"themes/ayer/layout/page.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":1595749812725},{"_id":"themes/ayer/layout/post.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":1595749812725},{"_id":"themes/ayer/layout/tags.ejs","hash":"e7c9f93c6f7041a7d2aa95e85cc131b22aa426b7","modified":1595749812725},{"_id":"themes/ayer/scripts/default_config.js","hash":"617c2614d8bd8ffda2f2f84ab54fb18866e39b33","modified":1595749812728},{"_id":"themes/ayer/source-src/main.js","hash":"e42992bf24b2864e33ea5fdfab122b5d41851066","modified":1595749812739},{"_id":"themes/ayer/source/404.html","hash":"b1395f87d2b6eaaed6eee6f0673e724e20a439c2","modified":1595749812739},{"_id":"themes/ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1595749812741},{"_id":"themes/ayer/README.md","hash":"de8e0de68d9bc27d2524c7b90aa1ca3a97c9a062","modified":1595749812710},{"_id":"themes/ayer/logo.png","hash":"16fbb131601570b21890a922cd6e596691ccff42","modified":1595749812726},{"_id":"themes/ayer/package.json","hash":"f1803fed71d2b0cde458595b000759132f87aa5c","modified":1595749812726},{"_id":"themes/ayer/.github/ISSUE_TEMPLATE/bug-report.md","hash":"23fa172c797258de232e1a5fd1794ce8a86c984f","modified":1595749812707},{"_id":"themes/ayer/.github/ISSUE_TEMPLATE/question.md","hash":"20a7174d36e8f090ba7800c08b0c44b15b753736","modified":1595749812708},{"_id":"themes/ayer/layout/_partial/after-footer.ejs","hash":"a9865e7262d4a5b5a724685f99db1846a1cbd168","modified":1595749812715},{"_id":"themes/ayer/layout/_partial/archive-post.ejs","hash":"6b3e77cdbf8271c2a22b839608cccaa651f84e93","modified":1595749812715},{"_id":"themes/ayer/layout/_partial/archive.ejs","hash":"12e04e14a663fb4d30f4a22e92b0c3c2de36aaab","modified":1595749812715},{"_id":"themes/ayer/layout/_partial/article.ejs","hash":"958c70a70b070ca2dc9789c33bf941eee8e70c36","modified":1595749812715},{"_id":"themes/ayer/layout/_partial/ayer.ejs","hash":"061e5d25789c9a0c3df3172c0c53966053af89d1","modified":1595749812716},{"_id":"themes/ayer/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1595749812716},{"_id":"themes/ayer/layout/_partial/footer.ejs","hash":"8890b71ae3ab8b7c5f1681758f9204714b5553b2","modified":1595749812716},{"_id":"themes/ayer/layout/_partial/google-analytics.ejs","hash":"3a23d6ae48305c9f1b5c400da780288c2425254b","modified":1595749812717},{"_id":"themes/ayer/layout/_partial/head.ejs","hash":"f60e599d19f4a1c759a00a4c12a349506e65d467","modified":1595749812717},{"_id":"themes/ayer/layout/_partial/katex.ejs","hash":"02cb9da065cd315a06d62d13872dc687c62e9a1f","modified":1595749812717},{"_id":"themes/ayer/layout/_partial/mathjax.ejs","hash":"bcc264b6d6b58b3b692139c4d8b1381da4820da8","modified":1595749812718},{"_id":"themes/ayer/layout/_partial/modal.ejs","hash":"b9caece8b5fb47e250c67f6f80f101f08d04eba9","modified":1595749812718},{"_id":"themes/ayer/layout/_partial/music.ejs","hash":"4a67b36cadf2661a5579a454b7d6e0be34e7a0d4","modified":1595749812718},{"_id":"themes/ayer/layout/_partial/sidebar.ejs","hash":"b7efb7f2b300de23d12ef310d710d809d979f4fd","modified":1595749812723},{"_id":"themes/ayer/layout/_partial/totop.ejs","hash":"b2fc5726168f012bc61845f33a46404ff4065947","modified":1595749812723},{"_id":"themes/ayer/layout/_partial/viewer.ejs","hash":"219f0a0ec2eb35e8ba27a849639a5f634273fb6f","modified":1595749812724},{"_id":"themes/ayer/scripts/filters/index.js","hash":"e0c3b821ecd1cb614569282fb4f6e6f555545f8b","modified":1595749812728},{"_id":"themes/ayer/scripts/filters/meta_generator.js","hash":"46f6461a2bdc509837c36ede4d32c8b12e3d49b9","modified":1595749812728},{"_id":"themes/ayer/scripts/helpers/ayer-plus-vendors.js","hash":"611f3bcd8220312f92c11fa6a5dad02f011068d2","modified":1595749812729},{"_id":"themes/ayer/scripts/helpers/wordcount.js","hash":"2014b5c5053ad737887b61014a045cc1b08799cd","modified":1595749812729},{"_id":"themes/ayer/.github/ISSUE_TEMPLATE/other.md","hash":"e4c347d70c3b8044eec656e8cfb78cfd49f2d991","modified":1595749812708},{"_id":"themes/ayer/scripts/lib/core.js","hash":"00509e97554914e5b0a20e0843dc90bcf53461aa","modified":1595749812729},{"_id":"themes/ayer/source-src/css/_darkmode.styl","hash":"3c8f112452c24fad9b8257440963309acfae4dd9","modified":1595749812730},{"_id":"themes/ayer/source-src/css/_normalize.styl","hash":"b90386215434cc76549c046e7f67392049492a6a","modified":1595749812731},{"_id":"themes/ayer/source-src/css/_remixicon.styl","hash":"78f4dd8c613df005d6ecf6a073d96d38bbbe531e","modified":1595749812737},{"_id":"themes/ayer/source-src/css/_variables.styl","hash":"2fdb4425b6213fed28921f53179e825aee0500cf","modified":1595749812738},{"_id":"themes/ayer/source-src/css/style.styl","hash":"07cea9104627ae1957bde7658be816cc19346766","modified":1595749812738},{"_id":"themes/ayer/source-src/js/ayer.js","hash":"15171005a5b07c4ac40d9a50afc6780fd659204a","modified":1595749812738},{"_id":"themes/ayer/source-src/js/share.js","hash":"e8fd85622f774be877438421c182cd37eb15196e","modified":1595749812738},{"_id":"themes/ayer/source/css/clipboard.styl","hash":"145f335d6369744a75c2c39a50f63a88f720f85b","modified":1595749812739},{"_id":"themes/ayer/source/css/custom.styl","hash":"3753c4505761a66faccf736816f053e1e3489982","modified":1595749812740},{"_id":"themes/ayer/source/dist/main.css","hash":"c7ffa5ffdd1244b937fb2a384011609bcca050ce","modified":1595749812740},{"_id":"themes/ayer/source/dist/main.js","hash":"7de4d695a80c7cc893d36b3ad84e0a2403034d86","modified":1595749812740},{"_id":"themes/ayer/.github/ISSUE_TEMPLATE/feature-request.md","hash":"ca76e0709f2e97edfa004922da78599ef35eb039","modified":1595749812708},{"_id":"themes/ayer/source/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1595749812743},{"_id":"themes/ayer/source/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1595749812743},{"_id":"themes/ayer/source/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1595749812743},{"_id":"themes/ayer/source-src/css/_extend.styl","hash":"974b9483061fe83f585cc496791ba07e87c78689","modified":1595749812730},{"_id":"themes/ayer/source-src/css/_mixins.styl","hash":"e4804d78ded3714495f8ac9cebdbd2871ed97549","modified":1595749812730},{"_id":"themes/ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1595749812759},{"_id":"themes/ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1595749812759},{"_id":"themes/ayer/source/images/sponsor.jpg","hash":"b3efa167f50cad85404c83f21dec2be570ed21dc","modified":1595749812760},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1595749812761},{"_id":"themes/ayer/source/js/clickBoom1.js","hash":"daac19b1cf7381f1a36deb6ac5a4892e14774887","modified":1595749812761},{"_id":"themes/ayer/source/js/clickBoom2.js","hash":"fd61d8aeb2cfeaa0e548ac83a1ee1631979cbdb9","modified":1595749812761},{"_id":"themes/ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1595749812762},{"_id":"themes/ayer/source/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1595749812762},{"_id":"themes/ayer/source/js/lazyload.min.js","hash":"d9bc50752cd7e331dbd0a833386838397c9a079f","modified":1595749812763},{"_id":"themes/ayer/source/js/search.js","hash":"6d5c093d12e922ad204dab1723b786c35847bf1b","modified":1595749812764},{"_id":"themes/ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1595749812764},{"_id":"themes/ayer/source/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1595749812759},{"_id":"themes/ayer/screenshots/hexo-theme-ayer.png","hash":"4111670e622ce09837b6b9cc641782af75805079","modified":1595749812728},{"_id":"themes/ayer/source/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":1595749812743},{"_id":"themes/ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1595749812742},{"_id":"themes/ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1595749812747},{"_id":"themes/ayer/source/js/jquery-2.0.3.min.js","hash":"e68550a39c95a6400287b3abd77f40c44f322e50","modified":1595749812762},{"_id":"themes/ayer/layout/_partial/post/albums.ejs","hash":"f4cfbabca9f59a9e5aa457a6f2a9cf6f56cd22b3","modified":1595749812718},{"_id":"themes/ayer/layout/_partial/post/busuanzi.ejs","hash":"4c7a9191658395bcac45dcd07c165af8773cffa9","modified":1595749812719},{"_id":"themes/ayer/layout/_partial/post/category.ejs","hash":"89cb32e8d98bad81d3ef33377212e9b253699d3d","modified":1595749812719},{"_id":"themes/ayer/layout/_partial/post/clipboard.ejs","hash":"c93d82de1635536a633b6254b604590ab4428594","modified":1595749812719},{"_id":"themes/ayer/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1595749812719},{"_id":"themes/ayer/layout/_partial/post/gallery.ejs","hash":"6f78a49edc91f230b0a838c77630e9671d8d6089","modified":1595749812719},{"_id":"themes/ayer/layout/_partial/post/gitalk.ejs","hash":"38bb3f504a878d163a430ce6253dae3142a8fae5","modified":1595749812721},{"_id":"themes/ayer/layout/_partial/post/justifiedGallery.ejs","hash":"a313df6a014a0f2ba6b869dabc56bacb8ff6324d","modified":1595749812721},{"_id":"themes/ayer/layout/_partial/post/minivaline.ejs","hash":"b34754288928558e3eaca9124f5b15e2beb63c6d","modified":1595749812721},{"_id":"themes/ayer/layout/_partial/post/nav.ejs","hash":"a73010cbbc463089a1376889850fb0890143c988","modified":1595749812721},{"_id":"themes/ayer/layout/_partial/post/search.ejs","hash":"47c818c236b063d6ce0c41e0824f9f10a3521414","modified":1595749812721},{"_id":"themes/ayer/layout/_partial/post/share.ejs","hash":"9a978d55358878c97186ed010e536e1b314adb35","modified":1595749812722},{"_id":"themes/ayer/layout/_partial/post/title.ejs","hash":"e55c57b8cb8c8acf0ed998ea31c2fbc1d6256027","modified":1595749812722},{"_id":"themes/ayer/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1595749812722},{"_id":"themes/ayer/layout/_partial/post/tocbot.ejs","hash":"17ac504f2a6d561765046a0ba19dcce504104517","modified":1595749812722},{"_id":"themes/ayer/layout/_partial/post/topping.ejs","hash":"de2c50fb5b7a816287c6d048a2a22ae9c29abcdd","modified":1595749812723},{"_id":"themes/ayer/layout/_partial/post/valine.ejs","hash":"8c8cd4af31635a2eed93314bb907394f1c9b7545","modified":1595749812723},{"_id":"themes/ayer/layout/_partial/post/word.ejs","hash":"5b785368a0a6f3b5538aa1b9e7574daa8dfb0df6","modified":1595749812723},{"_id":"themes/ayer/source-src/css/_partial/albums.styl","hash":"5802253789028a4d9dac474168fc7132045e72ff","modified":1595749812731},{"_id":"themes/ayer/source-src/css/_partial/article.styl","hash":"c93c96bccfafe568cebbeb14bf577e97cb6e3c64","modified":1595749812732},{"_id":"themes/ayer/source-src/css/_partial/articles.styl","hash":"ddbe833939180afdc832659c5cdad08f77ef4f46","modified":1595749812732},{"_id":"themes/ayer/source-src/css/_partial/apple.styl","hash":"333f9e59dc6625c4dee126a1c1a9c25ce9292655","modified":1595749812731},{"_id":"themes/ayer/source-src/css/_partial/float.styl","hash":"b1abfdfd05e74745484f7e6d043ef2842b3f6b41","modified":1595749812733},{"_id":"themes/ayer/source-src/css/_partial/archive.styl","hash":"c20ad235d8aab4bc77a2372a053d86fe0069f7fe","modified":1595749812731},{"_id":"themes/ayer/source-src/css/_partial/gallery.styl","hash":"f5eae1b0030cfd97f1646844c9d3f692dbb38946","modified":1595749812734},{"_id":"themes/ayer/source-src/css/_partial/ayer.styl","hash":"cfcae3839170f2d04ea504a3cd3d62a9cde6647d","modified":1595749812732},{"_id":"themes/ayer/source-src/css/_partial/gitalk.styl","hash":"0678e8b330daea56fa30d14e97de73289a7d6f22","modified":1595749812734},{"_id":"themes/ayer/source-src/css/_partial/highlight.styl","hash":"1210f704aae34ef653e3a458cccb700b05353ea1","modified":1595749812734},{"_id":"themes/ayer/source-src/css/_partial/layout.styl","hash":"11cb01af7fc318f371e4df414a7f3301b80e8cb6","modified":1595749812735},{"_id":"themes/ayer/source-src/css/_partial/lists.styl","hash":"dc45f8b1a5942d4d979fb0859bc47a86f73fe0a9","modified":1595749812735},{"_id":"themes/ayer/source-src/css/_partial/mobile.styl","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1595749812735},{"_id":"themes/ayer/source-src/css/_partial/navbar.styl","hash":"30d7e1de22185c4b4da33eef66b5eb96f9e5ae98","modified":1595749812735},{"_id":"themes/ayer/source-src/css/_partial/pace.styl","hash":"bbda18c692fc66ae99e45347ff52c14e44a08e3b","modified":1595749812735},{"_id":"themes/ayer/source-src/css/_partial/reward.styl","hash":"a032e43e5842f752fd612ddbbd7943ecece7c35b","modified":1595749812736},{"_id":"themes/ayer/source-src/css/_partial/share.styl","hash":"4a6e6ac9156553dd5cee1eeee8fdc6f1f8a5d117","modified":1595749812736},{"_id":"themes/ayer/source-src/css/_partial/search.styl","hash":"3f2c7bd1371f6f25aec7c581dbae7b52f95ec4c6","modified":1595749812736},{"_id":"themes/ayer/source-src/css/_partial/sidebar.styl","hash":"cdc7bea47a768b18991decde0d38c554399621ee","modified":1595749812736},{"_id":"themes/ayer/source-src/css/_partial/categories.styl","hash":"cb3b1667c83182d6309e6d066f53f2771723729e","modified":1595749812733},{"_id":"themes/ayer/source-src/css/_partial/footer.styl","hash":"ae22e9d1525f267be368359ed0096f26791b809e","modified":1595749812733},{"_id":"themes/ayer/source-src/css/_partial/justifiedGallery.styl","hash":"9828c78fb59c3ea3de7cce2569313d12c4b1a6ff","modified":1595749812734},{"_id":"themes/ayer/source-src/css/_partial/totop.styl","hash":"b6010788be1d99a345abcf0cf9cdf0a564b90d3c","modified":1595749812737},{"_id":"themes/ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1595749812758},{"_id":"themes/ayer/source/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":1595749812761},{"_id":"themes/ayer/source-src/css/_partial/tag.styl","hash":"6072aa6bd16e0a1e75f0258d7b20587cab56fff8","modified":1595749812736},{"_id":"themes/ayer/source-src/css/_partial/tocbot.styl","hash":"2135ab02e098ddfaaa60009d8413186a564af840","modified":1595749812737},{"_id":"themes/ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1595749812745},{"_id":"themes/ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1595749812749},{"_id":"themes/ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1595749812752},{"_id":"themes/ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1595749812757},{"_id":"public/search.xml","hash":"c88402d8e3d60ae2bab7c290bffc33e57bef7be7","modified":1619405641256},{"_id":"public/about-me/index.html","hash":"999fe7242a8f06e57962d1b3252f5c8a82fedc8f","modified":1619233208222},{"_id":"public/categories/index.html","hash":"e11eefe32ff53811a744483851e0a640a3727883","modified":1619405641256},{"_id":"public/tags/index.html","hash":"c09b6db0700d1fcf083c26b44339d5777fbcb642","modified":1619233208222},{"_id":"public/archives/page/4/index.html","hash":"0f2e59e408600440a94f4b70f0d82051480997dc","modified":1619405641256},{"_id":"public/archives/2020/page/3/index.html","hash":"70a462367283f003eb4786c2d3045f4db7171047","modified":1619233208222},{"_id":"public/archives/2020/07/index.html","hash":"c1437fbe259462e5551ae87f78f38c5e63265206","modified":1619233208222},{"_id":"public/archives/2020/09/index.html","hash":"67a93a7b6d7bea204d9c4a994a2a485ee47b5056","modified":1619233208222},{"_id":"public/archives/2020/11/index.html","hash":"8eb4ad370be4492feffddfae7cc41544d172a023","modified":1619233208222},{"_id":"public/archives/2020/12/index.html","hash":"841cb05d2e758f6ca20bf8df87485d476da0919d","modified":1619233208222},{"_id":"public/archives/2021/page/2/index.html","hash":"5e5440b105e1d9b27e6f4cfecaecf9319f76acd5","modified":1619405641256},{"_id":"public/archives/2021/01/index.html","hash":"a365ccf6f8b0c34a98847b6ef9878342f3da3a9d","modified":1619233208222},{"_id":"public/archives/2021/02/index.html","hash":"d23708400dc92b8541222290d6132c0a840bc632","modified":1619233208222},{"_id":"public/archives/2021/03/index.html","hash":"b47217ef3a64c89795c4d187b094ea62238794c9","modified":1619233208222},{"_id":"public/archives/2021/04/index.html","hash":"b10946e58410e768ece651d08d7e50f39e74b58a","modified":1619405641256},{"_id":"public/tags/influxdb/index.html","hash":"1455f9dc291aae8a202132e4aec244443d544085","modified":1619233208222},{"_id":"public/tags/PyTorch/index.html","hash":"5c488553baab1846eed230870ebdf94d86c47561","modified":1619233208222},{"_id":"public/tags/ROS/index.html","hash":"b8c9c37f4e0c3f701866ddab1ab1dc760ec307ee","modified":1619233208222},{"_id":"public/tags/json/index.html","hash":"8c672e3f271c2b8d3ad1cd17bd5a0b969222de55","modified":1619233208222},{"_id":"public/tags/Pandas/index.html","hash":"e98763582c0f68cf1f60f854d777321fead5611f","modified":1619233208222},{"_id":"public/tags/index/index.html","hash":"35746956b42200c114be073f999045a1320e4edc","modified":1619233208222},{"_id":"public/tags/Word-Cloud/index.html","hash":"175c6e069316840be5c0f76a21f645134f474cb8","modified":1619233208222},{"_id":"public/tags/os/index.html","hash":"e7cf23a7e64206cea8cf8d1acb990f4a27782928","modified":1619233208222},{"_id":"public/tags/MySQL/index.html","hash":"a8d69fcdbf66d5a3262db8ddfe8a5473255ff8c5","modified":1619233208222},{"_id":"public/tags/DataBases/index.html","hash":"1b1995f1bdad620cfeef7d9d59bbff2b6306ac59","modified":1619233208222},{"_id":"public/tags/神经网络/index.html","hash":"017d9a9667707ba60267d41ba268c587ebf487da","modified":1619233208222},{"_id":"public/tags/bytedance/index.html","hash":"f96fcef1ef011aed3e143eef8e09a340a2abbee8","modified":1619233208222},{"_id":"public/tags/笔试/index.html","hash":"86cbe063434309a2bfac04a1c6f01af03b26b489","modified":1619405641256},{"_id":"public/tags/并查集/index.html","hash":"1a04c1cb578cfe4876738e03fa19c5d5c799e65e","modified":1619233208222},{"_id":"public/tags/数组/index.html","hash":"6f60e4f0c680cf2c628ebb599d41075be94eef63","modified":1619233208222},{"_id":"public/tags/LeetCode/index.html","hash":"17f9589652b4e54bb8dd24bbf2ed4acd866e4424","modified":1619233208222},{"_id":"public/tags/排序问题/index.html","hash":"c20d04bd051b241eeebf4819554abb45cd6a54b0","modified":1619233208222},{"_id":"public/tags/滑动窗口/index.html","hash":"a5c227f209fc1114b9edbc7e3f8cf4a9f6ccf1c4","modified":1619233208222},{"_id":"public/tags/链表/index.html","hash":"5cd968fcd2ddce2699cad6b5fdc2f8d6f9ba33b0","modified":1619233208222},{"_id":"public/tags/单调栈/index.html","hash":"1038fee9f344b7bf439c3b1b83b9aa7ecb57213a","modified":1619233208222},{"_id":"public/tags/哈希表/index.html","hash":"ca5474eaf7df7cb87062361c1524f7d5fbad1b94","modified":1619233208222},{"_id":"public/tags/hot100/index.html","hash":"748fafe4837aff5c199d87ca53b96d1f8d936391","modified":1619233208222},{"_id":"public/tags/ascii/index.html","hash":"95aa4e7dedad7b519244adc98d5e27841d64e3ef","modified":1619233208222},{"_id":"public/tags/动态规划/index.html","hash":"9db1dc38a936068c23e63b159e6d6bdde97c3380","modified":1619233208222},{"_id":"public/tags/贪心法/index.html","hash":"b5ec07ead32c6640ca9e22a273748fd76eea7add","modified":1619233208222},{"_id":"public/tags/分治法/index.html","hash":"cb3d1a7f4fa405e80c652154e0dd9dd4acd46b97","modified":1619233208222},{"_id":"public/tags/双指针/index.html","hash":"7d25c64e263d085b2cc9595f0e9dbfb4a3d1a45b","modified":1619233208222},{"_id":"public/tags/分治/index.html","hash":"bdb5799c162aeee5728296f1cdc660b2b6ed91ec","modified":1619233208222},{"_id":"public/tags/贪心/index.html","hash":"832320930cb0afad4f8fecc728f15c936e7d19ad","modified":1619233208222},{"_id":"public/tags/递归/index.html","hash":"375374cbd5285e820b050a9e4e2f2e90d0de93c1","modified":1619233208222},{"_id":"public/tags/List数组操作/index.html","hash":"f91edc9c4f2849ceacd8f70f21a6c4d00e94153d","modified":1619233208222},{"_id":"public/tags/图/index.html","hash":"db6366b2403454870fd44ed897609db22217f65c","modified":1619233208222},{"_id":"public/tags/排序/index.html","hash":"f74202ba87002185738e2ef983f9391d074e2280","modified":1619233208222},{"_id":"public/tags/拓扑排序/index.html","hash":"1f16a116393e7ba01d54513282914f13d26eb361","modified":1619233208222},{"_id":"public/categories/机器学习/page/2/index.html","hash":"ed8c097eecd294dd1d9d01ef28aba17597ed42ac","modified":1619233208222},{"_id":"public/categories/ROS/index.html","hash":"e8774ea5f614ad64c1d89c2eccfa15fb049b26e0","modified":1619233208222},{"_id":"public/categories/Tools/index.html","hash":"64cf109cff6de9457335ec04d5856a80443386d4","modified":1619233208222},{"_id":"public/categories/机器视觉/index.html","hash":"d2eb668aaad4f2fdd71c52162e035ee614c1d4bc","modified":1619233208222},{"_id":"public/2021/04/24/统计学习方法七/index.html","hash":"b0380f3d07646ffa944cb7ad0bbb1967c1a70b50","modified":1619405641256},{"_id":"public/2021/04/17/统计学习方法六/index.html","hash":"35c5ea8b89fcab2882e16c663f5191d34803e30a","modified":1619233208222},{"_id":"public/2021/03/29/LeetCode刷题笔记七/index.html","hash":"c672611817e32ea06de6ccb58d882205de89707d","modified":1619233208222},{"_id":"public/2021/03/18/LeetCode刷题笔记六/index.html","hash":"44a64bc3644e58c9a0d408ca97e42e77e04785ec","modified":1619233208222},{"_id":"public/2021/03/14/春招-字节笔试/index.html","hash":"033083934655d5e348b54b7b28ec05a34e2df295","modified":1619233208222},{"_id":"public/2021/03/03/数据库-SQL语言/index.html","hash":"d82c039bf7c9c43c5c707ffad62619b8f3176a5d","modified":1619233208222},{"_id":"public/2021/02/02/LeetCode刷题笔记五/index.html","hash":"86172154829b4479c34a91db3e66b1eeec70e0cc","modified":1619233208222},{"_id":"public/2021/01/28/统计学习方法五/index.html","hash":"2ddcf420efe5bef3b16b887a8e58f98143fd3ce6","modified":1619233208222},{"_id":"public/2021/01/27/统计学习方法四/index.html","hash":"a7e6910b28190253aa0c458c1a2760d4e651b81f","modified":1619233208222},{"_id":"public/2021/01/26/统计学习方法三/index.html","hash":"9bfb1828fdceb2442700d6f8867a380dc2469e00","modified":1619233208222},{"_id":"public/2021/01/23/统计学习方法二/index.html","hash":"9c7d5e9a037bb9b0a3b76b04bfc73b79d73cec30","modified":1619233208222},{"_id":"public/2021/01/17/统计学习方法一/index.html","hash":"0a674f3b63f707b683abc7ba183e59995dd3373c","modified":1619233208222},{"_id":"public/2021/01/12/LeetCode刷题笔记四/index.html","hash":"0f431e8751aac21955a6e31617411daf342c7f19","modified":1619233208222},{"_id":"public/2020/12/29/LeetCode刷题笔记三/index.html","hash":"d6cb0038f75143af92786138218e170730bf0184","modified":1619233208222},{"_id":"public/2020/12/06/LeetCode刷题笔记二/index.html","hash":"442973a0ec048190594a0f5289d05805825f1572","modified":1619233208222},{"_id":"public/2020/11/25/PyTorch-学习篇2/index.html","hash":"b6dc50b7d489bf708a1e28f21f1bc21010e0f095","modified":1619233208222},{"_id":"public/2020/11/14/数据处理体验/index.html","hash":"7db6ebd0aa3a3c07bccd27b398c395da5f6aa0d3","modified":1619233208222},{"_id":"public/2020/11/24/PyTorch学习篇-1/index.html","hash":"b5263e8015304bc7dc30077ae51ab6b255834c9f","modified":1619233208222},{"_id":"public/2020/09/30/华为云无人车参赛笔记三/index.html","hash":"937c920b4d6bdca4202c752f31a130b8da8f1532","modified":1619233208222},{"_id":"public/2020/09/29/华为云无人车参赛笔记二/index.html","hash":"c90363aafd276e8aaf566a466ae7b867bf328a53","modified":1619233208222},{"_id":"public/2020/09/27/华为云无人车参赛笔记一/index.html","hash":"773fb19192c077643ce430324169e1d66312c279","modified":1619233208222},{"_id":"public/2020/09/26/OpenCV常用方法/index.html","hash":"5c19472fc6f5e2a29d021fe62f6b5c3324e40af6","modified":1619233208222},{"_id":"public/2020/09/03/LeetCode刷题笔记一/index.html","hash":"b8fd47ec2b8d25a00342c8cc64cfbf1a91e90f04","modified":1619233208222},{"_id":"public/2020/08/22/机器学习-常见知识梳理二/index.html","hash":"222414a8af0a3044b32b68831bb4e5700c6eec6b","modified":1619233208222},{"_id":"public/2020/08/15/思维工具-幕布/index.html","hash":"0bc4c9534e5125dad0870a3a29c701528d18d173","modified":1619233208222},{"_id":"public/2020/08/10/数据库-mysql语言基础/index.html","hash":"2a0dce5711c8a3dfc4979e3568af23f2e5b8a86a","modified":1619233208222},{"_id":"public/2020/08/08/数据-bookmarks的转化/index.html","hash":"41db75d2702b06bf0c2db420f25a22c0b36352c8","modified":1619233208222},{"_id":"public/2020/08/03/机器学习-常见知识梳理一/index.html","hash":"b21a844ae75b92e558ace2b9aa50c03ab0390cea","modified":1619233208222},{"_id":"public/2020/08/01/InfluxDB数据库-简单使用/index.html","hash":"585122b4f8bd68a9bcf778c3873a8e8d4e4a83d3","modified":1619233208222},{"_id":"public/2020/07/31/InfluxDB数据库-入门/index.html","hash":"426f091b40c1187f09f833593d520d2d1b98aba7","modified":1619233208222},{"_id":"public/2020/08/02/数据-词云分析初探/index.html","hash":"c74a5170cfbbff7a4c4157202a199fb2d8cf345d","modified":1619233208222},{"_id":"public/2020/07/30/InfluxDB数据库-基础/index.html","hash":"eb39be1bdbccdcfeb553f3bb5a61193172d97fed","modified":1619233208222},{"_id":"public/2020/07/29/VisualStudio Code学习/index.html","hash":"e9294a49db3f5b160fae59790b6de75a8ed21d49","modified":1619233208222},{"_id":"public/2020/07/28/ROS-安装篇/index.html","hash":"2f27b2fdaa298e392fcc85abe0bda416a0b5469d","modified":1619233208222},{"_id":"public/2020/07/26/我的第一篇博客文章/index.html","hash":"fa6deec527016bfefbf310fa8ec71991a2576108","modified":1619233208222},{"_id":"public/2020/07/26/hello-world/index.html","hash":"6686f17deae8de51a0e4cec60f0f8511548a3b71","modified":1619233208222},{"_id":"public/archives/index.html","hash":"d74a6549d3204ea6b48944dbf3ba6e42afe668fd","modified":1619405641256},{"_id":"public/archives/page/2/index.html","hash":"6c4066344abb1f2bb9575a166815582d56a3c96b","modified":1619405641256},{"_id":"public/archives/page/3/index.html","hash":"7280082626787a294e84696c0fd91e5a930cb760","modified":1619405641256},{"_id":"public/archives/2020/index.html","hash":"ee6ce5c1a865ea12f798111ce95f16b8622bf9cd","modified":1619233208222},{"_id":"public/archives/2020/page/2/index.html","hash":"368949bc6ce7cbfa4c618ba81cfdc20431ad3d90","modified":1619233208222},{"_id":"public/archives/2020/08/index.html","hash":"ddde2f5a1508214986abbcf054eaf9af14867ae6","modified":1619233208222},{"_id":"public/archives/2021/index.html","hash":"c7cb25eb4ac0d3dcc1c0b62625a7a8541f03e621","modified":1619405641256},{"_id":"public/index.html","hash":"9407f5efeac5a6dd83c0bff9b983cfe8fadbc6a7","modified":1619405641256},{"_id":"public/page/2/index.html","hash":"f345b0b61ab5464afaa2deca17d9f900912e101c","modified":1619405641256},{"_id":"public/page/3/index.html","hash":"53302b7ef8e16cd64c8da40f25db457b77ec62c1","modified":1619405641256},{"_id":"public/page/4/index.html","hash":"ad0497386b07c930e5a43435852faa8b51c4ee29","modified":1619405641256},{"_id":"public/tags/software/index.html","hash":"35b174fd4557a67cf74e9e017bc73f040a89f248","modified":1619233208222},{"_id":"public/tags/OpenCV/index.html","hash":"b214ca3ce35599e699292485ca4ec5dac24a12d0","modified":1619233208222},{"_id":"public/tags/华为云无人车/index.html","hash":"49c48e7f868f4f3eed4bb9afab6524fdbd0deb15","modified":1619233208222},{"_id":"public/tags/统计学习方法/index.html","hash":"314dd10705b782ca8c6b4e4b52c1a5cbf1aef928","modified":1619233208222},{"_id":"public/categories/Data-Analysis/index.html","hash":"ca5683d74d313fb9e719ea305f4e2fcf046c3ab7","modified":1619233208222},{"_id":"public/categories/机器学习/index.html","hash":"edfb41aff4b474b6013849b2391c1b2349920b0f","modified":1619233208222},{"_id":"public/categories/算法/index.html","hash":"83331aec99c3a9dc14857367015120bcad610ffa","modified":1619405641256},{"_id":"public/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1619233208222},{"_id":"public/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1619233208222},{"_id":"public/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1619233208222},{"_id":"public/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1619233208222},{"_id":"public/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1619233208222},{"_id":"public/images/sponsor.jpg","hash":"b3efa167f50cad85404c83f21dec2be570ed21dc","modified":1619233208222},{"_id":"public/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1619233208222},{"_id":"public/404.html","hash":"f9a601ed44a0294b797217629b59ea30eaca0280","modified":1619233208222},{"_id":"public/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1619233208222},{"_id":"public/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":1619233208222},{"_id":"public/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1619233208222},{"_id":"public/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":1619233208222},{"_id":"public/css/clipboard.css","hash":"7990b92ffeda1b06b94b50140d9c95dac21bd418","modified":1619233208222},{"_id":"public/css/custom.css","hash":"78b13bf5b98278ff65cdb0a731f2a1c98b2324a5","modified":1619233208222},{"_id":"public/dist/main.js","hash":"eac86de3ed854247e50b04d6908816b1837e08cf","modified":1619233208222},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1619233208222},{"_id":"public/js/clickBoom1.js","hash":"56582907b4c2ece5187b8d64125f91ddabb8a24e","modified":1619233208222},{"_id":"public/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1619233208222},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1619233208222},{"_id":"public/js/clickBoom2.js","hash":"bea5232eb8b32542283d9a28257f4b85ce2f3c1b","modified":1619233208222},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1619233208222},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1619233208222},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1619233208222},{"_id":"public/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1619233208222},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1619233208222},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1619233208222},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1619233208222},{"_id":"public/dist/main.css","hash":"c7ffa5ffdd1244b937fb2a384011609bcca050ce","modified":1619233208222},{"_id":"public/js/jquery-2.0.3.min.js","hash":"800edb7787c30f4982bf38f2cb8f4f6fb61340e9","modified":1619233208222},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1619233208222},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1619233208222},{"_id":"source/_posts/春招-笔试分享.md","hash":"667352f2dbb9833f2f9dbad91064989e260323c3","modified":1619405626906},{"_id":"public/2021/04/26/春招-笔试分享/index.html","hash":"e8dbc26c90c821021509e86a6500f434a8af40b3","modified":1619405641256}],"Category":[{"name":"Data Analysis","_id":"cknv5n87w0003k8tlcswj8nm5"},{"name":"机器学习","_id":"cknv5n883000ik8tl00kw2igb"},{"name":"ROS","_id":"cknv5n887000wk8tl93nl009q"},{"name":"Tools","_id":"cknv5n8880014k8tles8h9mdz"},{"name":"机器视觉","_id":"cknv5n88a001ck8tlhz3d6ex5"},{"name":"算法","_id":"cknv5n88e001sk8tl7v9kd4t4"}],"Data":[],"Page":[{"title":"About Me","date":"2020-07-27T02:20:03.000Z","_content":"> A Graduate in iDesignLab@SJTU.\n\nGitHub： sunyoe\n\nEmail： syjdmail@163.com\n\n荣誉：\n\n- 中国研究生数学建模竞赛二等奖\n- 华为云人工智能大赛无人车挑战杯全国二十强\n\n主要方向：\n\n- 机器人视觉伺服\n\n---\n欢迎访问iDesignlab实验室主页：http://idesignlab.sjtu.edu.cn","source":"about-me/index.md","raw":"---\ntitle: About Me\ndate: 2020-07-27 10:20:03\n---\n> A Graduate in iDesignLab@SJTU.\n\nGitHub： sunyoe\n\nEmail： syjdmail@163.com\n\n荣誉：\n\n- 中国研究生数学建模竞赛二等奖\n- 华为云人工智能大赛无人车挑战杯全国二十强\n\n主要方向：\n\n- 机器人视觉伺服\n\n---\n欢迎访问iDesignlab实验室主页：http://idesignlab.sjtu.edu.cn","updated":"2020-11-09T07:56:56.526Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"cknv5n87u0001k8tl9jx0b4o4","content":"<blockquote>\n<p>A Graduate in iDesignLab@SJTU.</p>\n</blockquote>\n<p>GitHub： sunyoe</p>\n<p>Email： syjdmail@163.com</p>\n<p>荣誉：</p>\n<ul>\n<li>中国研究生数学建模竞赛二等奖</li>\n<li>华为云人工智能大赛无人车挑战杯全国二十强</li>\n</ul>\n<p>主要方向：</p>\n<ul>\n<li>机器人视觉伺服</li>\n</ul>\n<hr>\n<p>欢迎访问iDesignlab实验室主页：<a href=\"http://idesignlab.sjtu.edu.cn\" target=\"_blank\" rel=\"noopener\">http://idesignlab.sjtu.edu.cn</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>A Graduate in iDesignLab@SJTU.</p>\n</blockquote>\n<p>GitHub： sunyoe</p>\n<p>Email： syjdmail@163.com</p>\n<p>荣誉：</p>\n<ul>\n<li>中国研究生数学建模竞赛二等奖</li>\n<li>华为云人工智能大赛无人车挑战杯全国二十强</li>\n</ul>\n<p>主要方向：</p>\n<ul>\n<li>机器人视觉伺服</li>\n</ul>\n<hr>\n<p>欢迎访问iDesignlab实验室主页：<a href=\"http://idesignlab.sjtu.edu.cn\" target=\"_blank\" rel=\"noopener\">http://idesignlab.sjtu.edu.cn</a></p>\n"},{"title":"categories","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\nlayout: \"categories\"\n---","date":"2020-07-27T02:01:32.684Z","updated":"2020-07-27T02:01:32.684Z","path":"categories/index.html","comments":1,"_id":"cknv5n88z0039k8tl0ercgzvw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\nlayout: \"tags\"\n---\n","date":"2020-07-27T02:02:18.222Z","updated":"2020-07-27T02:02:18.222Z","path":"tags/index.html","comments":1,"_id":"cknv5n890003bk8tl11tb5mli","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"【InfluxDB数据库】入门","date":"2020-07-31T13:28:23.000Z","_content":"\n版本：v2.0-beta\n系统：win+docker / ubuntu服务器\n\n## 1. Docker 安装\n[Docker-desktop官方下载链接](https://www.docker.com/products/docker-desktop)\n安装完成之后，就可以直接在终端运行docker了\n或者可以在VSCode中使用docker插件\n\n## 2. VSCode 中 Docker 插件探索\n\n<!--more-->\n\n## 3. 在Docker中使用influxdb\n以下两句代码只需使用任意一句即可。\n\n```\n#下载页面的 docker image\ndocker pull quay.io/influxdb/influxdb:2.0.0-beta\n\n#介绍页面的安装方法\ndocker run --name influxdb -p 9999:9999 quay.io/influxdb/influxdb:2.0.0-beta\n```\n\n安装完成后，会显示：\n\n然后在浏览器中访问`localhost:9999`即可打开v2.0界面。\n\n## 4. 服务器安装V2.0\n### 4.1 首先将压缩包上传到服务器\n(1)使用代码，但是不好用\n\n```\nscp -r localfile.txt username@192.168.0.1:/home/username/\n```\n其中，\n１）scp是命令，-r是参数\n２）localfile.txt 是文件的路径和文件名\n３）username是服务器账号\n４）192.168.0.1是要上传的服务器ip地址\n５）/home/username/是要拷入的文件夹路径\n\n（2）直接用filezilla、MobaXterm等工具上传到服务器\n### 4.2 安装\n输入下列语句，主要是打开压缩包，以及安装。\n\n```\n# Unpackage contents to the current working directory\ntar xvzf path/to/influxdb_2.0.0-beta.10_linux_amd64.tar.gz\n\n# Copy the influx and influxd binary to your $PATH\nsudo cp influxdb_2.0.0-beta.10_linux_amd64/{influx,influxd} /usr/local/bin/\n```\n\n### 4.3 运行\n理论上输入如下语句即可运行：\n\n`influxd`\n\n但是同样需要访问`localhost:9999`来访问：\n\n（1）首先这里的`localhost`指的是服务器的地址；\n\n（2）服务器（尤其是云服务器）需要注意添加9999安全组的IP路径，否则是无法访问的。\n\n修改成功后，登陆`ip_of_ECS:9999`就可以登陆V2.0界面了！\n![v2.png](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/1240.png)\nBeautiful！\n\n最后，提示一下**如果安装了V2.0版本后，原来的V1.8版本的命令就失效了**，以后想使用influxDB仅仅输入`influx`是不行的了！","source":"_posts/InfluxDB数据库-入门.md","raw":"---\ntitle: 【InfluxDB数据库】入门\ndate: 2020-07-31 21:28:23\ncategories: \n\t- Data Analysis\ntags:\n\t- software\n\t- influxdb\n---\n\n版本：v2.0-beta\n系统：win+docker / ubuntu服务器\n\n## 1. Docker 安装\n[Docker-desktop官方下载链接](https://www.docker.com/products/docker-desktop)\n安装完成之后，就可以直接在终端运行docker了\n或者可以在VSCode中使用docker插件\n\n## 2. VSCode 中 Docker 插件探索\n\n<!--more-->\n\n## 3. 在Docker中使用influxdb\n以下两句代码只需使用任意一句即可。\n\n```\n#下载页面的 docker image\ndocker pull quay.io/influxdb/influxdb:2.0.0-beta\n\n#介绍页面的安装方法\ndocker run --name influxdb -p 9999:9999 quay.io/influxdb/influxdb:2.0.0-beta\n```\n\n安装完成后，会显示：\n\n然后在浏览器中访问`localhost:9999`即可打开v2.0界面。\n\n## 4. 服务器安装V2.0\n### 4.1 首先将压缩包上传到服务器\n(1)使用代码，但是不好用\n\n```\nscp -r localfile.txt username@192.168.0.1:/home/username/\n```\n其中，\n１）scp是命令，-r是参数\n２）localfile.txt 是文件的路径和文件名\n３）username是服务器账号\n４）192.168.0.1是要上传的服务器ip地址\n５）/home/username/是要拷入的文件夹路径\n\n（2）直接用filezilla、MobaXterm等工具上传到服务器\n### 4.2 安装\n输入下列语句，主要是打开压缩包，以及安装。\n\n```\n# Unpackage contents to the current working directory\ntar xvzf path/to/influxdb_2.0.0-beta.10_linux_amd64.tar.gz\n\n# Copy the influx and influxd binary to your $PATH\nsudo cp influxdb_2.0.0-beta.10_linux_amd64/{influx,influxd} /usr/local/bin/\n```\n\n### 4.3 运行\n理论上输入如下语句即可运行：\n\n`influxd`\n\n但是同样需要访问`localhost:9999`来访问：\n\n（1）首先这里的`localhost`指的是服务器的地址；\n\n（2）服务器（尤其是云服务器）需要注意添加9999安全组的IP路径，否则是无法访问的。\n\n修改成功后，登陆`ip_of_ECS:9999`就可以登陆V2.0界面了！\n![v2.png](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/1240.png)\nBeautiful！\n\n最后，提示一下**如果安装了V2.0版本后，原来的V1.8版本的命令就失效了**，以后想使用influxDB仅仅输入`influx`是不行的了！","slug":"InfluxDB数据库-入门","published":1,"updated":"2021-01-26T06:16:41.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n87p0000k8tlct04brql","content":"<p>版本：v2.0-beta<br>系统：win+docker / ubuntu服务器</p>\n<h2 id=\"1-Docker-安装\"><a href=\"#1-Docker-安装\" class=\"headerlink\" title=\"1. Docker 安装\"></a>1. Docker 安装</h2><p><a href=\"https://www.docker.com/products/docker-desktop\" target=\"_blank\" rel=\"noopener\">Docker-desktop官方下载链接</a><br>安装完成之后，就可以直接在终端运行docker了<br>或者可以在VSCode中使用docker插件</p>\n<h2 id=\"2-VSCode-中-Docker-插件探索\"><a href=\"#2-VSCode-中-Docker-插件探索\" class=\"headerlink\" title=\"2. VSCode 中 Docker 插件探索\"></a>2. VSCode 中 Docker 插件探索</h2><a id=\"more\"></a>\n<h2 id=\"3-在Docker中使用influxdb\"><a href=\"#3-在Docker中使用influxdb\" class=\"headerlink\" title=\"3. 在Docker中使用influxdb\"></a>3. 在Docker中使用influxdb</h2><p>以下两句代码只需使用任意一句即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#下载页面的 docker image</span><br><span class=\"line\">docker pull quay.io&#x2F;influxdb&#x2F;influxdb:2.0.0-beta</span><br><span class=\"line\"></span><br><span class=\"line\">#介绍页面的安装方法</span><br><span class=\"line\">docker run --name influxdb -p 9999:9999 quay.io&#x2F;influxdb&#x2F;influxdb:2.0.0-beta</span><br></pre></td></tr></table></figure>\n<p>安装完成后，会显示：</p>\n<p>然后在浏览器中访问<code>localhost:9999</code>即可打开v2.0界面。</p>\n<h2 id=\"4-服务器安装V2-0\"><a href=\"#4-服务器安装V2-0\" class=\"headerlink\" title=\"4. 服务器安装V2.0\"></a>4. 服务器安装V2.0</h2><h3 id=\"4-1-首先将压缩包上传到服务器\"><a href=\"#4-1-首先将压缩包上传到服务器\" class=\"headerlink\" title=\"4.1 首先将压缩包上传到服务器\"></a>4.1 首先将压缩包上传到服务器</h3><p>(1)使用代码，但是不好用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r localfile.txt username@192.168.0.1:&#x2F;home&#x2F;username&#x2F;</span><br></pre></td></tr></table></figure>\n<p>其中，<br>１）scp是命令，-r是参数<br>２）localfile.txt 是文件的路径和文件名<br>３）username是服务器账号<br>４）192.168.0.1是要上传的服务器ip地址<br>５）/home/username/是要拷入的文件夹路径</p>\n<p>（2）直接用filezilla、MobaXterm等工具上传到服务器</p>\n<h3 id=\"4-2-安装\"><a href=\"#4-2-安装\" class=\"headerlink\" title=\"4.2 安装\"></a>4.2 安装</h3><p>输入下列语句，主要是打开压缩包，以及安装。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Unpackage contents to the current working directory</span><br><span class=\"line\">tar xvzf path&#x2F;to&#x2F;influxdb_2.0.0-beta.10_linux_amd64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># Copy the influx and influxd binary to your $PATH</span><br><span class=\"line\">sudo cp influxdb_2.0.0-beta.10_linux_amd64&#x2F;&#123;influx,influxd&#125; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-运行\"><a href=\"#4-3-运行\" class=\"headerlink\" title=\"4.3 运行\"></a>4.3 运行</h3><p>理论上输入如下语句即可运行：</p>\n<p><code>influxd</code></p>\n<p>但是同样需要访问<code>localhost:9999</code>来访问：</p>\n<p>（1）首先这里的<code>localhost</code>指的是服务器的地址；</p>\n<p>（2）服务器（尤其是云服务器）需要注意添加9999安全组的IP路径，否则是无法访问的。</p>\n<p>修改成功后，登陆<code>ip_of_ECS:9999</code>就可以登陆V2.0界面了！<br><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/1240.png\" alt=\"v2.png\"><br>Beautiful！</p>\n<p>最后，提示一下<strong>如果安装了V2.0版本后，原来的V1.8版本的命令就失效了</strong>，以后想使用influxDB仅仅输入<code>influx</code>是不行的了！</p>\n","site":{"data":{}},"excerpt":"<p>版本：v2.0-beta<br>系统：win+docker / ubuntu服务器</p>\n<h2 id=\"1-Docker-安装\"><a href=\"#1-Docker-安装\" class=\"headerlink\" title=\"1. Docker 安装\"></a>1. Docker 安装</h2><p><a href=\"https://www.docker.com/products/docker-desktop\" target=\"_blank\" rel=\"noopener\">Docker-desktop官方下载链接</a><br>安装完成之后，就可以直接在终端运行docker了<br>或者可以在VSCode中使用docker插件</p>\n<h2 id=\"2-VSCode-中-Docker-插件探索\"><a href=\"#2-VSCode-中-Docker-插件探索\" class=\"headerlink\" title=\"2. VSCode 中 Docker 插件探索\"></a>2. VSCode 中 Docker 插件探索</h2>","more":"<h2 id=\"3-在Docker中使用influxdb\"><a href=\"#3-在Docker中使用influxdb\" class=\"headerlink\" title=\"3. 在Docker中使用influxdb\"></a>3. 在Docker中使用influxdb</h2><p>以下两句代码只需使用任意一句即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#下载页面的 docker image</span><br><span class=\"line\">docker pull quay.io&#x2F;influxdb&#x2F;influxdb:2.0.0-beta</span><br><span class=\"line\"></span><br><span class=\"line\">#介绍页面的安装方法</span><br><span class=\"line\">docker run --name influxdb -p 9999:9999 quay.io&#x2F;influxdb&#x2F;influxdb:2.0.0-beta</span><br></pre></td></tr></table></figure>\n<p>安装完成后，会显示：</p>\n<p>然后在浏览器中访问<code>localhost:9999</code>即可打开v2.0界面。</p>\n<h2 id=\"4-服务器安装V2-0\"><a href=\"#4-服务器安装V2-0\" class=\"headerlink\" title=\"4. 服务器安装V2.0\"></a>4. 服务器安装V2.0</h2><h3 id=\"4-1-首先将压缩包上传到服务器\"><a href=\"#4-1-首先将压缩包上传到服务器\" class=\"headerlink\" title=\"4.1 首先将压缩包上传到服务器\"></a>4.1 首先将压缩包上传到服务器</h3><p>(1)使用代码，但是不好用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r localfile.txt username@192.168.0.1:&#x2F;home&#x2F;username&#x2F;</span><br></pre></td></tr></table></figure>\n<p>其中，<br>１）scp是命令，-r是参数<br>２）localfile.txt 是文件的路径和文件名<br>３）username是服务器账号<br>４）192.168.0.1是要上传的服务器ip地址<br>５）/home/username/是要拷入的文件夹路径</p>\n<p>（2）直接用filezilla、MobaXterm等工具上传到服务器</p>\n<h3 id=\"4-2-安装\"><a href=\"#4-2-安装\" class=\"headerlink\" title=\"4.2 安装\"></a>4.2 安装</h3><p>输入下列语句，主要是打开压缩包，以及安装。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Unpackage contents to the current working directory</span><br><span class=\"line\">tar xvzf path&#x2F;to&#x2F;influxdb_2.0.0-beta.10_linux_amd64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># Copy the influx and influxd binary to your $PATH</span><br><span class=\"line\">sudo cp influxdb_2.0.0-beta.10_linux_amd64&#x2F;&#123;influx,influxd&#125; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-运行\"><a href=\"#4-3-运行\" class=\"headerlink\" title=\"4.3 运行\"></a>4.3 运行</h3><p>理论上输入如下语句即可运行：</p>\n<p><code>influxd</code></p>\n<p>但是同样需要访问<code>localhost:9999</code>来访问：</p>\n<p>（1）首先这里的<code>localhost</code>指的是服务器的地址；</p>\n<p>（2）服务器（尤其是云服务器）需要注意添加9999安全组的IP路径，否则是无法访问的。</p>\n<p>修改成功后，登陆<code>ip_of_ECS:9999</code>就可以登陆V2.0界面了！<br><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/1240.png\" alt=\"v2.png\"><br>Beautiful！</p>\n<p>最后，提示一下<strong>如果安装了V2.0版本后，原来的V1.8版本的命令就失效了</strong>，以后想使用influxDB仅仅输入<code>influx</code>是不行的了！</p>"},{"title":"【InfluxDB数据库】简单使用","date":"2020-08-01T01:26:34.000Z","_content":"\n版本：V2.0-Beta\n\n## 1. 一些概念\n\n### Line protocol\n\ninflux使用line protocol来写入数据，格式和v1.8没有区别，如下：\n\n<!--more-->\n\n```\n// Syntax ，\n<measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]\n\n// Example\nmyMeasurement,tag1=value1,tag2=value2 fieldKey=\"fieldValue\" 1556813561098000000\n```\n\n注意：\n\n- 不能使用`\\n`换行\n- 浮点数可以使用科学计数法\n- 整数结尾要加一个`i`\n- 无符号整数结尾加一个`u`\n- 字符串长度限制在 64KB\n- 一般情况下使用的是unix时间戳\n- 需要转义的字符不多：空格，逗号，等号，引号，反斜杠等，使用`\\`进行转义\n- 注释：`#`\n- 命名不能以`_`开头\n\n### 带有注释的CSV\n文件`data.csv`\n\n## 2. 写入数据的方法\n\n### 从用户界面写入【最直观】\n\n1. influxDB 2.0 OSS界面中，选择**Data(load Data) > Buckets**\n2. 在希望写入数据的Bucket下选择**+Add Data**\n3. 然后会给三个方法：\n   （1）使用line protocol，上传文件（文件格式应为.line），或者手动输入；\n     （2）**爬虫方法——Scrape Metrics**，但是这个爬虫/刮板方法似乎很鸡肋，其爬取后的数据到底表示什么？可以点击**Explore > submit**查看数据情况，但是数据表示什么仍然不确定。\n   其格式为Prometheus，值得研究一下。\n     （3）**Telegraf**插件。\n\n### CLI写入\n\n用命令行方法，但是实现效果不佳\n\n使用命令`influx write -o -b -p -t -f`\n分别是org，bucket，precision，token，file\n\n- 可以用`\\`换行书写\n- 可以不用上传file的方式，直接写数据\n\n### 使用InfluxDB API写入【curl http】\n\n- 为什么要用这个写，主要是通过http方式将数据写入。\n- 写入数据压缩或者不压缩在代码上是有区别的。","source":"_posts/InfluxDB数据库-简单使用.md","raw":"---\ntitle: 【InfluxDB数据库】简单使用\ndate: 2020-08-01 09:26:34\ncategories:\n\t- Data Analysis\ntags:\n\t- software\n\t- influxdb\n---\n\n版本：V2.0-Beta\n\n## 1. 一些概念\n\n### Line protocol\n\ninflux使用line protocol来写入数据，格式和v1.8没有区别，如下：\n\n<!--more-->\n\n```\n// Syntax ，\n<measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]\n\n// Example\nmyMeasurement,tag1=value1,tag2=value2 fieldKey=\"fieldValue\" 1556813561098000000\n```\n\n注意：\n\n- 不能使用`\\n`换行\n- 浮点数可以使用科学计数法\n- 整数结尾要加一个`i`\n- 无符号整数结尾加一个`u`\n- 字符串长度限制在 64KB\n- 一般情况下使用的是unix时间戳\n- 需要转义的字符不多：空格，逗号，等号，引号，反斜杠等，使用`\\`进行转义\n- 注释：`#`\n- 命名不能以`_`开头\n\n### 带有注释的CSV\n文件`data.csv`\n\n## 2. 写入数据的方法\n\n### 从用户界面写入【最直观】\n\n1. influxDB 2.0 OSS界面中，选择**Data(load Data) > Buckets**\n2. 在希望写入数据的Bucket下选择**+Add Data**\n3. 然后会给三个方法：\n   （1）使用line protocol，上传文件（文件格式应为.line），或者手动输入；\n     （2）**爬虫方法——Scrape Metrics**，但是这个爬虫/刮板方法似乎很鸡肋，其爬取后的数据到底表示什么？可以点击**Explore > submit**查看数据情况，但是数据表示什么仍然不确定。\n   其格式为Prometheus，值得研究一下。\n     （3）**Telegraf**插件。\n\n### CLI写入\n\n用命令行方法，但是实现效果不佳\n\n使用命令`influx write -o -b -p -t -f`\n分别是org，bucket，precision，token，file\n\n- 可以用`\\`换行书写\n- 可以不用上传file的方式，直接写数据\n\n### 使用InfluxDB API写入【curl http】\n\n- 为什么要用这个写，主要是通过http方式将数据写入。\n- 写入数据压缩或者不压缩在代码上是有区别的。","slug":"InfluxDB数据库-简单使用","published":1,"updated":"2021-01-26T06:16:30.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n87u0002k8tlfyidgidd","content":"<p>版本：V2.0-Beta</p>\n<h2 id=\"1-一些概念\"><a href=\"#1-一些概念\" class=\"headerlink\" title=\"1. 一些概念\"></a>1. 一些概念</h2><h3 id=\"Line-protocol\"><a href=\"#Line-protocol\" class=\"headerlink\" title=\"Line protocol\"></a>Line protocol</h3><p>influx使用line protocol来写入数据，格式和v1.8没有区别，如下：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Syntax ，</span><br><span class=\"line\">&lt;measurement&gt;[,&lt;tag_key&gt;&#x3D;&lt;tag_value&gt;[,&lt;tag_key&gt;&#x3D;&lt;tag_value&gt;]] &lt;field_key&gt;&#x3D;&lt;field_value&gt;[,&lt;field_key&gt;&#x3D;&lt;field_value&gt;] [&lt;timestamp&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Example</span><br><span class=\"line\">myMeasurement,tag1&#x3D;value1,tag2&#x3D;value2 fieldKey&#x3D;&quot;fieldValue&quot; 1556813561098000000</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<ul>\n<li>不能使用<code>\\n</code>换行</li>\n<li>浮点数可以使用科学计数法</li>\n<li>整数结尾要加一个<code>i</code></li>\n<li>无符号整数结尾加一个<code>u</code></li>\n<li>字符串长度限制在 64KB</li>\n<li>一般情况下使用的是unix时间戳</li>\n<li>需要转义的字符不多：空格，逗号，等号，引号，反斜杠等，使用<code>\\</code>进行转义</li>\n<li>注释：<code>#</code></li>\n<li>命名不能以<code>_</code>开头</li>\n</ul>\n<h3 id=\"带有注释的CSV\"><a href=\"#带有注释的CSV\" class=\"headerlink\" title=\"带有注释的CSV\"></a>带有注释的CSV</h3><p>文件<code>data.csv</code></p>\n<h2 id=\"2-写入数据的方法\"><a href=\"#2-写入数据的方法\" class=\"headerlink\" title=\"2. 写入数据的方法\"></a>2. 写入数据的方法</h2><h3 id=\"从用户界面写入【最直观】\"><a href=\"#从用户界面写入【最直观】\" class=\"headerlink\" title=\"从用户界面写入【最直观】\"></a>从用户界面写入【最直观】</h3><ol>\n<li>influxDB 2.0 OSS界面中，选择<strong>Data(load Data) &gt; Buckets</strong></li>\n<li>在希望写入数据的Bucket下选择<strong>+Add Data</strong></li>\n<li>然后会给三个方法：<br>（1）使用line protocol，上传文件（文件格式应为.line），或者手动输入；<br>  （2）<strong>爬虫方法——Scrape Metrics</strong>，但是这个爬虫/刮板方法似乎很鸡肋，其爬取后的数据到底表示什么？可以点击<strong>Explore &gt; submit</strong>查看数据情况，但是数据表示什么仍然不确定。<br>其格式为Prometheus，值得研究一下。<br>  （3）<strong>Telegraf</strong>插件。</li>\n</ol>\n<h3 id=\"CLI写入\"><a href=\"#CLI写入\" class=\"headerlink\" title=\"CLI写入\"></a>CLI写入</h3><p>用命令行方法，但是实现效果不佳</p>\n<p>使用命令<code>influx write -o -b -p -t -f</code><br>分别是org，bucket，precision，token，file</p>\n<ul>\n<li>可以用<code>\\</code>换行书写</li>\n<li>可以不用上传file的方式，直接写数据</li>\n</ul>\n<h3 id=\"使用InfluxDB-API写入【curl-http】\"><a href=\"#使用InfluxDB-API写入【curl-http】\" class=\"headerlink\" title=\"使用InfluxDB API写入【curl http】\"></a>使用InfluxDB API写入【curl http】</h3><ul>\n<li>为什么要用这个写，主要是通过http方式将数据写入。</li>\n<li>写入数据压缩或者不压缩在代码上是有区别的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>版本：V2.0-Beta</p>\n<h2 id=\"1-一些概念\"><a href=\"#1-一些概念\" class=\"headerlink\" title=\"1. 一些概念\"></a>1. 一些概念</h2><h3 id=\"Line-protocol\"><a href=\"#Line-protocol\" class=\"headerlink\" title=\"Line protocol\"></a>Line protocol</h3><p>influx使用line protocol来写入数据，格式和v1.8没有区别，如下：</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Syntax ，</span><br><span class=\"line\">&lt;measurement&gt;[,&lt;tag_key&gt;&#x3D;&lt;tag_value&gt;[,&lt;tag_key&gt;&#x3D;&lt;tag_value&gt;]] &lt;field_key&gt;&#x3D;&lt;field_value&gt;[,&lt;field_key&gt;&#x3D;&lt;field_value&gt;] [&lt;timestamp&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Example</span><br><span class=\"line\">myMeasurement,tag1&#x3D;value1,tag2&#x3D;value2 fieldKey&#x3D;&quot;fieldValue&quot; 1556813561098000000</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<ul>\n<li>不能使用<code>\\n</code>换行</li>\n<li>浮点数可以使用科学计数法</li>\n<li>整数结尾要加一个<code>i</code></li>\n<li>无符号整数结尾加一个<code>u</code></li>\n<li>字符串长度限制在 64KB</li>\n<li>一般情况下使用的是unix时间戳</li>\n<li>需要转义的字符不多：空格，逗号，等号，引号，反斜杠等，使用<code>\\</code>进行转义</li>\n<li>注释：<code>#</code></li>\n<li>命名不能以<code>_</code>开头</li>\n</ul>\n<h3 id=\"带有注释的CSV\"><a href=\"#带有注释的CSV\" class=\"headerlink\" title=\"带有注释的CSV\"></a>带有注释的CSV</h3><p>文件<code>data.csv</code></p>\n<h2 id=\"2-写入数据的方法\"><a href=\"#2-写入数据的方法\" class=\"headerlink\" title=\"2. 写入数据的方法\"></a>2. 写入数据的方法</h2><h3 id=\"从用户界面写入【最直观】\"><a href=\"#从用户界面写入【最直观】\" class=\"headerlink\" title=\"从用户界面写入【最直观】\"></a>从用户界面写入【最直观】</h3><ol>\n<li>influxDB 2.0 OSS界面中，选择<strong>Data(load Data) &gt; Buckets</strong></li>\n<li>在希望写入数据的Bucket下选择<strong>+Add Data</strong></li>\n<li>然后会给三个方法：<br>（1）使用line protocol，上传文件（文件格式应为.line），或者手动输入；<br>  （2）<strong>爬虫方法——Scrape Metrics</strong>，但是这个爬虫/刮板方法似乎很鸡肋，其爬取后的数据到底表示什么？可以点击<strong>Explore &gt; submit</strong>查看数据情况，但是数据表示什么仍然不确定。<br>其格式为Prometheus，值得研究一下。<br>  （3）<strong>Telegraf</strong>插件。</li>\n</ol>\n<h3 id=\"CLI写入\"><a href=\"#CLI写入\" class=\"headerlink\" title=\"CLI写入\"></a>CLI写入</h3><p>用命令行方法，但是实现效果不佳</p>\n<p>使用命令<code>influx write -o -b -p -t -f</code><br>分别是org，bucket，precision，token，file</p>\n<ul>\n<li>可以用<code>\\</code>换行书写</li>\n<li>可以不用上传file的方式，直接写数据</li>\n</ul>\n<h3 id=\"使用InfluxDB-API写入【curl-http】\"><a href=\"#使用InfluxDB-API写入【curl-http】\" class=\"headerlink\" title=\"使用InfluxDB API写入【curl http】\"></a>使用InfluxDB API写入【curl http】</h3><ul>\n<li>为什么要用这个写，主要是通过http方式将数据写入。</li>\n<li>写入数据压缩或者不压缩在代码上是有区别的。</li>\n</ul>"},{"title":"【InfluxDB数据库】基础","date":"2020-07-30T01:31:44.000Z","_content":"\n系统：ubuntu\ninflux版本：v1.8\n\n## 1. 安装\n\n直接按照网站方法即可实现安装：  \n[install介绍](http://docs.influxdata.com/influxdb/v1.8/introduction/install/)\n\n<!--more-->\n\n## 2. 数据写入\n\n### 2.1 创建和使用databases\n\n`> create database mydb`\n关键词大小写均可，但是文件上使用的是大写；\n`> show databases`\n可以展示所有数据库；\n`> use mydb`\n使用数据库`mydb`，可以定向使用某个数据库\n\n### 2.2 写入数据\n\n>哪些数据可以被写入？\n\n#### 点的概念 - points\n\n点由`time`、`measurement`、`field`、`tags`构成：\n其中，`measurement`视为SQL表，时间是基础索引值（？）  \ntags和fields是SQL表中的有效列；  \ntags被索引，而fields不被索引；  \n**<font color=red>使用INSERT进行点数据的输入</font>**\n`id,tags=属性 空格 value=数值`\n每一部分内部用“，”分割，相互之间用空格分割，例如：\n`> insert temperature,machine=unit42,type=assembly external=25,internal=37`\n\n- **时间戳 - time**\n  参见v2.0版本的介绍；\n  因为本数据库用的是“时间序列”\n  timestamp\n\n- **`measurement`其实就是`id`**\n  例如`cpu_load`?\n  到底是什么\n\n- **`field`**\n  要测量的value，比如\n  `value=0.64` `temperature=21.2`\n\n- **`tags`**\n  `tags`是和value有关的所有数据(metadata)\n  例如host、region、dc等，**可是这些都是什么？**\n\n> **InfluxDB line protocol**\n> 需要使用该工具写入InfluxDB\n> [参考页面](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_reference/#line-protocol-syntax)\n\n## 3. 搜索数据 - Query - 询问\n\n1. 检索指定的数据内容：\n   `> select \"value_or_tag\" from  \"id/measurement\"`\n   <font color=red>一定要注意`from`前后都有空格！</font>\n2. 检索某个`id`的所有内容\n   `> select * from \"id/measurement\"`\n   但是文档上说，用这个不是太好，如果信息过多的话可能会有问题。\n3. `> select * from /.*/ limit 1`\n   这个没有解释，但从效果来看，是把所有数据库里面的信息都展示出来了。\n4. `> select * from \"id/measurement\" where \"value\" > 0.9`\n   添加选择性语句，用于选择满足条件的数据。\n5. 更多的方法\n   参考：[features and keywords](https://docs.influxdata.com/influxdb/v1.8/query_language/spec/)","source":"_posts/InfluxDB数据库-基础.md","raw":"---\ntitle: 【InfluxDB数据库】基础\ndate: 2020-07-30 09:31:44\ncategories:\n\t- Data Analysis\ntags:\n\t- software\n\t- influxdb\n---\n\n系统：ubuntu\ninflux版本：v1.8\n\n## 1. 安装\n\n直接按照网站方法即可实现安装：  \n[install介绍](http://docs.influxdata.com/influxdb/v1.8/introduction/install/)\n\n<!--more-->\n\n## 2. 数据写入\n\n### 2.1 创建和使用databases\n\n`> create database mydb`\n关键词大小写均可，但是文件上使用的是大写；\n`> show databases`\n可以展示所有数据库；\n`> use mydb`\n使用数据库`mydb`，可以定向使用某个数据库\n\n### 2.2 写入数据\n\n>哪些数据可以被写入？\n\n#### 点的概念 - points\n\n点由`time`、`measurement`、`field`、`tags`构成：\n其中，`measurement`视为SQL表，时间是基础索引值（？）  \ntags和fields是SQL表中的有效列；  \ntags被索引，而fields不被索引；  \n**<font color=red>使用INSERT进行点数据的输入</font>**\n`id,tags=属性 空格 value=数值`\n每一部分内部用“，”分割，相互之间用空格分割，例如：\n`> insert temperature,machine=unit42,type=assembly external=25,internal=37`\n\n- **时间戳 - time**\n  参见v2.0版本的介绍；\n  因为本数据库用的是“时间序列”\n  timestamp\n\n- **`measurement`其实就是`id`**\n  例如`cpu_load`?\n  到底是什么\n\n- **`field`**\n  要测量的value，比如\n  `value=0.64` `temperature=21.2`\n\n- **`tags`**\n  `tags`是和value有关的所有数据(metadata)\n  例如host、region、dc等，**可是这些都是什么？**\n\n> **InfluxDB line protocol**\n> 需要使用该工具写入InfluxDB\n> [参考页面](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_reference/#line-protocol-syntax)\n\n## 3. 搜索数据 - Query - 询问\n\n1. 检索指定的数据内容：\n   `> select \"value_or_tag\" from  \"id/measurement\"`\n   <font color=red>一定要注意`from`前后都有空格！</font>\n2. 检索某个`id`的所有内容\n   `> select * from \"id/measurement\"`\n   但是文档上说，用这个不是太好，如果信息过多的话可能会有问题。\n3. `> select * from /.*/ limit 1`\n   这个没有解释，但从效果来看，是把所有数据库里面的信息都展示出来了。\n4. `> select * from \"id/measurement\" where \"value\" > 0.9`\n   添加选择性语句，用于选择满足条件的数据。\n5. 更多的方法\n   参考：[features and keywords](https://docs.influxdata.com/influxdb/v1.8/query_language/spec/)","slug":"InfluxDB数据库-基础","published":1,"updated":"2021-01-26T06:16:13.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n87x0005k8tl4yg6euos","content":"<p>系统：ubuntu<br>influx版本：v1.8</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p>直接按照网站方法即可实现安装：<br><a href=\"http://docs.influxdata.com/influxdb/v1.8/introduction/install/\" target=\"_blank\" rel=\"noopener\">install介绍</a></p>\n<a id=\"more\"></a>\n<h2 id=\"2-数据写入\"><a href=\"#2-数据写入\" class=\"headerlink\" title=\"2. 数据写入\"></a>2. 数据写入</h2><h3 id=\"2-1-创建和使用databases\"><a href=\"#2-1-创建和使用databases\" class=\"headerlink\" title=\"2.1 创建和使用databases\"></a>2.1 创建和使用databases</h3><p><code>&gt; create database mydb</code><br>关键词大小写均可，但是文件上使用的是大写；<br><code>&gt; show databases</code><br>可以展示所有数据库；<br><code>&gt; use mydb</code><br>使用数据库<code>mydb</code>，可以定向使用某个数据库</p>\n<h3 id=\"2-2-写入数据\"><a href=\"#2-2-写入数据\" class=\"headerlink\" title=\"2.2 写入数据\"></a>2.2 写入数据</h3><blockquote>\n<p>哪些数据可以被写入？</p>\n</blockquote>\n<h4 id=\"点的概念-points\"><a href=\"#点的概念-points\" class=\"headerlink\" title=\"点的概念 - points\"></a>点的概念 - points</h4><p>点由<code>time</code>、<code>measurement</code>、<code>field</code>、<code>tags</code>构成：<br>其中，<code>measurement</code>视为SQL表，时间是基础索引值（？）<br>tags和fields是SQL表中的有效列；<br>tags被索引，而fields不被索引；<br><strong><font color=red>使用INSERT进行点数据的输入</font></strong><br><code>id,tags=属性 空格 value=数值</code><br>每一部分内部用“，”分割，相互之间用空格分割，例如：<br><code>&gt; insert temperature,machine=unit42,type=assembly external=25,internal=37</code></p>\n<ul>\n<li><p><strong>时间戳 - time</strong><br>参见v2.0版本的介绍；<br>因为本数据库用的是“时间序列”<br>timestamp</p>\n</li>\n<li><p><strong><code>measurement</code>其实就是<code>id</code></strong><br>例如<code>cpu_load</code>?<br>到底是什么</p>\n</li>\n<li><p><strong><code>field</code></strong><br>要测量的value，比如<br><code>value=0.64</code> <code>temperature=21.2</code></p>\n</li>\n<li><p><strong><code>tags</code></strong><br><code>tags</code>是和value有关的所有数据(metadata)<br>例如host、region、dc等，<strong>可是这些都是什么？</strong></p>\n</li>\n</ul>\n<blockquote>\n<p><strong>InfluxDB line protocol</strong><br>需要使用该工具写入InfluxDB<br><a href=\"https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_reference/#line-protocol-syntax\" target=\"_blank\" rel=\"noopener\">参考页面</a></p>\n</blockquote>\n<h2 id=\"3-搜索数据-Query-询问\"><a href=\"#3-搜索数据-Query-询问\" class=\"headerlink\" title=\"3. 搜索数据 - Query - 询问\"></a>3. 搜索数据 - Query - 询问</h2><ol>\n<li>检索指定的数据内容：<br><code>&gt; select &quot;value_or_tag&quot; from  &quot;id/measurement&quot;</code><font color=red>一定要注意`from`前后都有空格！</font></li>\n<li>检索某个<code>id</code>的所有内容<br><code>&gt; select * from &quot;id/measurement&quot;</code><br>但是文档上说，用这个不是太好，如果信息过多的话可能会有问题。</li>\n<li><code>&gt; select * from /.*/ limit 1</code><br>这个没有解释，但从效果来看，是把所有数据库里面的信息都展示出来了。</li>\n<li><code>&gt; select * from &quot;id/measurement&quot; where &quot;value&quot; &gt; 0.9</code><br>添加选择性语句，用于选择满足条件的数据。</li>\n<li>更多的方法<br>参考：<a href=\"https://docs.influxdata.com/influxdb/v1.8/query_language/spec/\" target=\"_blank\" rel=\"noopener\">features and keywords</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>系统：ubuntu<br>influx版本：v1.8</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p>直接按照网站方法即可实现安装：<br><a href=\"http://docs.influxdata.com/influxdb/v1.8/introduction/install/\" target=\"_blank\" rel=\"noopener\">install介绍</a></p>","more":"<h2 id=\"2-数据写入\"><a href=\"#2-数据写入\" class=\"headerlink\" title=\"2. 数据写入\"></a>2. 数据写入</h2><h3 id=\"2-1-创建和使用databases\"><a href=\"#2-1-创建和使用databases\" class=\"headerlink\" title=\"2.1 创建和使用databases\"></a>2.1 创建和使用databases</h3><p><code>&gt; create database mydb</code><br>关键词大小写均可，但是文件上使用的是大写；<br><code>&gt; show databases</code><br>可以展示所有数据库；<br><code>&gt; use mydb</code><br>使用数据库<code>mydb</code>，可以定向使用某个数据库</p>\n<h3 id=\"2-2-写入数据\"><a href=\"#2-2-写入数据\" class=\"headerlink\" title=\"2.2 写入数据\"></a>2.2 写入数据</h3><blockquote>\n<p>哪些数据可以被写入？</p>\n</blockquote>\n<h4 id=\"点的概念-points\"><a href=\"#点的概念-points\" class=\"headerlink\" title=\"点的概念 - points\"></a>点的概念 - points</h4><p>点由<code>time</code>、<code>measurement</code>、<code>field</code>、<code>tags</code>构成：<br>其中，<code>measurement</code>视为SQL表，时间是基础索引值（？）<br>tags和fields是SQL表中的有效列；<br>tags被索引，而fields不被索引；<br><strong><font color=red>使用INSERT进行点数据的输入</font></strong><br><code>id,tags=属性 空格 value=数值</code><br>每一部分内部用“，”分割，相互之间用空格分割，例如：<br><code>&gt; insert temperature,machine=unit42,type=assembly external=25,internal=37</code></p>\n<ul>\n<li><p><strong>时间戳 - time</strong><br>参见v2.0版本的介绍；<br>因为本数据库用的是“时间序列”<br>timestamp</p>\n</li>\n<li><p><strong><code>measurement</code>其实就是<code>id</code></strong><br>例如<code>cpu_load</code>?<br>到底是什么</p>\n</li>\n<li><p><strong><code>field</code></strong><br>要测量的value，比如<br><code>value=0.64</code> <code>temperature=21.2</code></p>\n</li>\n<li><p><strong><code>tags</code></strong><br><code>tags</code>是和value有关的所有数据(metadata)<br>例如host、region、dc等，<strong>可是这些都是什么？</strong></p>\n</li>\n</ul>\n<blockquote>\n<p><strong>InfluxDB line protocol</strong><br>需要使用该工具写入InfluxDB<br><a href=\"https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_reference/#line-protocol-syntax\" target=\"_blank\" rel=\"noopener\">参考页面</a></p>\n</blockquote>\n<h2 id=\"3-搜索数据-Query-询问\"><a href=\"#3-搜索数据-Query-询问\" class=\"headerlink\" title=\"3. 搜索数据 - Query - 询问\"></a>3. 搜索数据 - Query - 询问</h2><ol>\n<li>检索指定的数据内容：<br><code>&gt; select &quot;value_or_tag&quot; from  &quot;id/measurement&quot;</code><font color=red>一定要注意`from`前后都有空格！</font></li>\n<li>检索某个<code>id</code>的所有内容<br><code>&gt; select * from &quot;id/measurement&quot;</code><br>但是文档上说，用这个不是太好，如果信息过多的话可能会有问题。</li>\n<li><code>&gt; select * from /.*/ limit 1</code><br>这个没有解释，但从效果来看，是把所有数据库里面的信息都展示出来了。</li>\n<li><code>&gt; select * from &quot;id/measurement&quot; where &quot;value&quot; &gt; 0.9</code><br>添加选择性语句，用于选择满足条件的数据。</li>\n<li>更多的方法<br>参考：<a href=\"https://docs.influxdata.com/influxdb/v1.8/query_language/spec/\" target=\"_blank\" rel=\"noopener\">features and keywords</a></li>\n</ol>"},{"title":"PyTorch-学习篇2","date":"2020-11-25T06:55:56.000Z","_content":"\n> 本篇主要对学习中常见的torch、tensor方法进行记录，不定期更新。\n\n---\n\n# 模块 package\n\n`torch.util.data`包，参考：[pytorch实现自由的数据读取－torch.utils.data的学习](https://blog.csdn.net/tsq292978891/article/details/79414512)\n\n- `Dataset`\n\n- `Dataloader`\n- 用于读取数据集\n\n`torch.nn.DataParallel` 可以使用多个GPU来加速训练\n\n`torch.distributed`也是一个和分布式训练，多GPU训练有关的包\n\n`torch.optim`是一个思想了各种优化算法的库，可以用用于构建optimizar，里面有比较熟悉的SGD、Adam等优化器\n\n- 包括`optimizer.zero_grad()`，`loss.backward()`，`optimizer.step()`\n\n<!--more-->\n\n---\n\n# 方法 function\n\n一维list转化为三维list：`mean[:, None, None]`（前提是mean的类型是tensor）\n\n增加维度：`image[None]`（前提是tensor）\n\n生成序列：`torch.arange(start=1,end=6)` 里面会有两个参数，关键词可以不用写\n\n- `torch.range`的结果会包含 end\n- `torch.arange`的结果不包含 end\n- 两者创建的tensor类型也不一样，参考：[pytorch.range() 和 pytorch.arange() 的区别](https://blog.csdn.net/m0_37586991/article/details/88830026)\n\n**传入行坐标、列坐标，生成网格行坐标矩阵的列坐标矩阵**：`torch.meshgrid`【这个真的是有点惊艳】\n\n- `x1, y1 = torch.meshgrid(x, y)`\n- 传入的 x，y 是两个坐标轴\n- 输出的 x1, y1 是上面的x，y形成的网格的每一个角点的横纵坐标\n\n**拼接：**\n\n- `torch.cat((A, B), 0)` 在指定维度(0)进行拼接\n- `torch.stack((T1, T2), 0)`会在指定维度位置**新增一个维度**，然后进行拼接\n  - 该函数要求输入的**两个待拼接序列的shape必须是一样的**\n\n`tensor.detach()`准确来说是pytorch中的Variable对象的方法\n\n- 官方介绍：Returns a new Tensor, detached from the current graph.\n  The result will never require gradient.\n- 返回一个新的从当前图中分离的variable，这个返回的variable将不会需要梯度\n- 参考：[pytorch中的detach和detach_](https://www.cnblogs.com/jiangkejie/p/9981707.html)\n\n`torch.numel(x) `返回数组中元素的数目\n\n`torch.unbind(x, dim=1)`函数：移除指定维后，返回元组包含沿着指定维切片后的各个切片，参考：[PyTorch 函数解释：torch.narrow()、torch.unbind()](https://blog.csdn.net/dreamhome_s/article/details/106032025)\n\n`torch.topk`沿给定维度返回输入张量input中k个最大值，也可以返回最小的k个值（需要指定largest=False）\n\n`tensor.clean`\n\n展平，或者说也是一种变形：\n\n- `tensor.view()`\n  - 【只针对连续内存，如果索引顺序变化，自然也就不再连续了】\n- `tensor.reshape()`\n  - 没有连续内存的限制\n  - 里面如果有 -1，表示这一位会根据其他参数计算而得出来【毕竟总数是知道的，其他维上的数量知道了，这一维也就确定了】\n- `flatten`\n\n**使用tensor可以实现在矩阵中找小于大于某数的数的索引值的比较快的方式**\n\n```python\n# 蒙版索引\nbetween_thresholds=(matched_vals>=self.low_threshold)&(matched_vals<self.high_threshold)\n# 直接使用，从而找出matched_vals中介于满足两个阈值要求的数值\nmatrix[between_thresholds]\n```\n\n`torch.randperm(n)` 把0到n-1这些数随机打乱，得到一个数字序列\n\n`torch.clamp(input, min, max)` 将输入的input张量的每个元素夹紧到[min,max]区间，返回新张量。也就是说，大于max值的会缩小为max，小于min值得会放大为min值。\n\n`torch.nonzero(input)` 输入应为tensor类型，输出为两个tensor，记录了input中非零元素的索引位置（用横纵坐标来理解更容易）\n\n","source":"_posts/PyTorch-学习篇2.md","raw":"---\ntitle: PyTorch-学习篇2\ndate: 2020-11-25 14:55:56\ncategories:\n\t- 机器学习\ntags:\n\t- PyTorch\n---\n\n> 本篇主要对学习中常见的torch、tensor方法进行记录，不定期更新。\n\n---\n\n# 模块 package\n\n`torch.util.data`包，参考：[pytorch实现自由的数据读取－torch.utils.data的学习](https://blog.csdn.net/tsq292978891/article/details/79414512)\n\n- `Dataset`\n\n- `Dataloader`\n- 用于读取数据集\n\n`torch.nn.DataParallel` 可以使用多个GPU来加速训练\n\n`torch.distributed`也是一个和分布式训练，多GPU训练有关的包\n\n`torch.optim`是一个思想了各种优化算法的库，可以用用于构建optimizar，里面有比较熟悉的SGD、Adam等优化器\n\n- 包括`optimizer.zero_grad()`，`loss.backward()`，`optimizer.step()`\n\n<!--more-->\n\n---\n\n# 方法 function\n\n一维list转化为三维list：`mean[:, None, None]`（前提是mean的类型是tensor）\n\n增加维度：`image[None]`（前提是tensor）\n\n生成序列：`torch.arange(start=1,end=6)` 里面会有两个参数，关键词可以不用写\n\n- `torch.range`的结果会包含 end\n- `torch.arange`的结果不包含 end\n- 两者创建的tensor类型也不一样，参考：[pytorch.range() 和 pytorch.arange() 的区别](https://blog.csdn.net/m0_37586991/article/details/88830026)\n\n**传入行坐标、列坐标，生成网格行坐标矩阵的列坐标矩阵**：`torch.meshgrid`【这个真的是有点惊艳】\n\n- `x1, y1 = torch.meshgrid(x, y)`\n- 传入的 x，y 是两个坐标轴\n- 输出的 x1, y1 是上面的x，y形成的网格的每一个角点的横纵坐标\n\n**拼接：**\n\n- `torch.cat((A, B), 0)` 在指定维度(0)进行拼接\n- `torch.stack((T1, T2), 0)`会在指定维度位置**新增一个维度**，然后进行拼接\n  - 该函数要求输入的**两个待拼接序列的shape必须是一样的**\n\n`tensor.detach()`准确来说是pytorch中的Variable对象的方法\n\n- 官方介绍：Returns a new Tensor, detached from the current graph.\n  The result will never require gradient.\n- 返回一个新的从当前图中分离的variable，这个返回的variable将不会需要梯度\n- 参考：[pytorch中的detach和detach_](https://www.cnblogs.com/jiangkejie/p/9981707.html)\n\n`torch.numel(x) `返回数组中元素的数目\n\n`torch.unbind(x, dim=1)`函数：移除指定维后，返回元组包含沿着指定维切片后的各个切片，参考：[PyTorch 函数解释：torch.narrow()、torch.unbind()](https://blog.csdn.net/dreamhome_s/article/details/106032025)\n\n`torch.topk`沿给定维度返回输入张量input中k个最大值，也可以返回最小的k个值（需要指定largest=False）\n\n`tensor.clean`\n\n展平，或者说也是一种变形：\n\n- `tensor.view()`\n  - 【只针对连续内存，如果索引顺序变化，自然也就不再连续了】\n- `tensor.reshape()`\n  - 没有连续内存的限制\n  - 里面如果有 -1，表示这一位会根据其他参数计算而得出来【毕竟总数是知道的，其他维上的数量知道了，这一维也就确定了】\n- `flatten`\n\n**使用tensor可以实现在矩阵中找小于大于某数的数的索引值的比较快的方式**\n\n```python\n# 蒙版索引\nbetween_thresholds=(matched_vals>=self.low_threshold)&(matched_vals<self.high_threshold)\n# 直接使用，从而找出matched_vals中介于满足两个阈值要求的数值\nmatrix[between_thresholds]\n```\n\n`torch.randperm(n)` 把0到n-1这些数随机打乱，得到一个数字序列\n\n`torch.clamp(input, min, max)` 将输入的input张量的每个元素夹紧到[min,max]区间，返回新张量。也就是说，大于max值的会缩小为max，小于min值得会放大为min值。\n\n`torch.nonzero(input)` 输入应为tensor类型，输出为两个tensor，记录了input中非零元素的索引位置（用横纵坐标来理解更容易）\n\n","slug":"PyTorch-学习篇2","published":1,"updated":"2021-01-26T06:21:55.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n87x0006k8tl2yzefioh","content":"<blockquote>\n<p>本篇主要对学习中常见的torch、tensor方法进行记录，不定期更新。</p>\n</blockquote>\n<hr>\n<h1 id=\"模块-package\"><a href=\"#模块-package\" class=\"headerlink\" title=\"模块 package\"></a>模块 package</h1><p><code>torch.util.data</code>包，参考：<a href=\"https://blog.csdn.net/tsq292978891/article/details/79414512\" target=\"_blank\" rel=\"noopener\">pytorch实现自由的数据读取－torch.utils.data的学习</a></p>\n<ul>\n<li><p><code>Dataset</code></p>\n</li>\n<li><p><code>Dataloader</code></p>\n</li>\n<li>用于读取数据集</li>\n</ul>\n<p><code>torch.nn.DataParallel</code> 可以使用多个GPU来加速训练</p>\n<p><code>torch.distributed</code>也是一个和分布式训练，多GPU训练有关的包</p>\n<p><code>torch.optim</code>是一个思想了各种优化算法的库，可以用用于构建optimizar，里面有比较熟悉的SGD、Adam等优化器</p>\n<ul>\n<li>包括<code>optimizer.zero_grad()</code>，<code>loss.backward()</code>，<code>optimizer.step()</code></li>\n</ul>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"方法-function\"><a href=\"#方法-function\" class=\"headerlink\" title=\"方法 function\"></a>方法 function</h1><p>一维list转化为三维list：<code>mean[:, None, None]</code>（前提是mean的类型是tensor）</p>\n<p>增加维度：<code>image[None]</code>（前提是tensor）</p>\n<p>生成序列：<code>torch.arange(start=1,end=6)</code> 里面会有两个参数，关键词可以不用写</p>\n<ul>\n<li><code>torch.range</code>的结果会包含 end</li>\n<li><code>torch.arange</code>的结果不包含 end</li>\n<li>两者创建的tensor类型也不一样，参考：<a href=\"https://blog.csdn.net/m0_37586991/article/details/88830026\" target=\"_blank\" rel=\"noopener\">pytorch.range() 和 pytorch.arange() 的区别</a></li>\n</ul>\n<p><strong>传入行坐标、列坐标，生成网格行坐标矩阵的列坐标矩阵</strong>：<code>torch.meshgrid</code>【这个真的是有点惊艳】</p>\n<ul>\n<li><code>x1, y1 = torch.meshgrid(x, y)</code></li>\n<li>传入的 x，y 是两个坐标轴</li>\n<li>输出的 x1, y1 是上面的x，y形成的网格的每一个角点的横纵坐标</li>\n</ul>\n<p><strong>拼接：</strong></p>\n<ul>\n<li><code>torch.cat((A, B), 0)</code> 在指定维度(0)进行拼接</li>\n<li><code>torch.stack((T1, T2), 0)</code>会在指定维度位置<strong>新增一个维度</strong>，然后进行拼接<ul>\n<li>该函数要求输入的<strong>两个待拼接序列的shape必须是一样的</strong></li>\n</ul>\n</li>\n</ul>\n<p><code>tensor.detach()</code>准确来说是pytorch中的Variable对象的方法</p>\n<ul>\n<li>官方介绍：Returns a new Tensor, detached from the current graph.<br>The result will never require gradient.</li>\n<li>返回一个新的从当前图中分离的variable，这个返回的variable将不会需要梯度</li>\n<li>参考：<a href=\"https://www.cnblogs.com/jiangkejie/p/9981707.html\" target=\"_blank\" rel=\"noopener\">pytorch中的detach和detach_</a></li>\n</ul>\n<p><code>torch.numel(x)</code>返回数组中元素的数目</p>\n<p><code>torch.unbind(x, dim=1)</code>函数：移除指定维后，返回元组包含沿着指定维切片后的各个切片，参考：<a href=\"https://blog.csdn.net/dreamhome_s/article/details/106032025\" target=\"_blank\" rel=\"noopener\">PyTorch 函数解释：torch.narrow()、torch.unbind()</a></p>\n<p><code>torch.topk</code>沿给定维度返回输入张量input中k个最大值，也可以返回最小的k个值（需要指定largest=False）</p>\n<p><code>tensor.clean</code></p>\n<p>展平，或者说也是一种变形：</p>\n<ul>\n<li><code>tensor.view()</code><ul>\n<li>【只针对连续内存，如果索引顺序变化，自然也就不再连续了】</li>\n</ul>\n</li>\n<li><code>tensor.reshape()</code><ul>\n<li>没有连续内存的限制</li>\n<li>里面如果有 -1，表示这一位会根据其他参数计算而得出来【毕竟总数是知道的，其他维上的数量知道了，这一维也就确定了】</li>\n</ul>\n</li>\n<li><code>flatten</code></li>\n</ul>\n<p><strong>使用tensor可以实现在矩阵中找小于大于某数的数的索引值的比较快的方式</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 蒙版索引</span></span><br><span class=\"line\">between_thresholds=(matched_vals&gt;=self.low_threshold)&amp;(matched_vals&lt;self.high_threshold)</span><br><span class=\"line\"><span class=\"comment\"># 直接使用，从而找出matched_vals中介于满足两个阈值要求的数值</span></span><br><span class=\"line\">matrix[between_thresholds]</span><br></pre></td></tr></table></figure>\n<p><code>torch.randperm(n)</code> 把0到n-1这些数随机打乱，得到一个数字序列</p>\n<p><code>torch.clamp(input, min, max)</code> 将输入的input张量的每个元素夹紧到[min,max]区间，返回新张量。也就是说，大于max值的会缩小为max，小于min值得会放大为min值。</p>\n<p><code>torch.nonzero(input)</code> 输入应为tensor类型，输出为两个tensor，记录了input中非零元素的索引位置（用横纵坐标来理解更容易）</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇主要对学习中常见的torch、tensor方法进行记录，不定期更新。</p>\n</blockquote>\n<hr>\n<h1 id=\"模块-package\"><a href=\"#模块-package\" class=\"headerlink\" title=\"模块 package\"></a>模块 package</h1><p><code>torch.util.data</code>包，参考：<a href=\"https://blog.csdn.net/tsq292978891/article/details/79414512\" target=\"_blank\" rel=\"noopener\">pytorch实现自由的数据读取－torch.utils.data的学习</a></p>\n<ul>\n<li><p><code>Dataset</code></p>\n</li>\n<li><p><code>Dataloader</code></p>\n</li>\n<li>用于读取数据集</li>\n</ul>\n<p><code>torch.nn.DataParallel</code> 可以使用多个GPU来加速训练</p>\n<p><code>torch.distributed</code>也是一个和分布式训练，多GPU训练有关的包</p>\n<p><code>torch.optim</code>是一个思想了各种优化算法的库，可以用用于构建optimizar，里面有比较熟悉的SGD、Adam等优化器</p>\n<ul>\n<li>包括<code>optimizer.zero_grad()</code>，<code>loss.backward()</code>，<code>optimizer.step()</code></li>\n</ul>","more":"<hr>\n<h1 id=\"方法-function\"><a href=\"#方法-function\" class=\"headerlink\" title=\"方法 function\"></a>方法 function</h1><p>一维list转化为三维list：<code>mean[:, None, None]</code>（前提是mean的类型是tensor）</p>\n<p>增加维度：<code>image[None]</code>（前提是tensor）</p>\n<p>生成序列：<code>torch.arange(start=1,end=6)</code> 里面会有两个参数，关键词可以不用写</p>\n<ul>\n<li><code>torch.range</code>的结果会包含 end</li>\n<li><code>torch.arange</code>的结果不包含 end</li>\n<li>两者创建的tensor类型也不一样，参考：<a href=\"https://blog.csdn.net/m0_37586991/article/details/88830026\" target=\"_blank\" rel=\"noopener\">pytorch.range() 和 pytorch.arange() 的区别</a></li>\n</ul>\n<p><strong>传入行坐标、列坐标，生成网格行坐标矩阵的列坐标矩阵</strong>：<code>torch.meshgrid</code>【这个真的是有点惊艳】</p>\n<ul>\n<li><code>x1, y1 = torch.meshgrid(x, y)</code></li>\n<li>传入的 x，y 是两个坐标轴</li>\n<li>输出的 x1, y1 是上面的x，y形成的网格的每一个角点的横纵坐标</li>\n</ul>\n<p><strong>拼接：</strong></p>\n<ul>\n<li><code>torch.cat((A, B), 0)</code> 在指定维度(0)进行拼接</li>\n<li><code>torch.stack((T1, T2), 0)</code>会在指定维度位置<strong>新增一个维度</strong>，然后进行拼接<ul>\n<li>该函数要求输入的<strong>两个待拼接序列的shape必须是一样的</strong></li>\n</ul>\n</li>\n</ul>\n<p><code>tensor.detach()</code>准确来说是pytorch中的Variable对象的方法</p>\n<ul>\n<li>官方介绍：Returns a new Tensor, detached from the current graph.<br>The result will never require gradient.</li>\n<li>返回一个新的从当前图中分离的variable，这个返回的variable将不会需要梯度</li>\n<li>参考：<a href=\"https://www.cnblogs.com/jiangkejie/p/9981707.html\" target=\"_blank\" rel=\"noopener\">pytorch中的detach和detach_</a></li>\n</ul>\n<p><code>torch.numel(x)</code>返回数组中元素的数目</p>\n<p><code>torch.unbind(x, dim=1)</code>函数：移除指定维后，返回元组包含沿着指定维切片后的各个切片，参考：<a href=\"https://blog.csdn.net/dreamhome_s/article/details/106032025\" target=\"_blank\" rel=\"noopener\">PyTorch 函数解释：torch.narrow()、torch.unbind()</a></p>\n<p><code>torch.topk</code>沿给定维度返回输入张量input中k个最大值，也可以返回最小的k个值（需要指定largest=False）</p>\n<p><code>tensor.clean</code></p>\n<p>展平，或者说也是一种变形：</p>\n<ul>\n<li><code>tensor.view()</code><ul>\n<li>【只针对连续内存，如果索引顺序变化，自然也就不再连续了】</li>\n</ul>\n</li>\n<li><code>tensor.reshape()</code><ul>\n<li>没有连续内存的限制</li>\n<li>里面如果有 -1，表示这一位会根据其他参数计算而得出来【毕竟总数是知道的，其他维上的数量知道了，这一维也就确定了】</li>\n</ul>\n</li>\n<li><code>flatten</code></li>\n</ul>\n<p><strong>使用tensor可以实现在矩阵中找小于大于某数的数的索引值的比较快的方式</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 蒙版索引</span></span><br><span class=\"line\">between_thresholds=(matched_vals&gt;=self.low_threshold)&amp;(matched_vals&lt;self.high_threshold)</span><br><span class=\"line\"><span class=\"comment\"># 直接使用，从而找出matched_vals中介于满足两个阈值要求的数值</span></span><br><span class=\"line\">matrix[between_thresholds]</span><br></pre></td></tr></table></figure>\n<p><code>torch.randperm(n)</code> 把0到n-1这些数随机打乱，得到一个数字序列</p>\n<p><code>torch.clamp(input, min, max)</code> 将输入的input张量的每个元素夹紧到[min,max]区间，返回新张量。也就是说，大于max值的会缩小为max，小于min值得会放大为min值。</p>\n<p><code>torch.nonzero(input)</code> 输入应为tensor类型，输出为两个tensor，记录了input中非零元素的索引位置（用横纵坐标来理解更容易）</p>"},{"title":"PyTorch-学习篇1","date":"2020-11-24T13:38:26.000Z","_content":"\n> 本文根据PyTorch官方推荐同名书籍：《Deep learning with pytorch》的个人学习笔记而来。\n\n# Deep learning with pytorch\n\n基于优化任务性能的算法的基础上，自动提取分层特征的算法\n\n相对于手动选择特征，会有什么样的不同，以及怎么样去实现ta？1.3节涉及\n\nTo train this model, you need a few things (besides the loop itself, which can be a standard Python for loop): a source of training data, an optimizer to adapt the model to\nthe training data, and a way to get the model and data to the hardware that will be performing the calculations needed for training the model.  \n\n要训练该模型，您需要做一些事情（除了循环本身，它可以是标准的Python for循环）：训练数据的来源，用于使模型适应训练数据的优化器以及获取模型的方法 并将数据发送到硬件，该硬件将执行训练模型所需的计算。\n\n<!--more-->\n\n## tensor\n\n从tensor形式转化为storage形式，需要使用offset、size、stride三个变量\n\ntensor是一维的\n\nstride表示的是当tensor的维数+1时，元素必须跳过skip的个数\n\n在一个二维的tensor中\n\n$x_{i,j}=storage\\_offset+stride[0]*i+stride[1]*j$\n\noffset一般是 0，如果storage要存储一个很大的tensor的时候，可能offset会是一个正数\n\n**关于tensor，我觉的最关键的就是storage的理解**\n\npytorch一个强大的地方就是tensor数据的排列和存取方法，当你使用tensor进行存取时，storage就是一个很灵活的仓库\n\n你可以灵活地调整数据的维数，从而进行数据分析，而且还不会改变storage的分布，这确实是一个不错的创意\n\n## 关于训练\n\n本书的第三章对text、image等多种数据究竟应该如何传入神经网络进行了一点说明，并进行了比较基础的操作，非常具有启发性\n\n本书的第四章首先展示了一个比较简单的线性回归网络的全部程序，并且使用了反向传播等操作：\n\n- 通过不断的演化展示了在torch中可以利用其包含的API实现loss的反向传播和params的自动优化\n- 关于params的grad优化问题，还对zero-grad和step等常用方法进行了一点介绍\n\n第四章的后半部分（4.2.2以后）这是对训练过程中的一些细节问题进行讨论\n\n包括`optimizer.zero_grad()`，`loss.backward()`，`optimizer.step()`以及autograd方法：\n\n`params = torch.tensor([1.0, 0.0], requires_grad = True)`\n\n参数在定义时就采用了requires_grad，那么就会自动开始autograd跟踪，使用backward时，就会将变量关于参数的导数进行自动计算了\n\n## 一些技巧\n\n**首先是认识到过拟合的发生**\n\n解决方法之一是把数据集分割一下，必须要保证在每个部分都具有良好的效果才能说明模型是正确的\n\n解决方法之二：如果你的training loss没有减小，很有可能是你的模型过于简单了\n\n还有一种可能：你的数据没有包含足够的能够解释输出的有效信息\n\n另一条原则：如果训练集loss和测试集loss出现了偏差，那就说明是过拟合了！\n\n总结就是：\n\n- 首先保证有足够的数据\n- 适合的模型\n  - 一种方法是增加惩罚机制从而方便地让模型更平滑、变化地更慢一点\n  - 另一种方法是给输入数据增加噪声\n- 最简单的方法可能是让你的模型简单一点（不用拟合所有的点，从它们中穿过就好了）\n\n**选择合适的模型大小size，或者说参数多少的方法：**\n\n- 首先增加size，直到能够拟合\n- 然后减小，直到不再过拟合\n\n## 开启和关闭autograd\n\n**节省计算和存储**\n\n其实测试集的计算根本不需要反向传播，也不需要计算导数\n\n但是测试集的计算过程和训练集是一致的，使用了相同的函数和模型\n\n那么为了节省导数计算和存储，可以使用`torch.no_grad`方法（训练的函数中使用的是`requires_grad`的方法，只要使用，意味就会对参数进行跟踪）\n\n也可以使用`torch.set_grad_enabled`方法，来达到启用（enable）和关闭（disable）autograd的目的\n\n## 使用非线性激活函数\n\n值得注意的是，**权重 w** 可以是一个数字或者是矩阵（matrix）【这样权重w就可以掌握整个一层layer的神经元neurons】\n\n而 **输入 x** 与**偏置 b** 必须相匹配，一般是一个数字或一个向量（vector）\n\n激活函数的一个功能是件输出聚焦到一个指定的范围上\n\n1. `torch.nn.Hardtanh`激活函数\n\n小于0就全部为0，大于10就全部为10，类似这样的逻辑\n\n2. `torch.nn.sigmoid`激活函数\n\n3. `torch.tanh`\n\n这些激活函数，在x逐渐为负值时，渐进地接近0或者-1；而随着x上升，逐渐接近1，但是斜率会逐渐变小\n\n## 使用nn module搭建神经网络\n\n 搭建`nn.Module`的子类，至少需要重新定义一个`.forward()`函数：\n\n`.forward()`函数主要作用就是处理输入，变成输出\n\n所以通常来说，你的整个model会是`nn.Module`的一个子类，反过来，model也可嗯那个会包含其他的`nn.Module`的子类\n\n有三种方式实现相同的网络结构，并且使用的PyTorch功能越来越复杂\n\n- 第一种：`nn.Sequential`\n\n## 思维导图整理\n\n![image-20201111104603544](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201111104603544.png)\n\n![Deep-Learning-with-PyTorch](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/Deep-Learning-with-PyTorch.png)\n\n## 推荐书目\n\n- Grokking Deep Learning, by Andrew W. Traska, is a great resource for developing\n  a strong mental model and intuition on the mechanism underlying deep neural networks.\n- For a thorough introduction and reference to the field, we direct you to Deep\n  Learning, by Ian Goodfellow, Yoshua Bengio, and Aaron Courville.b【花书】\n- Last but not least, the full version of this book is available in Early Access now, with an estimated print date in late 2019: https://www.manning.com/books/deeplearning-with-pytorch.  ","source":"_posts/PyTorch学习篇-1.md","raw":"---\ntitle: PyTorch-学习篇1\ndate: 2020-11-24 21:38:26\ncategories:\n\t- 机器学习\ntags:\n\t- PyTorch\n---\n\n> 本文根据PyTorch官方推荐同名书籍：《Deep learning with pytorch》的个人学习笔记而来。\n\n# Deep learning with pytorch\n\n基于优化任务性能的算法的基础上，自动提取分层特征的算法\n\n相对于手动选择特征，会有什么样的不同，以及怎么样去实现ta？1.3节涉及\n\nTo train this model, you need a few things (besides the loop itself, which can be a standard Python for loop): a source of training data, an optimizer to adapt the model to\nthe training data, and a way to get the model and data to the hardware that will be performing the calculations needed for training the model.  \n\n要训练该模型，您需要做一些事情（除了循环本身，它可以是标准的Python for循环）：训练数据的来源，用于使模型适应训练数据的优化器以及获取模型的方法 并将数据发送到硬件，该硬件将执行训练模型所需的计算。\n\n<!--more-->\n\n## tensor\n\n从tensor形式转化为storage形式，需要使用offset、size、stride三个变量\n\ntensor是一维的\n\nstride表示的是当tensor的维数+1时，元素必须跳过skip的个数\n\n在一个二维的tensor中\n\n$x_{i,j}=storage\\_offset+stride[0]*i+stride[1]*j$\n\noffset一般是 0，如果storage要存储一个很大的tensor的时候，可能offset会是一个正数\n\n**关于tensor，我觉的最关键的就是storage的理解**\n\npytorch一个强大的地方就是tensor数据的排列和存取方法，当你使用tensor进行存取时，storage就是一个很灵活的仓库\n\n你可以灵活地调整数据的维数，从而进行数据分析，而且还不会改变storage的分布，这确实是一个不错的创意\n\n## 关于训练\n\n本书的第三章对text、image等多种数据究竟应该如何传入神经网络进行了一点说明，并进行了比较基础的操作，非常具有启发性\n\n本书的第四章首先展示了一个比较简单的线性回归网络的全部程序，并且使用了反向传播等操作：\n\n- 通过不断的演化展示了在torch中可以利用其包含的API实现loss的反向传播和params的自动优化\n- 关于params的grad优化问题，还对zero-grad和step等常用方法进行了一点介绍\n\n第四章的后半部分（4.2.2以后）这是对训练过程中的一些细节问题进行讨论\n\n包括`optimizer.zero_grad()`，`loss.backward()`，`optimizer.step()`以及autograd方法：\n\n`params = torch.tensor([1.0, 0.0], requires_grad = True)`\n\n参数在定义时就采用了requires_grad，那么就会自动开始autograd跟踪，使用backward时，就会将变量关于参数的导数进行自动计算了\n\n## 一些技巧\n\n**首先是认识到过拟合的发生**\n\n解决方法之一是把数据集分割一下，必须要保证在每个部分都具有良好的效果才能说明模型是正确的\n\n解决方法之二：如果你的training loss没有减小，很有可能是你的模型过于简单了\n\n还有一种可能：你的数据没有包含足够的能够解释输出的有效信息\n\n另一条原则：如果训练集loss和测试集loss出现了偏差，那就说明是过拟合了！\n\n总结就是：\n\n- 首先保证有足够的数据\n- 适合的模型\n  - 一种方法是增加惩罚机制从而方便地让模型更平滑、变化地更慢一点\n  - 另一种方法是给输入数据增加噪声\n- 最简单的方法可能是让你的模型简单一点（不用拟合所有的点，从它们中穿过就好了）\n\n**选择合适的模型大小size，或者说参数多少的方法：**\n\n- 首先增加size，直到能够拟合\n- 然后减小，直到不再过拟合\n\n## 开启和关闭autograd\n\n**节省计算和存储**\n\n其实测试集的计算根本不需要反向传播，也不需要计算导数\n\n但是测试集的计算过程和训练集是一致的，使用了相同的函数和模型\n\n那么为了节省导数计算和存储，可以使用`torch.no_grad`方法（训练的函数中使用的是`requires_grad`的方法，只要使用，意味就会对参数进行跟踪）\n\n也可以使用`torch.set_grad_enabled`方法，来达到启用（enable）和关闭（disable）autograd的目的\n\n## 使用非线性激活函数\n\n值得注意的是，**权重 w** 可以是一个数字或者是矩阵（matrix）【这样权重w就可以掌握整个一层layer的神经元neurons】\n\n而 **输入 x** 与**偏置 b** 必须相匹配，一般是一个数字或一个向量（vector）\n\n激活函数的一个功能是件输出聚焦到一个指定的范围上\n\n1. `torch.nn.Hardtanh`激活函数\n\n小于0就全部为0，大于10就全部为10，类似这样的逻辑\n\n2. `torch.nn.sigmoid`激活函数\n\n3. `torch.tanh`\n\n这些激活函数，在x逐渐为负值时，渐进地接近0或者-1；而随着x上升，逐渐接近1，但是斜率会逐渐变小\n\n## 使用nn module搭建神经网络\n\n 搭建`nn.Module`的子类，至少需要重新定义一个`.forward()`函数：\n\n`.forward()`函数主要作用就是处理输入，变成输出\n\n所以通常来说，你的整个model会是`nn.Module`的一个子类，反过来，model也可嗯那个会包含其他的`nn.Module`的子类\n\n有三种方式实现相同的网络结构，并且使用的PyTorch功能越来越复杂\n\n- 第一种：`nn.Sequential`\n\n## 思维导图整理\n\n![image-20201111104603544](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201111104603544.png)\n\n![Deep-Learning-with-PyTorch](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/Deep-Learning-with-PyTorch.png)\n\n## 推荐书目\n\n- Grokking Deep Learning, by Andrew W. Traska, is a great resource for developing\n  a strong mental model and intuition on the mechanism underlying deep neural networks.\n- For a thorough introduction and reference to the field, we direct you to Deep\n  Learning, by Ian Goodfellow, Yoshua Bengio, and Aaron Courville.b【花书】\n- Last but not least, the full version of this book is available in Early Access now, with an estimated print date in late 2019: https://www.manning.com/books/deeplearning-with-pytorch.  ","slug":"PyTorch学习篇-1","published":1,"updated":"2021-01-26T06:21:38.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n87y0007k8tl18bvhofn","content":"<blockquote>\n<p>本文根据PyTorch官方推荐同名书籍：《Deep learning with pytorch》的个人学习笔记而来。</p>\n</blockquote>\n<h1 id=\"Deep-learning-with-pytorch\"><a href=\"#Deep-learning-with-pytorch\" class=\"headerlink\" title=\"Deep learning with pytorch\"></a>Deep learning with pytorch</h1><p>基于优化任务性能的算法的基础上，自动提取分层特征的算法</p>\n<p>相对于手动选择特征，会有什么样的不同，以及怎么样去实现ta？1.3节涉及</p>\n<p>To train this model, you need a few things (besides the loop itself, which can be a standard Python for loop): a source of training data, an optimizer to adapt the model to<br>the training data, and a way to get the model and data to the hardware that will be performing the calculations needed for training the model.  </p>\n<p>要训练该模型，您需要做一些事情（除了循环本身，它可以是标准的Python for循环）：训练数据的来源，用于使模型适应训练数据的优化器以及获取模型的方法 并将数据发送到硬件，该硬件将执行训练模型所需的计算。</p>\n<a id=\"more\"></a>\n<h2 id=\"tensor\"><a href=\"#tensor\" class=\"headerlink\" title=\"tensor\"></a>tensor</h2><p>从tensor形式转化为storage形式，需要使用offset、size、stride三个变量</p>\n<p>tensor是一维的</p>\n<p>stride表示的是当tensor的维数+1时，元素必须跳过skip的个数</p>\n<p>在一个二维的tensor中</p>\n<p>$x_{i,j}=storage_offset+stride[0]<em>i+stride[1]</em>j$</p>\n<p>offset一般是 0，如果storage要存储一个很大的tensor的时候，可能offset会是一个正数</p>\n<p><strong>关于tensor，我觉的最关键的就是storage的理解</strong></p>\n<p>pytorch一个强大的地方就是tensor数据的排列和存取方法，当你使用tensor进行存取时，storage就是一个很灵活的仓库</p>\n<p>你可以灵活地调整数据的维数，从而进行数据分析，而且还不会改变storage的分布，这确实是一个不错的创意</p>\n<h2 id=\"关于训练\"><a href=\"#关于训练\" class=\"headerlink\" title=\"关于训练\"></a>关于训练</h2><p>本书的第三章对text、image等多种数据究竟应该如何传入神经网络进行了一点说明，并进行了比较基础的操作，非常具有启发性</p>\n<p>本书的第四章首先展示了一个比较简单的线性回归网络的全部程序，并且使用了反向传播等操作：</p>\n<ul>\n<li>通过不断的演化展示了在torch中可以利用其包含的API实现loss的反向传播和params的自动优化</li>\n<li>关于params的grad优化问题，还对zero-grad和step等常用方法进行了一点介绍</li>\n</ul>\n<p>第四章的后半部分（4.2.2以后）这是对训练过程中的一些细节问题进行讨论</p>\n<p>包括<code>optimizer.zero_grad()</code>，<code>loss.backward()</code>，<code>optimizer.step()</code>以及autograd方法：</p>\n<p><code>params = torch.tensor([1.0, 0.0], requires_grad = True)</code></p>\n<p>参数在定义时就采用了requires_grad，那么就会自动开始autograd跟踪，使用backward时，就会将变量关于参数的导数进行自动计算了</p>\n<h2 id=\"一些技巧\"><a href=\"#一些技巧\" class=\"headerlink\" title=\"一些技巧\"></a>一些技巧</h2><p><strong>首先是认识到过拟合的发生</strong></p>\n<p>解决方法之一是把数据集分割一下，必须要保证在每个部分都具有良好的效果才能说明模型是正确的</p>\n<p>解决方法之二：如果你的training loss没有减小，很有可能是你的模型过于简单了</p>\n<p>还有一种可能：你的数据没有包含足够的能够解释输出的有效信息</p>\n<p>另一条原则：如果训练集loss和测试集loss出现了偏差，那就说明是过拟合了！</p>\n<p>总结就是：</p>\n<ul>\n<li>首先保证有足够的数据</li>\n<li>适合的模型<ul>\n<li>一种方法是增加惩罚机制从而方便地让模型更平滑、变化地更慢一点</li>\n<li>另一种方法是给输入数据增加噪声</li>\n</ul>\n</li>\n<li>最简单的方法可能是让你的模型简单一点（不用拟合所有的点，从它们中穿过就好了）</li>\n</ul>\n<p><strong>选择合适的模型大小size，或者说参数多少的方法：</strong></p>\n<ul>\n<li>首先增加size，直到能够拟合</li>\n<li>然后减小，直到不再过拟合</li>\n</ul>\n<h2 id=\"开启和关闭autograd\"><a href=\"#开启和关闭autograd\" class=\"headerlink\" title=\"开启和关闭autograd\"></a>开启和关闭autograd</h2><p><strong>节省计算和存储</strong></p>\n<p>其实测试集的计算根本不需要反向传播，也不需要计算导数</p>\n<p>但是测试集的计算过程和训练集是一致的，使用了相同的函数和模型</p>\n<p>那么为了节省导数计算和存储，可以使用<code>torch.no_grad</code>方法（训练的函数中使用的是<code>requires_grad</code>的方法，只要使用，意味就会对参数进行跟踪）</p>\n<p>也可以使用<code>torch.set_grad_enabled</code>方法，来达到启用（enable）和关闭（disable）autograd的目的</p>\n<h2 id=\"使用非线性激活函数\"><a href=\"#使用非线性激活函数\" class=\"headerlink\" title=\"使用非线性激活函数\"></a>使用非线性激活函数</h2><p>值得注意的是，<strong>权重 w</strong> 可以是一个数字或者是矩阵（matrix）【这样权重w就可以掌握整个一层layer的神经元neurons】</p>\n<p>而 <strong>输入 x</strong> 与<strong>偏置 b</strong> 必须相匹配，一般是一个数字或一个向量（vector）</p>\n<p>激活函数的一个功能是件输出聚焦到一个指定的范围上</p>\n<ol>\n<li><code>torch.nn.Hardtanh</code>激活函数</li>\n</ol>\n<p>小于0就全部为0，大于10就全部为10，类似这样的逻辑</p>\n<ol>\n<li><p><code>torch.nn.sigmoid</code>激活函数</p>\n</li>\n<li><p><code>torch.tanh</code></p>\n</li>\n</ol>\n<p>这些激活函数，在x逐渐为负值时，渐进地接近0或者-1；而随着x上升，逐渐接近1，但是斜率会逐渐变小</p>\n<h2 id=\"使用nn-module搭建神经网络\"><a href=\"#使用nn-module搭建神经网络\" class=\"headerlink\" title=\"使用nn module搭建神经网络\"></a>使用nn module搭建神经网络</h2><p> 搭建<code>nn.Module</code>的子类，至少需要重新定义一个<code>.forward()</code>函数：</p>\n<p><code>.forward()</code>函数主要作用就是处理输入，变成输出</p>\n<p>所以通常来说，你的整个model会是<code>nn.Module</code>的一个子类，反过来，model也可嗯那个会包含其他的<code>nn.Module</code>的子类</p>\n<p>有三种方式实现相同的网络结构，并且使用的PyTorch功能越来越复杂</p>\n<ul>\n<li>第一种：<code>nn.Sequential</code></li>\n</ul>\n<h2 id=\"思维导图整理\"><a href=\"#思维导图整理\" class=\"headerlink\" title=\"思维导图整理\"></a>思维导图整理</h2><p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201111104603544.png\" alt=\"image-20201111104603544\"></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/Deep-Learning-with-PyTorch.png\" alt=\"Deep-Learning-with-PyTorch\"></p>\n<h2 id=\"推荐书目\"><a href=\"#推荐书目\" class=\"headerlink\" title=\"推荐书目\"></a>推荐书目</h2><ul>\n<li>Grokking Deep Learning, by Andrew W. Traska, is a great resource for developing<br>a strong mental model and intuition on the mechanism underlying deep neural networks.</li>\n<li>For a thorough introduction and reference to the field, we direct you to Deep<br>Learning, by Ian Goodfellow, Yoshua Bengio, and Aaron Courville.b【花书】</li>\n<li>Last but not least, the full version of this book is available in Early Access now, with an estimated print date in late 2019: <a href=\"https://www.manning.com/books/deeplearning-with-pytorch\" target=\"_blank\" rel=\"noopener\">https://www.manning.com/books/deeplearning-with-pytorch</a>.  </li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文根据PyTorch官方推荐同名书籍：《Deep learning with pytorch》的个人学习笔记而来。</p>\n</blockquote>\n<h1 id=\"Deep-learning-with-pytorch\"><a href=\"#Deep-learning-with-pytorch\" class=\"headerlink\" title=\"Deep learning with pytorch\"></a>Deep learning with pytorch</h1><p>基于优化任务性能的算法的基础上，自动提取分层特征的算法</p>\n<p>相对于手动选择特征，会有什么样的不同，以及怎么样去实现ta？1.3节涉及</p>\n<p>To train this model, you need a few things (besides the loop itself, which can be a standard Python for loop): a source of training data, an optimizer to adapt the model to<br>the training data, and a way to get the model and data to the hardware that will be performing the calculations needed for training the model.  </p>\n<p>要训练该模型，您需要做一些事情（除了循环本身，它可以是标准的Python for循环）：训练数据的来源，用于使模型适应训练数据的优化器以及获取模型的方法 并将数据发送到硬件，该硬件将执行训练模型所需的计算。</p>","more":"<h2 id=\"tensor\"><a href=\"#tensor\" class=\"headerlink\" title=\"tensor\"></a>tensor</h2><p>从tensor形式转化为storage形式，需要使用offset、size、stride三个变量</p>\n<p>tensor是一维的</p>\n<p>stride表示的是当tensor的维数+1时，元素必须跳过skip的个数</p>\n<p>在一个二维的tensor中</p>\n<p>$x_{i,j}=storage_offset+stride[0]<em>i+stride[1]</em>j$</p>\n<p>offset一般是 0，如果storage要存储一个很大的tensor的时候，可能offset会是一个正数</p>\n<p><strong>关于tensor，我觉的最关键的就是storage的理解</strong></p>\n<p>pytorch一个强大的地方就是tensor数据的排列和存取方法，当你使用tensor进行存取时，storage就是一个很灵活的仓库</p>\n<p>你可以灵活地调整数据的维数，从而进行数据分析，而且还不会改变storage的分布，这确实是一个不错的创意</p>\n<h2 id=\"关于训练\"><a href=\"#关于训练\" class=\"headerlink\" title=\"关于训练\"></a>关于训练</h2><p>本书的第三章对text、image等多种数据究竟应该如何传入神经网络进行了一点说明，并进行了比较基础的操作，非常具有启发性</p>\n<p>本书的第四章首先展示了一个比较简单的线性回归网络的全部程序，并且使用了反向传播等操作：</p>\n<ul>\n<li>通过不断的演化展示了在torch中可以利用其包含的API实现loss的反向传播和params的自动优化</li>\n<li>关于params的grad优化问题，还对zero-grad和step等常用方法进行了一点介绍</li>\n</ul>\n<p>第四章的后半部分（4.2.2以后）这是对训练过程中的一些细节问题进行讨论</p>\n<p>包括<code>optimizer.zero_grad()</code>，<code>loss.backward()</code>，<code>optimizer.step()</code>以及autograd方法：</p>\n<p><code>params = torch.tensor([1.0, 0.0], requires_grad = True)</code></p>\n<p>参数在定义时就采用了requires_grad，那么就会自动开始autograd跟踪，使用backward时，就会将变量关于参数的导数进行自动计算了</p>\n<h2 id=\"一些技巧\"><a href=\"#一些技巧\" class=\"headerlink\" title=\"一些技巧\"></a>一些技巧</h2><p><strong>首先是认识到过拟合的发生</strong></p>\n<p>解决方法之一是把数据集分割一下，必须要保证在每个部分都具有良好的效果才能说明模型是正确的</p>\n<p>解决方法之二：如果你的training loss没有减小，很有可能是你的模型过于简单了</p>\n<p>还有一种可能：你的数据没有包含足够的能够解释输出的有效信息</p>\n<p>另一条原则：如果训练集loss和测试集loss出现了偏差，那就说明是过拟合了！</p>\n<p>总结就是：</p>\n<ul>\n<li>首先保证有足够的数据</li>\n<li>适合的模型<ul>\n<li>一种方法是增加惩罚机制从而方便地让模型更平滑、变化地更慢一点</li>\n<li>另一种方法是给输入数据增加噪声</li>\n</ul>\n</li>\n<li>最简单的方法可能是让你的模型简单一点（不用拟合所有的点，从它们中穿过就好了）</li>\n</ul>\n<p><strong>选择合适的模型大小size，或者说参数多少的方法：</strong></p>\n<ul>\n<li>首先增加size，直到能够拟合</li>\n<li>然后减小，直到不再过拟合</li>\n</ul>\n<h2 id=\"开启和关闭autograd\"><a href=\"#开启和关闭autograd\" class=\"headerlink\" title=\"开启和关闭autograd\"></a>开启和关闭autograd</h2><p><strong>节省计算和存储</strong></p>\n<p>其实测试集的计算根本不需要反向传播，也不需要计算导数</p>\n<p>但是测试集的计算过程和训练集是一致的，使用了相同的函数和模型</p>\n<p>那么为了节省导数计算和存储，可以使用<code>torch.no_grad</code>方法（训练的函数中使用的是<code>requires_grad</code>的方法，只要使用，意味就会对参数进行跟踪）</p>\n<p>也可以使用<code>torch.set_grad_enabled</code>方法，来达到启用（enable）和关闭（disable）autograd的目的</p>\n<h2 id=\"使用非线性激活函数\"><a href=\"#使用非线性激活函数\" class=\"headerlink\" title=\"使用非线性激活函数\"></a>使用非线性激活函数</h2><p>值得注意的是，<strong>权重 w</strong> 可以是一个数字或者是矩阵（matrix）【这样权重w就可以掌握整个一层layer的神经元neurons】</p>\n<p>而 <strong>输入 x</strong> 与<strong>偏置 b</strong> 必须相匹配，一般是一个数字或一个向量（vector）</p>\n<p>激活函数的一个功能是件输出聚焦到一个指定的范围上</p>\n<ol>\n<li><code>torch.nn.Hardtanh</code>激活函数</li>\n</ol>\n<p>小于0就全部为0，大于10就全部为10，类似这样的逻辑</p>\n<ol>\n<li><p><code>torch.nn.sigmoid</code>激活函数</p>\n</li>\n<li><p><code>torch.tanh</code></p>\n</li>\n</ol>\n<p>这些激活函数，在x逐渐为负值时，渐进地接近0或者-1；而随着x上升，逐渐接近1，但是斜率会逐渐变小</p>\n<h2 id=\"使用nn-module搭建神经网络\"><a href=\"#使用nn-module搭建神经网络\" class=\"headerlink\" title=\"使用nn module搭建神经网络\"></a>使用nn module搭建神经网络</h2><p> 搭建<code>nn.Module</code>的子类，至少需要重新定义一个<code>.forward()</code>函数：</p>\n<p><code>.forward()</code>函数主要作用就是处理输入，变成输出</p>\n<p>所以通常来说，你的整个model会是<code>nn.Module</code>的一个子类，反过来，model也可嗯那个会包含其他的<code>nn.Module</code>的子类</p>\n<p>有三种方式实现相同的网络结构，并且使用的PyTorch功能越来越复杂</p>\n<ul>\n<li>第一种：<code>nn.Sequential</code></li>\n</ul>\n<h2 id=\"思维导图整理\"><a href=\"#思维导图整理\" class=\"headerlink\" title=\"思维导图整理\"></a>思维导图整理</h2><p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201111104603544.png\" alt=\"image-20201111104603544\"></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/Deep-Learning-with-PyTorch.png\" alt=\"Deep-Learning-with-PyTorch\"></p>\n<h2 id=\"推荐书目\"><a href=\"#推荐书目\" class=\"headerlink\" title=\"推荐书目\"></a>推荐书目</h2><ul>\n<li>Grokking Deep Learning, by Andrew W. Traska, is a great resource for developing<br>a strong mental model and intuition on the mechanism underlying deep neural networks.</li>\n<li>For a thorough introduction and reference to the field, we direct you to Deep<br>Learning, by Ian Goodfellow, Yoshua Bengio, and Aaron Courville.b【花书】</li>\n<li>Last but not least, the full version of this book is available in Early Access now, with an estimated print date in late 2019: <a href=\"https://www.manning.com/books/deeplearning-with-pytorch\" target=\"_blank\" rel=\"noopener\">https://www.manning.com/books/deeplearning-with-pytorch</a>.  </li>\n</ul>"},{"title":"【ROS】安装篇","date":"2020-07-28T02:00:41.000Z","_content":"\n安装一波三折值得细品\n\n## 0.系统\n\n使用Ubuntu原生系统自然最好；\n\n退而求其次，可以使用虚拟机的ubuntu系统，也很好用；\n\n曾尝试在Windows linux subsystem 上安装ubuntu和ROS，可以实现安装，也可以简单使用，但是针对仿真等比较耗内存的应用体验会比较差，而且还需要使用Xserver实现桌面映射。\n\n当前时间，最好用的是ubuntu 18.04系统，对应ROS-melodic版本，内容相对完善，也比较新；\n\nubuntu 20.04系统对应的ROS-Noetic在一些常用包上还是存在缺失问题，后期使用中会出现各种不兼容问题，值得注意。\n\n<!--more-->\n\n## 1. 换源\n\nROS系统需要的安装包大多来自 ros.org 或 github，建议使用换源以提高安装的成功率和效率；经常下载一小时，报错马上崩，很影响心态。\n\n亲测比较好用的apt换源有：\n\n[[简书换阿里源](https://www.jianshu.com/p/ad4dc5dbf55e)]\n\npip换源：\n\n[[更换linux系统中的pip源](https://www.cnblogs.com/g15009428458/p/12323137.html)]\n\n以及中科大源，见本文末。\n\n## 2. 安装\n\n[[ROS安装文章非常多](https://blog.csdn.net/sinat_38284212/article/details/100884644)]，基本步骤相同。\n\n一定要按部就班地来：\n\n最容易出现的问题是：`unable to load package xxx`\n\n原因：\n\n（1）换源失败\n\n（2）版本错误\n\n（3）没有更新软件和源\n\n*参考：[Ubuntu18.04.1安装ROS（'E:无法定位软件包'）](https://blog.csdn.net/sinat_34130812/article/details/81666728)*\n\n\n\n1. 参考[官网](http://wiki.ros.org/ROS/Installation/UbuntuMirrors)\n\n```bash\nsudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list'\n```\n\n获取镜像\n\n2. 设置密钥\n\n```bash\nsudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654\n```\n\n如果不设置，就会出现问题：[sudo apt-get update出现W: GPG 错误：http://packages.ros.org/ros/ubuntu xenial InRelease: 由于没有公钥，无法验证下列签名](https://blog.csdn.net/wangxue_1231/article/details/92801510)\n\n3. 重新更新一下（一定要！）\n\n```bash\nsudo apt-get update\n```\n\n4. 正式安装\n\n```bash\nsudo apt install ros-melodic-desktop-full\n```\n\n5. 启动：\n\n```bash\nsudo rosdep init\n```\n\n失败！\n\n最后容易出现的问题类似：\n\n[ubuntu16.04 运行rosdep init 返回ERROR：cannot download default sources list from](https://blog.csdn.net/qq_35590091/article/details/100515558)\n\n其本质原因还是换源没有换好，如果\n\n上面这个解决方法也不是太好，不妨使用下面文章中方法：\n\n[ERROR: cannot download default sources list from: https://raw.githubusercontent.com/ros/rosdistro/ma](https://blog.csdn.net/weixin_43288910/article/details/105627358?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3)\n\n也就是换成中国科大的源，亲测可用，即可愉快玩耍了！\n\n## rosdep 问题\n\nrosdep是ROS中推荐的一种安装方法，比如使用开源的机器人包，rosdep可以很方便地将package中需要的依赖找出并全部安装，听起来确实非常棒。\n\n但是实测会有一些小问题：\n\n- rosdep 无法使用的问题，非常普遍，网上建议一般是没有安装好rosdep，进行安装；\n- 安装rosdep之后，ros其他命令失效，这个问题实在是遇到了多次（不停地想尝试一下），最终还是选择重装ROS，其实不使用rosdep也不是大问题，在后续使用过程中逐步添加ROS的依赖包，也是可以的。\n\n\n\n","source":"_posts/ROS-安装篇.md","raw":"---\ntitle: 【ROS】安装篇\ndate: 2020-07-28 10:00:41\ncategories:\n\t- ROS\ntags:\n\t- ROS\n\t- software\n---\n\n安装一波三折值得细品\n\n## 0.系统\n\n使用Ubuntu原生系统自然最好；\n\n退而求其次，可以使用虚拟机的ubuntu系统，也很好用；\n\n曾尝试在Windows linux subsystem 上安装ubuntu和ROS，可以实现安装，也可以简单使用，但是针对仿真等比较耗内存的应用体验会比较差，而且还需要使用Xserver实现桌面映射。\n\n当前时间，最好用的是ubuntu 18.04系统，对应ROS-melodic版本，内容相对完善，也比较新；\n\nubuntu 20.04系统对应的ROS-Noetic在一些常用包上还是存在缺失问题，后期使用中会出现各种不兼容问题，值得注意。\n\n<!--more-->\n\n## 1. 换源\n\nROS系统需要的安装包大多来自 ros.org 或 github，建议使用换源以提高安装的成功率和效率；经常下载一小时，报错马上崩，很影响心态。\n\n亲测比较好用的apt换源有：\n\n[[简书换阿里源](https://www.jianshu.com/p/ad4dc5dbf55e)]\n\npip换源：\n\n[[更换linux系统中的pip源](https://www.cnblogs.com/g15009428458/p/12323137.html)]\n\n以及中科大源，见本文末。\n\n## 2. 安装\n\n[[ROS安装文章非常多](https://blog.csdn.net/sinat_38284212/article/details/100884644)]，基本步骤相同。\n\n一定要按部就班地来：\n\n最容易出现的问题是：`unable to load package xxx`\n\n原因：\n\n（1）换源失败\n\n（2）版本错误\n\n（3）没有更新软件和源\n\n*参考：[Ubuntu18.04.1安装ROS（'E:无法定位软件包'）](https://blog.csdn.net/sinat_34130812/article/details/81666728)*\n\n\n\n1. 参考[官网](http://wiki.ros.org/ROS/Installation/UbuntuMirrors)\n\n```bash\nsudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list'\n```\n\n获取镜像\n\n2. 设置密钥\n\n```bash\nsudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654\n```\n\n如果不设置，就会出现问题：[sudo apt-get update出现W: GPG 错误：http://packages.ros.org/ros/ubuntu xenial InRelease: 由于没有公钥，无法验证下列签名](https://blog.csdn.net/wangxue_1231/article/details/92801510)\n\n3. 重新更新一下（一定要！）\n\n```bash\nsudo apt-get update\n```\n\n4. 正式安装\n\n```bash\nsudo apt install ros-melodic-desktop-full\n```\n\n5. 启动：\n\n```bash\nsudo rosdep init\n```\n\n失败！\n\n最后容易出现的问题类似：\n\n[ubuntu16.04 运行rosdep init 返回ERROR：cannot download default sources list from](https://blog.csdn.net/qq_35590091/article/details/100515558)\n\n其本质原因还是换源没有换好，如果\n\n上面这个解决方法也不是太好，不妨使用下面文章中方法：\n\n[ERROR: cannot download default sources list from: https://raw.githubusercontent.com/ros/rosdistro/ma](https://blog.csdn.net/weixin_43288910/article/details/105627358?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3)\n\n也就是换成中国科大的源，亲测可用，即可愉快玩耍了！\n\n## rosdep 问题\n\nrosdep是ROS中推荐的一种安装方法，比如使用开源的机器人包，rosdep可以很方便地将package中需要的依赖找出并全部安装，听起来确实非常棒。\n\n但是实测会有一些小问题：\n\n- rosdep 无法使用的问题，非常普遍，网上建议一般是没有安装好rosdep，进行安装；\n- 安装rosdep之后，ros其他命令失效，这个问题实在是遇到了多次（不停地想尝试一下），最终还是选择重装ROS，其实不使用rosdep也不是大问题，在后续使用过程中逐步添加ROS的依赖包，也是可以的。\n\n\n\n","slug":"ROS-安装篇","published":1,"updated":"2021-01-26T06:22:06.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n880000ak8tlfueo9wr5","content":"<p>安装一波三折值得细品</p>\n<h2 id=\"0-系统\"><a href=\"#0-系统\" class=\"headerlink\" title=\"0.系统\"></a>0.系统</h2><p>使用Ubuntu原生系统自然最好；</p>\n<p>退而求其次，可以使用虚拟机的ubuntu系统，也很好用；</p>\n<p>曾尝试在Windows linux subsystem 上安装ubuntu和ROS，可以实现安装，也可以简单使用，但是针对仿真等比较耗内存的应用体验会比较差，而且还需要使用Xserver实现桌面映射。</p>\n<p>当前时间，最好用的是ubuntu 18.04系统，对应ROS-melodic版本，内容相对完善，也比较新；</p>\n<p>ubuntu 20.04系统对应的ROS-Noetic在一些常用包上还是存在缺失问题，后期使用中会出现各种不兼容问题，值得注意。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-换源\"><a href=\"#1-换源\" class=\"headerlink\" title=\"1. 换源\"></a>1. 换源</h2><p>ROS系统需要的安装包大多来自 ros.org 或 github，建议使用换源以提高安装的成功率和效率；经常下载一小时，报错马上崩，很影响心态。</p>\n<p>亲测比较好用的apt换源有：</p>\n<p>[<a href=\"https://www.jianshu.com/p/ad4dc5dbf55e\" target=\"_blank\" rel=\"noopener\">简书换阿里源</a>]</p>\n<p>pip换源：</p>\n<p>[<a href=\"https://www.cnblogs.com/g15009428458/p/12323137.html\" target=\"_blank\" rel=\"noopener\">更换linux系统中的pip源</a>]</p>\n<p>以及中科大源，见本文末。</p>\n<h2 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h2><p>[<a href=\"https://blog.csdn.net/sinat_38284212/article/details/100884644\" target=\"_blank\" rel=\"noopener\">ROS安装文章非常多</a>]，基本步骤相同。</p>\n<p>一定要按部就班地来：</p>\n<p>最容易出现的问题是：<code>unable to load package xxx</code></p>\n<p>原因：</p>\n<p>（1）换源失败</p>\n<p>（2）版本错误</p>\n<p>（3）没有更新软件和源</p>\n<p><em>参考：<a href=\"https://blog.csdn.net/sinat_34130812/article/details/81666728\" target=\"_blank\" rel=\"noopener\">Ubuntu18.04.1安装ROS（’E:无法定位软件包’）</a></em></p>\n<ol>\n<li>参考<a href=\"http://wiki.ros.org/ROS/Installation/UbuntuMirrors\" target=\"_blank\" rel=\"noopener\">官网</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo sh -c <span class=\"string\">'. /etc/lsb-release &amp;&amp; echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" &gt; /etc/apt/sources.list.d/ros-latest.list'</span></span><br></pre></td></tr></table></figure>\n<p>获取镜像</p>\n<ol>\n<li>设置密钥</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-key adv --keyserver <span class=\"string\">'hkp://keyserver.ubuntu.com:80'</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>\n<p>如果不设置，就会出现问题：<a href=\"https://blog.csdn.net/wangxue_1231/article/details/92801510\" target=\"_blank\" rel=\"noopener\">sudo apt-get update出现W: GPG 错误：http://packages.ros.org/ros/ubuntu xenial InRelease: 由于没有公钥，无法验证下列签名</a></p>\n<ol>\n<li>重新更新一下（一定要！）</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n<ol>\n<li>正式安装</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure>\n<ol>\n<li>启动：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rosdep init</span><br></pre></td></tr></table></figure>\n<p>失败！</p>\n<p>最后容易出现的问题类似：</p>\n<p><a href=\"https://blog.csdn.net/qq_35590091/article/details/100515558\" target=\"_blank\" rel=\"noopener\">ubuntu16.04 运行rosdep init 返回ERROR：cannot download default sources list from</a></p>\n<p>其本质原因还是换源没有换好，如果</p>\n<p>上面这个解决方法也不是太好，不妨使用下面文章中方法：</p>\n<p><a href=\"https://blog.csdn.net/weixin_43288910/article/details/105627358?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3\" target=\"_blank\" rel=\"noopener\">ERROR: cannot download default sources list from: https://raw.githubusercontent.com/ros/rosdistro/ma</a></p>\n<p>也就是换成中国科大的源，亲测可用，即可愉快玩耍了！</p>\n<h2 id=\"rosdep-问题\"><a href=\"#rosdep-问题\" class=\"headerlink\" title=\"rosdep 问题\"></a>rosdep 问题</h2><p>rosdep是ROS中推荐的一种安装方法，比如使用开源的机器人包，rosdep可以很方便地将package中需要的依赖找出并全部安装，听起来确实非常棒。</p>\n<p>但是实测会有一些小问题：</p>\n<ul>\n<li>rosdep 无法使用的问题，非常普遍，网上建议一般是没有安装好rosdep，进行安装；</li>\n<li>安装rosdep之后，ros其他命令失效，这个问题实在是遇到了多次（不停地想尝试一下），最终还是选择重装ROS，其实不使用rosdep也不是大问题，在后续使用过程中逐步添加ROS的依赖包，也是可以的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>安装一波三折值得细品</p>\n<h2 id=\"0-系统\"><a href=\"#0-系统\" class=\"headerlink\" title=\"0.系统\"></a>0.系统</h2><p>使用Ubuntu原生系统自然最好；</p>\n<p>退而求其次，可以使用虚拟机的ubuntu系统，也很好用；</p>\n<p>曾尝试在Windows linux subsystem 上安装ubuntu和ROS，可以实现安装，也可以简单使用，但是针对仿真等比较耗内存的应用体验会比较差，而且还需要使用Xserver实现桌面映射。</p>\n<p>当前时间，最好用的是ubuntu 18.04系统，对应ROS-melodic版本，内容相对完善，也比较新；</p>\n<p>ubuntu 20.04系统对应的ROS-Noetic在一些常用包上还是存在缺失问题，后期使用中会出现各种不兼容问题，值得注意。</p>","more":"<h2 id=\"1-换源\"><a href=\"#1-换源\" class=\"headerlink\" title=\"1. 换源\"></a>1. 换源</h2><p>ROS系统需要的安装包大多来自 ros.org 或 github，建议使用换源以提高安装的成功率和效率；经常下载一小时，报错马上崩，很影响心态。</p>\n<p>亲测比较好用的apt换源有：</p>\n<p>[<a href=\"https://www.jianshu.com/p/ad4dc5dbf55e\" target=\"_blank\" rel=\"noopener\">简书换阿里源</a>]</p>\n<p>pip换源：</p>\n<p>[<a href=\"https://www.cnblogs.com/g15009428458/p/12323137.html\" target=\"_blank\" rel=\"noopener\">更换linux系统中的pip源</a>]</p>\n<p>以及中科大源，见本文末。</p>\n<h2 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h2><p>[<a href=\"https://blog.csdn.net/sinat_38284212/article/details/100884644\" target=\"_blank\" rel=\"noopener\">ROS安装文章非常多</a>]，基本步骤相同。</p>\n<p>一定要按部就班地来：</p>\n<p>最容易出现的问题是：<code>unable to load package xxx</code></p>\n<p>原因：</p>\n<p>（1）换源失败</p>\n<p>（2）版本错误</p>\n<p>（3）没有更新软件和源</p>\n<p><em>参考：<a href=\"https://blog.csdn.net/sinat_34130812/article/details/81666728\" target=\"_blank\" rel=\"noopener\">Ubuntu18.04.1安装ROS（’E:无法定位软件包’）</a></em></p>\n<ol>\n<li>参考<a href=\"http://wiki.ros.org/ROS/Installation/UbuntuMirrors\" target=\"_blank\" rel=\"noopener\">官网</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo sh -c <span class=\"string\">'. /etc/lsb-release &amp;&amp; echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" &gt; /etc/apt/sources.list.d/ros-latest.list'</span></span><br></pre></td></tr></table></figure>\n<p>获取镜像</p>\n<ol>\n<li>设置密钥</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-key adv --keyserver <span class=\"string\">'hkp://keyserver.ubuntu.com:80'</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>\n<p>如果不设置，就会出现问题：<a href=\"https://blog.csdn.net/wangxue_1231/article/details/92801510\" target=\"_blank\" rel=\"noopener\">sudo apt-get update出现W: GPG 错误：http://packages.ros.org/ros/ubuntu xenial InRelease: 由于没有公钥，无法验证下列签名</a></p>\n<ol>\n<li>重新更新一下（一定要！）</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n<ol>\n<li>正式安装</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure>\n<ol>\n<li>启动：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rosdep init</span><br></pre></td></tr></table></figure>\n<p>失败！</p>\n<p>最后容易出现的问题类似：</p>\n<p><a href=\"https://blog.csdn.net/qq_35590091/article/details/100515558\" target=\"_blank\" rel=\"noopener\">ubuntu16.04 运行rosdep init 返回ERROR：cannot download default sources list from</a></p>\n<p>其本质原因还是换源没有换好，如果</p>\n<p>上面这个解决方法也不是太好，不妨使用下面文章中方法：</p>\n<p><a href=\"https://blog.csdn.net/weixin_43288910/article/details/105627358?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3\" target=\"_blank\" rel=\"noopener\">ERROR: cannot download default sources list from: https://raw.githubusercontent.com/ros/rosdistro/ma</a></p>\n<p>也就是换成中国科大的源，亲测可用，即可愉快玩耍了！</p>\n<h2 id=\"rosdep-问题\"><a href=\"#rosdep-问题\" class=\"headerlink\" title=\"rosdep 问题\"></a>rosdep 问题</h2><p>rosdep是ROS中推荐的一种安装方法，比如使用开源的机器人包，rosdep可以很方便地将package中需要的依赖找出并全部安装，听起来确实非常棒。</p>\n<p>但是实测会有一些小问题：</p>\n<ul>\n<li>rosdep 无法使用的问题，非常普遍，网上建议一般是没有安装好rosdep，进行安装；</li>\n<li>安装rosdep之后，ros其他命令失效，这个问题实在是遇到了多次（不停地想尝试一下），最终还是选择重装ROS，其实不使用rosdep也不是大问题，在后续使用过程中逐步添加ROS的依赖包，也是可以的。</li>\n</ul>"},{"title":"VisualStudio Code学习","date":"2020-07-29T01:15:29.000Z","_content":"\n**VScode是强大的代码编辑器**，用一些小技巧重新认识它：\n\n## 1. 开胃菜\n\n调出命令行：**按 ctrl + shift + p**\n\n设置页面：\n\n- 点击左下方设置按钮查询设置内容\n- 在设置界面中，会有部分设置内容下方 给出 settings.json 文件\n\n<!--more-->\n\n推荐插件：\n\n| 插件                      | 功能                                                 |\n| ------------------------- | :--------------------------------------------------- |\n| Bracket Pair Colorizer    | 让每一对括号有自己的颜色；括号越来越多的时候很有用。 |\n| vscode-icon               | 不同文件根据代码加图标；增加一点色彩。               |\n| Visual Studio IntelliCode | 补全代码；非常有用。                                 |\n| remote development        | 远程连接服务器等。                                   |\n\n其他涉及某项语言的插件，可以在用到的时候直接查找即可，甚至微信小程序、VUE、Django、ROS等也有插件可用。\n\n## 2. 协同 Anaconda Prompt\n\n在VSCode中使用Anaconda Prompt的虚拟终端，能够方便地配置好python调试环境等内容\n\n（就可以脱离Anaconda Prompt的束缚了）\n\n打开设置：\n\n### 修改方案一：【勉强实现conda的调用】\n\n主要是修改以下内容：\n\n```javascript\n{\n    \"python.pythonPath\": \"C:\\\\ProgramData\\\\Anaconda3\\\\python.exe\",\n    \"terminal.integrated.automationShell.windows\": \"\",\n    \"terminal.integrated.shell.windows\": \"\"\n}\n```\n\n> 参考：[[在vscode中打开conda的虚拟终端](https://blog.csdn.net/Add_a_cat/article/details/101051759)]\n\n这是一种相对简单的方法，只需要修改配置，就可以进行使用。\n\n**缺点：**目前发现这样的修改后，conda只能进入base环境，而不能进入其他环境，不利于使用\n\n### 修改方案二：【conda完美调用】\n\n首先，修改环境变量，使得能够直接在windows终端（cmd）中直接调用\n\n【注意在conda官方看来，将conda命令加入环境变量是有风险的】\n\n在path（我的电脑-属性-环境变量-系统变量）中，添加anaconda和script的地址，可以打开anaconda prompt输入path直接进行查看\n\n> 参考：[综合处理 'conda' 不是内部或外部命令,也不是可运行的程序 或批处理文件。](https://blog.csdn.net/yelly0/article/details/88426076)\n\n然后，将VSCode的`terminal`地址改为`cmd`，这样就可以像在`cmd`中一样使用`conda`了\n\n【注意：不能直接改成anaconda prompt，原因是不支持，或者说anaconda prompt本身的底层就是cmd】\n\n打开设置，搜索`shell`\n\n主要修改`Terminal>Intergrated>Shell:Windows`\n\n![image-20201105093651583](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201105093651583.png)\n\n打开`settings.json`\n\n修改`\"terminal.integrated.shell.windows\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\",`\n\n重新打开vscode，然后再打开终端就可以使用了【如果不重新打开，可能会报一点问题】\n\n注意不要添加`\"terminal.integrated.shellArgs.windows\"`项，该项也有可能对终端产生一定的影响\n\n## 3. 其他工具\n\n### Git\n\n结合gitlens的使用，比Git terminal更快一步。\n\n前提：认真配置好Git环境，可参考菜鸟教程关于Git的介绍。\n\n\n### SSH\n\n推荐插件：`remote development`\n\n实现对服务器的远程控制，注意第一次启动时需要对用户名等内容进行一点设置。\n\n*参考：[[使用remote](https://blog.csdn.net/weixin_40373708/article/details/90376258)]*\n\n此外，正常情况下，每次打开新文件夹需要再次输入密码，确实有点麻烦，还可以配置一下ssh-keygen，减少密码输入。\n\n*参考：[[ssh-keygen](https://blog.csdn.net/qq_43143808/article/details/106765470?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)]*\n\n### 工作区\n\n工作区的使用不完全手册\n\n可以把文件夹添加到工作区\n\n选择：\n\n![image-20200812151444206](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200812151444206.png)\n\n即可在工作区中同时打开两个文件夹了","source":"_posts/VisualStudio Code学习.md","raw":"---\ntitle: VisualStudio Code学习\ndate: 2020-07-29 09:15:29\ncategories:\n    - Tools\ntags: \n    - software\n---\n\n**VScode是强大的代码编辑器**，用一些小技巧重新认识它：\n\n## 1. 开胃菜\n\n调出命令行：**按 ctrl + shift + p**\n\n设置页面：\n\n- 点击左下方设置按钮查询设置内容\n- 在设置界面中，会有部分设置内容下方 给出 settings.json 文件\n\n<!--more-->\n\n推荐插件：\n\n| 插件                      | 功能                                                 |\n| ------------------------- | :--------------------------------------------------- |\n| Bracket Pair Colorizer    | 让每一对括号有自己的颜色；括号越来越多的时候很有用。 |\n| vscode-icon               | 不同文件根据代码加图标；增加一点色彩。               |\n| Visual Studio IntelliCode | 补全代码；非常有用。                                 |\n| remote development        | 远程连接服务器等。                                   |\n\n其他涉及某项语言的插件，可以在用到的时候直接查找即可，甚至微信小程序、VUE、Django、ROS等也有插件可用。\n\n## 2. 协同 Anaconda Prompt\n\n在VSCode中使用Anaconda Prompt的虚拟终端，能够方便地配置好python调试环境等内容\n\n（就可以脱离Anaconda Prompt的束缚了）\n\n打开设置：\n\n### 修改方案一：【勉强实现conda的调用】\n\n主要是修改以下内容：\n\n```javascript\n{\n    \"python.pythonPath\": \"C:\\\\ProgramData\\\\Anaconda3\\\\python.exe\",\n    \"terminal.integrated.automationShell.windows\": \"\",\n    \"terminal.integrated.shell.windows\": \"\"\n}\n```\n\n> 参考：[[在vscode中打开conda的虚拟终端](https://blog.csdn.net/Add_a_cat/article/details/101051759)]\n\n这是一种相对简单的方法，只需要修改配置，就可以进行使用。\n\n**缺点：**目前发现这样的修改后，conda只能进入base环境，而不能进入其他环境，不利于使用\n\n### 修改方案二：【conda完美调用】\n\n首先，修改环境变量，使得能够直接在windows终端（cmd）中直接调用\n\n【注意在conda官方看来，将conda命令加入环境变量是有风险的】\n\n在path（我的电脑-属性-环境变量-系统变量）中，添加anaconda和script的地址，可以打开anaconda prompt输入path直接进行查看\n\n> 参考：[综合处理 'conda' 不是内部或外部命令,也不是可运行的程序 或批处理文件。](https://blog.csdn.net/yelly0/article/details/88426076)\n\n然后，将VSCode的`terminal`地址改为`cmd`，这样就可以像在`cmd`中一样使用`conda`了\n\n【注意：不能直接改成anaconda prompt，原因是不支持，或者说anaconda prompt本身的底层就是cmd】\n\n打开设置，搜索`shell`\n\n主要修改`Terminal>Intergrated>Shell:Windows`\n\n![image-20201105093651583](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201105093651583.png)\n\n打开`settings.json`\n\n修改`\"terminal.integrated.shell.windows\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\",`\n\n重新打开vscode，然后再打开终端就可以使用了【如果不重新打开，可能会报一点问题】\n\n注意不要添加`\"terminal.integrated.shellArgs.windows\"`项，该项也有可能对终端产生一定的影响\n\n## 3. 其他工具\n\n### Git\n\n结合gitlens的使用，比Git terminal更快一步。\n\n前提：认真配置好Git环境，可参考菜鸟教程关于Git的介绍。\n\n\n### SSH\n\n推荐插件：`remote development`\n\n实现对服务器的远程控制，注意第一次启动时需要对用户名等内容进行一点设置。\n\n*参考：[[使用remote](https://blog.csdn.net/weixin_40373708/article/details/90376258)]*\n\n此外，正常情况下，每次打开新文件夹需要再次输入密码，确实有点麻烦，还可以配置一下ssh-keygen，减少密码输入。\n\n*参考：[[ssh-keygen](https://blog.csdn.net/qq_43143808/article/details/106765470?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)]*\n\n### 工作区\n\n工作区的使用不完全手册\n\n可以把文件夹添加到工作区\n\n选择：\n\n![image-20200812151444206](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200812151444206.png)\n\n即可在工作区中同时打开两个文件夹了","slug":"VisualStudio Code学习","published":1,"updated":"2021-01-26T06:22:17.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n880000bk8tl1k9kafnk","content":"<p><strong>VScode是强大的代码编辑器</strong>，用一些小技巧重新认识它：</p>\n<h2 id=\"1-开胃菜\"><a href=\"#1-开胃菜\" class=\"headerlink\" title=\"1. 开胃菜\"></a>1. 开胃菜</h2><p>调出命令行：<strong>按 ctrl + shift + p</strong></p>\n<p>设置页面：</p>\n<ul>\n<li>点击左下方设置按钮查询设置内容</li>\n<li>在设置界面中，会有部分设置内容下方 给出 settings.json 文件</li>\n</ul>\n<a id=\"more\"></a>\n<p>推荐插件：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>插件</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bracket Pair Colorizer</td>\n<td style=\"text-align:left\">让每一对括号有自己的颜色；括号越来越多的时候很有用。</td>\n</tr>\n<tr>\n<td>vscode-icon</td>\n<td style=\"text-align:left\">不同文件根据代码加图标；增加一点色彩。</td>\n</tr>\n<tr>\n<td>Visual Studio IntelliCode</td>\n<td style=\"text-align:left\">补全代码；非常有用。</td>\n</tr>\n<tr>\n<td>remote development</td>\n<td style=\"text-align:left\">远程连接服务器等。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>其他涉及某项语言的插件，可以在用到的时候直接查找即可，甚至微信小程序、VUE、Django、ROS等也有插件可用。</p>\n<h2 id=\"2-协同-Anaconda-Prompt\"><a href=\"#2-协同-Anaconda-Prompt\" class=\"headerlink\" title=\"2. 协同 Anaconda Prompt\"></a>2. 协同 Anaconda Prompt</h2><p>在VSCode中使用Anaconda Prompt的虚拟终端，能够方便地配置好python调试环境等内容</p>\n<p>（就可以脱离Anaconda Prompt的束缚了）</p>\n<p>打开设置：</p>\n<h3 id=\"修改方案一：【勉强实现conda的调用】\"><a href=\"#修改方案一：【勉强实现conda的调用】\" class=\"headerlink\" title=\"修改方案一：【勉强实现conda的调用】\"></a>修改方案一：【勉强实现conda的调用】</h3><p>主要是修改以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"python.pythonPath\"</span>: <span class=\"string\">\"C:\\\\ProgramData\\\\Anaconda3\\\\python.exe\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"terminal.integrated.automationShell.windows\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"terminal.integrated.shell.windows\"</span>: <span class=\"string\">\"\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参考：[<a href=\"https://blog.csdn.net/Add_a_cat/article/details/101051759\" target=\"_blank\" rel=\"noopener\">在vscode中打开conda的虚拟终端</a>]</p>\n</blockquote>\n<p>这是一种相对简单的方法，只需要修改配置，就可以进行使用。</p>\n<p><strong>缺点：</strong>目前发现这样的修改后，conda只能进入base环境，而不能进入其他环境，不利于使用</p>\n<h3 id=\"修改方案二：【conda完美调用】\"><a href=\"#修改方案二：【conda完美调用】\" class=\"headerlink\" title=\"修改方案二：【conda完美调用】\"></a>修改方案二：【conda完美调用】</h3><p>首先，修改环境变量，使得能够直接在windows终端（cmd）中直接调用</p>\n<p>【注意在conda官方看来，将conda命令加入环境变量是有风险的】</p>\n<p>在path（我的电脑-属性-环境变量-系统变量）中，添加anaconda和script的地址，可以打开anaconda prompt输入path直接进行查看</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/yelly0/article/details/88426076\" target=\"_blank\" rel=\"noopener\">综合处理 ‘conda’ 不是内部或外部命令,也不是可运行的程序 或批处理文件。</a></p>\n</blockquote>\n<p>然后，将VSCode的<code>terminal</code>地址改为<code>cmd</code>，这样就可以像在<code>cmd</code>中一样使用<code>conda</code>了</p>\n<p>【注意：不能直接改成anaconda prompt，原因是不支持，或者说anaconda prompt本身的底层就是cmd】</p>\n<p>打开设置，搜索<code>shell</code></p>\n<p>主要修改<code>Terminal&gt;Intergrated&gt;Shell:Windows</code></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201105093651583.png\" alt=\"image-20201105093651583\"></p>\n<p>打开<code>settings.json</code></p>\n<p>修改<code>&quot;terminal.integrated.shell.windows&quot;: &quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;,</code></p>\n<p>重新打开vscode，然后再打开终端就可以使用了【如果不重新打开，可能会报一点问题】</p>\n<p>注意不要添加<code>&quot;terminal.integrated.shellArgs.windows&quot;</code>项，该项也有可能对终端产生一定的影响</p>\n<h2 id=\"3-其他工具\"><a href=\"#3-其他工具\" class=\"headerlink\" title=\"3. 其他工具\"></a>3. 其他工具</h2><h3 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h3><p>结合gitlens的使用，比Git terminal更快一步。</p>\n<p>前提：认真配置好Git环境，可参考菜鸟教程关于Git的介绍。</p>\n<h3 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h3><p>推荐插件：<code>remote development</code></p>\n<p>实现对服务器的远程控制，注意第一次启动时需要对用户名等内容进行一点设置。</p>\n<p><em>参考：[<a href=\"https://blog.csdn.net/weixin_40373708/article/details/90376258\" target=\"_blank\" rel=\"noopener\">使用remote</a>]</em></p>\n<p>此外，正常情况下，每次打开新文件夹需要再次输入密码，确实有点麻烦，还可以配置一下ssh-keygen，减少密码输入。</p>\n<p><em>参考：[<a href=\"https://blog.csdn.net/qq_43143808/article/details/106765470?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase\" target=\"_blank\" rel=\"noopener\">ssh-keygen</a>]</em></p>\n<h3 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h3><p>工作区的使用不完全手册</p>\n<p>可以把文件夹添加到工作区</p>\n<p>选择：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200812151444206.png\" alt=\"image-20200812151444206\"></p>\n<p>即可在工作区中同时打开两个文件夹了</p>\n","site":{"data":{}},"excerpt":"<p><strong>VScode是强大的代码编辑器</strong>，用一些小技巧重新认识它：</p>\n<h2 id=\"1-开胃菜\"><a href=\"#1-开胃菜\" class=\"headerlink\" title=\"1. 开胃菜\"></a>1. 开胃菜</h2><p>调出命令行：<strong>按 ctrl + shift + p</strong></p>\n<p>设置页面：</p>\n<ul>\n<li>点击左下方设置按钮查询设置内容</li>\n<li>在设置界面中，会有部分设置内容下方 给出 settings.json 文件</li>\n</ul>","more":"<p>推荐插件：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>插件</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bracket Pair Colorizer</td>\n<td style=\"text-align:left\">让每一对括号有自己的颜色；括号越来越多的时候很有用。</td>\n</tr>\n<tr>\n<td>vscode-icon</td>\n<td style=\"text-align:left\">不同文件根据代码加图标；增加一点色彩。</td>\n</tr>\n<tr>\n<td>Visual Studio IntelliCode</td>\n<td style=\"text-align:left\">补全代码；非常有用。</td>\n</tr>\n<tr>\n<td>remote development</td>\n<td style=\"text-align:left\">远程连接服务器等。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>其他涉及某项语言的插件，可以在用到的时候直接查找即可，甚至微信小程序、VUE、Django、ROS等也有插件可用。</p>\n<h2 id=\"2-协同-Anaconda-Prompt\"><a href=\"#2-协同-Anaconda-Prompt\" class=\"headerlink\" title=\"2. 协同 Anaconda Prompt\"></a>2. 协同 Anaconda Prompt</h2><p>在VSCode中使用Anaconda Prompt的虚拟终端，能够方便地配置好python调试环境等内容</p>\n<p>（就可以脱离Anaconda Prompt的束缚了）</p>\n<p>打开设置：</p>\n<h3 id=\"修改方案一：【勉强实现conda的调用】\"><a href=\"#修改方案一：【勉强实现conda的调用】\" class=\"headerlink\" title=\"修改方案一：【勉强实现conda的调用】\"></a>修改方案一：【勉强实现conda的调用】</h3><p>主要是修改以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"python.pythonPath\"</span>: <span class=\"string\">\"C:\\\\ProgramData\\\\Anaconda3\\\\python.exe\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"terminal.integrated.automationShell.windows\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"terminal.integrated.shell.windows\"</span>: <span class=\"string\">\"\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参考：[<a href=\"https://blog.csdn.net/Add_a_cat/article/details/101051759\" target=\"_blank\" rel=\"noopener\">在vscode中打开conda的虚拟终端</a>]</p>\n</blockquote>\n<p>这是一种相对简单的方法，只需要修改配置，就可以进行使用。</p>\n<p><strong>缺点：</strong>目前发现这样的修改后，conda只能进入base环境，而不能进入其他环境，不利于使用</p>\n<h3 id=\"修改方案二：【conda完美调用】\"><a href=\"#修改方案二：【conda完美调用】\" class=\"headerlink\" title=\"修改方案二：【conda完美调用】\"></a>修改方案二：【conda完美调用】</h3><p>首先，修改环境变量，使得能够直接在windows终端（cmd）中直接调用</p>\n<p>【注意在conda官方看来，将conda命令加入环境变量是有风险的】</p>\n<p>在path（我的电脑-属性-环境变量-系统变量）中，添加anaconda和script的地址，可以打开anaconda prompt输入path直接进行查看</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/yelly0/article/details/88426076\" target=\"_blank\" rel=\"noopener\">综合处理 ‘conda’ 不是内部或外部命令,也不是可运行的程序 或批处理文件。</a></p>\n</blockquote>\n<p>然后，将VSCode的<code>terminal</code>地址改为<code>cmd</code>，这样就可以像在<code>cmd</code>中一样使用<code>conda</code>了</p>\n<p>【注意：不能直接改成anaconda prompt，原因是不支持，或者说anaconda prompt本身的底层就是cmd】</p>\n<p>打开设置，搜索<code>shell</code></p>\n<p>主要修改<code>Terminal&gt;Intergrated&gt;Shell:Windows</code></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201105093651583.png\" alt=\"image-20201105093651583\"></p>\n<p>打开<code>settings.json</code></p>\n<p>修改<code>&quot;terminal.integrated.shell.windows&quot;: &quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;,</code></p>\n<p>重新打开vscode，然后再打开终端就可以使用了【如果不重新打开，可能会报一点问题】</p>\n<p>注意不要添加<code>&quot;terminal.integrated.shellArgs.windows&quot;</code>项，该项也有可能对终端产生一定的影响</p>\n<h2 id=\"3-其他工具\"><a href=\"#3-其他工具\" class=\"headerlink\" title=\"3. 其他工具\"></a>3. 其他工具</h2><h3 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h3><p>结合gitlens的使用，比Git terminal更快一步。</p>\n<p>前提：认真配置好Git环境，可参考菜鸟教程关于Git的介绍。</p>\n<h3 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h3><p>推荐插件：<code>remote development</code></p>\n<p>实现对服务器的远程控制，注意第一次启动时需要对用户名等内容进行一点设置。</p>\n<p><em>参考：[<a href=\"https://blog.csdn.net/weixin_40373708/article/details/90376258\" target=\"_blank\" rel=\"noopener\">使用remote</a>]</em></p>\n<p>此外，正常情况下，每次打开新文件夹需要再次输入密码，确实有点麻烦，还可以配置一下ssh-keygen，减少密码输入。</p>\n<p><em>参考：[<a href=\"https://blog.csdn.net/qq_43143808/article/details/106765470?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase\" target=\"_blank\" rel=\"noopener\">ssh-keygen</a>]</em></p>\n<h3 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h3><p>工作区的使用不完全手册</p>\n<p>可以把文件夹添加到工作区</p>\n<p>选择：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200812151444206.png\" alt=\"image-20200812151444206\"></p>\n<p>即可在工作区中同时打开两个文件夹了</p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-07-26T06:37:22.037Z","updated":"2020-07-26T06:37:22.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n881000fk8tla1lu5zd9","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"华为云无人车参赛笔记三","date":"2020-09-30T01:31:01.000Z","_content":"\n关于华为云无人车大赛，第一篇笔记记录主要知识和技术点， 第二篇笔记记录调试思路和过程，本篇主要记录赛后的反思，包括半决赛和决赛。\n\n<!--more-->\n\n## 赛后反思\n\n### 半决赛\n\n半决赛中，博主所在的队伍表现尚可，第一场碰撞两次挡板，但是得以完赛；第二场中无碰撞、无压线，仅超时7s，是博主全部比赛中的最好成绩。\n\n总结半决赛问题，挡板的碰撞主要都出现在左转弯的半圈，也就是说左转弯的转弯半径调整不到位。\n\n博主针对转弯半径的调节比较保守，主张在不修改“从像素目标点到真实目标点”的基础上进行修改，主要修改之处有：\n\n- 转向系数 k\n- 偏移量 loR\n- 透视变换矩阵 M\n\n在一定范围内增加k值，可以让小车转弯半径变小，更快、更猛地转弯；\n\n改变偏移量（注意正负号），可以在转弯半径不变的情况下，调整小车与边线的距离；\n\n透视变换矩阵的改动是最大的改动，一般来说选择一个能够合理转换车道线的透视变换即可，好的透视变换应保证把梯形图片两边映射为直线，本比赛中，透视变换能时刻保证视野中有一条车道线即可。\n\n赛后再观察，以上修改只有透视变换的修改稍微触动根本，其他修改都是调参，足够长的时间和稳定的赛道，就可以调整出一个比较稳定的参数来。\n\n调参过程中发现，由于修改后的透视变换更适应右转车道线（转向平稳），而不适应左转车道线（原因之一是斑马线干扰），所以主要精力针对左转半圈。\n\n左转半圈常见问题：\n\n- 起步后压右线 - 可能是转角不够大，也可能偏移不够\n- 压右线后猛向左转，压或者出左线 - 转角过大，右车道线超出视野\n- 过斑马线后压右线 - 偏移不够\n- 左转弯进挡板撞右侧挡板 - 偏移不够\n\n但是在尽可能地调整转角和偏移量后，小车还是可能压线、撞挡板等，此时转角和偏移量的调整已经不起作用了，根本问题还是视觉检测车道线的问题，小车根本就没有按照车道线运动！\n\n一种投机取巧的方法是限幅，左转半径1.5米时大约使用32的转角可以实现比较平滑的转向，因此，将转弯幅度限制在25-40之间，可以取得比较好的效果。给转角提供一定的调整余地，有利于其自身调整，如果使用固定角度，可能无法跑完全部。【本方法有较大的局限性】\n\n半决赛中令人鼓舞的一点是验证了提速的可能性，因为之前上限只能到15，但是我们在工程师的引导下，去掉了蓝牙部分，速度成功提高到了25，决赛中一度按照30进行测试，也没有出现问题。\n\n### 决赛\n\n决赛的关键问题是赛场环境变了：\n\n- 灯光变得更亮\n- 赛道地毯反光更严重\n\n导致的问题有：\n\n- 按照原先的二值化阈值（125，分割0-255之间的数值）不能仅保留车道线，白色噪点增加\n- 容易误识别红绿黄灯\n- 雷达检测点数有变动\n\n半决赛及之前使用的保守方法，问题就在于不能很好地适应环境，以上环境变动之所以会影响完赛，原因有：\n\n- 车道线图片中白色面积增加，无法成功识别出车道线，因此起步后的转角会加大，出右车道线\n- 红绿黄灯的误识别是第二次没有完赛的关键原因\n- 本队所确定的入十字的标准是：1. 白色像素点比例小于某个数值，2. 雷达点数大于某个阈值（单侧或者双侧），因此，光线的改变和环境的改变，影响了入十字的参数，但是现场提供的调试时间完全不足以调参到位\n\n决赛三场全部未能完赛，实在是非常遗憾！\n\n- 第一场：二值化阈值未调整，转弯半径过大\n- 第二场：入十字碰右挡板两次，最后一次斑马线起步后误识别黄灯\n- 第三场：碰右挡板两次，碰左挡板1次\n\n## 总结\n\n仅通过参数调节以适应赛道的方法面对如本次决赛中环境变换的情况会很糟糕，亟待探索鲁棒性更好的方法。\n\n减少判断条件，尤其是依赖赛道环境的判断条件。\n\n增加自适应的变化调节，比如不是定值，而是不断地微调。","source":"_posts/华为云无人车参赛笔记三.md","raw":"---\ntitle: 华为云无人车参赛笔记三\ndate: 2020-09-30 09:31:01\ncategories:\n\t- [机器视觉]\ntags:\n\t- OpenCV\n\t- 华为云无人车\n\t- ROS\n---\n\n关于华为云无人车大赛，第一篇笔记记录主要知识和技术点， 第二篇笔记记录调试思路和过程，本篇主要记录赛后的反思，包括半决赛和决赛。\n\n<!--more-->\n\n## 赛后反思\n\n### 半决赛\n\n半决赛中，博主所在的队伍表现尚可，第一场碰撞两次挡板，但是得以完赛；第二场中无碰撞、无压线，仅超时7s，是博主全部比赛中的最好成绩。\n\n总结半决赛问题，挡板的碰撞主要都出现在左转弯的半圈，也就是说左转弯的转弯半径调整不到位。\n\n博主针对转弯半径的调节比较保守，主张在不修改“从像素目标点到真实目标点”的基础上进行修改，主要修改之处有：\n\n- 转向系数 k\n- 偏移量 loR\n- 透视变换矩阵 M\n\n在一定范围内增加k值，可以让小车转弯半径变小，更快、更猛地转弯；\n\n改变偏移量（注意正负号），可以在转弯半径不变的情况下，调整小车与边线的距离；\n\n透视变换矩阵的改动是最大的改动，一般来说选择一个能够合理转换车道线的透视变换即可，好的透视变换应保证把梯形图片两边映射为直线，本比赛中，透视变换能时刻保证视野中有一条车道线即可。\n\n赛后再观察，以上修改只有透视变换的修改稍微触动根本，其他修改都是调参，足够长的时间和稳定的赛道，就可以调整出一个比较稳定的参数来。\n\n调参过程中发现，由于修改后的透视变换更适应右转车道线（转向平稳），而不适应左转车道线（原因之一是斑马线干扰），所以主要精力针对左转半圈。\n\n左转半圈常见问题：\n\n- 起步后压右线 - 可能是转角不够大，也可能偏移不够\n- 压右线后猛向左转，压或者出左线 - 转角过大，右车道线超出视野\n- 过斑马线后压右线 - 偏移不够\n- 左转弯进挡板撞右侧挡板 - 偏移不够\n\n但是在尽可能地调整转角和偏移量后，小车还是可能压线、撞挡板等，此时转角和偏移量的调整已经不起作用了，根本问题还是视觉检测车道线的问题，小车根本就没有按照车道线运动！\n\n一种投机取巧的方法是限幅，左转半径1.5米时大约使用32的转角可以实现比较平滑的转向，因此，将转弯幅度限制在25-40之间，可以取得比较好的效果。给转角提供一定的调整余地，有利于其自身调整，如果使用固定角度，可能无法跑完全部。【本方法有较大的局限性】\n\n半决赛中令人鼓舞的一点是验证了提速的可能性，因为之前上限只能到15，但是我们在工程师的引导下，去掉了蓝牙部分，速度成功提高到了25，决赛中一度按照30进行测试，也没有出现问题。\n\n### 决赛\n\n决赛的关键问题是赛场环境变了：\n\n- 灯光变得更亮\n- 赛道地毯反光更严重\n\n导致的问题有：\n\n- 按照原先的二值化阈值（125，分割0-255之间的数值）不能仅保留车道线，白色噪点增加\n- 容易误识别红绿黄灯\n- 雷达检测点数有变动\n\n半决赛及之前使用的保守方法，问题就在于不能很好地适应环境，以上环境变动之所以会影响完赛，原因有：\n\n- 车道线图片中白色面积增加，无法成功识别出车道线，因此起步后的转角会加大，出右车道线\n- 红绿黄灯的误识别是第二次没有完赛的关键原因\n- 本队所确定的入十字的标准是：1. 白色像素点比例小于某个数值，2. 雷达点数大于某个阈值（单侧或者双侧），因此，光线的改变和环境的改变，影响了入十字的参数，但是现场提供的调试时间完全不足以调参到位\n\n决赛三场全部未能完赛，实在是非常遗憾！\n\n- 第一场：二值化阈值未调整，转弯半径过大\n- 第二场：入十字碰右挡板两次，最后一次斑马线起步后误识别黄灯\n- 第三场：碰右挡板两次，碰左挡板1次\n\n## 总结\n\n仅通过参数调节以适应赛道的方法面对如本次决赛中环境变换的情况会很糟糕，亟待探索鲁棒性更好的方法。\n\n减少判断条件，尤其是依赖赛道环境的判断条件。\n\n增加自适应的变化调节，比如不是定值，而是不断地微调。","slug":"华为云无人车参赛笔记三","published":1,"updated":"2021-01-26T06:22:37.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n883000hk8tl1ewh1oxk","content":"<p>关于华为云无人车大赛，第一篇笔记记录主要知识和技术点， 第二篇笔记记录调试思路和过程，本篇主要记录赛后的反思，包括半决赛和决赛。</p>\n<a id=\"more\"></a>\n<h2 id=\"赛后反思\"><a href=\"#赛后反思\" class=\"headerlink\" title=\"赛后反思\"></a>赛后反思</h2><h3 id=\"半决赛\"><a href=\"#半决赛\" class=\"headerlink\" title=\"半决赛\"></a>半决赛</h3><p>半决赛中，博主所在的队伍表现尚可，第一场碰撞两次挡板，但是得以完赛；第二场中无碰撞、无压线，仅超时7s，是博主全部比赛中的最好成绩。</p>\n<p>总结半决赛问题，挡板的碰撞主要都出现在左转弯的半圈，也就是说左转弯的转弯半径调整不到位。</p>\n<p>博主针对转弯半径的调节比较保守，主张在不修改“从像素目标点到真实目标点”的基础上进行修改，主要修改之处有：</p>\n<ul>\n<li>转向系数 k</li>\n<li>偏移量 loR</li>\n<li>透视变换矩阵 M</li>\n</ul>\n<p>在一定范围内增加k值，可以让小车转弯半径变小，更快、更猛地转弯；</p>\n<p>改变偏移量（注意正负号），可以在转弯半径不变的情况下，调整小车与边线的距离；</p>\n<p>透视变换矩阵的改动是最大的改动，一般来说选择一个能够合理转换车道线的透视变换即可，好的透视变换应保证把梯形图片两边映射为直线，本比赛中，透视变换能时刻保证视野中有一条车道线即可。</p>\n<p>赛后再观察，以上修改只有透视变换的修改稍微触动根本，其他修改都是调参，足够长的时间和稳定的赛道，就可以调整出一个比较稳定的参数来。</p>\n<p>调参过程中发现，由于修改后的透视变换更适应右转车道线（转向平稳），而不适应左转车道线（原因之一是斑马线干扰），所以主要精力针对左转半圈。</p>\n<p>左转半圈常见问题：</p>\n<ul>\n<li>起步后压右线 - 可能是转角不够大，也可能偏移不够</li>\n<li>压右线后猛向左转，压或者出左线 - 转角过大，右车道线超出视野</li>\n<li>过斑马线后压右线 - 偏移不够</li>\n<li>左转弯进挡板撞右侧挡板 - 偏移不够</li>\n</ul>\n<p>但是在尽可能地调整转角和偏移量后，小车还是可能压线、撞挡板等，此时转角和偏移量的调整已经不起作用了，根本问题还是视觉检测车道线的问题，小车根本就没有按照车道线运动！</p>\n<p>一种投机取巧的方法是限幅，左转半径1.5米时大约使用32的转角可以实现比较平滑的转向，因此，将转弯幅度限制在25-40之间，可以取得比较好的效果。给转角提供一定的调整余地，有利于其自身调整，如果使用固定角度，可能无法跑完全部。【本方法有较大的局限性】</p>\n<p>半决赛中令人鼓舞的一点是验证了提速的可能性，因为之前上限只能到15，但是我们在工程师的引导下，去掉了蓝牙部分，速度成功提高到了25，决赛中一度按照30进行测试，也没有出现问题。</p>\n<h3 id=\"决赛\"><a href=\"#决赛\" class=\"headerlink\" title=\"决赛\"></a>决赛</h3><p>决赛的关键问题是赛场环境变了：</p>\n<ul>\n<li>灯光变得更亮</li>\n<li>赛道地毯反光更严重</li>\n</ul>\n<p>导致的问题有：</p>\n<ul>\n<li>按照原先的二值化阈值（125，分割0-255之间的数值）不能仅保留车道线，白色噪点增加</li>\n<li>容易误识别红绿黄灯</li>\n<li>雷达检测点数有变动</li>\n</ul>\n<p>半决赛及之前使用的保守方法，问题就在于不能很好地适应环境，以上环境变动之所以会影响完赛，原因有：</p>\n<ul>\n<li>车道线图片中白色面积增加，无法成功识别出车道线，因此起步后的转角会加大，出右车道线</li>\n<li>红绿黄灯的误识别是第二次没有完赛的关键原因</li>\n<li>本队所确定的入十字的标准是：1. 白色像素点比例小于某个数值，2. 雷达点数大于某个阈值（单侧或者双侧），因此，光线的改变和环境的改变，影响了入十字的参数，但是现场提供的调试时间完全不足以调参到位</li>\n</ul>\n<p>决赛三场全部未能完赛，实在是非常遗憾！</p>\n<ul>\n<li>第一场：二值化阈值未调整，转弯半径过大</li>\n<li>第二场：入十字碰右挡板两次，最后一次斑马线起步后误识别黄灯</li>\n<li>第三场：碰右挡板两次，碰左挡板1次</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>仅通过参数调节以适应赛道的方法面对如本次决赛中环境变换的情况会很糟糕，亟待探索鲁棒性更好的方法。</p>\n<p>减少判断条件，尤其是依赖赛道环境的判断条件。</p>\n<p>增加自适应的变化调节，比如不是定值，而是不断地微调。</p>\n","site":{"data":{}},"excerpt":"<p>关于华为云无人车大赛，第一篇笔记记录主要知识和技术点， 第二篇笔记记录调试思路和过程，本篇主要记录赛后的反思，包括半决赛和决赛。</p>","more":"<h2 id=\"赛后反思\"><a href=\"#赛后反思\" class=\"headerlink\" title=\"赛后反思\"></a>赛后反思</h2><h3 id=\"半决赛\"><a href=\"#半决赛\" class=\"headerlink\" title=\"半决赛\"></a>半决赛</h3><p>半决赛中，博主所在的队伍表现尚可，第一场碰撞两次挡板，但是得以完赛；第二场中无碰撞、无压线，仅超时7s，是博主全部比赛中的最好成绩。</p>\n<p>总结半决赛问题，挡板的碰撞主要都出现在左转弯的半圈，也就是说左转弯的转弯半径调整不到位。</p>\n<p>博主针对转弯半径的调节比较保守，主张在不修改“从像素目标点到真实目标点”的基础上进行修改，主要修改之处有：</p>\n<ul>\n<li>转向系数 k</li>\n<li>偏移量 loR</li>\n<li>透视变换矩阵 M</li>\n</ul>\n<p>在一定范围内增加k值，可以让小车转弯半径变小，更快、更猛地转弯；</p>\n<p>改变偏移量（注意正负号），可以在转弯半径不变的情况下，调整小车与边线的距离；</p>\n<p>透视变换矩阵的改动是最大的改动，一般来说选择一个能够合理转换车道线的透视变换即可，好的透视变换应保证把梯形图片两边映射为直线，本比赛中，透视变换能时刻保证视野中有一条车道线即可。</p>\n<p>赛后再观察，以上修改只有透视变换的修改稍微触动根本，其他修改都是调参，足够长的时间和稳定的赛道，就可以调整出一个比较稳定的参数来。</p>\n<p>调参过程中发现，由于修改后的透视变换更适应右转车道线（转向平稳），而不适应左转车道线（原因之一是斑马线干扰），所以主要精力针对左转半圈。</p>\n<p>左转半圈常见问题：</p>\n<ul>\n<li>起步后压右线 - 可能是转角不够大，也可能偏移不够</li>\n<li>压右线后猛向左转，压或者出左线 - 转角过大，右车道线超出视野</li>\n<li>过斑马线后压右线 - 偏移不够</li>\n<li>左转弯进挡板撞右侧挡板 - 偏移不够</li>\n</ul>\n<p>但是在尽可能地调整转角和偏移量后，小车还是可能压线、撞挡板等，此时转角和偏移量的调整已经不起作用了，根本问题还是视觉检测车道线的问题，小车根本就没有按照车道线运动！</p>\n<p>一种投机取巧的方法是限幅，左转半径1.5米时大约使用32的转角可以实现比较平滑的转向，因此，将转弯幅度限制在25-40之间，可以取得比较好的效果。给转角提供一定的调整余地，有利于其自身调整，如果使用固定角度，可能无法跑完全部。【本方法有较大的局限性】</p>\n<p>半决赛中令人鼓舞的一点是验证了提速的可能性，因为之前上限只能到15，但是我们在工程师的引导下，去掉了蓝牙部分，速度成功提高到了25，决赛中一度按照30进行测试，也没有出现问题。</p>\n<h3 id=\"决赛\"><a href=\"#决赛\" class=\"headerlink\" title=\"决赛\"></a>决赛</h3><p>决赛的关键问题是赛场环境变了：</p>\n<ul>\n<li>灯光变得更亮</li>\n<li>赛道地毯反光更严重</li>\n</ul>\n<p>导致的问题有：</p>\n<ul>\n<li>按照原先的二值化阈值（125，分割0-255之间的数值）不能仅保留车道线，白色噪点增加</li>\n<li>容易误识别红绿黄灯</li>\n<li>雷达检测点数有变动</li>\n</ul>\n<p>半决赛及之前使用的保守方法，问题就在于不能很好地适应环境，以上环境变动之所以会影响完赛，原因有：</p>\n<ul>\n<li>车道线图片中白色面积增加，无法成功识别出车道线，因此起步后的转角会加大，出右车道线</li>\n<li>红绿黄灯的误识别是第二次没有完赛的关键原因</li>\n<li>本队所确定的入十字的标准是：1. 白色像素点比例小于某个数值，2. 雷达点数大于某个阈值（单侧或者双侧），因此，光线的改变和环境的改变，影响了入十字的参数，但是现场提供的调试时间完全不足以调参到位</li>\n</ul>\n<p>决赛三场全部未能完赛，实在是非常遗憾！</p>\n<ul>\n<li>第一场：二值化阈值未调整，转弯半径过大</li>\n<li>第二场：入十字碰右挡板两次，最后一次斑马线起步后误识别黄灯</li>\n<li>第三场：碰右挡板两次，碰左挡板1次</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>仅通过参数调节以适应赛道的方法面对如本次决赛中环境变换的情况会很糟糕，亟待探索鲁棒性更好的方法。</p>\n<p>减少判断条件，尤其是依赖赛道环境的判断条件。</p>\n<p>增加自适应的变化调节，比如不是定值，而是不断地微调。</p>"},{"title":"思维工具-幕布","date":"2020-08-15T01:42:51.000Z","_content":"\n幕布是我目前使用的最多的思维工具。\n\n但是当朋友反问我为什么要使用ta的时候，又说不上来ta究竟有何妙处。\n\n<!--more-->\n\n# 思维导图\n\n## MindJet![MindJet](https://www.mindmanager.com/static/mm/images/mindjet-icon.png)\n\n- 最早接触的思维导图工具是 MindJet，**完全不免费**是废弃的主要原因。\n\n- **思维导图的图形化让整体看上去很漂亮**，但是类似MindJet这样分支需要点击添加，还需要考虑分支的形状，位置，强迫症更是怎么调整都不舒服，渐渐觉得并不是很适合**日常思维整理**，更适合在有知识储备的前提下做整体规划。\n\n## XMind\n\n同样的问题在类似的软件上也会存在，在寻找MindJet替代品的过程中，XMind自然少不了打探一番。\n\n- 同样是图形化的思维导图构建，XMind界面漂亮了许多，功能也更人性化，看上去确实有一款现代化软件的潜力，短短时间受到了实验室的一致好评。\n\n![XMind](https://s3.cn-north-1.amazonaws.com.cn/assets.xmind.cn/www/assets/images/home/home-combine@2x-5200e40e30.png)\n\n- XMind的关键优势是做到了好看。\n\n如果只有好看的条目式思维导图，可能新鲜感只有上手的一两天，但是加上鱼骨图、九宫格矩阵等等设计方法中的图形，新鲜感和创造性便直线上升。\n\n用户会考虑怎么样用某个图能更好地表达我的意思，而这个图又刚好是XMind提供的，甚至软件提供的比原本想的还要好。\n\n**图形化的思维导图巅峰至此，懒人思考重新占领我的头脑。**\n\n# 需求\n\n普通人的生活不都是项目，思维混乱的时候应该使用什么来**整理思维。**\n\n- 作为一个整理思维的工具，我需要的不是花里胡哨的界面，而是整理过后留下内容与脉络。\n\n- 还有同步，最好这个软件在Windows、安卓、IOS平台都有客户端，无缝衔接。尝试过OneNote之后你会明白这个功能似乎不是很容易，关键是做到轻快流畅。\n\n## Mindlen![Mindline](http://www.mindline.cn/res/icon.png)\n\n- 在考研的时候，接触到了这款软件，ta能在平板上使用，还可以在手机上看，可以分享链接，在微信的小程序中看。\n\n- 虽然是图形化的思维导图编写，但是ta为用户的操作自由度做了缩减，ta会自动安排某条分支的位置。你可以调整分支的顺序，但是如果想细节上把某条分支移动一点点，抱歉，不可以。\n\n这曾经是我想要的，**如果软件默认就能实现很美妙的排版，自然没有必要去手动调整了**。\n\n而且不需要下载手机应用，用小程序即可。当时的手机已经没有太多空间，这是一个需求。\n\n没想到的是，我居然真的认真使用了几个月，痛苦的几个月。\n\n这款软件最大的问题是卡顿。\n\n不知道是软件优化问题，还是思维导图太大，渲染时间增长，打开写好的思维导图会耗掉你试图新建一个导图的时间。当导图内容逐渐增多，一点拖动就会非常卡顿，实在是很糟糕的体验。\n\n## 幕布![mubu](https://mubu.com/asset/img/logo/logo_full-2738cd893d.png)\n\n我曾两次接触幕布，第一次接触，**简陋的外观，非图形化的思维导图编写**，让我果断删掉了ta。\n\n但是朋友圈中出现了一个漂亮、整齐的思维导图的身影，没想到这是幕布做的。\n\n再次接触，我已经不再依赖图形化的导图编辑界面，幕布的**大纲式编写**充分体现了思维导图的最高境界——**“极简”**。\n\n![mubuexample](https://mubu.com/asset/img/index/img_2-dc9ac451da.png)\n\n我试图思考：\n\n- 为什么要使用思维导图。\n\n- 为什么要自己调整分支。\n\n- 为什么幕布可以根据大纲安排分支。\n\n说到底就是**条目的层级**，去掉了图形的形式，你更需要专心于当前编辑的条目，你需要思考哪些内容在当前条目的层级之下。\n\n### 圆点 · \n\n每一个接触幕布的人都会注意到**圆点** **·** ，这是幕布的灵魂。\n\n不喜欢，从此离开；喜欢，无比认可。\n\n非常鲜明的特性。\n\n- **圆点所在的条目有种独特的魅力，让用户专注于所在的条目，而忽略其他**。\n\nta已经不是一个思维导图创作工具，而是**思维整理工具**。\n\n- 在编写前，你也许有许多混乱的语言，无法组织，在幕布，可以先写下第一条，然后缩进，编写相关内容，感觉不是这里，回到上一个层级，重新开始一个新条目。\n\n- 没有了图形化，你可能暂时看不清到底在第几层，但是你能清晰地看到下一层，并且确认，下一层依赖于这一层。\n\n- 等最后完工，点击导图，自然完成。\n\n### 像是编程\n\n习惯了python之后，回头来看，这种缩进的风格实在是像极了编程。\n\n很适合训练自己的思考，既天马行空，又条理分明。\n\n### 同步\n\n幕布的同步绝对是我见过最好的。\n\n得益于轻量化的编写方式，绝大多数情况下内容都是文字，可以添加一些图片，但不会太多，这样的内容不会很大，软件提供了免费的云，每个人可以创建不限量的笔记，即刻保存，就会在所有联网的客户端同步。这个体验比滴答清单的同步还要出色。\n\n# 最后\n\n幕布确实让我有一种思维整理的感觉，每当思维混乱，来此做一些笔记，至少会明白下一步应该做什么。\n\n幕布让我可以随意书写，不用思考这句话是不是合理、有用，想到什么就可以开始写，ta做到了一个笔记本应该做好的事。\n\n幕布专注于轻量化，公式仍然免谈，ta不是创作文章的最好工具，但是是思维整理的工具。\n\n听说 XMind 现在也可以用大纲的模式编写思维导图，感觉又前进了一步。","source":"_posts/思维工具-幕布.md","raw":"---\ntitle: 思维工具-幕布\ndate: 2020-08-15 09:42:51\ncategories:\n\t- Tools\ntags:\n\t- software\n---\n\n幕布是我目前使用的最多的思维工具。\n\n但是当朋友反问我为什么要使用ta的时候，又说不上来ta究竟有何妙处。\n\n<!--more-->\n\n# 思维导图\n\n## MindJet![MindJet](https://www.mindmanager.com/static/mm/images/mindjet-icon.png)\n\n- 最早接触的思维导图工具是 MindJet，**完全不免费**是废弃的主要原因。\n\n- **思维导图的图形化让整体看上去很漂亮**，但是类似MindJet这样分支需要点击添加，还需要考虑分支的形状，位置，强迫症更是怎么调整都不舒服，渐渐觉得并不是很适合**日常思维整理**，更适合在有知识储备的前提下做整体规划。\n\n## XMind\n\n同样的问题在类似的软件上也会存在，在寻找MindJet替代品的过程中，XMind自然少不了打探一番。\n\n- 同样是图形化的思维导图构建，XMind界面漂亮了许多，功能也更人性化，看上去确实有一款现代化软件的潜力，短短时间受到了实验室的一致好评。\n\n![XMind](https://s3.cn-north-1.amazonaws.com.cn/assets.xmind.cn/www/assets/images/home/home-combine@2x-5200e40e30.png)\n\n- XMind的关键优势是做到了好看。\n\n如果只有好看的条目式思维导图，可能新鲜感只有上手的一两天，但是加上鱼骨图、九宫格矩阵等等设计方法中的图形，新鲜感和创造性便直线上升。\n\n用户会考虑怎么样用某个图能更好地表达我的意思，而这个图又刚好是XMind提供的，甚至软件提供的比原本想的还要好。\n\n**图形化的思维导图巅峰至此，懒人思考重新占领我的头脑。**\n\n# 需求\n\n普通人的生活不都是项目，思维混乱的时候应该使用什么来**整理思维。**\n\n- 作为一个整理思维的工具，我需要的不是花里胡哨的界面，而是整理过后留下内容与脉络。\n\n- 还有同步，最好这个软件在Windows、安卓、IOS平台都有客户端，无缝衔接。尝试过OneNote之后你会明白这个功能似乎不是很容易，关键是做到轻快流畅。\n\n## Mindlen![Mindline](http://www.mindline.cn/res/icon.png)\n\n- 在考研的时候，接触到了这款软件，ta能在平板上使用，还可以在手机上看，可以分享链接，在微信的小程序中看。\n\n- 虽然是图形化的思维导图编写，但是ta为用户的操作自由度做了缩减，ta会自动安排某条分支的位置。你可以调整分支的顺序，但是如果想细节上把某条分支移动一点点，抱歉，不可以。\n\n这曾经是我想要的，**如果软件默认就能实现很美妙的排版，自然没有必要去手动调整了**。\n\n而且不需要下载手机应用，用小程序即可。当时的手机已经没有太多空间，这是一个需求。\n\n没想到的是，我居然真的认真使用了几个月，痛苦的几个月。\n\n这款软件最大的问题是卡顿。\n\n不知道是软件优化问题，还是思维导图太大，渲染时间增长，打开写好的思维导图会耗掉你试图新建一个导图的时间。当导图内容逐渐增多，一点拖动就会非常卡顿，实在是很糟糕的体验。\n\n## 幕布![mubu](https://mubu.com/asset/img/logo/logo_full-2738cd893d.png)\n\n我曾两次接触幕布，第一次接触，**简陋的外观，非图形化的思维导图编写**，让我果断删掉了ta。\n\n但是朋友圈中出现了一个漂亮、整齐的思维导图的身影，没想到这是幕布做的。\n\n再次接触，我已经不再依赖图形化的导图编辑界面，幕布的**大纲式编写**充分体现了思维导图的最高境界——**“极简”**。\n\n![mubuexample](https://mubu.com/asset/img/index/img_2-dc9ac451da.png)\n\n我试图思考：\n\n- 为什么要使用思维导图。\n\n- 为什么要自己调整分支。\n\n- 为什么幕布可以根据大纲安排分支。\n\n说到底就是**条目的层级**，去掉了图形的形式，你更需要专心于当前编辑的条目，你需要思考哪些内容在当前条目的层级之下。\n\n### 圆点 · \n\n每一个接触幕布的人都会注意到**圆点** **·** ，这是幕布的灵魂。\n\n不喜欢，从此离开；喜欢，无比认可。\n\n非常鲜明的特性。\n\n- **圆点所在的条目有种独特的魅力，让用户专注于所在的条目，而忽略其他**。\n\nta已经不是一个思维导图创作工具，而是**思维整理工具**。\n\n- 在编写前，你也许有许多混乱的语言，无法组织，在幕布，可以先写下第一条，然后缩进，编写相关内容，感觉不是这里，回到上一个层级，重新开始一个新条目。\n\n- 没有了图形化，你可能暂时看不清到底在第几层，但是你能清晰地看到下一层，并且确认，下一层依赖于这一层。\n\n- 等最后完工，点击导图，自然完成。\n\n### 像是编程\n\n习惯了python之后，回头来看，这种缩进的风格实在是像极了编程。\n\n很适合训练自己的思考，既天马行空，又条理分明。\n\n### 同步\n\n幕布的同步绝对是我见过最好的。\n\n得益于轻量化的编写方式，绝大多数情况下内容都是文字，可以添加一些图片，但不会太多，这样的内容不会很大，软件提供了免费的云，每个人可以创建不限量的笔记，即刻保存，就会在所有联网的客户端同步。这个体验比滴答清单的同步还要出色。\n\n# 最后\n\n幕布确实让我有一种思维整理的感觉，每当思维混乱，来此做一些笔记，至少会明白下一步应该做什么。\n\n幕布让我可以随意书写，不用思考这句话是不是合理、有用，想到什么就可以开始写，ta做到了一个笔记本应该做好的事。\n\n幕布专注于轻量化，公式仍然免谈，ta不是创作文章的最好工具，但是是思维整理的工具。\n\n听说 XMind 现在也可以用大纲的模式编写思维导图，感觉又前进了一步。","slug":"思维工具-幕布","published":1,"updated":"2021-01-26T06:24:58.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n884000mk8tl0qab7dfa","content":"<p>幕布是我目前使用的最多的思维工具。</p>\n<p>但是当朋友反问我为什么要使用ta的时候，又说不上来ta究竟有何妙处。</p>\n<a id=\"more\"></a>\n<h1 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h1><h2 id=\"MindJet\"><a href=\"#MindJet\" class=\"headerlink\" title=\"MindJet\"></a>MindJet<img src=\"https://www.mindmanager.com/static/mm/images/mindjet-icon.png\" alt=\"MindJet\"></h2><ul>\n<li><p>最早接触的思维导图工具是 MindJet，<strong>完全不免费</strong>是废弃的主要原因。</p>\n</li>\n<li><p><strong>思维导图的图形化让整体看上去很漂亮</strong>，但是类似MindJet这样分支需要点击添加，还需要考虑分支的形状，位置，强迫症更是怎么调整都不舒服，渐渐觉得并不是很适合<strong>日常思维整理</strong>，更适合在有知识储备的前提下做整体规划。</p>\n</li>\n</ul>\n<h2 id=\"XMind\"><a href=\"#XMind\" class=\"headerlink\" title=\"XMind\"></a>XMind</h2><p>同样的问题在类似的软件上也会存在，在寻找MindJet替代品的过程中，XMind自然少不了打探一番。</p>\n<ul>\n<li>同样是图形化的思维导图构建，XMind界面漂亮了许多，功能也更人性化，看上去确实有一款现代化软件的潜力，短短时间受到了实验室的一致好评。</li>\n</ul>\n<p><img src=\"https://s3.cn-north-1.amazonaws.com.cn/assets.xmind.cn/www/assets/images/home/home-combine@2x-5200e40e30.png\" alt=\"XMind\"></p>\n<ul>\n<li>XMind的关键优势是做到了好看。</li>\n</ul>\n<p>如果只有好看的条目式思维导图，可能新鲜感只有上手的一两天，但是加上鱼骨图、九宫格矩阵等等设计方法中的图形，新鲜感和创造性便直线上升。</p>\n<p>用户会考虑怎么样用某个图能更好地表达我的意思，而这个图又刚好是XMind提供的，甚至软件提供的比原本想的还要好。</p>\n<p><strong>图形化的思维导图巅峰至此，懒人思考重新占领我的头脑。</strong></p>\n<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>普通人的生活不都是项目，思维混乱的时候应该使用什么来<strong>整理思维。</strong></p>\n<ul>\n<li><p>作为一个整理思维的工具，我需要的不是花里胡哨的界面，而是整理过后留下内容与脉络。</p>\n</li>\n<li><p>还有同步，最好这个软件在Windows、安卓、IOS平台都有客户端，无缝衔接。尝试过OneNote之后你会明白这个功能似乎不是很容易，关键是做到轻快流畅。</p>\n</li>\n</ul>\n<h2 id=\"Mindlen\"><a href=\"#Mindlen\" class=\"headerlink\" title=\"Mindlen\"></a>Mindlen<img src=\"http://www.mindline.cn/res/icon.png\" alt=\"Mindline\"></h2><ul>\n<li><p>在考研的时候，接触到了这款软件，ta能在平板上使用，还可以在手机上看，可以分享链接，在微信的小程序中看。</p>\n</li>\n<li><p>虽然是图形化的思维导图编写，但是ta为用户的操作自由度做了缩减，ta会自动安排某条分支的位置。你可以调整分支的顺序，但是如果想细节上把某条分支移动一点点，抱歉，不可以。</p>\n</li>\n</ul>\n<p>这曾经是我想要的，<strong>如果软件默认就能实现很美妙的排版，自然没有必要去手动调整了</strong>。</p>\n<p>而且不需要下载手机应用，用小程序即可。当时的手机已经没有太多空间，这是一个需求。</p>\n<p>没想到的是，我居然真的认真使用了几个月，痛苦的几个月。</p>\n<p>这款软件最大的问题是卡顿。</p>\n<p>不知道是软件优化问题，还是思维导图太大，渲染时间增长，打开写好的思维导图会耗掉你试图新建一个导图的时间。当导图内容逐渐增多，一点拖动就会非常卡顿，实在是很糟糕的体验。</p>\n<h2 id=\"幕布\"><a href=\"#幕布\" class=\"headerlink\" title=\"幕布\"></a>幕布<img src=\"https://mubu.com/asset/img/logo/logo_full-2738cd893d.png\" alt=\"mubu\"></h2><p>我曾两次接触幕布，第一次接触，<strong>简陋的外观，非图形化的思维导图编写</strong>，让我果断删掉了ta。</p>\n<p>但是朋友圈中出现了一个漂亮、整齐的思维导图的身影，没想到这是幕布做的。</p>\n<p>再次接触，我已经不再依赖图形化的导图编辑界面，幕布的<strong>大纲式编写</strong>充分体现了思维导图的最高境界——<strong>“极简”</strong>。</p>\n<p><img src=\"https://mubu.com/asset/img/index/img_2-dc9ac451da.png\" alt=\"mubuexample\"></p>\n<p>我试图思考：</p>\n<ul>\n<li><p>为什么要使用思维导图。</p>\n</li>\n<li><p>为什么要自己调整分支。</p>\n</li>\n<li><p>为什么幕布可以根据大纲安排分支。</p>\n</li>\n</ul>\n<p>说到底就是<strong>条目的层级</strong>，去掉了图形的形式，你更需要专心于当前编辑的条目，你需要思考哪些内容在当前条目的层级之下。</p>\n<h3 id=\"圆点-·\"><a href=\"#圆点-·\" class=\"headerlink\" title=\"圆点 ·\"></a>圆点 ·</h3><p>每一个接触幕布的人都会注意到<strong>圆点</strong> <strong>·</strong> ，这是幕布的灵魂。</p>\n<p>不喜欢，从此离开；喜欢，无比认可。</p>\n<p>非常鲜明的特性。</p>\n<ul>\n<li><strong>圆点所在的条目有种独特的魅力，让用户专注于所在的条目，而忽略其他</strong>。</li>\n</ul>\n<p>ta已经不是一个思维导图创作工具，而是<strong>思维整理工具</strong>。</p>\n<ul>\n<li><p>在编写前，你也许有许多混乱的语言，无法组织，在幕布，可以先写下第一条，然后缩进，编写相关内容，感觉不是这里，回到上一个层级，重新开始一个新条目。</p>\n</li>\n<li><p>没有了图形化，你可能暂时看不清到底在第几层，但是你能清晰地看到下一层，并且确认，下一层依赖于这一层。</p>\n</li>\n<li><p>等最后完工，点击导图，自然完成。</p>\n</li>\n</ul>\n<h3 id=\"像是编程\"><a href=\"#像是编程\" class=\"headerlink\" title=\"像是编程\"></a>像是编程</h3><p>习惯了python之后，回头来看，这种缩进的风格实在是像极了编程。</p>\n<p>很适合训练自己的思考，既天马行空，又条理分明。</p>\n<h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h3><p>幕布的同步绝对是我见过最好的。</p>\n<p>得益于轻量化的编写方式，绝大多数情况下内容都是文字，可以添加一些图片，但不会太多，这样的内容不会很大，软件提供了免费的云，每个人可以创建不限量的笔记，即刻保存，就会在所有联网的客户端同步。这个体验比滴答清单的同步还要出色。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>幕布确实让我有一种思维整理的感觉，每当思维混乱，来此做一些笔记，至少会明白下一步应该做什么。</p>\n<p>幕布让我可以随意书写，不用思考这句话是不是合理、有用，想到什么就可以开始写，ta做到了一个笔记本应该做好的事。</p>\n<p>幕布专注于轻量化，公式仍然免谈，ta不是创作文章的最好工具，但是是思维整理的工具。</p>\n<p>听说 XMind 现在也可以用大纲的模式编写思维导图，感觉又前进了一步。</p>\n","site":{"data":{}},"excerpt":"<p>幕布是我目前使用的最多的思维工具。</p>\n<p>但是当朋友反问我为什么要使用ta的时候，又说不上来ta究竟有何妙处。</p>","more":"<h1 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h1><h2 id=\"MindJet\"><a href=\"#MindJet\" class=\"headerlink\" title=\"MindJet\"></a>MindJet<img src=\"https://www.mindmanager.com/static/mm/images/mindjet-icon.png\" alt=\"MindJet\"></h2><ul>\n<li><p>最早接触的思维导图工具是 MindJet，<strong>完全不免费</strong>是废弃的主要原因。</p>\n</li>\n<li><p><strong>思维导图的图形化让整体看上去很漂亮</strong>，但是类似MindJet这样分支需要点击添加，还需要考虑分支的形状，位置，强迫症更是怎么调整都不舒服，渐渐觉得并不是很适合<strong>日常思维整理</strong>，更适合在有知识储备的前提下做整体规划。</p>\n</li>\n</ul>\n<h2 id=\"XMind\"><a href=\"#XMind\" class=\"headerlink\" title=\"XMind\"></a>XMind</h2><p>同样的问题在类似的软件上也会存在，在寻找MindJet替代品的过程中，XMind自然少不了打探一番。</p>\n<ul>\n<li>同样是图形化的思维导图构建，XMind界面漂亮了许多，功能也更人性化，看上去确实有一款现代化软件的潜力，短短时间受到了实验室的一致好评。</li>\n</ul>\n<p><img src=\"https://s3.cn-north-1.amazonaws.com.cn/assets.xmind.cn/www/assets/images/home/home-combine@2x-5200e40e30.png\" alt=\"XMind\"></p>\n<ul>\n<li>XMind的关键优势是做到了好看。</li>\n</ul>\n<p>如果只有好看的条目式思维导图，可能新鲜感只有上手的一两天，但是加上鱼骨图、九宫格矩阵等等设计方法中的图形，新鲜感和创造性便直线上升。</p>\n<p>用户会考虑怎么样用某个图能更好地表达我的意思，而这个图又刚好是XMind提供的，甚至软件提供的比原本想的还要好。</p>\n<p><strong>图形化的思维导图巅峰至此，懒人思考重新占领我的头脑。</strong></p>\n<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>普通人的生活不都是项目，思维混乱的时候应该使用什么来<strong>整理思维。</strong></p>\n<ul>\n<li><p>作为一个整理思维的工具，我需要的不是花里胡哨的界面，而是整理过后留下内容与脉络。</p>\n</li>\n<li><p>还有同步，最好这个软件在Windows、安卓、IOS平台都有客户端，无缝衔接。尝试过OneNote之后你会明白这个功能似乎不是很容易，关键是做到轻快流畅。</p>\n</li>\n</ul>\n<h2 id=\"Mindlen\"><a href=\"#Mindlen\" class=\"headerlink\" title=\"Mindlen\"></a>Mindlen<img src=\"http://www.mindline.cn/res/icon.png\" alt=\"Mindline\"></h2><ul>\n<li><p>在考研的时候，接触到了这款软件，ta能在平板上使用，还可以在手机上看，可以分享链接，在微信的小程序中看。</p>\n</li>\n<li><p>虽然是图形化的思维导图编写，但是ta为用户的操作自由度做了缩减，ta会自动安排某条分支的位置。你可以调整分支的顺序，但是如果想细节上把某条分支移动一点点，抱歉，不可以。</p>\n</li>\n</ul>\n<p>这曾经是我想要的，<strong>如果软件默认就能实现很美妙的排版，自然没有必要去手动调整了</strong>。</p>\n<p>而且不需要下载手机应用，用小程序即可。当时的手机已经没有太多空间，这是一个需求。</p>\n<p>没想到的是，我居然真的认真使用了几个月，痛苦的几个月。</p>\n<p>这款软件最大的问题是卡顿。</p>\n<p>不知道是软件优化问题，还是思维导图太大，渲染时间增长，打开写好的思维导图会耗掉你试图新建一个导图的时间。当导图内容逐渐增多，一点拖动就会非常卡顿，实在是很糟糕的体验。</p>\n<h2 id=\"幕布\"><a href=\"#幕布\" class=\"headerlink\" title=\"幕布\"></a>幕布<img src=\"https://mubu.com/asset/img/logo/logo_full-2738cd893d.png\" alt=\"mubu\"></h2><p>我曾两次接触幕布，第一次接触，<strong>简陋的外观，非图形化的思维导图编写</strong>，让我果断删掉了ta。</p>\n<p>但是朋友圈中出现了一个漂亮、整齐的思维导图的身影，没想到这是幕布做的。</p>\n<p>再次接触，我已经不再依赖图形化的导图编辑界面，幕布的<strong>大纲式编写</strong>充分体现了思维导图的最高境界——<strong>“极简”</strong>。</p>\n<p><img src=\"https://mubu.com/asset/img/index/img_2-dc9ac451da.png\" alt=\"mubuexample\"></p>\n<p>我试图思考：</p>\n<ul>\n<li><p>为什么要使用思维导图。</p>\n</li>\n<li><p>为什么要自己调整分支。</p>\n</li>\n<li><p>为什么幕布可以根据大纲安排分支。</p>\n</li>\n</ul>\n<p>说到底就是<strong>条目的层级</strong>，去掉了图形的形式，你更需要专心于当前编辑的条目，你需要思考哪些内容在当前条目的层级之下。</p>\n<h3 id=\"圆点-·\"><a href=\"#圆点-·\" class=\"headerlink\" title=\"圆点 ·\"></a>圆点 ·</h3><p>每一个接触幕布的人都会注意到<strong>圆点</strong> <strong>·</strong> ，这是幕布的灵魂。</p>\n<p>不喜欢，从此离开；喜欢，无比认可。</p>\n<p>非常鲜明的特性。</p>\n<ul>\n<li><strong>圆点所在的条目有种独特的魅力，让用户专注于所在的条目，而忽略其他</strong>。</li>\n</ul>\n<p>ta已经不是一个思维导图创作工具，而是<strong>思维整理工具</strong>。</p>\n<ul>\n<li><p>在编写前，你也许有许多混乱的语言，无法组织，在幕布，可以先写下第一条，然后缩进，编写相关内容，感觉不是这里，回到上一个层级，重新开始一个新条目。</p>\n</li>\n<li><p>没有了图形化，你可能暂时看不清到底在第几层，但是你能清晰地看到下一层，并且确认，下一层依赖于这一层。</p>\n</li>\n<li><p>等最后完工，点击导图，自然完成。</p>\n</li>\n</ul>\n<h3 id=\"像是编程\"><a href=\"#像是编程\" class=\"headerlink\" title=\"像是编程\"></a>像是编程</h3><p>习惯了python之后，回头来看，这种缩进的风格实在是像极了编程。</p>\n<p>很适合训练自己的思考，既天马行空，又条理分明。</p>\n<h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h3><p>幕布的同步绝对是我见过最好的。</p>\n<p>得益于轻量化的编写方式，绝大多数情况下内容都是文字，可以添加一些图片，但不会太多，这样的内容不会很大，软件提供了免费的云，每个人可以创建不限量的笔记，即刻保存，就会在所有联网的客户端同步。这个体验比滴答清单的同步还要出色。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>幕布确实让我有一种思维整理的感觉，每当思维混乱，来此做一些笔记，至少会明白下一步应该做什么。</p>\n<p>幕布让我可以随意书写，不用思考这句话是不是合理、有用，想到什么就可以开始写，ta做到了一个笔记本应该做好的事。</p>\n<p>幕布专注于轻量化，公式仍然免谈，ta不是创作文章的最好工具，但是是思维整理的工具。</p>\n<p>听说 XMind 现在也可以用大纲的模式编写思维导图，感觉又前进了一步。</p>"},{"title":"我的第一篇博客文章","date":"2020-07-26T06:39:43.000Z","_content":"\n# 凡是过往，皆为序章，博客从此开始\n\n<!--more-->\n\n## 内容规划\n\nROS与机器人\n\n视觉处理与神经网络\n\n数据分析\n\nweb开发\n\npython学习\n","source":"_posts/我的第一篇博客文章.md","raw":"---\ntitle: 我的第一篇博客文章\ndate: 2020-07-26 14:39:43\ntags:\n---\n\n# 凡是过往，皆为序章，博客从此开始\n\n<!--more-->\n\n## 内容规划\n\nROS与机器人\n\n视觉处理与神经网络\n\n数据分析\n\nweb开发\n\npython学习\n","slug":"我的第一篇博客文章","published":1,"updated":"2021-01-26T06:25:53.451Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n884000ok8tle95c50j2","content":"<h1 id=\"凡是过往，皆为序章，博客从此开始\"><a href=\"#凡是过往，皆为序章，博客从此开始\" class=\"headerlink\" title=\"凡是过往，皆为序章，博客从此开始\"></a>凡是过往，皆为序章，博客从此开始</h1><a id=\"more\"></a>\n<h2 id=\"内容规划\"><a href=\"#内容规划\" class=\"headerlink\" title=\"内容规划\"></a>内容规划</h2><p>ROS与机器人</p>\n<p>视觉处理与神经网络</p>\n<p>数据分析</p>\n<p>web开发</p>\n<p>python学习</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"凡是过往，皆为序章，博客从此开始\"><a href=\"#凡是过往，皆为序章，博客从此开始\" class=\"headerlink\" title=\"凡是过往，皆为序章，博客从此开始\"></a>凡是过往，皆为序章，博客从此开始</h1>","more":"<h2 id=\"内容规划\"><a href=\"#内容规划\" class=\"headerlink\" title=\"内容规划\"></a>内容规划</h2><p>ROS与机器人</p>\n<p>视觉处理与神经网络</p>\n<p>数据分析</p>\n<p>web开发</p>\n<p>python学习</p>"},{"title":"【数据】bookmarks的转化","date":"2020-08-08T01:41:13.000Z","_content":"\n假期归来，想把家里电脑上的收藏夹搬到笔记本电脑上，其实更好的方法是建一个账户同步，但是本着能麻烦绝不方便的原则，试一下另一种方法。\n\n## 思路\n\n- 浏览器导出收藏夹文件：Bookmarks，该文件格式为json\n- 从Bookmarks中找出网站名和网址，整理成一个表格文件\n- 对这个表格做一下词云分析，看一下究竟假期看了些什么，详见[【数据】词云分析初探](https://sunyoe.github.io/2020/08/02/数据-词云分析初探/)\n\n<!--more-->\n\n## 动手\n\n### 整理Bookmarks\n\n其实已经非常简单了，把握核心就是把 json 看成一个“大”字典。\n\n看一下原始内容：\n\n```json\n{\n   \"checksum\": \"ca7fb0d38496e7252c02db776f1f634a\",\n   \"roots\": {\n      \"bookmark_bar\": {\n         \"children\": [ {\n            \"date_added\": \"13199114198683132\",\n            \"guid\": \"e62ed638-a320-45be-9456-eb3490b55096\",\n            \"id\": \"5\",\n            \"meta_info\": {\n               \"last_visited_desktop\": \"13206982609994441\"\n            },\n            \"name\": \"百度\",\n            \"type\": \"url\",\n            \"url\": \"https://www.baidu.com/\"\n         }, {\n            \"children\": [ {\n               \"children\": [ {\n                  \"date_added\": \"13228716556104664\",\n                  \"guid\": \"2011bd3e-d3df-42ae-b9b8-27420da1deb5\",\n                  \"id\": \"62\",\n                  \"name\": \"常见问题解答-Covid-19，问题和解答\",\n                  \"type\": \"url\",\n                  \"url\": \"http://www.salute.gov.it/portale/nuovocoronavirus/dettaglioFaqNuovoCoronavirus.jsp?lingua=italiano&id=228#11\"\n               }],\n               \"date_added\": \"13231592490508714\",\n               \"date_modified\": \"13231599756212563\",\n               \"guid\": \"5d867818-cf41-45a2-ad6f-25600f590419\",\n               \"id\": \"105\",\n               \"name\": \"EBD项目\",\n               \"type\": \"folder\"\n            }...\n }\n```\n\n整体还是非常有规律的，对应到浏览器中就是大的收藏夹套内部分类收藏夹，收藏夹内还有文件夹，从type可以看到哪些是“url”。\n\n> 这里突然觉得自己的方法可能有点笨，用type的方法去分类也是一个不错的选择\n\n我的方法自然是使用字典+列表的索引来实现了，心得就是：\n\n- 字典直接根据 “key” 键的名字来索引：\n\n  ```python\n  bm_url_data['children']\n  ```\n\n- 列表则可以根据数字来索引：\n\n  ```python\n  bm_url_data[i]['children']\n  ```\n\n这种方法确实是非常的原始，因为Bookmarks中字典列表循环嵌套，要不断来回索引，除了部分文件夹中可以简单用循环来节省一下工作量，其他方面根本就没有省多少事。\n\n### 转为excel\n\n上面最终取出的url和网址分别组成列表，这样就得到了两个列表。\n\n将两个列表进行关联，并转入excel文件，用pandas实在是再好不过了！\n\n```python\nimport pandas as pd\nfrom pandas.core.frame import DataFrame\n\n# 先根据两个列表，生成bookmarks的字典\nbookmarks_dict = {'网站名': bm_name,\n                  'url' : bm_url}\n\n# 从bookmarks 生成 DataFrame数据\nbookmarks_fram = DataFrame(bookmarks_dict)\nprint(bookmarks_fram)\n\n# 最后直接将DataFrame数据转化到excel中\nbookmarks_fram.to_excel('./bookmarks.xlsx')\n```\n\n得益于完善的封装，以及DataFrame这一数据格式的独特优势，使用这种转换方法绝对是非常简洁。\n\n此外，还找到xlwt等python包，也可以实现数据写入excel，但是相对就要麻烦很多了。","source":"_posts/数据-bookmarks的转化.md","raw":"---\ntitle: 【数据】bookmarks的转化\ndate: 2020-08-08 09:41:13\ncategories:\n\t- Data Analysis\ntags:\n\t- json\n\t- Pandas\n\t- index\n---\n\n假期归来，想把家里电脑上的收藏夹搬到笔记本电脑上，其实更好的方法是建一个账户同步，但是本着能麻烦绝不方便的原则，试一下另一种方法。\n\n## 思路\n\n- 浏览器导出收藏夹文件：Bookmarks，该文件格式为json\n- 从Bookmarks中找出网站名和网址，整理成一个表格文件\n- 对这个表格做一下词云分析，看一下究竟假期看了些什么，详见[【数据】词云分析初探](https://sunyoe.github.io/2020/08/02/数据-词云分析初探/)\n\n<!--more-->\n\n## 动手\n\n### 整理Bookmarks\n\n其实已经非常简单了，把握核心就是把 json 看成一个“大”字典。\n\n看一下原始内容：\n\n```json\n{\n   \"checksum\": \"ca7fb0d38496e7252c02db776f1f634a\",\n   \"roots\": {\n      \"bookmark_bar\": {\n         \"children\": [ {\n            \"date_added\": \"13199114198683132\",\n            \"guid\": \"e62ed638-a320-45be-9456-eb3490b55096\",\n            \"id\": \"5\",\n            \"meta_info\": {\n               \"last_visited_desktop\": \"13206982609994441\"\n            },\n            \"name\": \"百度\",\n            \"type\": \"url\",\n            \"url\": \"https://www.baidu.com/\"\n         }, {\n            \"children\": [ {\n               \"children\": [ {\n                  \"date_added\": \"13228716556104664\",\n                  \"guid\": \"2011bd3e-d3df-42ae-b9b8-27420da1deb5\",\n                  \"id\": \"62\",\n                  \"name\": \"常见问题解答-Covid-19，问题和解答\",\n                  \"type\": \"url\",\n                  \"url\": \"http://www.salute.gov.it/portale/nuovocoronavirus/dettaglioFaqNuovoCoronavirus.jsp?lingua=italiano&id=228#11\"\n               }],\n               \"date_added\": \"13231592490508714\",\n               \"date_modified\": \"13231599756212563\",\n               \"guid\": \"5d867818-cf41-45a2-ad6f-25600f590419\",\n               \"id\": \"105\",\n               \"name\": \"EBD项目\",\n               \"type\": \"folder\"\n            }...\n }\n```\n\n整体还是非常有规律的，对应到浏览器中就是大的收藏夹套内部分类收藏夹，收藏夹内还有文件夹，从type可以看到哪些是“url”。\n\n> 这里突然觉得自己的方法可能有点笨，用type的方法去分类也是一个不错的选择\n\n我的方法自然是使用字典+列表的索引来实现了，心得就是：\n\n- 字典直接根据 “key” 键的名字来索引：\n\n  ```python\n  bm_url_data['children']\n  ```\n\n- 列表则可以根据数字来索引：\n\n  ```python\n  bm_url_data[i]['children']\n  ```\n\n这种方法确实是非常的原始，因为Bookmarks中字典列表循环嵌套，要不断来回索引，除了部分文件夹中可以简单用循环来节省一下工作量，其他方面根本就没有省多少事。\n\n### 转为excel\n\n上面最终取出的url和网址分别组成列表，这样就得到了两个列表。\n\n将两个列表进行关联，并转入excel文件，用pandas实在是再好不过了！\n\n```python\nimport pandas as pd\nfrom pandas.core.frame import DataFrame\n\n# 先根据两个列表，生成bookmarks的字典\nbookmarks_dict = {'网站名': bm_name,\n                  'url' : bm_url}\n\n# 从bookmarks 生成 DataFrame数据\nbookmarks_fram = DataFrame(bookmarks_dict)\nprint(bookmarks_fram)\n\n# 最后直接将DataFrame数据转化到excel中\nbookmarks_fram.to_excel('./bookmarks.xlsx')\n```\n\n得益于完善的封装，以及DataFrame这一数据格式的独特优势，使用这种转换方法绝对是非常简洁。\n\n此外，还找到xlwt等python包，也可以实现数据写入excel，但是相对就要麻烦很多了。","slug":"数据-bookmarks的转化","published":1,"updated":"2021-01-26T06:23:23.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n885000tk8tlfr2ngsj0","content":"<p>假期归来，想把家里电脑上的收藏夹搬到笔记本电脑上，其实更好的方法是建一个账户同步，但是本着能麻烦绝不方便的原则，试一下另一种方法。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li>浏览器导出收藏夹文件：Bookmarks，该文件格式为json</li>\n<li>从Bookmarks中找出网站名和网址，整理成一个表格文件</li>\n<li>对这个表格做一下词云分析，看一下究竟假期看了些什么，详见<a href=\"https://sunyoe.github.io/2020/08/02/数据-词云分析初探/\" target=\"_blank\" rel=\"noopener\">【数据】词云分析初探</a></li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"动手\"><a href=\"#动手\" class=\"headerlink\" title=\"动手\"></a>动手</h2><h3 id=\"整理Bookmarks\"><a href=\"#整理Bookmarks\" class=\"headerlink\" title=\"整理Bookmarks\"></a>整理Bookmarks</h3><p>其实已经非常简单了，把握核心就是把 json 看成一个“大”字典。</p>\n<p>看一下原始内容：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"checksum\"</span>: <span class=\"string\">\"ca7fb0d38496e7252c02db776f1f634a\"</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"roots\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"bookmark_bar\"</span>: &#123;</span><br><span class=\"line\">         <span class=\"attr\">\"children\"</span>: [ &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"date_added\"</span>: <span class=\"string\">\"13199114198683132\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"guid\"</span>: <span class=\"string\">\"e62ed638-a320-45be-9456-eb3490b55096\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"5\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"meta_info\"</span>: &#123;</span><br><span class=\"line\">               <span class=\"attr\">\"last_visited_desktop\"</span>: <span class=\"string\">\"13206982609994441\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"百度\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"url\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://www.baidu.com/\"</span></span><br><span class=\"line\">         &#125;, &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"children\"</span>: [ &#123;</span><br><span class=\"line\">               <span class=\"attr\">\"children\"</span>: [ &#123;</span><br><span class=\"line\">                  <span class=\"attr\">\"date_added\"</span>: <span class=\"string\">\"13228716556104664\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"guid\"</span>: <span class=\"string\">\"2011bd3e-d3df-42ae-b9b8-27420da1deb5\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"62\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"常见问题解答-Covid-19，问题和解答\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"url\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"http://www.salute.gov.it/portale/nuovocoronavirus/dettaglioFaqNuovoCoronavirus.jsp?lingua=italiano&amp;id=228#11\"</span></span><br><span class=\"line\">               &#125;],</span><br><span class=\"line\">               <span class=\"attr\">\"date_added\"</span>: <span class=\"string\">\"13231592490508714\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"date_modified\"</span>: <span class=\"string\">\"13231599756212563\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"guid\"</span>: <span class=\"string\">\"5d867818-cf41-45a2-ad6f-25600f590419\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"105\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"EBD项目\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"folder\"</span></span><br><span class=\"line\">            &#125;...</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>整体还是非常有规律的，对应到浏览器中就是大的收藏夹套内部分类收藏夹，收藏夹内还有文件夹，从type可以看到哪些是“url”。</p>\n<blockquote>\n<p>这里突然觉得自己的方法可能有点笨，用type的方法去分类也是一个不错的选择</p>\n</blockquote>\n<p>我的方法自然是使用字典+列表的索引来实现了，心得就是：</p>\n<ul>\n<li><p>字典直接根据 “key” 键的名字来索引：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bm_url_data[<span class=\"string\">'children'</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>列表则可以根据数字来索引：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bm_url_data[i][<span class=\"string\">'children'</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这种方法确实是非常的原始，因为Bookmarks中字典列表循环嵌套，要不断来回索引，除了部分文件夹中可以简单用循环来节省一下工作量，其他方面根本就没有省多少事。</p>\n<h3 id=\"转为excel\"><a href=\"#转为excel\" class=\"headerlink\" title=\"转为excel\"></a>转为excel</h3><p>上面最终取出的url和网址分别组成列表，这样就得到了两个列表。</p>\n<p>将两个列表进行关联，并转入excel文件，用pandas实在是再好不过了！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> pandas.core.frame <span class=\"keyword\">import</span> DataFrame</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先根据两个列表，生成bookmarks的字典</span></span><br><span class=\"line\">bookmarks_dict = &#123;<span class=\"string\">'网站名'</span>: bm_name,</span><br><span class=\"line\">                  <span class=\"string\">'url'</span> : bm_url&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从bookmarks 生成 DataFrame数据</span></span><br><span class=\"line\">bookmarks_fram = DataFrame(bookmarks_dict)</span><br><span class=\"line\">print(bookmarks_fram)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最后直接将DataFrame数据转化到excel中</span></span><br><span class=\"line\">bookmarks_fram.to_excel(<span class=\"string\">'./bookmarks.xlsx'</span>)</span><br></pre></td></tr></table></figure>\n<p>得益于完善的封装，以及DataFrame这一数据格式的独特优势，使用这种转换方法绝对是非常简洁。</p>\n<p>此外，还找到xlwt等python包，也可以实现数据写入excel，但是相对就要麻烦很多了。</p>\n","site":{"data":{}},"excerpt":"<p>假期归来，想把家里电脑上的收藏夹搬到笔记本电脑上，其实更好的方法是建一个账户同步，但是本着能麻烦绝不方便的原则，试一下另一种方法。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li>浏览器导出收藏夹文件：Bookmarks，该文件格式为json</li>\n<li>从Bookmarks中找出网站名和网址，整理成一个表格文件</li>\n<li>对这个表格做一下词云分析，看一下究竟假期看了些什么，详见<a href=\"https://sunyoe.github.io/2020/08/02/数据-词云分析初探/\" target=\"_blank\" rel=\"noopener\">【数据】词云分析初探</a></li>\n</ul>","more":"<h2 id=\"动手\"><a href=\"#动手\" class=\"headerlink\" title=\"动手\"></a>动手</h2><h3 id=\"整理Bookmarks\"><a href=\"#整理Bookmarks\" class=\"headerlink\" title=\"整理Bookmarks\"></a>整理Bookmarks</h3><p>其实已经非常简单了，把握核心就是把 json 看成一个“大”字典。</p>\n<p>看一下原始内容：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"checksum\"</span>: <span class=\"string\">\"ca7fb0d38496e7252c02db776f1f634a\"</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"roots\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"bookmark_bar\"</span>: &#123;</span><br><span class=\"line\">         <span class=\"attr\">\"children\"</span>: [ &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"date_added\"</span>: <span class=\"string\">\"13199114198683132\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"guid\"</span>: <span class=\"string\">\"e62ed638-a320-45be-9456-eb3490b55096\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"5\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"meta_info\"</span>: &#123;</span><br><span class=\"line\">               <span class=\"attr\">\"last_visited_desktop\"</span>: <span class=\"string\">\"13206982609994441\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"百度\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"url\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://www.baidu.com/\"</span></span><br><span class=\"line\">         &#125;, &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"children\"</span>: [ &#123;</span><br><span class=\"line\">               <span class=\"attr\">\"children\"</span>: [ &#123;</span><br><span class=\"line\">                  <span class=\"attr\">\"date_added\"</span>: <span class=\"string\">\"13228716556104664\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"guid\"</span>: <span class=\"string\">\"2011bd3e-d3df-42ae-b9b8-27420da1deb5\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"62\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"常见问题解答-Covid-19，问题和解答\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"url\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"http://www.salute.gov.it/portale/nuovocoronavirus/dettaglioFaqNuovoCoronavirus.jsp?lingua=italiano&amp;id=228#11\"</span></span><br><span class=\"line\">               &#125;],</span><br><span class=\"line\">               <span class=\"attr\">\"date_added\"</span>: <span class=\"string\">\"13231592490508714\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"date_modified\"</span>: <span class=\"string\">\"13231599756212563\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"guid\"</span>: <span class=\"string\">\"5d867818-cf41-45a2-ad6f-25600f590419\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"105\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"EBD项目\"</span>,</span><br><span class=\"line\">               <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"folder\"</span></span><br><span class=\"line\">            &#125;...</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>整体还是非常有规律的，对应到浏览器中就是大的收藏夹套内部分类收藏夹，收藏夹内还有文件夹，从type可以看到哪些是“url”。</p>\n<blockquote>\n<p>这里突然觉得自己的方法可能有点笨，用type的方法去分类也是一个不错的选择</p>\n</blockquote>\n<p>我的方法自然是使用字典+列表的索引来实现了，心得就是：</p>\n<ul>\n<li><p>字典直接根据 “key” 键的名字来索引：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bm_url_data[<span class=\"string\">'children'</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>列表则可以根据数字来索引：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bm_url_data[i][<span class=\"string\">'children'</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这种方法确实是非常的原始，因为Bookmarks中字典列表循环嵌套，要不断来回索引，除了部分文件夹中可以简单用循环来节省一下工作量，其他方面根本就没有省多少事。</p>\n<h3 id=\"转为excel\"><a href=\"#转为excel\" class=\"headerlink\" title=\"转为excel\"></a>转为excel</h3><p>上面最终取出的url和网址分别组成列表，这样就得到了两个列表。</p>\n<p>将两个列表进行关联，并转入excel文件，用pandas实在是再好不过了！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> pandas.core.frame <span class=\"keyword\">import</span> DataFrame</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先根据两个列表，生成bookmarks的字典</span></span><br><span class=\"line\">bookmarks_dict = &#123;<span class=\"string\">'网站名'</span>: bm_name,</span><br><span class=\"line\">                  <span class=\"string\">'url'</span> : bm_url&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从bookmarks 生成 DataFrame数据</span></span><br><span class=\"line\">bookmarks_fram = DataFrame(bookmarks_dict)</span><br><span class=\"line\">print(bookmarks_fram)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最后直接将DataFrame数据转化到excel中</span></span><br><span class=\"line\">bookmarks_fram.to_excel(<span class=\"string\">'./bookmarks.xlsx'</span>)</span><br></pre></td></tr></table></figure>\n<p>得益于完善的封装，以及DataFrame这一数据格式的独特优势，使用这种转换方法绝对是非常简洁。</p>\n<p>此外，还找到xlwt等python包，也可以实现数据写入excel，但是相对就要麻烦很多了。</p>"},{"title":"【数据】词云分析初探","date":"2020-08-02T01:29:55.000Z","_content":"\n词云可以对比文件中不同词汇出现的频率。\n\n就像这样：\n\n![WordCloudTest](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/WordCloudTest.png)\n\n<!--more-->\n\n用字体大小代表出现频率高低，非常直观的数据表现形式。\n\n> 需要的依赖包有：\n>\n> - wordcloud\n> - pandas，numpy，matplotlib\n> - jieba\n> - pathlib，PIL\n\n## 读取文件\n\n使用python读取文件需要根据不同文件格式进行尝试。\n\n例如，本文对一个xlsx文件（也就是excel文件）进行读取，查找资料会发现：\n\n- 可以使用传统包，例如：\n\n`from openpyxl import load_workbook`\n\n使用`load_workbook`函数进行读取。*参考：[Python读取xlsx文件](https://www.cnblogs.com/hui-shao/p/read_xlsx.html)*\n\n- 更好的方法可能是 Pandas：\n\n`pandas.read_excel(filename)`\n\n**值得注意的是 pandas 处理数据的格式。**\n\nPandas读取数据后，会转换为 **DataFrame**，这是一种表格行数据结构，既有行索引，又有列索引，合理使用会有奇效。\n\n> 参考：\n\n[Pandas-DataFrame基础知识点总结](https://www.jianshu.com/p/8024ceef4fe2)\n\n[Python利用pandas处理Excel数据的应用](https://www.cnblogs.com/liulinghua90/p/9935642.html)\n\n## 数据预处理\n\n不同数据的预处理方法不同，此处在上述处理后，获得了DataFrame数据，但是它还不能直接生成词云，理论上最直接的字符串是词云的最佳来源。\n\n![image-20200802095805871](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200802095805871.png)\n\n因此，我们需要把上面的DataFrame中的有效数据变成字符串。\n\n可以根据索引名（上图中的“网站名”，“url”）进行索引，读取值，并添加到列表中：\n\n`net_list = mytext['网站名'].values`\n\n然后再将列表转化为字符串，此处用空格连接两个值：\n\n`result = ' '.join(net_list)`\n\n这样就得到了我们想要的字符串数据。\n\n## 词云生成\n\n理论上，使用如下语句：\n\n```python\nmycloud = WordCloud().generate(result)\n%matplotlib inline\nplt.imshow(mycloud, interpolation = \"bilinear\")\nplt.axis(\"off\")\n```\n\n就可以生成词云，并作图，但是它的结果可能是类似这样的：\n\n![下载](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/下载.png)\n\n就是说只能显示英文，而不能显示中文，而且仔细观察还有一些很长串的方框，是因为没有把一句中文长句进行分词。\n\n因此，对于中文词云的实现，还需要进行分词，可以使用jieba分词：\n\n```python\nwords = jieba.cut(result, cut_all = True)\nwc_words = ' '.join(words) \n```\n\n首先将原来的字符串进行分词，分词后会成为一个列表，再将列表重新整合为字符串。\n\n> 参考：\n>\n> - [用wordcloud和jieba生成中文词云](https://blog.csdn.net/itanders/article/details/88858415)\n>\n> - [python词云wordcloud+jieba生成中文词云图](https://blog.csdn.net/qq_26450765/article/details/81362634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n\n\n\n要生成中文词云，还需要设置字体，以保证中文能够显示出来。\n\n此外还可以设置背景图，背景颜色，让图片更加好看；（建议选用分辨率比较高的图片，否则生成的词云也会比较模糊）\n\n比如这张：\n\n![20180806084453906](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/20180806084453906.jpg)\n\n针对词云中可能出现的无用的高频词汇，还可以添加列表将其剔除。\n\n```python\nwordCloud = WordCloud(\n    background_color = 'white',   \t# 背景颜色\n    mask = backgroud_Image,\t\t\t# 背景图片\n    font_path = 'C:\\Windows\\Fonts\\STZHONGS.TTF',\t# 中文字体\n    max_words = 1000,\t\t\t\t# 最大词数\n    stopwords = {'CSDN','博客'},\t\t# 要剔除的词汇\n    max_font_size = 150,\t\t\t# 最大字号\n    random_state = 1,\t\t\t\t\n    scale = 1\n    )\nwordCloud.generate(wc_words)\t\t# 生成词云\n\nimage_colors = ImageColorGenerator(backgroud_Image)\t\t# 仅使用背景图片的样式生成词云样式\nplt.imshow(wordCloud.recolor(color_func = image_colors)) # 再使用背景图片的颜色进行上色\nplt.axis(\"off\")\nplt.show()\nwordCloud.to_file(savePath)\t\t\t# 保存图片\n```\n\n这样就得到一开始的词云了，看着这些关键词，不说了，要开始学了！\n\n![WordCloudTest](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/WordCloudTest.png)\n\n","source":"_posts/数据-词云分析初探.md","raw":"---\ntitle: 【数据】词云分析初探\ndate: 2020-08-02 09:29:55\ncategories:\n\t- Data Analysis\ntags:\n\t- Word Cloud\n\t- Pandas\n---\n\n词云可以对比文件中不同词汇出现的频率。\n\n就像这样：\n\n![WordCloudTest](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/WordCloudTest.png)\n\n<!--more-->\n\n用字体大小代表出现频率高低，非常直观的数据表现形式。\n\n> 需要的依赖包有：\n>\n> - wordcloud\n> - pandas，numpy，matplotlib\n> - jieba\n> - pathlib，PIL\n\n## 读取文件\n\n使用python读取文件需要根据不同文件格式进行尝试。\n\n例如，本文对一个xlsx文件（也就是excel文件）进行读取，查找资料会发现：\n\n- 可以使用传统包，例如：\n\n`from openpyxl import load_workbook`\n\n使用`load_workbook`函数进行读取。*参考：[Python读取xlsx文件](https://www.cnblogs.com/hui-shao/p/read_xlsx.html)*\n\n- 更好的方法可能是 Pandas：\n\n`pandas.read_excel(filename)`\n\n**值得注意的是 pandas 处理数据的格式。**\n\nPandas读取数据后，会转换为 **DataFrame**，这是一种表格行数据结构，既有行索引，又有列索引，合理使用会有奇效。\n\n> 参考：\n\n[Pandas-DataFrame基础知识点总结](https://www.jianshu.com/p/8024ceef4fe2)\n\n[Python利用pandas处理Excel数据的应用](https://www.cnblogs.com/liulinghua90/p/9935642.html)\n\n## 数据预处理\n\n不同数据的预处理方法不同，此处在上述处理后，获得了DataFrame数据，但是它还不能直接生成词云，理论上最直接的字符串是词云的最佳来源。\n\n![image-20200802095805871](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200802095805871.png)\n\n因此，我们需要把上面的DataFrame中的有效数据变成字符串。\n\n可以根据索引名（上图中的“网站名”，“url”）进行索引，读取值，并添加到列表中：\n\n`net_list = mytext['网站名'].values`\n\n然后再将列表转化为字符串，此处用空格连接两个值：\n\n`result = ' '.join(net_list)`\n\n这样就得到了我们想要的字符串数据。\n\n## 词云生成\n\n理论上，使用如下语句：\n\n```python\nmycloud = WordCloud().generate(result)\n%matplotlib inline\nplt.imshow(mycloud, interpolation = \"bilinear\")\nplt.axis(\"off\")\n```\n\n就可以生成词云，并作图，但是它的结果可能是类似这样的：\n\n![下载](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/下载.png)\n\n就是说只能显示英文，而不能显示中文，而且仔细观察还有一些很长串的方框，是因为没有把一句中文长句进行分词。\n\n因此，对于中文词云的实现，还需要进行分词，可以使用jieba分词：\n\n```python\nwords = jieba.cut(result, cut_all = True)\nwc_words = ' '.join(words) \n```\n\n首先将原来的字符串进行分词，分词后会成为一个列表，再将列表重新整合为字符串。\n\n> 参考：\n>\n> - [用wordcloud和jieba生成中文词云](https://blog.csdn.net/itanders/article/details/88858415)\n>\n> - [python词云wordcloud+jieba生成中文词云图](https://blog.csdn.net/qq_26450765/article/details/81362634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n\n\n\n要生成中文词云，还需要设置字体，以保证中文能够显示出来。\n\n此外还可以设置背景图，背景颜色，让图片更加好看；（建议选用分辨率比较高的图片，否则生成的词云也会比较模糊）\n\n比如这张：\n\n![20180806084453906](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/20180806084453906.jpg)\n\n针对词云中可能出现的无用的高频词汇，还可以添加列表将其剔除。\n\n```python\nwordCloud = WordCloud(\n    background_color = 'white',   \t# 背景颜色\n    mask = backgroud_Image,\t\t\t# 背景图片\n    font_path = 'C:\\Windows\\Fonts\\STZHONGS.TTF',\t# 中文字体\n    max_words = 1000,\t\t\t\t# 最大词数\n    stopwords = {'CSDN','博客'},\t\t# 要剔除的词汇\n    max_font_size = 150,\t\t\t# 最大字号\n    random_state = 1,\t\t\t\t\n    scale = 1\n    )\nwordCloud.generate(wc_words)\t\t# 生成词云\n\nimage_colors = ImageColorGenerator(backgroud_Image)\t\t# 仅使用背景图片的样式生成词云样式\nplt.imshow(wordCloud.recolor(color_func = image_colors)) # 再使用背景图片的颜色进行上色\nplt.axis(\"off\")\nplt.show()\nwordCloud.to_file(savePath)\t\t\t# 保存图片\n```\n\n这样就得到一开始的词云了，看着这些关键词，不说了，要开始学了！\n\n![WordCloudTest](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/WordCloudTest.png)\n\n","slug":"数据-词云分析初探","published":1,"updated":"2021-01-26T06:23:50.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n886000vk8tlci9y94yp","content":"<p>词云可以对比文件中不同词汇出现的频率。</p>\n<p>就像这样：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/WordCloudTest.png\" alt=\"WordCloudTest\"></p>\n<a id=\"more\"></a>\n<p>用字体大小代表出现频率高低，非常直观的数据表现形式。</p>\n<blockquote>\n<p>需要的依赖包有：</p>\n<ul>\n<li>wordcloud</li>\n<li>pandas，numpy，matplotlib</li>\n<li>jieba</li>\n<li>pathlib，PIL</li>\n</ul>\n</blockquote>\n<h2 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h2><p>使用python读取文件需要根据不同文件格式进行尝试。</p>\n<p>例如，本文对一个xlsx文件（也就是excel文件）进行读取，查找资料会发现：</p>\n<ul>\n<li>可以使用传统包，例如：</li>\n</ul>\n<p><code>from openpyxl import load_workbook</code></p>\n<p>使用<code>load_workbook</code>函数进行读取。<em>参考：<a href=\"https://www.cnblogs.com/hui-shao/p/read_xlsx.html\" target=\"_blank\" rel=\"noopener\">Python读取xlsx文件</a></em></p>\n<ul>\n<li>更好的方法可能是 Pandas：</li>\n</ul>\n<p><code>pandas.read_excel(filename)</code></p>\n<p><strong>值得注意的是 pandas 处理数据的格式。</strong></p>\n<p>Pandas读取数据后，会转换为 <strong>DataFrame</strong>，这是一种表格行数据结构，既有行索引，又有列索引，合理使用会有奇效。</p>\n<blockquote>\n<p>参考：</p>\n</blockquote>\n<p><a href=\"https://www.jianshu.com/p/8024ceef4fe2\" target=\"_blank\" rel=\"noopener\">Pandas-DataFrame基础知识点总结</a></p>\n<p><a href=\"https://www.cnblogs.com/liulinghua90/p/9935642.html\" target=\"_blank\" rel=\"noopener\">Python利用pandas处理Excel数据的应用</a></p>\n<h2 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h2><p>不同数据的预处理方法不同，此处在上述处理后，获得了DataFrame数据，但是它还不能直接生成词云，理论上最直接的字符串是词云的最佳来源。</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200802095805871.png\" alt=\"image-20200802095805871\"></p>\n<p>因此，我们需要把上面的DataFrame中的有效数据变成字符串。</p>\n<p>可以根据索引名（上图中的“网站名”，“url”）进行索引，读取值，并添加到列表中：</p>\n<p><code>net_list = mytext[&#39;网站名&#39;].values</code></p>\n<p>然后再将列表转化为字符串，此处用空格连接两个值：</p>\n<p><code>result = &#39; &#39;.join(net_list)</code></p>\n<p>这样就得到了我们想要的字符串数据。</p>\n<h2 id=\"词云生成\"><a href=\"#词云生成\" class=\"headerlink\" title=\"词云生成\"></a>词云生成</h2><p>理论上，使用如下语句：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mycloud = WordCloud().generate(result)</span><br><span class=\"line\">%matplotlib inline</span><br><span class=\"line\">plt.imshow(mycloud, interpolation = <span class=\"string\">\"bilinear\"</span>)</span><br><span class=\"line\">plt.axis(<span class=\"string\">\"off\"</span>)</span><br></pre></td></tr></table></figure>\n<p>就可以生成词云，并作图，但是它的结果可能是类似这样的：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/下载.png\" alt=\"下载\"></p>\n<p>就是说只能显示英文，而不能显示中文，而且仔细观察还有一些很长串的方框，是因为没有把一句中文长句进行分词。</p>\n<p>因此，对于中文词云的实现，还需要进行分词，可以使用jieba分词：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">words = jieba.cut(result, cut_all = <span class=\"literal\">True</span>)</span><br><span class=\"line\">wc_words = <span class=\"string\">' '</span>.join(words)</span><br></pre></td></tr></table></figure>\n<p>首先将原来的字符串进行分词，分词后会成为一个列表，再将列表重新整合为字符串。</p>\n<blockquote>\n<p>参考：</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/itanders/article/details/88858415\" target=\"_blank\" rel=\"noopener\">用wordcloud和jieba生成中文词云</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_26450765/article/details/81362634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\" target=\"_blank\" rel=\"noopener\">python词云wordcloud+jieba生成中文词云图</a></p>\n</li>\n</ul>\n</blockquote>\n<p>要生成中文词云，还需要设置字体，以保证中文能够显示出来。</p>\n<p>此外还可以设置背景图，背景颜色，让图片更加好看；（建议选用分辨率比较高的图片，否则生成的词云也会比较模糊）</p>\n<p>比如这张：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/20180806084453906.jpg\" alt=\"20180806084453906\"></p>\n<p>针对词云中可能出现的无用的高频词汇，还可以添加列表将其剔除。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wordCloud = WordCloud(</span><br><span class=\"line\">    background_color = <span class=\"string\">'white'</span>,   \t<span class=\"comment\"># 背景颜色</span></span><br><span class=\"line\">    mask = backgroud_Image,\t\t\t<span class=\"comment\"># 背景图片</span></span><br><span class=\"line\">    font_path = <span class=\"string\">'C:\\Windows\\Fonts\\STZHONGS.TTF'</span>,\t<span class=\"comment\"># 中文字体</span></span><br><span class=\"line\">    max_words = <span class=\"number\">1000</span>,\t\t\t\t<span class=\"comment\"># 最大词数</span></span><br><span class=\"line\">    stopwords = &#123;<span class=\"string\">'CSDN'</span>,<span class=\"string\">'博客'</span>&#125;,\t\t<span class=\"comment\"># 要剔除的词汇</span></span><br><span class=\"line\">    max_font_size = <span class=\"number\">150</span>,\t\t\t<span class=\"comment\"># 最大字号</span></span><br><span class=\"line\">    random_state = <span class=\"number\">1</span>,\t\t\t\t</span><br><span class=\"line\">    scale = <span class=\"number\">1</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">wordCloud.generate(wc_words)\t\t<span class=\"comment\"># 生成词云</span></span><br><span class=\"line\"></span><br><span class=\"line\">image_colors = ImageColorGenerator(backgroud_Image)\t\t<span class=\"comment\"># 仅使用背景图片的样式生成词云样式</span></span><br><span class=\"line\">plt.imshow(wordCloud.recolor(color_func = image_colors)) <span class=\"comment\"># 再使用背景图片的颜色进行上色</span></span><br><span class=\"line\">plt.axis(<span class=\"string\">\"off\"</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\">wordCloud.to_file(savePath)\t\t\t<span class=\"comment\"># 保存图片</span></span><br></pre></td></tr></table></figure>\n<p>这样就得到一开始的词云了，看着这些关键词，不说了，要开始学了！</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/WordCloudTest.png\" alt=\"WordCloudTest\"></p>\n","site":{"data":{}},"excerpt":"<p>词云可以对比文件中不同词汇出现的频率。</p>\n<p>就像这样：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/WordCloudTest.png\" alt=\"WordCloudTest\"></p>","more":"<p>用字体大小代表出现频率高低，非常直观的数据表现形式。</p>\n<blockquote>\n<p>需要的依赖包有：</p>\n<ul>\n<li>wordcloud</li>\n<li>pandas，numpy，matplotlib</li>\n<li>jieba</li>\n<li>pathlib，PIL</li>\n</ul>\n</blockquote>\n<h2 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h2><p>使用python读取文件需要根据不同文件格式进行尝试。</p>\n<p>例如，本文对一个xlsx文件（也就是excel文件）进行读取，查找资料会发现：</p>\n<ul>\n<li>可以使用传统包，例如：</li>\n</ul>\n<p><code>from openpyxl import load_workbook</code></p>\n<p>使用<code>load_workbook</code>函数进行读取。<em>参考：<a href=\"https://www.cnblogs.com/hui-shao/p/read_xlsx.html\" target=\"_blank\" rel=\"noopener\">Python读取xlsx文件</a></em></p>\n<ul>\n<li>更好的方法可能是 Pandas：</li>\n</ul>\n<p><code>pandas.read_excel(filename)</code></p>\n<p><strong>值得注意的是 pandas 处理数据的格式。</strong></p>\n<p>Pandas读取数据后，会转换为 <strong>DataFrame</strong>，这是一种表格行数据结构，既有行索引，又有列索引，合理使用会有奇效。</p>\n<blockquote>\n<p>参考：</p>\n</blockquote>\n<p><a href=\"https://www.jianshu.com/p/8024ceef4fe2\" target=\"_blank\" rel=\"noopener\">Pandas-DataFrame基础知识点总结</a></p>\n<p><a href=\"https://www.cnblogs.com/liulinghua90/p/9935642.html\" target=\"_blank\" rel=\"noopener\">Python利用pandas处理Excel数据的应用</a></p>\n<h2 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h2><p>不同数据的预处理方法不同，此处在上述处理后，获得了DataFrame数据，但是它还不能直接生成词云，理论上最直接的字符串是词云的最佳来源。</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200802095805871.png\" alt=\"image-20200802095805871\"></p>\n<p>因此，我们需要把上面的DataFrame中的有效数据变成字符串。</p>\n<p>可以根据索引名（上图中的“网站名”，“url”）进行索引，读取值，并添加到列表中：</p>\n<p><code>net_list = mytext[&#39;网站名&#39;].values</code></p>\n<p>然后再将列表转化为字符串，此处用空格连接两个值：</p>\n<p><code>result = &#39; &#39;.join(net_list)</code></p>\n<p>这样就得到了我们想要的字符串数据。</p>\n<h2 id=\"词云生成\"><a href=\"#词云生成\" class=\"headerlink\" title=\"词云生成\"></a>词云生成</h2><p>理论上，使用如下语句：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mycloud = WordCloud().generate(result)</span><br><span class=\"line\">%matplotlib inline</span><br><span class=\"line\">plt.imshow(mycloud, interpolation = <span class=\"string\">\"bilinear\"</span>)</span><br><span class=\"line\">plt.axis(<span class=\"string\">\"off\"</span>)</span><br></pre></td></tr></table></figure>\n<p>就可以生成词云，并作图，但是它的结果可能是类似这样的：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/下载.png\" alt=\"下载\"></p>\n<p>就是说只能显示英文，而不能显示中文，而且仔细观察还有一些很长串的方框，是因为没有把一句中文长句进行分词。</p>\n<p>因此，对于中文词云的实现，还需要进行分词，可以使用jieba分词：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">words = jieba.cut(result, cut_all = <span class=\"literal\">True</span>)</span><br><span class=\"line\">wc_words = <span class=\"string\">' '</span>.join(words)</span><br></pre></td></tr></table></figure>\n<p>首先将原来的字符串进行分词，分词后会成为一个列表，再将列表重新整合为字符串。</p>\n<blockquote>\n<p>参考：</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/itanders/article/details/88858415\" target=\"_blank\" rel=\"noopener\">用wordcloud和jieba生成中文词云</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_26450765/article/details/81362634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\" target=\"_blank\" rel=\"noopener\">python词云wordcloud+jieba生成中文词云图</a></p>\n</li>\n</ul>\n</blockquote>\n<p>要生成中文词云，还需要设置字体，以保证中文能够显示出来。</p>\n<p>此外还可以设置背景图，背景颜色，让图片更加好看；（建议选用分辨率比较高的图片，否则生成的词云也会比较模糊）</p>\n<p>比如这张：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/20180806084453906.jpg\" alt=\"20180806084453906\"></p>\n<p>针对词云中可能出现的无用的高频词汇，还可以添加列表将其剔除。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wordCloud = WordCloud(</span><br><span class=\"line\">    background_color = <span class=\"string\">'white'</span>,   \t<span class=\"comment\"># 背景颜色</span></span><br><span class=\"line\">    mask = backgroud_Image,\t\t\t<span class=\"comment\"># 背景图片</span></span><br><span class=\"line\">    font_path = <span class=\"string\">'C:\\Windows\\Fonts\\STZHONGS.TTF'</span>,\t<span class=\"comment\"># 中文字体</span></span><br><span class=\"line\">    max_words = <span class=\"number\">1000</span>,\t\t\t\t<span class=\"comment\"># 最大词数</span></span><br><span class=\"line\">    stopwords = &#123;<span class=\"string\">'CSDN'</span>,<span class=\"string\">'博客'</span>&#125;,\t\t<span class=\"comment\"># 要剔除的词汇</span></span><br><span class=\"line\">    max_font_size = <span class=\"number\">150</span>,\t\t\t<span class=\"comment\"># 最大字号</span></span><br><span class=\"line\">    random_state = <span class=\"number\">1</span>,\t\t\t\t</span><br><span class=\"line\">    scale = <span class=\"number\">1</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">wordCloud.generate(wc_words)\t\t<span class=\"comment\"># 生成词云</span></span><br><span class=\"line\"></span><br><span class=\"line\">image_colors = ImageColorGenerator(backgroud_Image)\t\t<span class=\"comment\"># 仅使用背景图片的样式生成词云样式</span></span><br><span class=\"line\">plt.imshow(wordCloud.recolor(color_func = image_colors)) <span class=\"comment\"># 再使用背景图片的颜色进行上色</span></span><br><span class=\"line\">plt.axis(<span class=\"string\">\"off\"</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\">wordCloud.to_file(savePath)\t\t\t<span class=\"comment\"># 保存图片</span></span><br></pre></td></tr></table></figure>\n<p>这样就得到一开始的词云了，看着这些关键词，不说了，要开始学了！</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/WordCloudTest.png\" alt=\"WordCloudTest\"></p>"},{"title":"数据处理体验","date":"2020-11-14T08:41:29.000Z","_content":"\n# OS库的学习\n\n> 参考：[os模块的学习-获取目录下指定的文件类型](https://blog.csdn.net/binggan_2019/article/details/88895432)\n>\n> [菜鸟教程-Python OS文件/目录方法](https://www.runoob.com/python/os-file-methods.html)\n\n其实使用os库的目的就是更方便地遍历文件\n\n<!--more-->\n\n那么问题有：\n\n怎么判断是一个文件还是文件夹？\n\n- os.path.isdir函数用来判断是不是文件夹\n- os.path.isfile函数用来判断是不是文件\n\n怎么移动到下一个文件夹\n\n如果移动到了下一层文件夹了呢？怎么样回到原来路径上来？\n\n## 常见OS使用思路\n\n### 思路一\n\n首先建立path，也就是根路径【os.gecwd()】\n\n然后后面的文件调取都是在 path + filename的基础上进行的【使用os.path.join()函数将两部分进行融合】\n\n在循环中进行文件判断【循环是建立在list基础上的，使用os】\n\n使用os.path.isdir简单判断是文件夹还是文件，并直接对文件进行处理\n\n【判断文件类型】可以使用split对文件名称进行分割`str.split('.')`，分割后是一个列表，然后选择最后一个量【索引值为-1】，最后在判断这段str是不是在指定的类型之中\n\n### 思路二\n\n使用os.walk()：\n\n`for root, dirs, files in os.walk(\".\", topdown=False)`\n\n直接得到目录、文件夹列表、文件列表的内容\n\n这样就好多了\n\n还是有个问题，这个东西返回的是一个列表，但是我们需要准确知道某个文件是在哪个具体的文件夹下面的\n\n**注意：这里我们要返回某个文件的绝对地址时，并不需要root+dir+file，只需要root+file就可以了**\n\n还是有个问题，walk函数中的参数是如何进行设置的\n\n```python\nos.walk(top, topdown, onerror, followlinks)\n```\n\n- top：所要遍历的目录的地址，返回一个三元组（root, dirs, files）\n- topdown：默认为true——也就是优先遍历top目录，如果设置为false则优先遍历top的子目录\n\n# mat文件\n\npython加载mat文件\n\n首先要使用的包是`scipy.io.loadmat(matfile)`\n\n> 参考：[python读取并写入mat文件的方法](https://www.jb51.net/article/165224.htm)\n\n读取结果是一个dict数据类型，也就是字典，其实是非常好的\n\n然后可以直接处理了，当然。\n\n但是可能转成pandas数据进行处理可能是更好的选择\n\n**不过，如果要转化成pandas数据，必须保证数据是一维的！**\n\n不过很有意思的是，这里面的数据已经是numpy的ndarray格式了，所以直接用这个进行处理可能要更好一点\n\n获取到的数据相当于维数是（360000， 5）\n\n那么我们在进行读取的时候，必须按照每一维进行读取：\n\n例如`base_data[:, i]`，表示读取第 i+1 维的全部数据，总共有360000个，这个索引确实也是很有意思了\n\n# csv和tsv数据\n\n应该说在这个方面 Pandas 是完胜的\n\n因为numpy适合一维、二维数据，而且最好数据类型比较统一\n\n很多csv数据类型并不统一，所以使用Pandas来进行加载就要好很多，而且是可以直接进行索引的，如果不可以，那就要指定一些表头等的内容了","source":"_posts/数据处理体验.md","raw":"---\ntitle: 数据处理体验\ndate: 2020-11-14 16:41:29\ncategories:\n\t- Data Analysis\ntags: \n\t- Pandas\n\t- os\n---\n\n# OS库的学习\n\n> 参考：[os模块的学习-获取目录下指定的文件类型](https://blog.csdn.net/binggan_2019/article/details/88895432)\n>\n> [菜鸟教程-Python OS文件/目录方法](https://www.runoob.com/python/os-file-methods.html)\n\n其实使用os库的目的就是更方便地遍历文件\n\n<!--more-->\n\n那么问题有：\n\n怎么判断是一个文件还是文件夹？\n\n- os.path.isdir函数用来判断是不是文件夹\n- os.path.isfile函数用来判断是不是文件\n\n怎么移动到下一个文件夹\n\n如果移动到了下一层文件夹了呢？怎么样回到原来路径上来？\n\n## 常见OS使用思路\n\n### 思路一\n\n首先建立path，也就是根路径【os.gecwd()】\n\n然后后面的文件调取都是在 path + filename的基础上进行的【使用os.path.join()函数将两部分进行融合】\n\n在循环中进行文件判断【循环是建立在list基础上的，使用os】\n\n使用os.path.isdir简单判断是文件夹还是文件，并直接对文件进行处理\n\n【判断文件类型】可以使用split对文件名称进行分割`str.split('.')`，分割后是一个列表，然后选择最后一个量【索引值为-1】，最后在判断这段str是不是在指定的类型之中\n\n### 思路二\n\n使用os.walk()：\n\n`for root, dirs, files in os.walk(\".\", topdown=False)`\n\n直接得到目录、文件夹列表、文件列表的内容\n\n这样就好多了\n\n还是有个问题，这个东西返回的是一个列表，但是我们需要准确知道某个文件是在哪个具体的文件夹下面的\n\n**注意：这里我们要返回某个文件的绝对地址时，并不需要root+dir+file，只需要root+file就可以了**\n\n还是有个问题，walk函数中的参数是如何进行设置的\n\n```python\nos.walk(top, topdown, onerror, followlinks)\n```\n\n- top：所要遍历的目录的地址，返回一个三元组（root, dirs, files）\n- topdown：默认为true——也就是优先遍历top目录，如果设置为false则优先遍历top的子目录\n\n# mat文件\n\npython加载mat文件\n\n首先要使用的包是`scipy.io.loadmat(matfile)`\n\n> 参考：[python读取并写入mat文件的方法](https://www.jb51.net/article/165224.htm)\n\n读取结果是一个dict数据类型，也就是字典，其实是非常好的\n\n然后可以直接处理了，当然。\n\n但是可能转成pandas数据进行处理可能是更好的选择\n\n**不过，如果要转化成pandas数据，必须保证数据是一维的！**\n\n不过很有意思的是，这里面的数据已经是numpy的ndarray格式了，所以直接用这个进行处理可能要更好一点\n\n获取到的数据相当于维数是（360000， 5）\n\n那么我们在进行读取的时候，必须按照每一维进行读取：\n\n例如`base_data[:, i]`，表示读取第 i+1 维的全部数据，总共有360000个，这个索引确实也是很有意思了\n\n# csv和tsv数据\n\n应该说在这个方面 Pandas 是完胜的\n\n因为numpy适合一维、二维数据，而且最好数据类型比较统一\n\n很多csv数据类型并不统一，所以使用Pandas来进行加载就要好很多，而且是可以直接进行索引的，如果不可以，那就要指定一些表头等的内容了","slug":"数据处理体验","published":1,"updated":"2021-01-26T06:23:32.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n8870010k8tl8zaw95rh","content":"<h1 id=\"OS库的学习\"><a href=\"#OS库的学习\" class=\"headerlink\" title=\"OS库的学习\"></a>OS库的学习</h1><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/binggan_2019/article/details/88895432\" target=\"_blank\" rel=\"noopener\">os模块的学习-获取目录下指定的文件类型</a></p>\n<p><a href=\"https://www.runoob.com/python/os-file-methods.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程-Python OS文件/目录方法</a></p>\n</blockquote>\n<p>其实使用os库的目的就是更方便地遍历文件</p>\n<a id=\"more\"></a>\n<p>那么问题有：</p>\n<p>怎么判断是一个文件还是文件夹？</p>\n<ul>\n<li>os.path.isdir函数用来判断是不是文件夹</li>\n<li>os.path.isfile函数用来判断是不是文件</li>\n</ul>\n<p>怎么移动到下一个文件夹</p>\n<p>如果移动到了下一层文件夹了呢？怎么样回到原来路径上来？</p>\n<h2 id=\"常见OS使用思路\"><a href=\"#常见OS使用思路\" class=\"headerlink\" title=\"常见OS使用思路\"></a>常见OS使用思路</h2><h3 id=\"思路一\"><a href=\"#思路一\" class=\"headerlink\" title=\"思路一\"></a>思路一</h3><p>首先建立path，也就是根路径【os.gecwd()】</p>\n<p>然后后面的文件调取都是在 path + filename的基础上进行的【使用os.path.join()函数将两部分进行融合】</p>\n<p>在循环中进行文件判断【循环是建立在list基础上的，使用os】</p>\n<p>使用os.path.isdir简单判断是文件夹还是文件，并直接对文件进行处理</p>\n<p>【判断文件类型】可以使用split对文件名称进行分割<code>str.split(&#39;.&#39;)</code>，分割后是一个列表，然后选择最后一个量【索引值为-1】，最后在判断这段str是不是在指定的类型之中</p>\n<h3 id=\"思路二\"><a href=\"#思路二\" class=\"headerlink\" title=\"思路二\"></a>思路二</h3><p>使用os.walk()：</p>\n<p><code>for root, dirs, files in os.walk(&quot;.&quot;, topdown=False)</code></p>\n<p>直接得到目录、文件夹列表、文件列表的内容</p>\n<p>这样就好多了</p>\n<p>还是有个问题，这个东西返回的是一个列表，但是我们需要准确知道某个文件是在哪个具体的文件夹下面的</p>\n<p><strong>注意：这里我们要返回某个文件的绝对地址时，并不需要root+dir+file，只需要root+file就可以了</strong></p>\n<p>还是有个问题，walk函数中的参数是如何进行设置的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.walk(top, topdown, onerror, followlinks)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>top：所要遍历的目录的地址，返回一个三元组（root, dirs, files）</li>\n<li>topdown：默认为true——也就是优先遍历top目录，如果设置为false则优先遍历top的子目录</li>\n</ul>\n<h1 id=\"mat文件\"><a href=\"#mat文件\" class=\"headerlink\" title=\"mat文件\"></a>mat文件</h1><p>python加载mat文件</p>\n<p>首先要使用的包是<code>scipy.io.loadmat(matfile)</code></p>\n<blockquote>\n<p>参考：<a href=\"https://www.jb51.net/article/165224.htm\" target=\"_blank\" rel=\"noopener\">python读取并写入mat文件的方法</a></p>\n</blockquote>\n<p>读取结果是一个dict数据类型，也就是字典，其实是非常好的</p>\n<p>然后可以直接处理了，当然。</p>\n<p>但是可能转成pandas数据进行处理可能是更好的选择</p>\n<p><strong>不过，如果要转化成pandas数据，必须保证数据是一维的！</strong></p>\n<p>不过很有意思的是，这里面的数据已经是numpy的ndarray格式了，所以直接用这个进行处理可能要更好一点</p>\n<p>获取到的数据相当于维数是（360000， 5）</p>\n<p>那么我们在进行读取的时候，必须按照每一维进行读取：</p>\n<p>例如<code>base_data[:, i]</code>，表示读取第 i+1 维的全部数据，总共有360000个，这个索引确实也是很有意思了</p>\n<h1 id=\"csv和tsv数据\"><a href=\"#csv和tsv数据\" class=\"headerlink\" title=\"csv和tsv数据\"></a>csv和tsv数据</h1><p>应该说在这个方面 Pandas 是完胜的</p>\n<p>因为numpy适合一维、二维数据，而且最好数据类型比较统一</p>\n<p>很多csv数据类型并不统一，所以使用Pandas来进行加载就要好很多，而且是可以直接进行索引的，如果不可以，那就要指定一些表头等的内容了</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"OS库的学习\"><a href=\"#OS库的学习\" class=\"headerlink\" title=\"OS库的学习\"></a>OS库的学习</h1><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/binggan_2019/article/details/88895432\" target=\"_blank\" rel=\"noopener\">os模块的学习-获取目录下指定的文件类型</a></p>\n<p><a href=\"https://www.runoob.com/python/os-file-methods.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程-Python OS文件/目录方法</a></p>\n</blockquote>\n<p>其实使用os库的目的就是更方便地遍历文件</p>","more":"<p>那么问题有：</p>\n<p>怎么判断是一个文件还是文件夹？</p>\n<ul>\n<li>os.path.isdir函数用来判断是不是文件夹</li>\n<li>os.path.isfile函数用来判断是不是文件</li>\n</ul>\n<p>怎么移动到下一个文件夹</p>\n<p>如果移动到了下一层文件夹了呢？怎么样回到原来路径上来？</p>\n<h2 id=\"常见OS使用思路\"><a href=\"#常见OS使用思路\" class=\"headerlink\" title=\"常见OS使用思路\"></a>常见OS使用思路</h2><h3 id=\"思路一\"><a href=\"#思路一\" class=\"headerlink\" title=\"思路一\"></a>思路一</h3><p>首先建立path，也就是根路径【os.gecwd()】</p>\n<p>然后后面的文件调取都是在 path + filename的基础上进行的【使用os.path.join()函数将两部分进行融合】</p>\n<p>在循环中进行文件判断【循环是建立在list基础上的，使用os】</p>\n<p>使用os.path.isdir简单判断是文件夹还是文件，并直接对文件进行处理</p>\n<p>【判断文件类型】可以使用split对文件名称进行分割<code>str.split(&#39;.&#39;)</code>，分割后是一个列表，然后选择最后一个量【索引值为-1】，最后在判断这段str是不是在指定的类型之中</p>\n<h3 id=\"思路二\"><a href=\"#思路二\" class=\"headerlink\" title=\"思路二\"></a>思路二</h3><p>使用os.walk()：</p>\n<p><code>for root, dirs, files in os.walk(&quot;.&quot;, topdown=False)</code></p>\n<p>直接得到目录、文件夹列表、文件列表的内容</p>\n<p>这样就好多了</p>\n<p>还是有个问题，这个东西返回的是一个列表，但是我们需要准确知道某个文件是在哪个具体的文件夹下面的</p>\n<p><strong>注意：这里我们要返回某个文件的绝对地址时，并不需要root+dir+file，只需要root+file就可以了</strong></p>\n<p>还是有个问题，walk函数中的参数是如何进行设置的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.walk(top, topdown, onerror, followlinks)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>top：所要遍历的目录的地址，返回一个三元组（root, dirs, files）</li>\n<li>topdown：默认为true——也就是优先遍历top目录，如果设置为false则优先遍历top的子目录</li>\n</ul>\n<h1 id=\"mat文件\"><a href=\"#mat文件\" class=\"headerlink\" title=\"mat文件\"></a>mat文件</h1><p>python加载mat文件</p>\n<p>首先要使用的包是<code>scipy.io.loadmat(matfile)</code></p>\n<blockquote>\n<p>参考：<a href=\"https://www.jb51.net/article/165224.htm\" target=\"_blank\" rel=\"noopener\">python读取并写入mat文件的方法</a></p>\n</blockquote>\n<p>读取结果是一个dict数据类型，也就是字典，其实是非常好的</p>\n<p>然后可以直接处理了，当然。</p>\n<p>但是可能转成pandas数据进行处理可能是更好的选择</p>\n<p><strong>不过，如果要转化成pandas数据，必须保证数据是一维的！</strong></p>\n<p>不过很有意思的是，这里面的数据已经是numpy的ndarray格式了，所以直接用这个进行处理可能要更好一点</p>\n<p>获取到的数据相当于维数是（360000， 5）</p>\n<p>那么我们在进行读取的时候，必须按照每一维进行读取：</p>\n<p>例如<code>base_data[:, i]</code>，表示读取第 i+1 维的全部数据，总共有360000个，这个索引确实也是很有意思了</p>\n<h1 id=\"csv和tsv数据\"><a href=\"#csv和tsv数据\" class=\"headerlink\" title=\"csv和tsv数据\"></a>csv和tsv数据</h1><p>应该说在这个方面 Pandas 是完胜的</p>\n<p>因为numpy适合一维、二维数据，而且最好数据类型比较统一</p>\n<p>很多csv数据类型并不统一，所以使用Pandas来进行加载就要好很多，而且是可以直接进行索引的，如果不可以，那就要指定一些表头等的内容了</p>"},{"title":"数据-MySQL语言基础","date":"2020-08-10T01:24:52.000Z","_content":"\n## 语言基础\n\n注释：`#`\n\n调用某个库：`use databases`\n\n着重号`xxx`\n\n<!--more-->\n\n### DQL语言\n\n1. 基础查询\n\n   `select 查询列表 from 表名；`\n\n- 查询列表：\n\n  - 表中字段\n  - 常量值\n  - 表达式\n  - 函数\n\n- 查询结果是一个虚拟的表格\n\n- 查询表中的单个字段\n\n  `select last_name from  employees;`\n\n- 查询表中的多个字段，用逗号隔开\n\n  `select last_name,id from employees;`\n\n  - **顺序随意 **- 可以自定义\n  - 不知道怎么拼，直接在图形化界面点就可以\n  - 按```F12```就能排列好顺序\n\n- 查全部 - **顺序和表内会一模一样**\n\n  ```mysql\n  select * from employees\n  ```\n\n2. 查询常量值\n\n   ```mysql\n   select 100;\n   \n   select 'john';\n   ```\n\n   - 查询表达式\n\n   ```mysql\n   select 100*98;\n   ```\n\n   - 查询函数\n\n   ```mysql\n   select version();\n   ```\n\n3. 起别名 \n\n   - 方式一：as\n\n   - 在查询的字段有比较高的重复率时使用比较好\n\n   ```mysql\n   select 100%98 as 结果;\n   \n   select last_name as 姓,last_name as 名 from employees;\n   ```\n\n   - 方式二：空格\n\n   ```mysql\n   select last_name 姓,last_name 名 from employees;\n   ```\n\n   **注意别名不能使用特殊符号，如果使用了，请加双引号\" \" **\n\n4. 去重 - distinct\n\n   ```mysql\n   select distinct id from mydatabase\n   ```\n\n5. +号的作用\n\n   - +号在mysql中只有**运算符**的功能\n   - 会试图将字符型转换为数值型，但是如果不能转换成功，**字符型数值转换为0**\n\n6. 拼接\n\n   - 比如把姓和名连接成一个字段：\n\n     这样是不行的：\n\n     ```mysql\n     select last_name+first_name as 姓名 from employees;\n     ```\n\n   - **应当用concat 关键字进行连接**，括号里面使用的是着重符号，而不全是单引号，像逗号才使用单引号\n\n     ```mysql\n     select CONCAT('first_name','last_name') as 姓名;\n     ```\n\n     如果想用“，”隔开，那就使用：\n\n     ```mysql\n     select CONCAT('last_name',',','first_name') as out_put;\n     ```\n\n   - **如果其中有NULL字段，那么结果就会是NULL**\n\n     为了消除这种null字段的影响，应当加上一些判断\n\n     `IFNULL(id_a, '0')`函数可以判断`id_a`是不是null，如果是，就会取0；\n\n7. 显示表的结构用 `DESC database;`\n\n8. **条件查询**\n\n   `select 查询列表 from 表名 where 筛选条件;`\n\n   - 先执行from，然后执行筛选，最后是查询\n\n   分类：\n\n   - 按条件表达式筛选\n\n     条件运算符：> < = ‘!=不等于’ ‘<>不等于’ <= >=\n\n     关键是分清楚：要查什么，条件是什么\n\n     > 查询：工资 > 12000 的员工信息\n     >\n     > ​\t要查的是员工信息，条件是工资；\n     >\n     > 查询：部门编号不等于90的员工名和部门编号\n     >\n     > ​\t要查的是员工名和部门编号，条件是部门编号不等于90；\n\n   - 按逻辑运算符\n\n     &&   ||    !  \n\n     and  or  not\n\n     **用于连接条件表达式**\n\n     > 查询：工资在10000和20000之间的员工名，工资以及奖金\n     >\n     > 查询：部门编号不是在90和110之间，或者工资高于15000的员工信息\n\n   - ==**模糊运算符**==\n\n     **like**\n\n     > 查询：员工名中包含字符a的员工信息\n     >\n     > ```mysql\n     > select * \n     > from employees\n     > where last_name LIKE '%a%';\n     > ```\n\n     - `%`表示一种通配符\n     - 一般要和通配符结合使用：\n\n     > % - 任意多个字符，包括 0 个字符\n     >\n     > _  - 任意单个字符\n     >\n     > **如果查询第二个字符为 _ 的员工，那么就要进行转义！**\n     >\n     > ```mysql\n     > select last_name\n     > from employees\n     > where last_name like '_\\_%';\n     > \n     > # 也可以自定义一个转义符号，用ESCAPE字符\n     > where last_name like '_$_%' escape '$';\n     > ```\n\n     **between and** - 提高简洁度\n\n     > 查询员工编号在100和120之间的员工信息\n     >\n     > ```mysql\n     > select *\n     > from employees\n     > where employee_id BETWEEN 100 AND 120;\n     > \n     > # 明显好于之前的方法\n     > where employee_id >= 100 AND employee_id <= 120;\n     > ```\n\n     - 区间包含临界值\n     - between 后面的数字要比 and 后面的小，不能调换顺序，否则会出错！\n\n     **in**\n\n     - 判断某字段的值是否属于in列表中的某一值\n     - in 列表中的值类型必须一致或者兼容（就是可以转换，例如 '123' 和 123）\n     - 不能套用通配符\n\n     > 查询：员工的工种编号 是 IT_PROG、AD_VP、AD_PRES中的员工名和工种编号\n     >\n     > ```mysql\n     > select last_name, job_id\n     > from employees\n     > where job_id IN('IT_PROG', 'AD_VP', 'AD_PRES');\n     > \n     > # 比使用OR来解决要方便很多\n     > where job_id='IT_PROT' OR job_id='AD_VP' OR job_id='AD_PRES';\n     > # 也就是说 in 和上面语句中的 等于号= 是一致的\n     > ```\n\n     **is null**\n\n     - ==”普通的等于号=“== 不能判断NULL值，但是可以使用 “IS NULL” 进行判断\n     - is null 或 is not null可以判断null值\n\n     > 查询：没有奖金的员工名和奖金率\n     >\n     > ```mysql\n     > select last_name, commission_pct\n     > from employees\n     > where commission_pct IS NULL;\n     > ```\n     >\n     > 查询：有奖金的？==IS NOT NULL==\n\n### DML语言\n\n- 增删改\n\n### DDL语言\n\n### TCL语言、DCL语言","source":"_posts/数据库-mysql语言基础.md","raw":"---\ntitle: 数据-MySQL语言基础\ndate: 2020-08-10 09:24:52\ncategories:\n\t- Data Analysis\ntags:\n\t- MySQL\n\t- DataBases\n---\n\n## 语言基础\n\n注释：`#`\n\n调用某个库：`use databases`\n\n着重号`xxx`\n\n<!--more-->\n\n### DQL语言\n\n1. 基础查询\n\n   `select 查询列表 from 表名；`\n\n- 查询列表：\n\n  - 表中字段\n  - 常量值\n  - 表达式\n  - 函数\n\n- 查询结果是一个虚拟的表格\n\n- 查询表中的单个字段\n\n  `select last_name from  employees;`\n\n- 查询表中的多个字段，用逗号隔开\n\n  `select last_name,id from employees;`\n\n  - **顺序随意 **- 可以自定义\n  - 不知道怎么拼，直接在图形化界面点就可以\n  - 按```F12```就能排列好顺序\n\n- 查全部 - **顺序和表内会一模一样**\n\n  ```mysql\n  select * from employees\n  ```\n\n2. 查询常量值\n\n   ```mysql\n   select 100;\n   \n   select 'john';\n   ```\n\n   - 查询表达式\n\n   ```mysql\n   select 100*98;\n   ```\n\n   - 查询函数\n\n   ```mysql\n   select version();\n   ```\n\n3. 起别名 \n\n   - 方式一：as\n\n   - 在查询的字段有比较高的重复率时使用比较好\n\n   ```mysql\n   select 100%98 as 结果;\n   \n   select last_name as 姓,last_name as 名 from employees;\n   ```\n\n   - 方式二：空格\n\n   ```mysql\n   select last_name 姓,last_name 名 from employees;\n   ```\n\n   **注意别名不能使用特殊符号，如果使用了，请加双引号\" \" **\n\n4. 去重 - distinct\n\n   ```mysql\n   select distinct id from mydatabase\n   ```\n\n5. +号的作用\n\n   - +号在mysql中只有**运算符**的功能\n   - 会试图将字符型转换为数值型，但是如果不能转换成功，**字符型数值转换为0**\n\n6. 拼接\n\n   - 比如把姓和名连接成一个字段：\n\n     这样是不行的：\n\n     ```mysql\n     select last_name+first_name as 姓名 from employees;\n     ```\n\n   - **应当用concat 关键字进行连接**，括号里面使用的是着重符号，而不全是单引号，像逗号才使用单引号\n\n     ```mysql\n     select CONCAT('first_name','last_name') as 姓名;\n     ```\n\n     如果想用“，”隔开，那就使用：\n\n     ```mysql\n     select CONCAT('last_name',',','first_name') as out_put;\n     ```\n\n   - **如果其中有NULL字段，那么结果就会是NULL**\n\n     为了消除这种null字段的影响，应当加上一些判断\n\n     `IFNULL(id_a, '0')`函数可以判断`id_a`是不是null，如果是，就会取0；\n\n7. 显示表的结构用 `DESC database;`\n\n8. **条件查询**\n\n   `select 查询列表 from 表名 where 筛选条件;`\n\n   - 先执行from，然后执行筛选，最后是查询\n\n   分类：\n\n   - 按条件表达式筛选\n\n     条件运算符：> < = ‘!=不等于’ ‘<>不等于’ <= >=\n\n     关键是分清楚：要查什么，条件是什么\n\n     > 查询：工资 > 12000 的员工信息\n     >\n     > ​\t要查的是员工信息，条件是工资；\n     >\n     > 查询：部门编号不等于90的员工名和部门编号\n     >\n     > ​\t要查的是员工名和部门编号，条件是部门编号不等于90；\n\n   - 按逻辑运算符\n\n     &&   ||    !  \n\n     and  or  not\n\n     **用于连接条件表达式**\n\n     > 查询：工资在10000和20000之间的员工名，工资以及奖金\n     >\n     > 查询：部门编号不是在90和110之间，或者工资高于15000的员工信息\n\n   - ==**模糊运算符**==\n\n     **like**\n\n     > 查询：员工名中包含字符a的员工信息\n     >\n     > ```mysql\n     > select * \n     > from employees\n     > where last_name LIKE '%a%';\n     > ```\n\n     - `%`表示一种通配符\n     - 一般要和通配符结合使用：\n\n     > % - 任意多个字符，包括 0 个字符\n     >\n     > _  - 任意单个字符\n     >\n     > **如果查询第二个字符为 _ 的员工，那么就要进行转义！**\n     >\n     > ```mysql\n     > select last_name\n     > from employees\n     > where last_name like '_\\_%';\n     > \n     > # 也可以自定义一个转义符号，用ESCAPE字符\n     > where last_name like '_$_%' escape '$';\n     > ```\n\n     **between and** - 提高简洁度\n\n     > 查询员工编号在100和120之间的员工信息\n     >\n     > ```mysql\n     > select *\n     > from employees\n     > where employee_id BETWEEN 100 AND 120;\n     > \n     > # 明显好于之前的方法\n     > where employee_id >= 100 AND employee_id <= 120;\n     > ```\n\n     - 区间包含临界值\n     - between 后面的数字要比 and 后面的小，不能调换顺序，否则会出错！\n\n     **in**\n\n     - 判断某字段的值是否属于in列表中的某一值\n     - in 列表中的值类型必须一致或者兼容（就是可以转换，例如 '123' 和 123）\n     - 不能套用通配符\n\n     > 查询：员工的工种编号 是 IT_PROG、AD_VP、AD_PRES中的员工名和工种编号\n     >\n     > ```mysql\n     > select last_name, job_id\n     > from employees\n     > where job_id IN('IT_PROG', 'AD_VP', 'AD_PRES');\n     > \n     > # 比使用OR来解决要方便很多\n     > where job_id='IT_PROT' OR job_id='AD_VP' OR job_id='AD_PRES';\n     > # 也就是说 in 和上面语句中的 等于号= 是一致的\n     > ```\n\n     **is null**\n\n     - ==”普通的等于号=“== 不能判断NULL值，但是可以使用 “IS NULL” 进行判断\n     - is null 或 is not null可以判断null值\n\n     > 查询：没有奖金的员工名和奖金率\n     >\n     > ```mysql\n     > select last_name, commission_pct\n     > from employees\n     > where commission_pct IS NULL;\n     > ```\n     >\n     > 查询：有奖金的？==IS NOT NULL==\n\n### DML语言\n\n- 增删改\n\n### DDL语言\n\n### TCL语言、DCL语言","slug":"数据库-mysql语言基础","published":1,"updated":"2021-03-03T08:37:31.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n8880011k8tlbnlo93o9","content":"<h2 id=\"语言基础\"><a href=\"#语言基础\" class=\"headerlink\" title=\"语言基础\"></a>语言基础</h2><p>注释：<code>#</code></p>\n<p>调用某个库：<code>use databases</code></p>\n<p>着重号<code>xxx</code></p>\n<a id=\"more\"></a>\n<h3 id=\"DQL语言\"><a href=\"#DQL语言\" class=\"headerlink\" title=\"DQL语言\"></a>DQL语言</h3><ol>\n<li><p>基础查询</p>\n<p><code>select 查询列表 from 表名；</code></p>\n</li>\n</ol>\n<ul>\n<li><p>查询列表：</p>\n<ul>\n<li>表中字段</li>\n<li>常量值</li>\n<li>表达式</li>\n<li>函数</li>\n</ul>\n</li>\n<li><p>查询结果是一个虚拟的表格</p>\n</li>\n<li><p>查询表中的单个字段</p>\n<p><code>select last_name from  employees;</code></p>\n</li>\n<li><p>查询表中的多个字段，用逗号隔开</p>\n<p><code>select last_name,id from employees;</code></p>\n<ul>\n<li><strong>顺序随意 </strong>- 可以自定义</li>\n<li>不知道怎么拼，直接在图形化界面点就可以</li>\n<li>按<code>F12</code>就能排列好顺序</li>\n</ul>\n</li>\n<li><p>查全部 - <strong>顺序和表内会一模一样</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from employees</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li><p>查询常量值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select 100;</span><br><span class=\"line\"></span><br><span class=\"line\">select &#39;john&#39;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查询表达式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select 100*98;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查询函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select version();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>起别名 </p>\n<ul>\n<li><p>方式一：as</p>\n</li>\n<li><p>在查询的字段有比较高的重复率时使用比较好</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select 100%98 as 结果;</span><br><span class=\"line\"></span><br><span class=\"line\">select last_name as 姓,last_name as 名 from employees;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方式二：空格</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name 姓,last_name 名 from employees;</span><br></pre></td></tr></table></figure>\n<p><strong>注意别名不能使用特殊符号，如果使用了，请加双引号” “ </strong></p>\n</li>\n<li><p>去重 - distinct</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct id from mydatabase</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>+号的作用</p>\n<ul>\n<li>+号在mysql中只有<strong>运算符</strong>的功能</li>\n<li>会试图将字符型转换为数值型，但是如果不能转换成功，<strong>字符型数值转换为0</strong></li>\n</ul>\n</li>\n<li><p>拼接</p>\n<ul>\n<li><p>比如把姓和名连接成一个字段：</p>\n<p>这样是不行的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name+first_name as 姓名 from employees;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>应当用concat 关键字进行连接</strong>，括号里面使用的是着重符号，而不全是单引号，像逗号才使用单引号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select CONCAT(&#39;first_name&#39;,&#39;last_name&#39;) as 姓名;</span><br></pre></td></tr></table></figure>\n<p>如果想用“，”隔开，那就使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select CONCAT(&#39;last_name&#39;,&#39;,&#39;,&#39;first_name&#39;) as out_put;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>如果其中有NULL字段，那么结果就会是NULL</strong></p>\n<p>为了消除这种null字段的影响，应当加上一些判断</p>\n<p><code>IFNULL(id_a, &#39;0&#39;)</code>函数可以判断<code>id_a</code>是不是null，如果是，就会取0；</p>\n</li>\n</ul>\n</li>\n<li><p>显示表的结构用 <code>DESC database;</code></p>\n</li>\n<li><p><strong>条件查询</strong></p>\n<p><code>select 查询列表 from 表名 where 筛选条件;</code></p>\n<ul>\n<li>先执行from，然后执行筛选，最后是查询</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li><p>按条件表达式筛选</p>\n<p>条件运算符：&gt; &lt; = ‘!=不等于’ ‘&lt;&gt;不等于’ &lt;= &gt;=</p>\n<p>关键是分清楚：要查什么，条件是什么</p>\n<blockquote>\n<p>查询：工资 &gt; 12000 的员工信息</p>\n<p>​    要查的是员工信息，条件是工资；</p>\n<p>查询：部门编号不等于90的员工名和部门编号</p>\n<p>​    要查的是员工名和部门编号，条件是部门编号不等于90；</p>\n</blockquote>\n</li>\n<li><p>按逻辑运算符</p>\n<p>&amp;&amp;   ||    !  </p>\n<p>and  or  not</p>\n<p><strong>用于连接条件表达式</strong></p>\n<blockquote>\n<p>查询：工资在10000和20000之间的员工名，工资以及奖金</p>\n<p>查询：部门编号不是在90和110之间，或者工资高于15000的员工信息</p>\n</blockquote>\n</li>\n<li><p>==<strong>模糊运算符</strong>==</p>\n<p><strong>like</strong></p>\n<blockquote>\n<p>查询：员工名中包含字符a的员工信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * </span><br><span class=\"line\">from employees</span><br><span class=\"line\">where last_name LIKE &#39;%a%&#39;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li><code>%</code>表示一种通配符</li>\n<li>一般要和通配符结合使用：</li>\n</ul>\n<blockquote>\n<p>% - 任意多个字符，包括 0 个字符</p>\n<p>_  - 任意单个字符</p>\n<p><strong>如果查询第二个字符为 _ 的员工，那么就要进行转义！</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name</span><br><span class=\"line\">from employees</span><br><span class=\"line\">where last_name like &#39;_\\_%&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\"># 也可以自定义一个转义符号，用ESCAPE字符</span><br><span class=\"line\">where last_name like &#39;_$_%&#39; escape &#39;$&#39;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>between and</strong> - 提高简洁度</p>\n<blockquote>\n<p>查询员工编号在100和120之间的员工信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select *</span><br><span class=\"line\">from employees</span><br><span class=\"line\">where employee_id BETWEEN 100 AND 120;</span><br><span class=\"line\"></span><br><span class=\"line\"># 明显好于之前的方法</span><br><span class=\"line\">where employee_id &gt;&#x3D; 100 AND employee_id &lt;&#x3D; 120;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>区间包含临界值</li>\n<li>between 后面的数字要比 and 后面的小，不能调换顺序，否则会出错！</li>\n</ul>\n<p><strong>in</strong></p>\n<ul>\n<li>判断某字段的值是否属于in列表中的某一值</li>\n<li>in 列表中的值类型必须一致或者兼容（就是可以转换，例如 ‘123’ 和 123）</li>\n<li>不能套用通配符</li>\n</ul>\n<blockquote>\n<p>查询：员工的工种编号 是 IT_PROG、AD_VP、AD_PRES中的员工名和工种编号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name, job_id</span><br><span class=\"line\">from employees</span><br><span class=\"line\">where job_id IN(&#39;IT_PROG&#39;, &#39;AD_VP&#39;, &#39;AD_PRES&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"># 比使用OR来解决要方便很多</span><br><span class=\"line\">where job_id&#x3D;&#39;IT_PROT&#39; OR job_id&#x3D;&#39;AD_VP&#39; OR job_id&#x3D;&#39;AD_PRES&#39;;</span><br><span class=\"line\"># 也就是说 in 和上面语句中的 等于号&#x3D; 是一致的</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>is null</strong></p>\n<ul>\n<li>==”普通的等于号=“== 不能判断NULL值，但是可以使用 “IS NULL” 进行判断</li>\n<li>is null 或 is not null可以判断null值</li>\n</ul>\n<blockquote>\n<p>查询：没有奖金的员工名和奖金率</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name, commission_pct</span><br><span class=\"line\">from employees</span><br><span class=\"line\">where commission_pct IS NULL;</span><br></pre></td></tr></table></figure>\n<p>查询：有奖金的？==IS NOT NULL==</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"DML语言\"><a href=\"#DML语言\" class=\"headerlink\" title=\"DML语言\"></a>DML语言</h3><ul>\n<li>增删改</li>\n</ul>\n<h3 id=\"DDL语言\"><a href=\"#DDL语言\" class=\"headerlink\" title=\"DDL语言\"></a>DDL语言</h3><h3 id=\"TCL语言、DCL语言\"><a href=\"#TCL语言、DCL语言\" class=\"headerlink\" title=\"TCL语言、DCL语言\"></a>TCL语言、DCL语言</h3>","site":{"data":{}},"excerpt":"<h2 id=\"语言基础\"><a href=\"#语言基础\" class=\"headerlink\" title=\"语言基础\"></a>语言基础</h2><p>注释：<code>#</code></p>\n<p>调用某个库：<code>use databases</code></p>\n<p>着重号<code>xxx</code></p>","more":"<h3 id=\"DQL语言\"><a href=\"#DQL语言\" class=\"headerlink\" title=\"DQL语言\"></a>DQL语言</h3><ol>\n<li><p>基础查询</p>\n<p><code>select 查询列表 from 表名；</code></p>\n</li>\n</ol>\n<ul>\n<li><p>查询列表：</p>\n<ul>\n<li>表中字段</li>\n<li>常量值</li>\n<li>表达式</li>\n<li>函数</li>\n</ul>\n</li>\n<li><p>查询结果是一个虚拟的表格</p>\n</li>\n<li><p>查询表中的单个字段</p>\n<p><code>select last_name from  employees;</code></p>\n</li>\n<li><p>查询表中的多个字段，用逗号隔开</p>\n<p><code>select last_name,id from employees;</code></p>\n<ul>\n<li><strong>顺序随意 </strong>- 可以自定义</li>\n<li>不知道怎么拼，直接在图形化界面点就可以</li>\n<li>按<code>F12</code>就能排列好顺序</li>\n</ul>\n</li>\n<li><p>查全部 - <strong>顺序和表内会一模一样</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from employees</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li><p>查询常量值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select 100;</span><br><span class=\"line\"></span><br><span class=\"line\">select &#39;john&#39;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查询表达式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select 100*98;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查询函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select version();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>起别名 </p>\n<ul>\n<li><p>方式一：as</p>\n</li>\n<li><p>在查询的字段有比较高的重复率时使用比较好</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select 100%98 as 结果;</span><br><span class=\"line\"></span><br><span class=\"line\">select last_name as 姓,last_name as 名 from employees;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方式二：空格</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name 姓,last_name 名 from employees;</span><br></pre></td></tr></table></figure>\n<p><strong>注意别名不能使用特殊符号，如果使用了，请加双引号” “ </strong></p>\n</li>\n<li><p>去重 - distinct</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct id from mydatabase</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>+号的作用</p>\n<ul>\n<li>+号在mysql中只有<strong>运算符</strong>的功能</li>\n<li>会试图将字符型转换为数值型，但是如果不能转换成功，<strong>字符型数值转换为0</strong></li>\n</ul>\n</li>\n<li><p>拼接</p>\n<ul>\n<li><p>比如把姓和名连接成一个字段：</p>\n<p>这样是不行的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name+first_name as 姓名 from employees;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>应当用concat 关键字进行连接</strong>，括号里面使用的是着重符号，而不全是单引号，像逗号才使用单引号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select CONCAT(&#39;first_name&#39;,&#39;last_name&#39;) as 姓名;</span><br></pre></td></tr></table></figure>\n<p>如果想用“，”隔开，那就使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select CONCAT(&#39;last_name&#39;,&#39;,&#39;,&#39;first_name&#39;) as out_put;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>如果其中有NULL字段，那么结果就会是NULL</strong></p>\n<p>为了消除这种null字段的影响，应当加上一些判断</p>\n<p><code>IFNULL(id_a, &#39;0&#39;)</code>函数可以判断<code>id_a</code>是不是null，如果是，就会取0；</p>\n</li>\n</ul>\n</li>\n<li><p>显示表的结构用 <code>DESC database;</code></p>\n</li>\n<li><p><strong>条件查询</strong></p>\n<p><code>select 查询列表 from 表名 where 筛选条件;</code></p>\n<ul>\n<li>先执行from，然后执行筛选，最后是查询</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li><p>按条件表达式筛选</p>\n<p>条件运算符：&gt; &lt; = ‘!=不等于’ ‘&lt;&gt;不等于’ &lt;= &gt;=</p>\n<p>关键是分清楚：要查什么，条件是什么</p>\n<blockquote>\n<p>查询：工资 &gt; 12000 的员工信息</p>\n<p>​    要查的是员工信息，条件是工资；</p>\n<p>查询：部门编号不等于90的员工名和部门编号</p>\n<p>​    要查的是员工名和部门编号，条件是部门编号不等于90；</p>\n</blockquote>\n</li>\n<li><p>按逻辑运算符</p>\n<p>&amp;&amp;   ||    !  </p>\n<p>and  or  not</p>\n<p><strong>用于连接条件表达式</strong></p>\n<blockquote>\n<p>查询：工资在10000和20000之间的员工名，工资以及奖金</p>\n<p>查询：部门编号不是在90和110之间，或者工资高于15000的员工信息</p>\n</blockquote>\n</li>\n<li><p>==<strong>模糊运算符</strong>==</p>\n<p><strong>like</strong></p>\n<blockquote>\n<p>查询：员工名中包含字符a的员工信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * </span><br><span class=\"line\">from employees</span><br><span class=\"line\">where last_name LIKE &#39;%a%&#39;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li><code>%</code>表示一种通配符</li>\n<li>一般要和通配符结合使用：</li>\n</ul>\n<blockquote>\n<p>% - 任意多个字符，包括 0 个字符</p>\n<p>_  - 任意单个字符</p>\n<p><strong>如果查询第二个字符为 _ 的员工，那么就要进行转义！</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name</span><br><span class=\"line\">from employees</span><br><span class=\"line\">where last_name like &#39;_\\_%&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\"># 也可以自定义一个转义符号，用ESCAPE字符</span><br><span class=\"line\">where last_name like &#39;_$_%&#39; escape &#39;$&#39;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>between and</strong> - 提高简洁度</p>\n<blockquote>\n<p>查询员工编号在100和120之间的员工信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select *</span><br><span class=\"line\">from employees</span><br><span class=\"line\">where employee_id BETWEEN 100 AND 120;</span><br><span class=\"line\"></span><br><span class=\"line\"># 明显好于之前的方法</span><br><span class=\"line\">where employee_id &gt;&#x3D; 100 AND employee_id &lt;&#x3D; 120;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>区间包含临界值</li>\n<li>between 后面的数字要比 and 后面的小，不能调换顺序，否则会出错！</li>\n</ul>\n<p><strong>in</strong></p>\n<ul>\n<li>判断某字段的值是否属于in列表中的某一值</li>\n<li>in 列表中的值类型必须一致或者兼容（就是可以转换，例如 ‘123’ 和 123）</li>\n<li>不能套用通配符</li>\n</ul>\n<blockquote>\n<p>查询：员工的工种编号 是 IT_PROG、AD_VP、AD_PRES中的员工名和工种编号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name, job_id</span><br><span class=\"line\">from employees</span><br><span class=\"line\">where job_id IN(&#39;IT_PROG&#39;, &#39;AD_VP&#39;, &#39;AD_PRES&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"># 比使用OR来解决要方便很多</span><br><span class=\"line\">where job_id&#x3D;&#39;IT_PROT&#39; OR job_id&#x3D;&#39;AD_VP&#39; OR job_id&#x3D;&#39;AD_PRES&#39;;</span><br><span class=\"line\"># 也就是说 in 和上面语句中的 等于号&#x3D; 是一致的</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>is null</strong></p>\n<ul>\n<li>==”普通的等于号=“== 不能判断NULL值，但是可以使用 “IS NULL” 进行判断</li>\n<li>is null 或 is not null可以判断null值</li>\n</ul>\n<blockquote>\n<p>查询：没有奖金的员工名和奖金率</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_name, commission_pct</span><br><span class=\"line\">from employees</span><br><span class=\"line\">where commission_pct IS NULL;</span><br></pre></td></tr></table></figure>\n<p>查询：有奖金的？==IS NOT NULL==</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"DML语言\"><a href=\"#DML语言\" class=\"headerlink\" title=\"DML语言\"></a>DML语言</h3><ul>\n<li>增删改</li>\n</ul>\n<h3 id=\"DDL语言\"><a href=\"#DDL语言\" class=\"headerlink\" title=\"DDL语言\"></a>DDL语言</h3><h3 id=\"TCL语言、DCL语言\"><a href=\"#TCL语言、DCL语言\" class=\"headerlink\" title=\"TCL语言、DCL语言\"></a>TCL语言、DCL语言</h3>"},{"title":"【机器学习】常见知识梳理（一）","date":"2020-08-03T01:10:23.000Z","_content":"\n各种包的存在已经使得生成一个机器学习代码十分方便，但是当遇到一个个分厂常见的名词时，可能还是需要从理论上了解一番。\n\n这里先不指定具体的框架，因为不论是tensorflow、keras、pytorch、caffe、mxnet几乎都会有这些内容，区别可能是名称或者方法的具体路径不同。\n\n<!--more-->\n\n## 模型\n\n### 层-layer-积木\n\n**dense层**或fully connect（FC）层\n\n- 全连接层\n\nflatten扁平层\n\n- 多维的输入一维化，常用在从卷积层到全连接层的过渡，不影响batch的大小\n\nsoftmax层\n\n- 柔性最大化层，将神经网络的输出结果转化为概率分布，从而便于使用交叉熵\n\n卷积层conv\n\n- **卷积层的内容涉及卷积神经网络，可以单独说，这一部分比较多**\n\nbatch normaliazation（BN）层\n\n- 归一化层\n\n此外还有池化层 pooling layer等，这些层就是构成模型的基础层，绝大多数神经网络都建立在这些层的组合之上。\n\n\n\n### 优化方法-optimizer\n\n神经网络普遍使用**“梯度下降-Gradient Descent”**的算法来对网络中的参数进行迭代优化。\n\n可以这样想象：如果没有优化，网络中的参数就是静态的，那可能不是最优化的；经典案例——下山的例子告诉我们，按照最大梯度方向走出一定步长就可以实现下山，从而找到我们想要的山谷点；如果网络参数不是最大梯度方向，那我们就可以根据误差值来修正网络参数，从而使其更加准确。\n\n> 梯度爆炸和梯度消失问题\n\n有三种常用的优化方法：随机梯度下降-SGD、RMSprop、Adam。\n\n它们的原理稍有些复杂，好在大多数框架已经进行了封装，可以先进行使用尝试，后续再谈。\n\n\n\n### 损失函数-loss function\n\n也可以叫误差函数，成本函数，代价函数（cost function），总之是表示神经网络计算结果与真实结果之间的误差的一种函数。\n\n如果只是数字，当然可以直接比两个数字是不是很接近，但是当人们发现评价一个模型的loss或者cost也需要加入用时甚至使用的空间时，代价函数的形式就需要进行调整了。\n\n常用的loss function有：\n\n- MSE：（预测值和真实值之间）均方误差\n\n- binary cross-entropy：二分交叉熵，也可以叫二分对数损失；适合二元标签预测\n\n- categorical cross-entropy： 多分类对数损失，分类交叉熵，多分类标签预测，是与激活函数softmax关联的默认选择\n\n  \n\n### 反向传播算法-Back propagation\n\n神经网络的精髓。\n\n反向传播的数学原理就是数学中的链式法则。\n\n![链式法则](https://pic3.zhimg.com/v2-14ae4c7f3ed45de439d457471bcb6b7a_1440w.jpg?source=172ae18b)\n\n反向传播的目的是不断优化网络中的参数。\n\n## 改进\n\n### padding-加边\n\n- stride-步长\n- filter\n\npadding的目的之一是保持数据大小的稳定，添加一些没有信息的边界，也扩大了输出的大小；\n\n目的之二是充分利用边界信息。\n\n### pooling-池化\n\n- 常见的有最大池化（Max Pooling）和平均池化（Average Pooling）方法\n\n  ![image-20200804093720762](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200804093720762.png)\n\n- 这是一种有效压缩图像信息的方法\n\n### dropout-丢弃\n\n神经网络和人脑不同的地方在于，人脑目前看来是真正的概率性，神经网络在计算机中其实是确定的程序。\n\n为了增加神经网络的泛化能力，我们可以随机地丢弃一部分网络（不会影响总体的结构），如果这样的**网络仍能正确分类或者决策**，那岂不是说明**该网络比原网络有更强的泛化能力**，实验证明Dropout的处理方式有利于提高模型的准确性和泛化能力。\n\n## 训练\n\n模型的训练需要大量的数据，也就需要很强的算力，这也是为什么神经网络的思想早已出现，但直到几年前才开始爆发式发展的原因之一。\n\n目前训练数据的基本思路是：\n\n- 把一组完整的大量的数据分成两部分，一部分数据量大一点，作为训练集（training data），一部分数据量小一点，作为测试集（test data）\n\n- 训练数据还要分成一个个小的批次，可以认为是batch，每一个batch中的数据多少，是batch size\n\n  > 之所以这样做，一方面是因为数据训练时会进入内存，然后分配到CPU或者GPU中进行运算，如果进入内存的数据过多，可能会影响计算速度；另一方面，如果一次性把所有数据进行计算，相当于一次计算只更新了一次模型参数，其实收益很小。\n  >\n  > 如果分成小批量进行计算，每计算一次就更新了一次模型参数，这样比原来能多更新几次，增加了训练的收益。\n\n- 把所有的训练集数据批运算完一遍，称作一个epoch，可以设定多个epoch，这样就可以不断进行迭代优化\n\n- 最后再拿出宝贵的测试集数据，用模型测试一下，获得准确度。\n\n怎么划分训练集和测试集、如何定义批量大小和epoch大小，也是神经网络优化的一个大问题。\n\n总体来说，划分训练集和测试集越随机越好，模型准确度随批量大小和epoch大小的变化则是先升后降。\n\n毕竟就算把**训练集**训练无数遍，甚至能默写，这也不是想要的学习，还可能产生**过拟合**的问题，提高**泛化能力**才是真正的学习。","source":"_posts/机器学习-常见知识梳理一.md","raw":"---\ntitle: 【机器学习】常见知识梳理（一）\ndate: 2020-08-03 09:10:23\ncategories:\n\t- 机器学习\ntags:\n\t- 神经网络\n---\n\n各种包的存在已经使得生成一个机器学习代码十分方便，但是当遇到一个个分厂常见的名词时，可能还是需要从理论上了解一番。\n\n这里先不指定具体的框架，因为不论是tensorflow、keras、pytorch、caffe、mxnet几乎都会有这些内容，区别可能是名称或者方法的具体路径不同。\n\n<!--more-->\n\n## 模型\n\n### 层-layer-积木\n\n**dense层**或fully connect（FC）层\n\n- 全连接层\n\nflatten扁平层\n\n- 多维的输入一维化，常用在从卷积层到全连接层的过渡，不影响batch的大小\n\nsoftmax层\n\n- 柔性最大化层，将神经网络的输出结果转化为概率分布，从而便于使用交叉熵\n\n卷积层conv\n\n- **卷积层的内容涉及卷积神经网络，可以单独说，这一部分比较多**\n\nbatch normaliazation（BN）层\n\n- 归一化层\n\n此外还有池化层 pooling layer等，这些层就是构成模型的基础层，绝大多数神经网络都建立在这些层的组合之上。\n\n\n\n### 优化方法-optimizer\n\n神经网络普遍使用**“梯度下降-Gradient Descent”**的算法来对网络中的参数进行迭代优化。\n\n可以这样想象：如果没有优化，网络中的参数就是静态的，那可能不是最优化的；经典案例——下山的例子告诉我们，按照最大梯度方向走出一定步长就可以实现下山，从而找到我们想要的山谷点；如果网络参数不是最大梯度方向，那我们就可以根据误差值来修正网络参数，从而使其更加准确。\n\n> 梯度爆炸和梯度消失问题\n\n有三种常用的优化方法：随机梯度下降-SGD、RMSprop、Adam。\n\n它们的原理稍有些复杂，好在大多数框架已经进行了封装，可以先进行使用尝试，后续再谈。\n\n\n\n### 损失函数-loss function\n\n也可以叫误差函数，成本函数，代价函数（cost function），总之是表示神经网络计算结果与真实结果之间的误差的一种函数。\n\n如果只是数字，当然可以直接比两个数字是不是很接近，但是当人们发现评价一个模型的loss或者cost也需要加入用时甚至使用的空间时，代价函数的形式就需要进行调整了。\n\n常用的loss function有：\n\n- MSE：（预测值和真实值之间）均方误差\n\n- binary cross-entropy：二分交叉熵，也可以叫二分对数损失；适合二元标签预测\n\n- categorical cross-entropy： 多分类对数损失，分类交叉熵，多分类标签预测，是与激活函数softmax关联的默认选择\n\n  \n\n### 反向传播算法-Back propagation\n\n神经网络的精髓。\n\n反向传播的数学原理就是数学中的链式法则。\n\n![链式法则](https://pic3.zhimg.com/v2-14ae4c7f3ed45de439d457471bcb6b7a_1440w.jpg?source=172ae18b)\n\n反向传播的目的是不断优化网络中的参数。\n\n## 改进\n\n### padding-加边\n\n- stride-步长\n- filter\n\npadding的目的之一是保持数据大小的稳定，添加一些没有信息的边界，也扩大了输出的大小；\n\n目的之二是充分利用边界信息。\n\n### pooling-池化\n\n- 常见的有最大池化（Max Pooling）和平均池化（Average Pooling）方法\n\n  ![image-20200804093720762](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200804093720762.png)\n\n- 这是一种有效压缩图像信息的方法\n\n### dropout-丢弃\n\n神经网络和人脑不同的地方在于，人脑目前看来是真正的概率性，神经网络在计算机中其实是确定的程序。\n\n为了增加神经网络的泛化能力，我们可以随机地丢弃一部分网络（不会影响总体的结构），如果这样的**网络仍能正确分类或者决策**，那岂不是说明**该网络比原网络有更强的泛化能力**，实验证明Dropout的处理方式有利于提高模型的准确性和泛化能力。\n\n## 训练\n\n模型的训练需要大量的数据，也就需要很强的算力，这也是为什么神经网络的思想早已出现，但直到几年前才开始爆发式发展的原因之一。\n\n目前训练数据的基本思路是：\n\n- 把一组完整的大量的数据分成两部分，一部分数据量大一点，作为训练集（training data），一部分数据量小一点，作为测试集（test data）\n\n- 训练数据还要分成一个个小的批次，可以认为是batch，每一个batch中的数据多少，是batch size\n\n  > 之所以这样做，一方面是因为数据训练时会进入内存，然后分配到CPU或者GPU中进行运算，如果进入内存的数据过多，可能会影响计算速度；另一方面，如果一次性把所有数据进行计算，相当于一次计算只更新了一次模型参数，其实收益很小。\n  >\n  > 如果分成小批量进行计算，每计算一次就更新了一次模型参数，这样比原来能多更新几次，增加了训练的收益。\n\n- 把所有的训练集数据批运算完一遍，称作一个epoch，可以设定多个epoch，这样就可以不断进行迭代优化\n\n- 最后再拿出宝贵的测试集数据，用模型测试一下，获得准确度。\n\n怎么划分训练集和测试集、如何定义批量大小和epoch大小，也是神经网络优化的一个大问题。\n\n总体来说，划分训练集和测试集越随机越好，模型准确度随批量大小和epoch大小的变化则是先升后降。\n\n毕竟就算把**训练集**训练无数遍，甚至能默写，这也不是想要的学习，还可能产生**过拟合**的问题，提高**泛化能力**才是真正的学习。","slug":"机器学习-常见知识梳理一","published":1,"updated":"2021-01-26T06:23:11.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n8890015k8tlaifse32a","content":"<p>各种包的存在已经使得生成一个机器学习代码十分方便，但是当遇到一个个分厂常见的名词时，可能还是需要从理论上了解一番。</p>\n<p>这里先不指定具体的框架，因为不论是tensorflow、keras、pytorch、caffe、mxnet几乎都会有这些内容，区别可能是名称或者方法的具体路径不同。</p>\n<a id=\"more\"></a>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><h3 id=\"层-layer-积木\"><a href=\"#层-layer-积木\" class=\"headerlink\" title=\"层-layer-积木\"></a>层-layer-积木</h3><p><strong>dense层</strong>或fully connect（FC）层</p>\n<ul>\n<li>全连接层</li>\n</ul>\n<p>flatten扁平层</p>\n<ul>\n<li>多维的输入一维化，常用在从卷积层到全连接层的过渡，不影响batch的大小</li>\n</ul>\n<p>softmax层</p>\n<ul>\n<li>柔性最大化层，将神经网络的输出结果转化为概率分布，从而便于使用交叉熵</li>\n</ul>\n<p>卷积层conv</p>\n<ul>\n<li><strong>卷积层的内容涉及卷积神经网络，可以单独说，这一部分比较多</strong></li>\n</ul>\n<p>batch normaliazation（BN）层</p>\n<ul>\n<li>归一化层</li>\n</ul>\n<p>此外还有池化层 pooling layer等，这些层就是构成模型的基础层，绝大多数神经网络都建立在这些层的组合之上。</p>\n<h3 id=\"优化方法-optimizer\"><a href=\"#优化方法-optimizer\" class=\"headerlink\" title=\"优化方法-optimizer\"></a>优化方法-optimizer</h3><p>神经网络普遍使用<strong>“梯度下降-Gradient Descent”</strong>的算法来对网络中的参数进行迭代优化。</p>\n<p>可以这样想象：如果没有优化，网络中的参数就是静态的，那可能不是最优化的；经典案例——下山的例子告诉我们，按照最大梯度方向走出一定步长就可以实现下山，从而找到我们想要的山谷点；如果网络参数不是最大梯度方向，那我们就可以根据误差值来修正网络参数，从而使其更加准确。</p>\n<blockquote>\n<p>梯度爆炸和梯度消失问题</p>\n</blockquote>\n<p>有三种常用的优化方法：随机梯度下降-SGD、RMSprop、Adam。</p>\n<p>它们的原理稍有些复杂，好在大多数框架已经进行了封装，可以先进行使用尝试，后续再谈。</p>\n<h3 id=\"损失函数-loss-function\"><a href=\"#损失函数-loss-function\" class=\"headerlink\" title=\"损失函数-loss function\"></a>损失函数-loss function</h3><p>也可以叫误差函数，成本函数，代价函数（cost function），总之是表示神经网络计算结果与真实结果之间的误差的一种函数。</p>\n<p>如果只是数字，当然可以直接比两个数字是不是很接近，但是当人们发现评价一个模型的loss或者cost也需要加入用时甚至使用的空间时，代价函数的形式就需要进行调整了。</p>\n<p>常用的loss function有：</p>\n<ul>\n<li><p>MSE：（预测值和真实值之间）均方误差</p>\n</li>\n<li><p>binary cross-entropy：二分交叉熵，也可以叫二分对数损失；适合二元标签预测</p>\n</li>\n<li><p>categorical cross-entropy： 多分类对数损失，分类交叉熵，多分类标签预测，是与激活函数softmax关联的默认选择</p>\n</li>\n</ul>\n<h3 id=\"反向传播算法-Back-propagation\"><a href=\"#反向传播算法-Back-propagation\" class=\"headerlink\" title=\"反向传播算法-Back propagation\"></a>反向传播算法-Back propagation</h3><p>神经网络的精髓。</p>\n<p>反向传播的数学原理就是数学中的链式法则。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-14ae4c7f3ed45de439d457471bcb6b7a_1440w.jpg?source=172ae18b\" alt=\"链式法则\"></p>\n<p>反向传播的目的是不断优化网络中的参数。</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><h3 id=\"padding-加边\"><a href=\"#padding-加边\" class=\"headerlink\" title=\"padding-加边\"></a>padding-加边</h3><ul>\n<li>stride-步长</li>\n<li>filter</li>\n</ul>\n<p>padding的目的之一是保持数据大小的稳定，添加一些没有信息的边界，也扩大了输出的大小；</p>\n<p>目的之二是充分利用边界信息。</p>\n<h3 id=\"pooling-池化\"><a href=\"#pooling-池化\" class=\"headerlink\" title=\"pooling-池化\"></a>pooling-池化</h3><ul>\n<li><p>常见的有最大池化（Max Pooling）和平均池化（Average Pooling）方法</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200804093720762.png\" alt=\"image-20200804093720762\"></p>\n</li>\n<li><p>这是一种有效压缩图像信息的方法</p>\n</li>\n</ul>\n<h3 id=\"dropout-丢弃\"><a href=\"#dropout-丢弃\" class=\"headerlink\" title=\"dropout-丢弃\"></a>dropout-丢弃</h3><p>神经网络和人脑不同的地方在于，人脑目前看来是真正的概率性，神经网络在计算机中其实是确定的程序。</p>\n<p>为了增加神经网络的泛化能力，我们可以随机地丢弃一部分网络（不会影响总体的结构），如果这样的<strong>网络仍能正确分类或者决策</strong>，那岂不是说明<strong>该网络比原网络有更强的泛化能力</strong>，实验证明Dropout的处理方式有利于提高模型的准确性和泛化能力。</p>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p>模型的训练需要大量的数据，也就需要很强的算力，这也是为什么神经网络的思想早已出现，但直到几年前才开始爆发式发展的原因之一。</p>\n<p>目前训练数据的基本思路是：</p>\n<ul>\n<li><p>把一组完整的大量的数据分成两部分，一部分数据量大一点，作为训练集（training data），一部分数据量小一点，作为测试集（test data）</p>\n</li>\n<li><p>训练数据还要分成一个个小的批次，可以认为是batch，每一个batch中的数据多少，是batch size</p>\n<blockquote>\n<p>之所以这样做，一方面是因为数据训练时会进入内存，然后分配到CPU或者GPU中进行运算，如果进入内存的数据过多，可能会影响计算速度；另一方面，如果一次性把所有数据进行计算，相当于一次计算只更新了一次模型参数，其实收益很小。</p>\n<p>如果分成小批量进行计算，每计算一次就更新了一次模型参数，这样比原来能多更新几次，增加了训练的收益。</p>\n</blockquote>\n</li>\n<li><p>把所有的训练集数据批运算完一遍，称作一个epoch，可以设定多个epoch，这样就可以不断进行迭代优化</p>\n</li>\n<li><p>最后再拿出宝贵的测试集数据，用模型测试一下，获得准确度。</p>\n</li>\n</ul>\n<p>怎么划分训练集和测试集、如何定义批量大小和epoch大小，也是神经网络优化的一个大问题。</p>\n<p>总体来说，划分训练集和测试集越随机越好，模型准确度随批量大小和epoch大小的变化则是先升后降。</p>\n<p>毕竟就算把<strong>训练集</strong>训练无数遍，甚至能默写，这也不是想要的学习，还可能产生<strong>过拟合</strong>的问题，提高<strong>泛化能力</strong>才是真正的学习。</p>\n","site":{"data":{}},"excerpt":"<p>各种包的存在已经使得生成一个机器学习代码十分方便，但是当遇到一个个分厂常见的名词时，可能还是需要从理论上了解一番。</p>\n<p>这里先不指定具体的框架，因为不论是tensorflow、keras、pytorch、caffe、mxnet几乎都会有这些内容，区别可能是名称或者方法的具体路径不同。</p>","more":"<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><h3 id=\"层-layer-积木\"><a href=\"#层-layer-积木\" class=\"headerlink\" title=\"层-layer-积木\"></a>层-layer-积木</h3><p><strong>dense层</strong>或fully connect（FC）层</p>\n<ul>\n<li>全连接层</li>\n</ul>\n<p>flatten扁平层</p>\n<ul>\n<li>多维的输入一维化，常用在从卷积层到全连接层的过渡，不影响batch的大小</li>\n</ul>\n<p>softmax层</p>\n<ul>\n<li>柔性最大化层，将神经网络的输出结果转化为概率分布，从而便于使用交叉熵</li>\n</ul>\n<p>卷积层conv</p>\n<ul>\n<li><strong>卷积层的内容涉及卷积神经网络，可以单独说，这一部分比较多</strong></li>\n</ul>\n<p>batch normaliazation（BN）层</p>\n<ul>\n<li>归一化层</li>\n</ul>\n<p>此外还有池化层 pooling layer等，这些层就是构成模型的基础层，绝大多数神经网络都建立在这些层的组合之上。</p>\n<h3 id=\"优化方法-optimizer\"><a href=\"#优化方法-optimizer\" class=\"headerlink\" title=\"优化方法-optimizer\"></a>优化方法-optimizer</h3><p>神经网络普遍使用<strong>“梯度下降-Gradient Descent”</strong>的算法来对网络中的参数进行迭代优化。</p>\n<p>可以这样想象：如果没有优化，网络中的参数就是静态的，那可能不是最优化的；经典案例——下山的例子告诉我们，按照最大梯度方向走出一定步长就可以实现下山，从而找到我们想要的山谷点；如果网络参数不是最大梯度方向，那我们就可以根据误差值来修正网络参数，从而使其更加准确。</p>\n<blockquote>\n<p>梯度爆炸和梯度消失问题</p>\n</blockquote>\n<p>有三种常用的优化方法：随机梯度下降-SGD、RMSprop、Adam。</p>\n<p>它们的原理稍有些复杂，好在大多数框架已经进行了封装，可以先进行使用尝试，后续再谈。</p>\n<h3 id=\"损失函数-loss-function\"><a href=\"#损失函数-loss-function\" class=\"headerlink\" title=\"损失函数-loss function\"></a>损失函数-loss function</h3><p>也可以叫误差函数，成本函数，代价函数（cost function），总之是表示神经网络计算结果与真实结果之间的误差的一种函数。</p>\n<p>如果只是数字，当然可以直接比两个数字是不是很接近，但是当人们发现评价一个模型的loss或者cost也需要加入用时甚至使用的空间时，代价函数的形式就需要进行调整了。</p>\n<p>常用的loss function有：</p>\n<ul>\n<li><p>MSE：（预测值和真实值之间）均方误差</p>\n</li>\n<li><p>binary cross-entropy：二分交叉熵，也可以叫二分对数损失；适合二元标签预测</p>\n</li>\n<li><p>categorical cross-entropy： 多分类对数损失，分类交叉熵，多分类标签预测，是与激活函数softmax关联的默认选择</p>\n</li>\n</ul>\n<h3 id=\"反向传播算法-Back-propagation\"><a href=\"#反向传播算法-Back-propagation\" class=\"headerlink\" title=\"反向传播算法-Back propagation\"></a>反向传播算法-Back propagation</h3><p>神经网络的精髓。</p>\n<p>反向传播的数学原理就是数学中的链式法则。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-14ae4c7f3ed45de439d457471bcb6b7a_1440w.jpg?source=172ae18b\" alt=\"链式法则\"></p>\n<p>反向传播的目的是不断优化网络中的参数。</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><h3 id=\"padding-加边\"><a href=\"#padding-加边\" class=\"headerlink\" title=\"padding-加边\"></a>padding-加边</h3><ul>\n<li>stride-步长</li>\n<li>filter</li>\n</ul>\n<p>padding的目的之一是保持数据大小的稳定，添加一些没有信息的边界，也扩大了输出的大小；</p>\n<p>目的之二是充分利用边界信息。</p>\n<h3 id=\"pooling-池化\"><a href=\"#pooling-池化\" class=\"headerlink\" title=\"pooling-池化\"></a>pooling-池化</h3><ul>\n<li><p>常见的有最大池化（Max Pooling）和平均池化（Average Pooling）方法</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200804093720762.png\" alt=\"image-20200804093720762\"></p>\n</li>\n<li><p>这是一种有效压缩图像信息的方法</p>\n</li>\n</ul>\n<h3 id=\"dropout-丢弃\"><a href=\"#dropout-丢弃\" class=\"headerlink\" title=\"dropout-丢弃\"></a>dropout-丢弃</h3><p>神经网络和人脑不同的地方在于，人脑目前看来是真正的概率性，神经网络在计算机中其实是确定的程序。</p>\n<p>为了增加神经网络的泛化能力，我们可以随机地丢弃一部分网络（不会影响总体的结构），如果这样的<strong>网络仍能正确分类或者决策</strong>，那岂不是说明<strong>该网络比原网络有更强的泛化能力</strong>，实验证明Dropout的处理方式有利于提高模型的准确性和泛化能力。</p>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p>模型的训练需要大量的数据，也就需要很强的算力，这也是为什么神经网络的思想早已出现，但直到几年前才开始爆发式发展的原因之一。</p>\n<p>目前训练数据的基本思路是：</p>\n<ul>\n<li><p>把一组完整的大量的数据分成两部分，一部分数据量大一点，作为训练集（training data），一部分数据量小一点，作为测试集（test data）</p>\n</li>\n<li><p>训练数据还要分成一个个小的批次，可以认为是batch，每一个batch中的数据多少，是batch size</p>\n<blockquote>\n<p>之所以这样做，一方面是因为数据训练时会进入内存，然后分配到CPU或者GPU中进行运算，如果进入内存的数据过多，可能会影响计算速度；另一方面，如果一次性把所有数据进行计算，相当于一次计算只更新了一次模型参数，其实收益很小。</p>\n<p>如果分成小批量进行计算，每计算一次就更新了一次模型参数，这样比原来能多更新几次，增加了训练的收益。</p>\n</blockquote>\n</li>\n<li><p>把所有的训练集数据批运算完一遍，称作一个epoch，可以设定多个epoch，这样就可以不断进行迭代优化</p>\n</li>\n<li><p>最后再拿出宝贵的测试集数据，用模型测试一下，获得准确度。</p>\n</li>\n</ul>\n<p>怎么划分训练集和测试集、如何定义批量大小和epoch大小，也是神经网络优化的一个大问题。</p>\n<p>总体来说，划分训练集和测试集越随机越好，模型准确度随批量大小和epoch大小的变化则是先升后降。</p>\n<p>毕竟就算把<strong>训练集</strong>训练无数遍，甚至能默写，这也不是想要的学习，还可能产生<strong>过拟合</strong>的问题，提高<strong>泛化能力</strong>才是真正的学习。</p>"},{"title":"春招-字节笔试","date":"2021-03-14T13:36:38.000Z","_content":"\n# 体验\n\n平台：牛客网\n\n特点：\n\n1. 标准 sys 输入和输出，给输入和输出的范例，主要是多行输入和单行输出\n2. 可以自测，可以print\n\n# 题目\n\n总共有四道题目\n\n## 1）环形数组 - 找座位问题\n\n给出一个环形数组，其中全部为 0 或 1\n\n请找到一个 0，它距离两侧的 1 应该最远\n\n<!--more-->\n\n比如：\n\n【0 0 0 0 0 1 0 0】\n\n那么 应该是在索引2的位置放1，距离最远，最远距离为 4\n\n分析：\n\n其实就是找两个 1 之间最大距离，或者说 连续 0 的最多数量\n\n我的方法就是找 两个 1 之间的最大距离\n\n而且，为了满足环形要求，直接在现在的数组后面续上一个数组\n\n这样遍历一遍，就能解决问题了\n\n【本题全部测试用例通过，10分】\n\n## 2）多叉树寻根问题\n\n问题描述：\n\n一个初代病毒 T 可以分裂出多个子代病毒\n\n子代病毒还可以继续分裂\n\n原病毒是无致命性的，但是分裂和遗传的过程中可能会有致命性\n\n如果已知某几个病毒是有致命性的，请找出它们的最近的共同根节点\n\n输入的写法【多行输入】：\n\nN 个病毒，R 条分裂\n\nM个致病：编号依次是\n\n分裂关系1：亲代、子代数量、子代编号\n\n分裂关系2：亲代、子代数量、子代编号\n\n分析：\n\n其实本题充分描绘了一颗多叉树的全貌，但是问题是：\n\n（1）如何进行还原\n\n（2）怎么样找最近的\n\n我首先想到的就是 Union-find 并查集的方法，一个建图的问题\n\n复习一下：并查集问题涉及以下几个步骤：\n\nunion - 建图\n\nconnected - 判断是不是连通\n\ncount - 用于计数（对于岛屿问题可以使用）\n\n在建图和判断连通的过程中，会使用 find 函数寻找根节点\n\n那么本题中虽然有非常明确的多叉树结构，但是还不需要把全图建好，重要的是根据 find 函数寻找到根节点\n\n所以我的方法就是根据所给树的信息建立 parents 的表单\n\n> 因为输入信息中 父 - 子 节点的关系十分明确，可以直接对子节点存储 parent 的情况\n\n然后就是比较 各致命病毒 的父节点，什么是否是一样的？\n\n- 这个问题有点难，我想的可能不够完整\n\n我的想法是：\n\n由于该树中，其实大小是有一定的顺序的，是一颗二叉搜索树\n\n致命病毒id 也是有顺序的，可以根据最小的节点为标准\n\n如果别的病毒的父节点 id > 该节点的父节点 id，那么其他病毒就找父节点，然后再比较父节点\n\n只有 别的病毒的父节点 id < 该节点的父节点 id 时，才会找该节点的父节点 id\n\n---\n\n几点说明：\n\n共同父节点是一定存在的，怎么说 0 也是共节点\n\n但是要找的是最近的\n\n【结果，本题通过了 70% 的测试用例， 本题30分】\n\n## 3）破解机关问题 - 环形数组\n\n这个问题很有意思，我也想问\n\n比如原神中有多个火柱子，初始状态有亮 - 1，有灭 - 0\n\n请问怎么样用最少的次数将所有的火柱子都点亮，如果不能全部点亮，就返回 -1\n\n举例：\n\n10\n\n0 1 1 0 0 0 1 0 0 1\n\n最后应该是 4次就可以将所有火柱子点亮\n\n分析：\n\n我的方法应该是贪心算法\n\n只要遇到0，那么下一个柱子就点亮，这样会同时影响 i, i+1, i+2三个柱子的值：\n\n```python\nif f[i] == 0:\n    f[i] = 1\n    f[i+1] = int(f[i+1]==0)\n    f[i+2] = int(f[i+2]==0)\n```\n\n个人觉得这个地方的逻辑判断做的还可以：\n\n如果 `f[i+1]=1`，那么，就会变成 false - 0\n\n如果 `f[i+1]=0`，那么，就会变成 true - 1\n\n相当于是与 0 异或\n\n按照这种方法前面都好说，但是当 i = n - 2的时候， i + 2 = n，会超出索引\n\n由于这是一个环形，所以需要把第一个柱子续在后面，一个即可【应该吧】\n\n我当时的判断条件是：当 i = n - 1时，如果 f[i] = 0，那么就判断 false\n\n但是现在看来还是不太对\n\n因为 i = n - 2的时候， i + 2 = n，会改掉第一个柱子的值，这样还是不太对\n\n应该是 i = n - 2 的时候，如果 f [i] = 0，那么其实就是 false 了\n\n【本题最好的通过情况是 37.5% ， 本题30分】\n\n---\n\n而且这个方法对很多问题的算法并不是最佳的，比如：\n\n4\n\n0 0 1 0\n\n很显然一次就够了，但是按算法，会是 false\n\n## 4）棋盘游戏问题\n\n这类几何拓扑的问题，一看到就想放弃，确实不擅长做，主要是觉得二维进行遍历和存储的时候很麻烦\n\n问题描述：\n\n给一个 n * m 的棋盘，以及棋盘的状态（有的位置是空的`·`，有的非空 `#`）\n\n有若干 1 * 2 的棋子可以进行填充\n\n问是不是可以用棋子将棋盘填满，**而且填法唯一**，返回唯一填法\n\n如果不是，就返回 -1\n\n---\n\n其实如果是唯一 填法，那么填起来应该也不会太难\n\n我们可以看几个案例：\n\n（1）\n\n```bash\n· ·\n\n· ·\n```\n\n这是 2x2 的棋盘，有两种方式可以填满，所以不是唯一的\n\n那么是不是说只要有这样的位置，就可以断定填不满了呢？不是\n\n（2）\n\n```bash\n· · #\n· · ·\n· # #\n```\n\n这是有唯一解的，唯一解为\n\n```bash\n< > #\n^ < >\nv # #\n```\n\n其中 `< >` 表示横着放的棋子，`^ v` 表示竖着放的棋子\n\n经过和同学的讨论，大家认为是这样，可以从头开始遍历，但是需要深度优先\n\n比如从左上角开始遍历：\n\n- 可能有两种放置方法，可以任选一种【任选也说明了多叉树的分支，这肯定要用回溯算法进行回调的，复杂度比较高】\n  - 但是最好有顺序，比如优先 横放，次之 竖放\n- 然后选择没有被占领的一个空格，看是不是可以放下棋子\n  - 如果放不下，这条路肯定走不通了，就要返回了\n  - 如果可以放下，那么继续选择旁边没有被占领的空格，遍历\n- 如果没有上面说的空格，那么就按照竖列，遍历到底\n  - 如果没有返回 false，肯定需要遍历完整个棋盘\n\n这个问题里面，如果有很多种解法，那么至少需要找到两组成功的解法，才能说明 false\n\n否则需要一直找下去，找不到成功解法才 false\n\n还是应该找一种能判断 false 的方法","source":"_posts/春招-字节笔试.md","raw":"---\ntitle: 春招-字节笔试\ndate: 2021-03-14 21:36:38\ncategories:\n\t- 算法\ntags:\n\t- bytedance\n\t- 笔试\n\t- 并查集\n\t- 数组\n---\n\n# 体验\n\n平台：牛客网\n\n特点：\n\n1. 标准 sys 输入和输出，给输入和输出的范例，主要是多行输入和单行输出\n2. 可以自测，可以print\n\n# 题目\n\n总共有四道题目\n\n## 1）环形数组 - 找座位问题\n\n给出一个环形数组，其中全部为 0 或 1\n\n请找到一个 0，它距离两侧的 1 应该最远\n\n<!--more-->\n\n比如：\n\n【0 0 0 0 0 1 0 0】\n\n那么 应该是在索引2的位置放1，距离最远，最远距离为 4\n\n分析：\n\n其实就是找两个 1 之间最大距离，或者说 连续 0 的最多数量\n\n我的方法就是找 两个 1 之间的最大距离\n\n而且，为了满足环形要求，直接在现在的数组后面续上一个数组\n\n这样遍历一遍，就能解决问题了\n\n【本题全部测试用例通过，10分】\n\n## 2）多叉树寻根问题\n\n问题描述：\n\n一个初代病毒 T 可以分裂出多个子代病毒\n\n子代病毒还可以继续分裂\n\n原病毒是无致命性的，但是分裂和遗传的过程中可能会有致命性\n\n如果已知某几个病毒是有致命性的，请找出它们的最近的共同根节点\n\n输入的写法【多行输入】：\n\nN 个病毒，R 条分裂\n\nM个致病：编号依次是\n\n分裂关系1：亲代、子代数量、子代编号\n\n分裂关系2：亲代、子代数量、子代编号\n\n分析：\n\n其实本题充分描绘了一颗多叉树的全貌，但是问题是：\n\n（1）如何进行还原\n\n（2）怎么样找最近的\n\n我首先想到的就是 Union-find 并查集的方法，一个建图的问题\n\n复习一下：并查集问题涉及以下几个步骤：\n\nunion - 建图\n\nconnected - 判断是不是连通\n\ncount - 用于计数（对于岛屿问题可以使用）\n\n在建图和判断连通的过程中，会使用 find 函数寻找根节点\n\n那么本题中虽然有非常明确的多叉树结构，但是还不需要把全图建好，重要的是根据 find 函数寻找到根节点\n\n所以我的方法就是根据所给树的信息建立 parents 的表单\n\n> 因为输入信息中 父 - 子 节点的关系十分明确，可以直接对子节点存储 parent 的情况\n\n然后就是比较 各致命病毒 的父节点，什么是否是一样的？\n\n- 这个问题有点难，我想的可能不够完整\n\n我的想法是：\n\n由于该树中，其实大小是有一定的顺序的，是一颗二叉搜索树\n\n致命病毒id 也是有顺序的，可以根据最小的节点为标准\n\n如果别的病毒的父节点 id > 该节点的父节点 id，那么其他病毒就找父节点，然后再比较父节点\n\n只有 别的病毒的父节点 id < 该节点的父节点 id 时，才会找该节点的父节点 id\n\n---\n\n几点说明：\n\n共同父节点是一定存在的，怎么说 0 也是共节点\n\n但是要找的是最近的\n\n【结果，本题通过了 70% 的测试用例， 本题30分】\n\n## 3）破解机关问题 - 环形数组\n\n这个问题很有意思，我也想问\n\n比如原神中有多个火柱子，初始状态有亮 - 1，有灭 - 0\n\n请问怎么样用最少的次数将所有的火柱子都点亮，如果不能全部点亮，就返回 -1\n\n举例：\n\n10\n\n0 1 1 0 0 0 1 0 0 1\n\n最后应该是 4次就可以将所有火柱子点亮\n\n分析：\n\n我的方法应该是贪心算法\n\n只要遇到0，那么下一个柱子就点亮，这样会同时影响 i, i+1, i+2三个柱子的值：\n\n```python\nif f[i] == 0:\n    f[i] = 1\n    f[i+1] = int(f[i+1]==0)\n    f[i+2] = int(f[i+2]==0)\n```\n\n个人觉得这个地方的逻辑判断做的还可以：\n\n如果 `f[i+1]=1`，那么，就会变成 false - 0\n\n如果 `f[i+1]=0`，那么，就会变成 true - 1\n\n相当于是与 0 异或\n\n按照这种方法前面都好说，但是当 i = n - 2的时候， i + 2 = n，会超出索引\n\n由于这是一个环形，所以需要把第一个柱子续在后面，一个即可【应该吧】\n\n我当时的判断条件是：当 i = n - 1时，如果 f[i] = 0，那么就判断 false\n\n但是现在看来还是不太对\n\n因为 i = n - 2的时候， i + 2 = n，会改掉第一个柱子的值，这样还是不太对\n\n应该是 i = n - 2 的时候，如果 f [i] = 0，那么其实就是 false 了\n\n【本题最好的通过情况是 37.5% ， 本题30分】\n\n---\n\n而且这个方法对很多问题的算法并不是最佳的，比如：\n\n4\n\n0 0 1 0\n\n很显然一次就够了，但是按算法，会是 false\n\n## 4）棋盘游戏问题\n\n这类几何拓扑的问题，一看到就想放弃，确实不擅长做，主要是觉得二维进行遍历和存储的时候很麻烦\n\n问题描述：\n\n给一个 n * m 的棋盘，以及棋盘的状态（有的位置是空的`·`，有的非空 `#`）\n\n有若干 1 * 2 的棋子可以进行填充\n\n问是不是可以用棋子将棋盘填满，**而且填法唯一**，返回唯一填法\n\n如果不是，就返回 -1\n\n---\n\n其实如果是唯一 填法，那么填起来应该也不会太难\n\n我们可以看几个案例：\n\n（1）\n\n```bash\n· ·\n\n· ·\n```\n\n这是 2x2 的棋盘，有两种方式可以填满，所以不是唯一的\n\n那么是不是说只要有这样的位置，就可以断定填不满了呢？不是\n\n（2）\n\n```bash\n· · #\n· · ·\n· # #\n```\n\n这是有唯一解的，唯一解为\n\n```bash\n< > #\n^ < >\nv # #\n```\n\n其中 `< >` 表示横着放的棋子，`^ v` 表示竖着放的棋子\n\n经过和同学的讨论，大家认为是这样，可以从头开始遍历，但是需要深度优先\n\n比如从左上角开始遍历：\n\n- 可能有两种放置方法，可以任选一种【任选也说明了多叉树的分支，这肯定要用回溯算法进行回调的，复杂度比较高】\n  - 但是最好有顺序，比如优先 横放，次之 竖放\n- 然后选择没有被占领的一个空格，看是不是可以放下棋子\n  - 如果放不下，这条路肯定走不通了，就要返回了\n  - 如果可以放下，那么继续选择旁边没有被占领的空格，遍历\n- 如果没有上面说的空格，那么就按照竖列，遍历到底\n  - 如果没有返回 false，肯定需要遍历完整个棋盘\n\n这个问题里面，如果有很多种解法，那么至少需要找到两组成功的解法，才能说明 false\n\n否则需要一直找下去，找不到成功解法才 false\n\n还是应该找一种能判断 false 的方法","slug":"春招-字节笔试","published":1,"updated":"2021-03-18T01:52:00.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n8890018k8tl79bg883g","content":"<h1 id=\"体验\"><a href=\"#体验\" class=\"headerlink\" title=\"体验\"></a>体验</h1><p>平台：牛客网</p>\n<p>特点：</p>\n<ol>\n<li>标准 sys 输入和输出，给输入和输出的范例，主要是多行输入和单行输出</li>\n<li>可以自测，可以print</li>\n</ol>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>总共有四道题目</p>\n<h2 id=\"1）环形数组-找座位问题\"><a href=\"#1）环形数组-找座位问题\" class=\"headerlink\" title=\"1）环形数组 - 找座位问题\"></a>1）环形数组 - 找座位问题</h2><p>给出一个环形数组，其中全部为 0 或 1</p>\n<p>请找到一个 0，它距离两侧的 1 应该最远</p>\n<a id=\"more\"></a>\n<p>比如：</p>\n<p>【0 0 0 0 0 1 0 0】</p>\n<p>那么 应该是在索引2的位置放1，距离最远，最远距离为 4</p>\n<p>分析：</p>\n<p>其实就是找两个 1 之间最大距离，或者说 连续 0 的最多数量</p>\n<p>我的方法就是找 两个 1 之间的最大距离</p>\n<p>而且，为了满足环形要求，直接在现在的数组后面续上一个数组</p>\n<p>这样遍历一遍，就能解决问题了</p>\n<p>【本题全部测试用例通过，10分】</p>\n<h2 id=\"2）多叉树寻根问题\"><a href=\"#2）多叉树寻根问题\" class=\"headerlink\" title=\"2）多叉树寻根问题\"></a>2）多叉树寻根问题</h2><p>问题描述：</p>\n<p>一个初代病毒 T 可以分裂出多个子代病毒</p>\n<p>子代病毒还可以继续分裂</p>\n<p>原病毒是无致命性的，但是分裂和遗传的过程中可能会有致命性</p>\n<p>如果已知某几个病毒是有致命性的，请找出它们的最近的共同根节点</p>\n<p>输入的写法【多行输入】：</p>\n<p>N 个病毒，R 条分裂</p>\n<p>M个致病：编号依次是</p>\n<p>分裂关系1：亲代、子代数量、子代编号</p>\n<p>分裂关系2：亲代、子代数量、子代编号</p>\n<p>分析：</p>\n<p>其实本题充分描绘了一颗多叉树的全貌，但是问题是：</p>\n<p>（1）如何进行还原</p>\n<p>（2）怎么样找最近的</p>\n<p>我首先想到的就是 Union-find 并查集的方法，一个建图的问题</p>\n<p>复习一下：并查集问题涉及以下几个步骤：</p>\n<p>union - 建图</p>\n<p>connected - 判断是不是连通</p>\n<p>count - 用于计数（对于岛屿问题可以使用）</p>\n<p>在建图和判断连通的过程中，会使用 find 函数寻找根节点</p>\n<p>那么本题中虽然有非常明确的多叉树结构，但是还不需要把全图建好，重要的是根据 find 函数寻找到根节点</p>\n<p>所以我的方法就是根据所给树的信息建立 parents 的表单</p>\n<blockquote>\n<p>因为输入信息中 父 - 子 节点的关系十分明确，可以直接对子节点存储 parent 的情况</p>\n</blockquote>\n<p>然后就是比较 各致命病毒 的父节点，什么是否是一样的？</p>\n<ul>\n<li>这个问题有点难，我想的可能不够完整</li>\n</ul>\n<p>我的想法是：</p>\n<p>由于该树中，其实大小是有一定的顺序的，是一颗二叉搜索树</p>\n<p>致命病毒id 也是有顺序的，可以根据最小的节点为标准</p>\n<p>如果别的病毒的父节点 id &gt; 该节点的父节点 id，那么其他病毒就找父节点，然后再比较父节点</p>\n<p>只有 别的病毒的父节点 id &lt; 该节点的父节点 id 时，才会找该节点的父节点 id</p>\n<hr>\n<p>几点说明：</p>\n<p>共同父节点是一定存在的，怎么说 0 也是共节点</p>\n<p>但是要找的是最近的</p>\n<p>【结果，本题通过了 70% 的测试用例， 本题30分】</p>\n<h2 id=\"3）破解机关问题-环形数组\"><a href=\"#3）破解机关问题-环形数组\" class=\"headerlink\" title=\"3）破解机关问题 - 环形数组\"></a>3）破解机关问题 - 环形数组</h2><p>这个问题很有意思，我也想问</p>\n<p>比如原神中有多个火柱子，初始状态有亮 - 1，有灭 - 0</p>\n<p>请问怎么样用最少的次数将所有的火柱子都点亮，如果不能全部点亮，就返回 -1</p>\n<p>举例：</p>\n<p>10</p>\n<p>0 1 1 0 0 0 1 0 0 1</p>\n<p>最后应该是 4次就可以将所有火柱子点亮</p>\n<p>分析：</p>\n<p>我的方法应该是贪心算法</p>\n<p>只要遇到0，那么下一个柱子就点亮，这样会同时影响 i, i+1, i+2三个柱子的值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> f[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">    f[i] = <span class=\"number\">1</span></span><br><span class=\"line\">    f[i+<span class=\"number\">1</span>] = int(f[i+<span class=\"number\">1</span>]==<span class=\"number\">0</span>)</span><br><span class=\"line\">    f[i+<span class=\"number\">2</span>] = int(f[i+<span class=\"number\">2</span>]==<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>个人觉得这个地方的逻辑判断做的还可以：</p>\n<p>如果 <code>f[i+1]=1</code>，那么，就会变成 false - 0</p>\n<p>如果 <code>f[i+1]=0</code>，那么，就会变成 true - 1</p>\n<p>相当于是与 0 异或</p>\n<p>按照这种方法前面都好说，但是当 i = n - 2的时候， i + 2 = n，会超出索引</p>\n<p>由于这是一个环形，所以需要把第一个柱子续在后面，一个即可【应该吧】</p>\n<p>我当时的判断条件是：当 i = n - 1时，如果 f[i] = 0，那么就判断 false</p>\n<p>但是现在看来还是不太对</p>\n<p>因为 i = n - 2的时候， i + 2 = n，会改掉第一个柱子的值，这样还是不太对</p>\n<p>应该是 i = n - 2 的时候，如果 f [i] = 0，那么其实就是 false 了</p>\n<p>【本题最好的通过情况是 37.5% ， 本题30分】</p>\n<hr>\n<p>而且这个方法对很多问题的算法并不是最佳的，比如：</p>\n<p>4</p>\n<p>0 0 1 0</p>\n<p>很显然一次就够了，但是按算法，会是 false</p>\n<h2 id=\"4）棋盘游戏问题\"><a href=\"#4）棋盘游戏问题\" class=\"headerlink\" title=\"4）棋盘游戏问题\"></a>4）棋盘游戏问题</h2><p>这类几何拓扑的问题，一看到就想放弃，确实不擅长做，主要是觉得二维进行遍历和存储的时候很麻烦</p>\n<p>问题描述：</p>\n<p>给一个 n * m 的棋盘，以及棋盘的状态（有的位置是空的<code>·</code>，有的非空 <code>#</code>）</p>\n<p>有若干 1 * 2 的棋子可以进行填充</p>\n<p>问是不是可以用棋子将棋盘填满，<strong>而且填法唯一</strong>，返回唯一填法</p>\n<p>如果不是，就返回 -1</p>\n<hr>\n<p>其实如果是唯一 填法，那么填起来应该也不会太难</p>\n<p>我们可以看几个案例：</p>\n<p>（1）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· ·</span><br><span class=\"line\"></span><br><span class=\"line\">· ·</span><br></pre></td></tr></table></figure>\n<p>这是 2x2 的棋盘，有两种方式可以填满，所以不是唯一的</p>\n<p>那么是不是说只要有这样的位置，就可以断定填不满了呢？不是</p>\n<p>（2）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· · <span class=\"comment\">#</span></span><br><span class=\"line\">· · ·</span><br><span class=\"line\">· <span class=\"comment\"># #</span></span><br></pre></td></tr></table></figure>\n<p>这是有唯一解的，唯一解为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt; &gt; <span class=\"comment\">#</span></span><br><span class=\"line\">^ &lt; &gt;</span><br><span class=\"line\">v <span class=\"comment\"># #</span></span><br></pre></td></tr></table></figure>\n<p>其中 <code>&lt; &gt;</code> 表示横着放的棋子，<code>^ v</code> 表示竖着放的棋子</p>\n<p>经过和同学的讨论，大家认为是这样，可以从头开始遍历，但是需要深度优先</p>\n<p>比如从左上角开始遍历：</p>\n<ul>\n<li>可能有两种放置方法，可以任选一种【任选也说明了多叉树的分支，这肯定要用回溯算法进行回调的，复杂度比较高】<ul>\n<li>但是最好有顺序，比如优先 横放，次之 竖放</li>\n</ul>\n</li>\n<li>然后选择没有被占领的一个空格，看是不是可以放下棋子<ul>\n<li>如果放不下，这条路肯定走不通了，就要返回了</li>\n<li>如果可以放下，那么继续选择旁边没有被占领的空格，遍历</li>\n</ul>\n</li>\n<li>如果没有上面说的空格，那么就按照竖列，遍历到底<ul>\n<li>如果没有返回 false，肯定需要遍历完整个棋盘</li>\n</ul>\n</li>\n</ul>\n<p>这个问题里面，如果有很多种解法，那么至少需要找到两组成功的解法，才能说明 false</p>\n<p>否则需要一直找下去，找不到成功解法才 false</p>\n<p>还是应该找一种能判断 false 的方法</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"体验\"><a href=\"#体验\" class=\"headerlink\" title=\"体验\"></a>体验</h1><p>平台：牛客网</p>\n<p>特点：</p>\n<ol>\n<li>标准 sys 输入和输出，给输入和输出的范例，主要是多行输入和单行输出</li>\n<li>可以自测，可以print</li>\n</ol>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>总共有四道题目</p>\n<h2 id=\"1）环形数组-找座位问题\"><a href=\"#1）环形数组-找座位问题\" class=\"headerlink\" title=\"1）环形数组 - 找座位问题\"></a>1）环形数组 - 找座位问题</h2><p>给出一个环形数组，其中全部为 0 或 1</p>\n<p>请找到一个 0，它距离两侧的 1 应该最远</p>","more":"<p>比如：</p>\n<p>【0 0 0 0 0 1 0 0】</p>\n<p>那么 应该是在索引2的位置放1，距离最远，最远距离为 4</p>\n<p>分析：</p>\n<p>其实就是找两个 1 之间最大距离，或者说 连续 0 的最多数量</p>\n<p>我的方法就是找 两个 1 之间的最大距离</p>\n<p>而且，为了满足环形要求，直接在现在的数组后面续上一个数组</p>\n<p>这样遍历一遍，就能解决问题了</p>\n<p>【本题全部测试用例通过，10分】</p>\n<h2 id=\"2）多叉树寻根问题\"><a href=\"#2）多叉树寻根问题\" class=\"headerlink\" title=\"2）多叉树寻根问题\"></a>2）多叉树寻根问题</h2><p>问题描述：</p>\n<p>一个初代病毒 T 可以分裂出多个子代病毒</p>\n<p>子代病毒还可以继续分裂</p>\n<p>原病毒是无致命性的，但是分裂和遗传的过程中可能会有致命性</p>\n<p>如果已知某几个病毒是有致命性的，请找出它们的最近的共同根节点</p>\n<p>输入的写法【多行输入】：</p>\n<p>N 个病毒，R 条分裂</p>\n<p>M个致病：编号依次是</p>\n<p>分裂关系1：亲代、子代数量、子代编号</p>\n<p>分裂关系2：亲代、子代数量、子代编号</p>\n<p>分析：</p>\n<p>其实本题充分描绘了一颗多叉树的全貌，但是问题是：</p>\n<p>（1）如何进行还原</p>\n<p>（2）怎么样找最近的</p>\n<p>我首先想到的就是 Union-find 并查集的方法，一个建图的问题</p>\n<p>复习一下：并查集问题涉及以下几个步骤：</p>\n<p>union - 建图</p>\n<p>connected - 判断是不是连通</p>\n<p>count - 用于计数（对于岛屿问题可以使用）</p>\n<p>在建图和判断连通的过程中，会使用 find 函数寻找根节点</p>\n<p>那么本题中虽然有非常明确的多叉树结构，但是还不需要把全图建好，重要的是根据 find 函数寻找到根节点</p>\n<p>所以我的方法就是根据所给树的信息建立 parents 的表单</p>\n<blockquote>\n<p>因为输入信息中 父 - 子 节点的关系十分明确，可以直接对子节点存储 parent 的情况</p>\n</blockquote>\n<p>然后就是比较 各致命病毒 的父节点，什么是否是一样的？</p>\n<ul>\n<li>这个问题有点难，我想的可能不够完整</li>\n</ul>\n<p>我的想法是：</p>\n<p>由于该树中，其实大小是有一定的顺序的，是一颗二叉搜索树</p>\n<p>致命病毒id 也是有顺序的，可以根据最小的节点为标准</p>\n<p>如果别的病毒的父节点 id &gt; 该节点的父节点 id，那么其他病毒就找父节点，然后再比较父节点</p>\n<p>只有 别的病毒的父节点 id &lt; 该节点的父节点 id 时，才会找该节点的父节点 id</p>\n<hr>\n<p>几点说明：</p>\n<p>共同父节点是一定存在的，怎么说 0 也是共节点</p>\n<p>但是要找的是最近的</p>\n<p>【结果，本题通过了 70% 的测试用例， 本题30分】</p>\n<h2 id=\"3）破解机关问题-环形数组\"><a href=\"#3）破解机关问题-环形数组\" class=\"headerlink\" title=\"3）破解机关问题 - 环形数组\"></a>3）破解机关问题 - 环形数组</h2><p>这个问题很有意思，我也想问</p>\n<p>比如原神中有多个火柱子，初始状态有亮 - 1，有灭 - 0</p>\n<p>请问怎么样用最少的次数将所有的火柱子都点亮，如果不能全部点亮，就返回 -1</p>\n<p>举例：</p>\n<p>10</p>\n<p>0 1 1 0 0 0 1 0 0 1</p>\n<p>最后应该是 4次就可以将所有火柱子点亮</p>\n<p>分析：</p>\n<p>我的方法应该是贪心算法</p>\n<p>只要遇到0，那么下一个柱子就点亮，这样会同时影响 i, i+1, i+2三个柱子的值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> f[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">    f[i] = <span class=\"number\">1</span></span><br><span class=\"line\">    f[i+<span class=\"number\">1</span>] = int(f[i+<span class=\"number\">1</span>]==<span class=\"number\">0</span>)</span><br><span class=\"line\">    f[i+<span class=\"number\">2</span>] = int(f[i+<span class=\"number\">2</span>]==<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>个人觉得这个地方的逻辑判断做的还可以：</p>\n<p>如果 <code>f[i+1]=1</code>，那么，就会变成 false - 0</p>\n<p>如果 <code>f[i+1]=0</code>，那么，就会变成 true - 1</p>\n<p>相当于是与 0 异或</p>\n<p>按照这种方法前面都好说，但是当 i = n - 2的时候， i + 2 = n，会超出索引</p>\n<p>由于这是一个环形，所以需要把第一个柱子续在后面，一个即可【应该吧】</p>\n<p>我当时的判断条件是：当 i = n - 1时，如果 f[i] = 0，那么就判断 false</p>\n<p>但是现在看来还是不太对</p>\n<p>因为 i = n - 2的时候， i + 2 = n，会改掉第一个柱子的值，这样还是不太对</p>\n<p>应该是 i = n - 2 的时候，如果 f [i] = 0，那么其实就是 false 了</p>\n<p>【本题最好的通过情况是 37.5% ， 本题30分】</p>\n<hr>\n<p>而且这个方法对很多问题的算法并不是最佳的，比如：</p>\n<p>4</p>\n<p>0 0 1 0</p>\n<p>很显然一次就够了，但是按算法，会是 false</p>\n<h2 id=\"4）棋盘游戏问题\"><a href=\"#4）棋盘游戏问题\" class=\"headerlink\" title=\"4）棋盘游戏问题\"></a>4）棋盘游戏问题</h2><p>这类几何拓扑的问题，一看到就想放弃，确实不擅长做，主要是觉得二维进行遍历和存储的时候很麻烦</p>\n<p>问题描述：</p>\n<p>给一个 n * m 的棋盘，以及棋盘的状态（有的位置是空的<code>·</code>，有的非空 <code>#</code>）</p>\n<p>有若干 1 * 2 的棋子可以进行填充</p>\n<p>问是不是可以用棋子将棋盘填满，<strong>而且填法唯一</strong>，返回唯一填法</p>\n<p>如果不是，就返回 -1</p>\n<hr>\n<p>其实如果是唯一 填法，那么填起来应该也不会太难</p>\n<p>我们可以看几个案例：</p>\n<p>（1）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· ·</span><br><span class=\"line\"></span><br><span class=\"line\">· ·</span><br></pre></td></tr></table></figure>\n<p>这是 2x2 的棋盘，有两种方式可以填满，所以不是唯一的</p>\n<p>那么是不是说只要有这样的位置，就可以断定填不满了呢？不是</p>\n<p>（2）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· · <span class=\"comment\">#</span></span><br><span class=\"line\">· · ·</span><br><span class=\"line\">· <span class=\"comment\"># #</span></span><br></pre></td></tr></table></figure>\n<p>这是有唯一解的，唯一解为</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt; &gt; <span class=\"comment\">#</span></span><br><span class=\"line\">^ &lt; &gt;</span><br><span class=\"line\">v <span class=\"comment\"># #</span></span><br></pre></td></tr></table></figure>\n<p>其中 <code>&lt; &gt;</code> 表示横着放的棋子，<code>^ v</code> 表示竖着放的棋子</p>\n<p>经过和同学的讨论，大家认为是这样，可以从头开始遍历，但是需要深度优先</p>\n<p>比如从左上角开始遍历：</p>\n<ul>\n<li>可能有两种放置方法，可以任选一种【任选也说明了多叉树的分支，这肯定要用回溯算法进行回调的，复杂度比较高】<ul>\n<li>但是最好有顺序，比如优先 横放，次之 竖放</li>\n</ul>\n</li>\n<li>然后选择没有被占领的一个空格，看是不是可以放下棋子<ul>\n<li>如果放不下，这条路肯定走不通了，就要返回了</li>\n<li>如果可以放下，那么继续选择旁边没有被占领的空格，遍历</li>\n</ul>\n</li>\n<li>如果没有上面说的空格，那么就按照竖列，遍历到底<ul>\n<li>如果没有返回 false，肯定需要遍历完整个棋盘</li>\n</ul>\n</li>\n</ul>\n<p>这个问题里面，如果有很多种解法，那么至少需要找到两组成功的解法，才能说明 false</p>\n<p>否则需要一直找下去，找不到成功解法才 false</p>\n<p>还是应该找一种能判断 false 的方法</p>"},{"title":"【统计学习方法】1-统计学习与监督学习基础","date":"2021-01-17T07:46:48.000Z","_content":"\n**统计学习是什么？**\n\n是一种计算机基于数据构建概率统计模型，也是运用模型对数据进行预测和分析的方法\n\n---\n\n![](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/下载.png)\n\n<!--more-->\n\n---\n\n# 统计学习的三种问题\n\n| 预测任务分类 | 回归问题 |    分类问题    | 标注问题 |\n| :----------: | :------: | :------------: | :------: |\n| 输入变量类型 | 连续变量 |                | 变量序列 |\n| 输出变量类型 | 连续变量 | 有限个离散变量 | 变量序列 |\n\n# 统计学习的数据\n\n数据集\n\n- 训练数据：用来学习模型\n- 测试数据：进行预测\n- 训练数据和测试数据均由输入与输出对（又叫做样本或样本点）构成\n\n训练集：通常表示为：$T=\\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\\}$，$\\{x_i,y_i\\}$即样本或样本点。\n\n# 统计学习方法三要素\n\n**方法 = 模型 + 策略 + 算法**\n\n# 基本概率公式\n\n- 加法规则：$P(x)=\\Sigma_yP(x,y)$\n- 乘法规则：$P(x,y)=P(x)P(y|x)$\n- 其中 x 和 y 是随机变量","source":"_posts/统计学习方法一.md","raw":"---\n\ntitle: 【统计学习方法】1-统计学习与监督学习基础\ndate: 2021-01-17 15:46:48\ncategories:\n\t- 机器学习\ntags:\n\t- 统计学习方法\n---\n\n**统计学习是什么？**\n\n是一种计算机基于数据构建概率统计模型，也是运用模型对数据进行预测和分析的方法\n\n---\n\n![](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/下载.png)\n\n<!--more-->\n\n---\n\n# 统计学习的三种问题\n\n| 预测任务分类 | 回归问题 |    分类问题    | 标注问题 |\n| :----------: | :------: | :------------: | :------: |\n| 输入变量类型 | 连续变量 |                | 变量序列 |\n| 输出变量类型 | 连续变量 | 有限个离散变量 | 变量序列 |\n\n# 统计学习的数据\n\n数据集\n\n- 训练数据：用来学习模型\n- 测试数据：进行预测\n- 训练数据和测试数据均由输入与输出对（又叫做样本或样本点）构成\n\n训练集：通常表示为：$T=\\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\\}$，$\\{x_i,y_i\\}$即样本或样本点。\n\n# 统计学习方法三要素\n\n**方法 = 模型 + 策略 + 算法**\n\n# 基本概率公式\n\n- 加法规则：$P(x)=\\Sigma_yP(x,y)$\n- 乘法规则：$P(x,y)=P(x)P(y|x)$\n- 其中 x 和 y 是随机变量","slug":"统计学习方法一","published":1,"updated":"2021-01-26T06:15:29.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n88b001dk8tl6xjh1dzd","content":"<p><strong>统计学习是什么？</strong></p>\n<p>是一种计算机基于数据构建概率统计模型，也是运用模型对数据进行预测和分析的方法</p>\n<hr>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/下载.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"统计学习的三种问题\"><a href=\"#统计学习的三种问题\" class=\"headerlink\" title=\"统计学习的三种问题\"></a>统计学习的三种问题</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">预测任务分类</th>\n<th style=\"text-align:center\">回归问题</th>\n<th style=\"text-align:center\">分类问题</th>\n<th style=\"text-align:center\">标注问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">输入变量类型</td>\n<td style=\"text-align:center\">连续变量</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">变量序列</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">输出变量类型</td>\n<td style=\"text-align:center\">连续变量</td>\n<td style=\"text-align:center\">有限个离散变量</td>\n<td style=\"text-align:center\">变量序列</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"统计学习的数据\"><a href=\"#统计学习的数据\" class=\"headerlink\" title=\"统计学习的数据\"></a>统计学习的数据</h1><p>数据集</p>\n<ul>\n<li>训练数据：用来学习模型</li>\n<li>测试数据：进行预测</li>\n<li>训练数据和测试数据均由输入与输出对（又叫做样本或样本点）构成</li>\n</ul>\n<p>训练集：通常表示为：$T=\\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\\}$，$\\{x_i,y_i\\}$即样本或样本点。</p>\n<h1 id=\"统计学习方法三要素\"><a href=\"#统计学习方法三要素\" class=\"headerlink\" title=\"统计学习方法三要素\"></a>统计学习方法三要素</h1><p><strong>方法 = 模型 + 策略 + 算法</strong></p>\n<h1 id=\"基本概率公式\"><a href=\"#基本概率公式\" class=\"headerlink\" title=\"基本概率公式\"></a>基本概率公式</h1><ul>\n<li>加法规则：$P(x)=\\Sigma_yP(x,y)$</li>\n<li>乘法规则：$P(x,y)=P(x)P(y|x)$</li>\n<li>其中 x 和 y 是随机变量</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>统计学习是什么？</strong></p>\n<p>是一种计算机基于数据构建概率统计模型，也是运用模型对数据进行预测和分析的方法</p>\n<hr>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/下载.png\" alt=\"\"></p>","more":"<hr>\n<h1 id=\"统计学习的三种问题\"><a href=\"#统计学习的三种问题\" class=\"headerlink\" title=\"统计学习的三种问题\"></a>统计学习的三种问题</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">预测任务分类</th>\n<th style=\"text-align:center\">回归问题</th>\n<th style=\"text-align:center\">分类问题</th>\n<th style=\"text-align:center\">标注问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">输入变量类型</td>\n<td style=\"text-align:center\">连续变量</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">变量序列</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">输出变量类型</td>\n<td style=\"text-align:center\">连续变量</td>\n<td style=\"text-align:center\">有限个离散变量</td>\n<td style=\"text-align:center\">变量序列</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"统计学习的数据\"><a href=\"#统计学习的数据\" class=\"headerlink\" title=\"统计学习的数据\"></a>统计学习的数据</h1><p>数据集</p>\n<ul>\n<li>训练数据：用来学习模型</li>\n<li>测试数据：进行预测</li>\n<li>训练数据和测试数据均由输入与输出对（又叫做样本或样本点）构成</li>\n</ul>\n<p>训练集：通常表示为：$T=\\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\\}$，$\\{x_i,y_i\\}$即样本或样本点。</p>\n<h1 id=\"统计学习方法三要素\"><a href=\"#统计学习方法三要素\" class=\"headerlink\" title=\"统计学习方法三要素\"></a>统计学习方法三要素</h1><p><strong>方法 = 模型 + 策略 + 算法</strong></p>\n<h1 id=\"基本概率公式\"><a href=\"#基本概率公式\" class=\"headerlink\" title=\"基本概率公式\"></a>基本概率公式</h1><ul>\n<li>加法规则：$P(x)=\\Sigma_yP(x,y)$</li>\n<li>乘法规则：$P(x,y)=P(x)P(y|x)$</li>\n<li>其中 x 和 y 是随机变量</li>\n</ul>"},{"title":"【机器学习】常见知识梳理（二）","date":"2020-08-22T01:04:49.000Z","_content":"\n本文内容根据《有趣的机器学习》一书整理而成，可作为简单了解。\n\n## 目前的机器学习分类\n\n**监督学习**\n\n- 有数据和标签\n\n**无监督学习**\n\n- 只有数据没有标签\n\n**半监督学习**\n\n- 少量数据有标签\n- 大量数据无标签\n\n**强化学习（Reinforcement learning）**\n\n- 从经验中总结提升\n\n**遗传算法（Genetic algorithm）**\n\n- 适者生存，不适者淘汰，优中选优\n\n<!--more-->\n\n## 神经网络\n\n一种统计学模型，能够不断学习\n\n### 框架\n\n**神经层**\n\n- 输入层\n  - 计算机能看到的全是数字\n- 隐藏层\n  - 信息加工处理\n- 输出层\n\n**神经元（节点）**\n\n- 每个神经元都有它自己的刺激函数\n- 有的神经元被激活，有的没有被激活\n- 反向学习后改动神经元激活情况，有的变迟钝，有的被激活，对重要信息进行反映\n\n### 学习经验\n\n认识预测结果和真实结果之间的差别（错误偏差）；\n\n然后把差别反向的方向上改动一点点。\n\n### 技巧\n\n**如何评价**\n\n- 训练数据（70%）和测试数据（30%）\n- 用测试数据来评价\n- 从误差值开始评价\n- 误差曲线和精确度曲线\n- R2 score 回归问题的精度\n- f1 score 不均匀\n- 过拟合\n  - 训练误差和测试误差\n  - 正则化\n- 交叉验证，调参\n\n**特征标准化（使数据跨度尽量统一）**\n\n**什么是好特征**\n\n- 更容易辨别事物的特征（有区分能力）\n- 避免无意义的信息\n- 避免重复性的信息\n- 避免复杂的信息\n\n**激励函数**\n\n- 不能用线性方程所概括的问题\n\n- y=AF（Wx）激励函数\n\n  要确保激励函数必须是可以微分的这样才能用微分把误差传递回去\n\n  - **relu 函数**\n    - 卷积中推荐\n    - 循环中推荐\n    - 负实轴上的值全为0\n  - **sigmoid 函数**\n    - 当横轴非常小时，函数值为0\n    - 当横轴非常大时，函数值为1\n  - **tanh 函数**\n    - 循环中推荐\n\n**过拟合 overfitting**\n\n- 增加数据量\n- 正则化\n  - 惩罚机制\n\n**不均衡数据**\n\n- 比如数据有多数派和少数派，机器预测会选择多数派\n- 避免这种情况的方法\n  - 获取更多的数据\n  - 换一种评价方式\n  - 重组数据<复制少数并合成，砍掉一些多数>\n  - 修改算法<如sigmoid函数调整门槛位置，原门槛大约是±1>\n\n**批标准化（Batch Normalization）**\n\n- Batch 把数据变成小批，对每一层进行正规化处理\n- 还进行反向Normalization，让NN自己学习是否起到作用\n\n**L1/L2正规化<针对过拟合问题>**\n\n- 方法是在cost函数中除了样本误差部份外，再增加 theta 参数平方和项\n- 如果拟合结果的非线性太强，theta 的平方和会比较大，惩罚机制\n\n**加速训练过程**\n\n- SGD\n- adagrad\n- monument\n- RMSPROP\n- adam\n\n### 卷积神经网络（Convolutional Neural Networks）\n\n图像识别，自然语言处理\n\n**卷积**\n\n- 不是对每个像素，而是对像素块进行处理，加强了对图像的识别\n\n**批量过滤器**\n\n- 不断移动，搜集像素块\n\n像素块->边缘信息->局部物体->物体全部\n\n**图片有高度**\n\n- 黑白高度0和1\n- 彩色图片颜色信息就是高度\n- 每搜索过滤一次，图片长宽变小，深度加深\n\n**pooling 池化**\n\n- 防止丢失信息\n- 池化层包含预设定的池化函数，其功能是将特征图中单个点的结果替换为其相邻区域的特征图统计量\n\n**分类器**\n\n**ReLU 线性整流单元**\n\n### 循环神经网络（RNN）\n\n可以用人工智能编写一首歌\n\n顺序排列\n\n数据间的关联，存储记忆\n\n**弊端**\n\n- 有序数据\n- 健忘\n  - 梯度消失，梯度弥散\n    - 当信息出现在开始时刻，由于误差反向计算时有加权，当权重比较小时，在开始时刻的误差接近于0，相当于没有误差，产生了错误\n  - 梯度爆炸\n    - 这次是由于权重大于1，累积到开始时刻时，误差已经很大了\n\n**LSTM RNN**\n\n延缓记忆消失\n\n- 输入控制\n- 忘记控制\n- 输出控制\n\n### 自编码（Autoencoder）\n\n如何用神经网络指导非监督学习\n\n**是一种神经网络形式**\n\n- 图片-打码-解码\n- 图片-压缩（信息小但全面，有代表性）-解压\n  - 压缩获取原数据的精髓\n  - 求出误差，反向传递\n\n**只用了数据，没有用标签，所以是非监督学习**\n\n**PCA 原数据主程序分析**\n\n### GAN 生成对抗网络\n\n凭空捏造数据\n\n**新手画家（generator）凭借随机数生成有用数据**\n\n**（给于一定的数据标签）新手鉴赏家（discriminator）（学习判断哪些是真实数据，哪些是生成数据，然后将经验反向传递给generator教它如何用生成生成数据能更像真实数据）-新手画家**\n\n### 强化学习\n\n从什么都没有到学习达到目标的方法\n\n#### 基本过程\n\n评分-高分/低分-机器有分数导向性，会自动选择更多的高分动作；\n\n也就是进行数据尝试，然后获得数据标签，反过来激励机器多做高分动作。\n\n#### 大致分类\n\n**基于**\n\n- value-based 基于价值\n  - Q-Learning\n  - Actor-Critic\n- 基于动作/基于概率\n  - Policy Gradients\n\n**环境区分**\n\n- 理解环境\n  - 按部就班，在自己所处的环境下解决问题\n- 不理解环境\n  - 多一个虚拟环境的建模过程\n  - 想象力更好\n\n**更新**\n\n- 回合更新\n  - 每局结束之后再更新\n- 单步更新\n  - 每结束一步就更新一次\n  - Actor-Critic 演员评论家\n\n**学习方法**\n\n- 在线学习\n  - 本人在场，亲自学习\n  - Sarsa / Sarsa（lamda）\n- 离线学习\n  - 看别人玩，从中学习\n  - 比如 Alpha Go\n\n#### 典型强化学习方法\n\n**Q-Learning**\n\n- Q表决策，离线学习\n- 估计（预测）的动作不一定是接下来要做的动作\n- 估计动作按Q表，但是做动作还是随机的\n\n**Sarsa**\n\n- 在线学习\n- 估计的动作也是实际的动作\n\n**Sarsa（lamda）**\n\n- lamda 衰变值\n  - 离宝藏越近的脚步越重要（更新力度就要大）\n  - 离宝藏越远，由于衰变累积，更新就会小一点\n- 比如Sarsa（0）\n  - 每走一步更新一次<单步更新>\n- Sarsa（n）\n  - 走完更新<回合更新>\n\n**Deep Q Network**\n\n- Q 现实 和 Q 估计\n- 记忆库 + 现实网络 + 估计网络\n- 可以自己玩电子游戏\n\n**Policy Gradient**\n\n- 基于动作，尤其是连续动作，但是输出值很多\n- 随机筛选\n- 没有误差，但是有反向传递（这句话似乎是错误的，但是莫烦确实这样说）\n- 输出值-奖惩-加大被选可能（现实中的奖惩会左右更新过程）\n\n**Actor-Critic 演员评论家**\n\n- 基于价值\n- 学习奖惩，与环境之间的奖惩\n- 有一个问题是，基于奖惩有可能会左右摇摆，Actor这边有自己的神经网络，学习了方法，Critic这边也有\n- 然后学一步，高分》》演员-低分》》评论家-高分···如此反复\n\n**Deep Deterministic Policy Gradient**\n\n- 更高级的方法，避免再左右中学不到东西\n- 连续动作上更有效的学习，只有一个输出值\n- 是 Actor-Critic 和 DQN 的加合\n\n**AAA-C（A3-C）**\n\n- 平行方式训练 Actor-Critic\n- 经验分享\n- 多核并行运算","source":"_posts/机器学习-常见知识梳理二.md","raw":"---\ntitle: 【机器学习】常见知识梳理（二）\ndate: 2020-08-22 09:04:49\ncategories:\n\t- 机器学习\n---\n\n本文内容根据《有趣的机器学习》一书整理而成，可作为简单了解。\n\n## 目前的机器学习分类\n\n**监督学习**\n\n- 有数据和标签\n\n**无监督学习**\n\n- 只有数据没有标签\n\n**半监督学习**\n\n- 少量数据有标签\n- 大量数据无标签\n\n**强化学习（Reinforcement learning）**\n\n- 从经验中总结提升\n\n**遗传算法（Genetic algorithm）**\n\n- 适者生存，不适者淘汰，优中选优\n\n<!--more-->\n\n## 神经网络\n\n一种统计学模型，能够不断学习\n\n### 框架\n\n**神经层**\n\n- 输入层\n  - 计算机能看到的全是数字\n- 隐藏层\n  - 信息加工处理\n- 输出层\n\n**神经元（节点）**\n\n- 每个神经元都有它自己的刺激函数\n- 有的神经元被激活，有的没有被激活\n- 反向学习后改动神经元激活情况，有的变迟钝，有的被激活，对重要信息进行反映\n\n### 学习经验\n\n认识预测结果和真实结果之间的差别（错误偏差）；\n\n然后把差别反向的方向上改动一点点。\n\n### 技巧\n\n**如何评价**\n\n- 训练数据（70%）和测试数据（30%）\n- 用测试数据来评价\n- 从误差值开始评价\n- 误差曲线和精确度曲线\n- R2 score 回归问题的精度\n- f1 score 不均匀\n- 过拟合\n  - 训练误差和测试误差\n  - 正则化\n- 交叉验证，调参\n\n**特征标准化（使数据跨度尽量统一）**\n\n**什么是好特征**\n\n- 更容易辨别事物的特征（有区分能力）\n- 避免无意义的信息\n- 避免重复性的信息\n- 避免复杂的信息\n\n**激励函数**\n\n- 不能用线性方程所概括的问题\n\n- y=AF（Wx）激励函数\n\n  要确保激励函数必须是可以微分的这样才能用微分把误差传递回去\n\n  - **relu 函数**\n    - 卷积中推荐\n    - 循环中推荐\n    - 负实轴上的值全为0\n  - **sigmoid 函数**\n    - 当横轴非常小时，函数值为0\n    - 当横轴非常大时，函数值为1\n  - **tanh 函数**\n    - 循环中推荐\n\n**过拟合 overfitting**\n\n- 增加数据量\n- 正则化\n  - 惩罚机制\n\n**不均衡数据**\n\n- 比如数据有多数派和少数派，机器预测会选择多数派\n- 避免这种情况的方法\n  - 获取更多的数据\n  - 换一种评价方式\n  - 重组数据<复制少数并合成，砍掉一些多数>\n  - 修改算法<如sigmoid函数调整门槛位置，原门槛大约是±1>\n\n**批标准化（Batch Normalization）**\n\n- Batch 把数据变成小批，对每一层进行正规化处理\n- 还进行反向Normalization，让NN自己学习是否起到作用\n\n**L1/L2正规化<针对过拟合问题>**\n\n- 方法是在cost函数中除了样本误差部份外，再增加 theta 参数平方和项\n- 如果拟合结果的非线性太强，theta 的平方和会比较大，惩罚机制\n\n**加速训练过程**\n\n- SGD\n- adagrad\n- monument\n- RMSPROP\n- adam\n\n### 卷积神经网络（Convolutional Neural Networks）\n\n图像识别，自然语言处理\n\n**卷积**\n\n- 不是对每个像素，而是对像素块进行处理，加强了对图像的识别\n\n**批量过滤器**\n\n- 不断移动，搜集像素块\n\n像素块->边缘信息->局部物体->物体全部\n\n**图片有高度**\n\n- 黑白高度0和1\n- 彩色图片颜色信息就是高度\n- 每搜索过滤一次，图片长宽变小，深度加深\n\n**pooling 池化**\n\n- 防止丢失信息\n- 池化层包含预设定的池化函数，其功能是将特征图中单个点的结果替换为其相邻区域的特征图统计量\n\n**分类器**\n\n**ReLU 线性整流单元**\n\n### 循环神经网络（RNN）\n\n可以用人工智能编写一首歌\n\n顺序排列\n\n数据间的关联，存储记忆\n\n**弊端**\n\n- 有序数据\n- 健忘\n  - 梯度消失，梯度弥散\n    - 当信息出现在开始时刻，由于误差反向计算时有加权，当权重比较小时，在开始时刻的误差接近于0，相当于没有误差，产生了错误\n  - 梯度爆炸\n    - 这次是由于权重大于1，累积到开始时刻时，误差已经很大了\n\n**LSTM RNN**\n\n延缓记忆消失\n\n- 输入控制\n- 忘记控制\n- 输出控制\n\n### 自编码（Autoencoder）\n\n如何用神经网络指导非监督学习\n\n**是一种神经网络形式**\n\n- 图片-打码-解码\n- 图片-压缩（信息小但全面，有代表性）-解压\n  - 压缩获取原数据的精髓\n  - 求出误差，反向传递\n\n**只用了数据，没有用标签，所以是非监督学习**\n\n**PCA 原数据主程序分析**\n\n### GAN 生成对抗网络\n\n凭空捏造数据\n\n**新手画家（generator）凭借随机数生成有用数据**\n\n**（给于一定的数据标签）新手鉴赏家（discriminator）（学习判断哪些是真实数据，哪些是生成数据，然后将经验反向传递给generator教它如何用生成生成数据能更像真实数据）-新手画家**\n\n### 强化学习\n\n从什么都没有到学习达到目标的方法\n\n#### 基本过程\n\n评分-高分/低分-机器有分数导向性，会自动选择更多的高分动作；\n\n也就是进行数据尝试，然后获得数据标签，反过来激励机器多做高分动作。\n\n#### 大致分类\n\n**基于**\n\n- value-based 基于价值\n  - Q-Learning\n  - Actor-Critic\n- 基于动作/基于概率\n  - Policy Gradients\n\n**环境区分**\n\n- 理解环境\n  - 按部就班，在自己所处的环境下解决问题\n- 不理解环境\n  - 多一个虚拟环境的建模过程\n  - 想象力更好\n\n**更新**\n\n- 回合更新\n  - 每局结束之后再更新\n- 单步更新\n  - 每结束一步就更新一次\n  - Actor-Critic 演员评论家\n\n**学习方法**\n\n- 在线学习\n  - 本人在场，亲自学习\n  - Sarsa / Sarsa（lamda）\n- 离线学习\n  - 看别人玩，从中学习\n  - 比如 Alpha Go\n\n#### 典型强化学习方法\n\n**Q-Learning**\n\n- Q表决策，离线学习\n- 估计（预测）的动作不一定是接下来要做的动作\n- 估计动作按Q表，但是做动作还是随机的\n\n**Sarsa**\n\n- 在线学习\n- 估计的动作也是实际的动作\n\n**Sarsa（lamda）**\n\n- lamda 衰变值\n  - 离宝藏越近的脚步越重要（更新力度就要大）\n  - 离宝藏越远，由于衰变累积，更新就会小一点\n- 比如Sarsa（0）\n  - 每走一步更新一次<单步更新>\n- Sarsa（n）\n  - 走完更新<回合更新>\n\n**Deep Q Network**\n\n- Q 现实 和 Q 估计\n- 记忆库 + 现实网络 + 估计网络\n- 可以自己玩电子游戏\n\n**Policy Gradient**\n\n- 基于动作，尤其是连续动作，但是输出值很多\n- 随机筛选\n- 没有误差，但是有反向传递（这句话似乎是错误的，但是莫烦确实这样说）\n- 输出值-奖惩-加大被选可能（现实中的奖惩会左右更新过程）\n\n**Actor-Critic 演员评论家**\n\n- 基于价值\n- 学习奖惩，与环境之间的奖惩\n- 有一个问题是，基于奖惩有可能会左右摇摆，Actor这边有自己的神经网络，学习了方法，Critic这边也有\n- 然后学一步，高分》》演员-低分》》评论家-高分···如此反复\n\n**Deep Deterministic Policy Gradient**\n\n- 更高级的方法，避免再左右中学不到东西\n- 连续动作上更有效的学习，只有一个输出值\n- 是 Actor-Critic 和 DQN 的加合\n\n**AAA-C（A3-C）**\n\n- 平行方式训练 Actor-Critic\n- 经验分享\n- 多核并行运算","slug":"机器学习-常见知识梳理二","published":1,"updated":"2021-01-26T06:23:04.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n88b001gk8tl8t866c1j","content":"<p>本文内容根据《有趣的机器学习》一书整理而成，可作为简单了解。</p>\n<h2 id=\"目前的机器学习分类\"><a href=\"#目前的机器学习分类\" class=\"headerlink\" title=\"目前的机器学习分类\"></a>目前的机器学习分类</h2><p><strong>监督学习</strong></p>\n<ul>\n<li>有数据和标签</li>\n</ul>\n<p><strong>无监督学习</strong></p>\n<ul>\n<li>只有数据没有标签</li>\n</ul>\n<p><strong>半监督学习</strong></p>\n<ul>\n<li>少量数据有标签</li>\n<li>大量数据无标签</li>\n</ul>\n<p><strong>强化学习（Reinforcement learning）</strong></p>\n<ul>\n<li>从经验中总结提升</li>\n</ul>\n<p><strong>遗传算法（Genetic algorithm）</strong></p>\n<ul>\n<li>适者生存，不适者淘汰，优中选优</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p>一种统计学模型，能够不断学习</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><p><strong>神经层</strong></p>\n<ul>\n<li>输入层<ul>\n<li>计算机能看到的全是数字</li>\n</ul>\n</li>\n<li>隐藏层<ul>\n<li>信息加工处理</li>\n</ul>\n</li>\n<li>输出层</li>\n</ul>\n<p><strong>神经元（节点）</strong></p>\n<ul>\n<li>每个神经元都有它自己的刺激函数</li>\n<li>有的神经元被激活，有的没有被激活</li>\n<li>反向学习后改动神经元激活情况，有的变迟钝，有的被激活，对重要信息进行反映</li>\n</ul>\n<h3 id=\"学习经验\"><a href=\"#学习经验\" class=\"headerlink\" title=\"学习经验\"></a>学习经验</h3><p>认识预测结果和真实结果之间的差别（错误偏差）；</p>\n<p>然后把差别反向的方向上改动一点点。</p>\n<h3 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><p><strong>如何评价</strong></p>\n<ul>\n<li>训练数据（70%）和测试数据（30%）</li>\n<li>用测试数据来评价</li>\n<li>从误差值开始评价</li>\n<li>误差曲线和精确度曲线</li>\n<li>R2 score 回归问题的精度</li>\n<li>f1 score 不均匀</li>\n<li>过拟合<ul>\n<li>训练误差和测试误差</li>\n<li>正则化</li>\n</ul>\n</li>\n<li>交叉验证，调参</li>\n</ul>\n<p><strong>特征标准化（使数据跨度尽量统一）</strong></p>\n<p><strong>什么是好特征</strong></p>\n<ul>\n<li>更容易辨别事物的特征（有区分能力）</li>\n<li>避免无意义的信息</li>\n<li>避免重复性的信息</li>\n<li>避免复杂的信息</li>\n</ul>\n<p><strong>激励函数</strong></p>\n<ul>\n<li><p>不能用线性方程所概括的问题</p>\n</li>\n<li><p>y=AF（Wx）激励函数</p>\n<p>要确保激励函数必须是可以微分的这样才能用微分把误差传递回去</p>\n<ul>\n<li><strong>relu 函数</strong><ul>\n<li>卷积中推荐</li>\n<li>循环中推荐</li>\n<li>负实轴上的值全为0</li>\n</ul>\n</li>\n<li><strong>sigmoid 函数</strong><ul>\n<li>当横轴非常小时，函数值为0</li>\n<li>当横轴非常大时，函数值为1</li>\n</ul>\n</li>\n<li><strong>tanh 函数</strong><ul>\n<li>循环中推荐</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>过拟合 overfitting</strong></p>\n<ul>\n<li>增加数据量</li>\n<li>正则化<ul>\n<li>惩罚机制</li>\n</ul>\n</li>\n</ul>\n<p><strong>不均衡数据</strong></p>\n<ul>\n<li>比如数据有多数派和少数派，机器预测会选择多数派</li>\n<li>避免这种情况的方法<ul>\n<li>获取更多的数据</li>\n<li>换一种评价方式</li>\n<li>重组数据&lt;复制少数并合成，砍掉一些多数&gt;</li>\n<li>修改算法&lt;如sigmoid函数调整门槛位置，原门槛大约是±1&gt;</li>\n</ul>\n</li>\n</ul>\n<p><strong>批标准化（Batch Normalization）</strong></p>\n<ul>\n<li>Batch 把数据变成小批，对每一层进行正规化处理</li>\n<li>还进行反向Normalization，让NN自己学习是否起到作用</li>\n</ul>\n<p><strong>L1/L2正规化&lt;针对过拟合问题&gt;</strong></p>\n<ul>\n<li>方法是在cost函数中除了样本误差部份外，再增加 theta 参数平方和项</li>\n<li>如果拟合结果的非线性太强，theta 的平方和会比较大，惩罚机制</li>\n</ul>\n<p><strong>加速训练过程</strong></p>\n<ul>\n<li>SGD</li>\n<li>adagrad</li>\n<li>monument</li>\n<li>RMSPROP</li>\n<li>adam</li>\n</ul>\n<h3 id=\"卷积神经网络（Convolutional-Neural-Networks）\"><a href=\"#卷积神经网络（Convolutional-Neural-Networks）\" class=\"headerlink\" title=\"卷积神经网络（Convolutional Neural Networks）\"></a>卷积神经网络（Convolutional Neural Networks）</h3><p>图像识别，自然语言处理</p>\n<p><strong>卷积</strong></p>\n<ul>\n<li>不是对每个像素，而是对像素块进行处理，加强了对图像的识别</li>\n</ul>\n<p><strong>批量过滤器</strong></p>\n<ul>\n<li>不断移动，搜集像素块</li>\n</ul>\n<p>像素块-&gt;边缘信息-&gt;局部物体-&gt;物体全部</p>\n<p><strong>图片有高度</strong></p>\n<ul>\n<li>黑白高度0和1</li>\n<li>彩色图片颜色信息就是高度</li>\n<li>每搜索过滤一次，图片长宽变小，深度加深</li>\n</ul>\n<p><strong>pooling 池化</strong></p>\n<ul>\n<li>防止丢失信息</li>\n<li>池化层包含预设定的池化函数，其功能是将特征图中单个点的结果替换为其相邻区域的特征图统计量</li>\n</ul>\n<p><strong>分类器</strong></p>\n<p><strong>ReLU 线性整流单元</strong></p>\n<h3 id=\"循环神经网络（RNN）\"><a href=\"#循环神经网络（RNN）\" class=\"headerlink\" title=\"循环神经网络（RNN）\"></a>循环神经网络（RNN）</h3><p>可以用人工智能编写一首歌</p>\n<p>顺序排列</p>\n<p>数据间的关联，存储记忆</p>\n<p><strong>弊端</strong></p>\n<ul>\n<li>有序数据</li>\n<li>健忘<ul>\n<li>梯度消失，梯度弥散<ul>\n<li>当信息出现在开始时刻，由于误差反向计算时有加权，当权重比较小时，在开始时刻的误差接近于0，相当于没有误差，产生了错误</li>\n</ul>\n</li>\n<li>梯度爆炸<ul>\n<li>这次是由于权重大于1，累积到开始时刻时，误差已经很大了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>LSTM RNN</strong></p>\n<p>延缓记忆消失</p>\n<ul>\n<li>输入控制</li>\n<li>忘记控制</li>\n<li>输出控制</li>\n</ul>\n<h3 id=\"自编码（Autoencoder）\"><a href=\"#自编码（Autoencoder）\" class=\"headerlink\" title=\"自编码（Autoencoder）\"></a>自编码（Autoencoder）</h3><p>如何用神经网络指导非监督学习</p>\n<p><strong>是一种神经网络形式</strong></p>\n<ul>\n<li>图片-打码-解码</li>\n<li>图片-压缩（信息小但全面，有代表性）-解压<ul>\n<li>压缩获取原数据的精髓</li>\n<li>求出误差，反向传递</li>\n</ul>\n</li>\n</ul>\n<p><strong>只用了数据，没有用标签，所以是非监督学习</strong></p>\n<p><strong>PCA 原数据主程序分析</strong></p>\n<h3 id=\"GAN-生成对抗网络\"><a href=\"#GAN-生成对抗网络\" class=\"headerlink\" title=\"GAN 生成对抗网络\"></a>GAN 生成对抗网络</h3><p>凭空捏造数据</p>\n<p><strong>新手画家（generator）凭借随机数生成有用数据</strong></p>\n<p><strong>（给于一定的数据标签）新手鉴赏家（discriminator）（学习判断哪些是真实数据，哪些是生成数据，然后将经验反向传递给generator教它如何用生成生成数据能更像真实数据）-新手画家</strong></p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>从什么都没有到学习达到目标的方法</p>\n<h4 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h4><p>评分-高分/低分-机器有分数导向性，会自动选择更多的高分动作；</p>\n<p>也就是进行数据尝试，然后获得数据标签，反过来激励机器多做高分动作。</p>\n<h4 id=\"大致分类\"><a href=\"#大致分类\" class=\"headerlink\" title=\"大致分类\"></a>大致分类</h4><p><strong>基于</strong></p>\n<ul>\n<li>value-based 基于价值<ul>\n<li>Q-Learning</li>\n<li>Actor-Critic</li>\n</ul>\n</li>\n<li>基于动作/基于概率<ul>\n<li>Policy Gradients</li>\n</ul>\n</li>\n</ul>\n<p><strong>环境区分</strong></p>\n<ul>\n<li>理解环境<ul>\n<li>按部就班，在自己所处的环境下解决问题</li>\n</ul>\n</li>\n<li>不理解环境<ul>\n<li>多一个虚拟环境的建模过程</li>\n<li>想象力更好</li>\n</ul>\n</li>\n</ul>\n<p><strong>更新</strong></p>\n<ul>\n<li>回合更新<ul>\n<li>每局结束之后再更新</li>\n</ul>\n</li>\n<li>单步更新<ul>\n<li>每结束一步就更新一次</li>\n<li>Actor-Critic 演员评论家</li>\n</ul>\n</li>\n</ul>\n<p><strong>学习方法</strong></p>\n<ul>\n<li>在线学习<ul>\n<li>本人在场，亲自学习</li>\n<li>Sarsa / Sarsa（lamda）</li>\n</ul>\n</li>\n<li>离线学习<ul>\n<li>看别人玩，从中学习</li>\n<li>比如 Alpha Go</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"典型强化学习方法\"><a href=\"#典型强化学习方法\" class=\"headerlink\" title=\"典型强化学习方法\"></a>典型强化学习方法</h4><p><strong>Q-Learning</strong></p>\n<ul>\n<li>Q表决策，离线学习</li>\n<li>估计（预测）的动作不一定是接下来要做的动作</li>\n<li>估计动作按Q表，但是做动作还是随机的</li>\n</ul>\n<p><strong>Sarsa</strong></p>\n<ul>\n<li>在线学习</li>\n<li>估计的动作也是实际的动作</li>\n</ul>\n<p><strong>Sarsa（lamda）</strong></p>\n<ul>\n<li>lamda 衰变值<ul>\n<li>离宝藏越近的脚步越重要（更新力度就要大）</li>\n<li>离宝藏越远，由于衰变累积，更新就会小一点</li>\n</ul>\n</li>\n<li>比如Sarsa（0）<ul>\n<li>每走一步更新一次&lt;单步更新&gt;</li>\n</ul>\n</li>\n<li>Sarsa（n）<ul>\n<li>走完更新&lt;回合更新&gt;</li>\n</ul>\n</li>\n</ul>\n<p><strong>Deep Q Network</strong></p>\n<ul>\n<li>Q 现实 和 Q 估计</li>\n<li>记忆库 + 现实网络 + 估计网络</li>\n<li>可以自己玩电子游戏</li>\n</ul>\n<p><strong>Policy Gradient</strong></p>\n<ul>\n<li>基于动作，尤其是连续动作，但是输出值很多</li>\n<li>随机筛选</li>\n<li>没有误差，但是有反向传递（这句话似乎是错误的，但是莫烦确实这样说）</li>\n<li>输出值-奖惩-加大被选可能（现实中的奖惩会左右更新过程）</li>\n</ul>\n<p><strong>Actor-Critic 演员评论家</strong></p>\n<ul>\n<li>基于价值</li>\n<li>学习奖惩，与环境之间的奖惩</li>\n<li>有一个问题是，基于奖惩有可能会左右摇摆，Actor这边有自己的神经网络，学习了方法，Critic这边也有</li>\n<li>然后学一步，高分》》演员-低分》》评论家-高分···如此反复</li>\n</ul>\n<p><strong>Deep Deterministic Policy Gradient</strong></p>\n<ul>\n<li>更高级的方法，避免再左右中学不到东西</li>\n<li>连续动作上更有效的学习，只有一个输出值</li>\n<li>是 Actor-Critic 和 DQN 的加合</li>\n</ul>\n<p><strong>AAA-C（A3-C）</strong></p>\n<ul>\n<li>平行方式训练 Actor-Critic</li>\n<li>经验分享</li>\n<li>多核并行运算</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文内容根据《有趣的机器学习》一书整理而成，可作为简单了解。</p>\n<h2 id=\"目前的机器学习分类\"><a href=\"#目前的机器学习分类\" class=\"headerlink\" title=\"目前的机器学习分类\"></a>目前的机器学习分类</h2><p><strong>监督学习</strong></p>\n<ul>\n<li>有数据和标签</li>\n</ul>\n<p><strong>无监督学习</strong></p>\n<ul>\n<li>只有数据没有标签</li>\n</ul>\n<p><strong>半监督学习</strong></p>\n<ul>\n<li>少量数据有标签</li>\n<li>大量数据无标签</li>\n</ul>\n<p><strong>强化学习（Reinforcement learning）</strong></p>\n<ul>\n<li>从经验中总结提升</li>\n</ul>\n<p><strong>遗传算法（Genetic algorithm）</strong></p>\n<ul>\n<li>适者生存，不适者淘汰，优中选优</li>\n</ul>","more":"<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p>一种统计学模型，能够不断学习</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><p><strong>神经层</strong></p>\n<ul>\n<li>输入层<ul>\n<li>计算机能看到的全是数字</li>\n</ul>\n</li>\n<li>隐藏层<ul>\n<li>信息加工处理</li>\n</ul>\n</li>\n<li>输出层</li>\n</ul>\n<p><strong>神经元（节点）</strong></p>\n<ul>\n<li>每个神经元都有它自己的刺激函数</li>\n<li>有的神经元被激活，有的没有被激活</li>\n<li>反向学习后改动神经元激活情况，有的变迟钝，有的被激活，对重要信息进行反映</li>\n</ul>\n<h3 id=\"学习经验\"><a href=\"#学习经验\" class=\"headerlink\" title=\"学习经验\"></a>学习经验</h3><p>认识预测结果和真实结果之间的差别（错误偏差）；</p>\n<p>然后把差别反向的方向上改动一点点。</p>\n<h3 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><p><strong>如何评价</strong></p>\n<ul>\n<li>训练数据（70%）和测试数据（30%）</li>\n<li>用测试数据来评价</li>\n<li>从误差值开始评价</li>\n<li>误差曲线和精确度曲线</li>\n<li>R2 score 回归问题的精度</li>\n<li>f1 score 不均匀</li>\n<li>过拟合<ul>\n<li>训练误差和测试误差</li>\n<li>正则化</li>\n</ul>\n</li>\n<li>交叉验证，调参</li>\n</ul>\n<p><strong>特征标准化（使数据跨度尽量统一）</strong></p>\n<p><strong>什么是好特征</strong></p>\n<ul>\n<li>更容易辨别事物的特征（有区分能力）</li>\n<li>避免无意义的信息</li>\n<li>避免重复性的信息</li>\n<li>避免复杂的信息</li>\n</ul>\n<p><strong>激励函数</strong></p>\n<ul>\n<li><p>不能用线性方程所概括的问题</p>\n</li>\n<li><p>y=AF（Wx）激励函数</p>\n<p>要确保激励函数必须是可以微分的这样才能用微分把误差传递回去</p>\n<ul>\n<li><strong>relu 函数</strong><ul>\n<li>卷积中推荐</li>\n<li>循环中推荐</li>\n<li>负实轴上的值全为0</li>\n</ul>\n</li>\n<li><strong>sigmoid 函数</strong><ul>\n<li>当横轴非常小时，函数值为0</li>\n<li>当横轴非常大时，函数值为1</li>\n</ul>\n</li>\n<li><strong>tanh 函数</strong><ul>\n<li>循环中推荐</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>过拟合 overfitting</strong></p>\n<ul>\n<li>增加数据量</li>\n<li>正则化<ul>\n<li>惩罚机制</li>\n</ul>\n</li>\n</ul>\n<p><strong>不均衡数据</strong></p>\n<ul>\n<li>比如数据有多数派和少数派，机器预测会选择多数派</li>\n<li>避免这种情况的方法<ul>\n<li>获取更多的数据</li>\n<li>换一种评价方式</li>\n<li>重组数据&lt;复制少数并合成，砍掉一些多数&gt;</li>\n<li>修改算法&lt;如sigmoid函数调整门槛位置，原门槛大约是±1&gt;</li>\n</ul>\n</li>\n</ul>\n<p><strong>批标准化（Batch Normalization）</strong></p>\n<ul>\n<li>Batch 把数据变成小批，对每一层进行正规化处理</li>\n<li>还进行反向Normalization，让NN自己学习是否起到作用</li>\n</ul>\n<p><strong>L1/L2正规化&lt;针对过拟合问题&gt;</strong></p>\n<ul>\n<li>方法是在cost函数中除了样本误差部份外，再增加 theta 参数平方和项</li>\n<li>如果拟合结果的非线性太强，theta 的平方和会比较大，惩罚机制</li>\n</ul>\n<p><strong>加速训练过程</strong></p>\n<ul>\n<li>SGD</li>\n<li>adagrad</li>\n<li>monument</li>\n<li>RMSPROP</li>\n<li>adam</li>\n</ul>\n<h3 id=\"卷积神经网络（Convolutional-Neural-Networks）\"><a href=\"#卷积神经网络（Convolutional-Neural-Networks）\" class=\"headerlink\" title=\"卷积神经网络（Convolutional Neural Networks）\"></a>卷积神经网络（Convolutional Neural Networks）</h3><p>图像识别，自然语言处理</p>\n<p><strong>卷积</strong></p>\n<ul>\n<li>不是对每个像素，而是对像素块进行处理，加强了对图像的识别</li>\n</ul>\n<p><strong>批量过滤器</strong></p>\n<ul>\n<li>不断移动，搜集像素块</li>\n</ul>\n<p>像素块-&gt;边缘信息-&gt;局部物体-&gt;物体全部</p>\n<p><strong>图片有高度</strong></p>\n<ul>\n<li>黑白高度0和1</li>\n<li>彩色图片颜色信息就是高度</li>\n<li>每搜索过滤一次，图片长宽变小，深度加深</li>\n</ul>\n<p><strong>pooling 池化</strong></p>\n<ul>\n<li>防止丢失信息</li>\n<li>池化层包含预设定的池化函数，其功能是将特征图中单个点的结果替换为其相邻区域的特征图统计量</li>\n</ul>\n<p><strong>分类器</strong></p>\n<p><strong>ReLU 线性整流单元</strong></p>\n<h3 id=\"循环神经网络（RNN）\"><a href=\"#循环神经网络（RNN）\" class=\"headerlink\" title=\"循环神经网络（RNN）\"></a>循环神经网络（RNN）</h3><p>可以用人工智能编写一首歌</p>\n<p>顺序排列</p>\n<p>数据间的关联，存储记忆</p>\n<p><strong>弊端</strong></p>\n<ul>\n<li>有序数据</li>\n<li>健忘<ul>\n<li>梯度消失，梯度弥散<ul>\n<li>当信息出现在开始时刻，由于误差反向计算时有加权，当权重比较小时，在开始时刻的误差接近于0，相当于没有误差，产生了错误</li>\n</ul>\n</li>\n<li>梯度爆炸<ul>\n<li>这次是由于权重大于1，累积到开始时刻时，误差已经很大了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>LSTM RNN</strong></p>\n<p>延缓记忆消失</p>\n<ul>\n<li>输入控制</li>\n<li>忘记控制</li>\n<li>输出控制</li>\n</ul>\n<h3 id=\"自编码（Autoencoder）\"><a href=\"#自编码（Autoencoder）\" class=\"headerlink\" title=\"自编码（Autoencoder）\"></a>自编码（Autoencoder）</h3><p>如何用神经网络指导非监督学习</p>\n<p><strong>是一种神经网络形式</strong></p>\n<ul>\n<li>图片-打码-解码</li>\n<li>图片-压缩（信息小但全面，有代表性）-解压<ul>\n<li>压缩获取原数据的精髓</li>\n<li>求出误差，反向传递</li>\n</ul>\n</li>\n</ul>\n<p><strong>只用了数据，没有用标签，所以是非监督学习</strong></p>\n<p><strong>PCA 原数据主程序分析</strong></p>\n<h3 id=\"GAN-生成对抗网络\"><a href=\"#GAN-生成对抗网络\" class=\"headerlink\" title=\"GAN 生成对抗网络\"></a>GAN 生成对抗网络</h3><p>凭空捏造数据</p>\n<p><strong>新手画家（generator）凭借随机数生成有用数据</strong></p>\n<p><strong>（给于一定的数据标签）新手鉴赏家（discriminator）（学习判断哪些是真实数据，哪些是生成数据，然后将经验反向传递给generator教它如何用生成生成数据能更像真实数据）-新手画家</strong></p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>从什么都没有到学习达到目标的方法</p>\n<h4 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h4><p>评分-高分/低分-机器有分数导向性，会自动选择更多的高分动作；</p>\n<p>也就是进行数据尝试，然后获得数据标签，反过来激励机器多做高分动作。</p>\n<h4 id=\"大致分类\"><a href=\"#大致分类\" class=\"headerlink\" title=\"大致分类\"></a>大致分类</h4><p><strong>基于</strong></p>\n<ul>\n<li>value-based 基于价值<ul>\n<li>Q-Learning</li>\n<li>Actor-Critic</li>\n</ul>\n</li>\n<li>基于动作/基于概率<ul>\n<li>Policy Gradients</li>\n</ul>\n</li>\n</ul>\n<p><strong>环境区分</strong></p>\n<ul>\n<li>理解环境<ul>\n<li>按部就班，在自己所处的环境下解决问题</li>\n</ul>\n</li>\n<li>不理解环境<ul>\n<li>多一个虚拟环境的建模过程</li>\n<li>想象力更好</li>\n</ul>\n</li>\n</ul>\n<p><strong>更新</strong></p>\n<ul>\n<li>回合更新<ul>\n<li>每局结束之后再更新</li>\n</ul>\n</li>\n<li>单步更新<ul>\n<li>每结束一步就更新一次</li>\n<li>Actor-Critic 演员评论家</li>\n</ul>\n</li>\n</ul>\n<p><strong>学习方法</strong></p>\n<ul>\n<li>在线学习<ul>\n<li>本人在场，亲自学习</li>\n<li>Sarsa / Sarsa（lamda）</li>\n</ul>\n</li>\n<li>离线学习<ul>\n<li>看别人玩，从中学习</li>\n<li>比如 Alpha Go</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"典型强化学习方法\"><a href=\"#典型强化学习方法\" class=\"headerlink\" title=\"典型强化学习方法\"></a>典型强化学习方法</h4><p><strong>Q-Learning</strong></p>\n<ul>\n<li>Q表决策，离线学习</li>\n<li>估计（预测）的动作不一定是接下来要做的动作</li>\n<li>估计动作按Q表，但是做动作还是随机的</li>\n</ul>\n<p><strong>Sarsa</strong></p>\n<ul>\n<li>在线学习</li>\n<li>估计的动作也是实际的动作</li>\n</ul>\n<p><strong>Sarsa（lamda）</strong></p>\n<ul>\n<li>lamda 衰变值<ul>\n<li>离宝藏越近的脚步越重要（更新力度就要大）</li>\n<li>离宝藏越远，由于衰变累积，更新就会小一点</li>\n</ul>\n</li>\n<li>比如Sarsa（0）<ul>\n<li>每走一步更新一次&lt;单步更新&gt;</li>\n</ul>\n</li>\n<li>Sarsa（n）<ul>\n<li>走完更新&lt;回合更新&gt;</li>\n</ul>\n</li>\n</ul>\n<p><strong>Deep Q Network</strong></p>\n<ul>\n<li>Q 现实 和 Q 估计</li>\n<li>记忆库 + 现实网络 + 估计网络</li>\n<li>可以自己玩电子游戏</li>\n</ul>\n<p><strong>Policy Gradient</strong></p>\n<ul>\n<li>基于动作，尤其是连续动作，但是输出值很多</li>\n<li>随机筛选</li>\n<li>没有误差，但是有反向传递（这句话似乎是错误的，但是莫烦确实这样说）</li>\n<li>输出值-奖惩-加大被选可能（现实中的奖惩会左右更新过程）</li>\n</ul>\n<p><strong>Actor-Critic 演员评论家</strong></p>\n<ul>\n<li>基于价值</li>\n<li>学习奖惩，与环境之间的奖惩</li>\n<li>有一个问题是，基于奖惩有可能会左右摇摆，Actor这边有自己的神经网络，学习了方法，Critic这边也有</li>\n<li>然后学一步，高分》》演员-低分》》评论家-高分···如此反复</li>\n</ul>\n<p><strong>Deep Deterministic Policy Gradient</strong></p>\n<ul>\n<li>更高级的方法，避免再左右中学不到东西</li>\n<li>连续动作上更有效的学习，只有一个输出值</li>\n<li>是 Actor-Critic 和 DQN 的加合</li>\n</ul>\n<p><strong>AAA-C（A3-C）</strong></p>\n<ul>\n<li>平行方式训练 Actor-Critic</li>\n<li>经验分享</li>\n<li>多核并行运算</li>\n</ul>"},{"title":"【统计学习方法】7-SVM支持向量机","date":"2021-04-24T02:08:14.000Z","_content":"\n**一句话介绍**\n\n支持向量机是一种分类模型，求解能够正确划分训练数据集并且几何间隔最大的分离超平面。\n\n------\n\n# 0.支持向量\n\n要理解什么是支持向量（support vector），首先需要理解以下几个概念：\n\n如果我们有一堆数据（二维），在二维平面上分布如下图所示：\n\n![微信图片_20210424102729](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20210424102729.jpg)\n\n我们可以用一条直线将这堆数据分成两个部分：\n\n【当这堆数据维数是**3维**，这条直线就成了**平面**；当数据**维数更高**，这条分隔线就成了**超平面**】以下统称超平面，数学表达为：\n\n$w^*\\cdot x + b^*=0$\n\n要说明的是，仅仅把这堆数据分离开，也许有无数个超平面可以做到；\n\n我们做一些规范，最大几何间隔的分离超平面，是唯一且存在的。\n\n很明显，分隔之后，有的点离这个超平面近，有的远，最近点到超平面的距离，称为**间隔**，这个最近的样本点的实例就被称为支持向量【本定义适用于线性可分情况下】。\n\n支持向量在确定分离超平面中起决定性作用（不移动支持向量，分离超平面就不会变化），所以把这种分类模型称为支持向量机。\n\n<!-- more -->\n\n相关重要概念：\n\n**类标记**概念：可以理解为因变量，但是这个量更准确地说是观测值、实际值，而不是由函数计算出来的\n\n**函数间隔**：该点的类标记和超平面函数值的乘积$\\hat \\gamma_i=y_i(w\\cdot x_i+b)$【表示分类预测的正确性和确信度】\n\n**几何间隔**：规定$L||w||=1$（L2范数）情况下的函数间隔$\\gamma_i=y_i(\\frac{w}{||w||}\\cdot x_i+\\frac{b}{||w||})$【实例点到超平面的带符号的距离】\n\n**硬间隔最大化**：线性可分的训练数据集——线性可分支持向量机\n\n**软间隔最大化**：训练数据集近似线性可分——线性支持向量机\n\n# 1.线性可分支持向量机\n\n找**最大间隔分离超平面**：该超平面对训练数据集的几何间隔至少应大于某个值；\n\n凸优化问题 P116 与凸二次规划问题\n\n## 最大间隔法\n\nin：可分训练数据集，x 和对应的类标记 y\n\nout：最大间隔分离超平面（参数 w 和 b），分类决策函数（$sign$函数）\n\n### 间隔边界\n\n与最大间隔分离超平面相平行的平面中，有两个超平面 H1 和 H2 之间没有任何实例点，这两个超平面就是间隔边界，中间的距离就是间隔。\n\n![IMG_20201117_105233](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/IMG_20201117_105233.jpg)\n\n### 线性可分支持向量机的对偶算法\n\n使用拉格朗日乘子法进行问题的转化，注意我们的目标：要使间隔最大——也就是![img](http://101.133.159.251:6001/plugins/servlet/latexmath/placeholder?key=2f22ec97a5d006440605bddabf953edc&vertAlign=-5px)尽可能小\n\n分类决策函数：$f(x)=sign(\\Sigma_{i=1}^N\\alpha_i^*y_i(x\\cdot x_i)+b^*)$只依赖于输入x和训练样本输入的内积\n\n本方法中，将训练数据中对应于$\\alpha^*_i>0$的样本点称为支持向量【这里的是$\\alpha_i$拉格朗日乘子】\n\n> 本方法核心思想是拉格朗日乘子法，在使用的过程中，将约束条件从几何间隔转化为了$\\alpha_i$的约束\n\n# 2.线性支持向量机\n\n## 训练样本线性不可分——软间隔最大化\n\n其实主要是有少量的“特异点”（outlier），将这些点去除之后，剩下的样本就线性可分了。\n\n我们并不能直接去除这些特异点，但是可以放宽标准，增加一个松弛变量，一来放宽限制，二来在目标函数中进行惩罚，确保误分类的样本尽量少。\n\n> 线性支持向量机包含线性可分支持向量机\n\n如果假设此处的分离超平面是$w^*\\cdot x+b^*=0$，那么 w 的解是唯一的，但是 b 的解可能不唯一，而是存在一个区间\n\n下图表示软间隔的支持向量：\n\n![软间隔的支持向量](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/软间隔的支持向量.jpg)\n\n\n\n## 合页损失函数\n\n在本问题中，还有一种以合页损失函数表示的目标函数：\n\n$\\Sigma_{i=1}^N[1-y_i(w\\cdot x_i+b)]_++\\lambda||w||^2$\n\n其中前半部分称为合页损失函数(hinge loss function)：$L(y(w\\cdot x+b))=[1-y(w\\cdot x+b)]_+$\n\n其中$[z]_+=\\left \\{ \\begin{aligned} z , z>0 \\\\ 0, z \\leq 0\\end{aligned} \\right.$\n\n该函数特性就是\n\n- 如果样本点被正确分类且函数间隔大于1，那么损失是0\n- 其他情况下，损失是$1-y_i(w\\cdot x_i+b)$\n\n下图中：\n\n- 左侧水平线是 0-1损失 的一部分【真正的二类分类问题】\n- 虚线斜线是合页损失函数（不带1时）\n- 实现是完整的合页损失函数，只有当确信度足够高时，损失才是0，要求更高\n\n![合页损失函数](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/合页损失函数.jpg)\n\n\n\n# 3.非线性支持向量机与核函数\n\n非线性可分问题：如果能用一个超曲面将正负类正确分开，则称非线性可分问题\n\n求解思路：进行非线性变换，将非线性问题变换为线性问题然后进行求解\n\n## 核技巧\n\n基本想法\n\n- 通过一个非线性变换将输入空间（欧式空间或者离散空间）对应于一个特征空间（希尔伯特空间）\n  使得输入空间中的超曲面模型对应于特征空间中的超平面模型\n- 在特征空间中求解线性支持向量机\n\n## 核函数\n\n从输入空间 X 到 特征空间 H 的映射关系为$\\phi(x)$\n\n则输入空间中的两个量的核函数值应该是映射函数的内积$K(x,z)=\\phi(x)\\cdot \\phi(z)$，K 是核函数\n\n给定核函数，特征空间和映射关系的取法不唯一\n\n## 非线性支持向量机\n\n只需要将线性支持向量机对偶形式中的内积换成核函数即可，当然实际计算过程过程麻烦了很多\n\n# 4.序列最小最优化方法\n\n支持向量机的学习问题可以转化为求解凸二次规划问题，但样本容量较大时，算法会变得低效；\n\n支持向量及的高效实现方法之一：**序列最小最优化 SMO 算法**\n\n分两步：\n\n（1）选择变量的启发式方法，将原问题不断分解为子问题 \n\n（2）求解两个变量二次规划的解析方法\n\n直到所有变量满足KKT条件为止","source":"_posts/统计学习方法七.md","raw":"---\ntitle: 【统计学习方法】7-SVM支持向量机\ndate: 2021-04-24 10:08:14\ncategories:\n\t- 机器学习\ntags:\n\t- 统计学习方法\n---\n\n**一句话介绍**\n\n支持向量机是一种分类模型，求解能够正确划分训练数据集并且几何间隔最大的分离超平面。\n\n------\n\n# 0.支持向量\n\n要理解什么是支持向量（support vector），首先需要理解以下几个概念：\n\n如果我们有一堆数据（二维），在二维平面上分布如下图所示：\n\n![微信图片_20210424102729](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20210424102729.jpg)\n\n我们可以用一条直线将这堆数据分成两个部分：\n\n【当这堆数据维数是**3维**，这条直线就成了**平面**；当数据**维数更高**，这条分隔线就成了**超平面**】以下统称超平面，数学表达为：\n\n$w^*\\cdot x + b^*=0$\n\n要说明的是，仅仅把这堆数据分离开，也许有无数个超平面可以做到；\n\n我们做一些规范，最大几何间隔的分离超平面，是唯一且存在的。\n\n很明显，分隔之后，有的点离这个超平面近，有的远，最近点到超平面的距离，称为**间隔**，这个最近的样本点的实例就被称为支持向量【本定义适用于线性可分情况下】。\n\n支持向量在确定分离超平面中起决定性作用（不移动支持向量，分离超平面就不会变化），所以把这种分类模型称为支持向量机。\n\n<!-- more -->\n\n相关重要概念：\n\n**类标记**概念：可以理解为因变量，但是这个量更准确地说是观测值、实际值，而不是由函数计算出来的\n\n**函数间隔**：该点的类标记和超平面函数值的乘积$\\hat \\gamma_i=y_i(w\\cdot x_i+b)$【表示分类预测的正确性和确信度】\n\n**几何间隔**：规定$L||w||=1$（L2范数）情况下的函数间隔$\\gamma_i=y_i(\\frac{w}{||w||}\\cdot x_i+\\frac{b}{||w||})$【实例点到超平面的带符号的距离】\n\n**硬间隔最大化**：线性可分的训练数据集——线性可分支持向量机\n\n**软间隔最大化**：训练数据集近似线性可分——线性支持向量机\n\n# 1.线性可分支持向量机\n\n找**最大间隔分离超平面**：该超平面对训练数据集的几何间隔至少应大于某个值；\n\n凸优化问题 P116 与凸二次规划问题\n\n## 最大间隔法\n\nin：可分训练数据集，x 和对应的类标记 y\n\nout：最大间隔分离超平面（参数 w 和 b），分类决策函数（$sign$函数）\n\n### 间隔边界\n\n与最大间隔分离超平面相平行的平面中，有两个超平面 H1 和 H2 之间没有任何实例点，这两个超平面就是间隔边界，中间的距离就是间隔。\n\n![IMG_20201117_105233](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/IMG_20201117_105233.jpg)\n\n### 线性可分支持向量机的对偶算法\n\n使用拉格朗日乘子法进行问题的转化，注意我们的目标：要使间隔最大——也就是![img](http://101.133.159.251:6001/plugins/servlet/latexmath/placeholder?key=2f22ec97a5d006440605bddabf953edc&vertAlign=-5px)尽可能小\n\n分类决策函数：$f(x)=sign(\\Sigma_{i=1}^N\\alpha_i^*y_i(x\\cdot x_i)+b^*)$只依赖于输入x和训练样本输入的内积\n\n本方法中，将训练数据中对应于$\\alpha^*_i>0$的样本点称为支持向量【这里的是$\\alpha_i$拉格朗日乘子】\n\n> 本方法核心思想是拉格朗日乘子法，在使用的过程中，将约束条件从几何间隔转化为了$\\alpha_i$的约束\n\n# 2.线性支持向量机\n\n## 训练样本线性不可分——软间隔最大化\n\n其实主要是有少量的“特异点”（outlier），将这些点去除之后，剩下的样本就线性可分了。\n\n我们并不能直接去除这些特异点，但是可以放宽标准，增加一个松弛变量，一来放宽限制，二来在目标函数中进行惩罚，确保误分类的样本尽量少。\n\n> 线性支持向量机包含线性可分支持向量机\n\n如果假设此处的分离超平面是$w^*\\cdot x+b^*=0$，那么 w 的解是唯一的，但是 b 的解可能不唯一，而是存在一个区间\n\n下图表示软间隔的支持向量：\n\n![软间隔的支持向量](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/软间隔的支持向量.jpg)\n\n\n\n## 合页损失函数\n\n在本问题中，还有一种以合页损失函数表示的目标函数：\n\n$\\Sigma_{i=1}^N[1-y_i(w\\cdot x_i+b)]_++\\lambda||w||^2$\n\n其中前半部分称为合页损失函数(hinge loss function)：$L(y(w\\cdot x+b))=[1-y(w\\cdot x+b)]_+$\n\n其中$[z]_+=\\left \\{ \\begin{aligned} z , z>0 \\\\ 0, z \\leq 0\\end{aligned} \\right.$\n\n该函数特性就是\n\n- 如果样本点被正确分类且函数间隔大于1，那么损失是0\n- 其他情况下，损失是$1-y_i(w\\cdot x_i+b)$\n\n下图中：\n\n- 左侧水平线是 0-1损失 的一部分【真正的二类分类问题】\n- 虚线斜线是合页损失函数（不带1时）\n- 实现是完整的合页损失函数，只有当确信度足够高时，损失才是0，要求更高\n\n![合页损失函数](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/合页损失函数.jpg)\n\n\n\n# 3.非线性支持向量机与核函数\n\n非线性可分问题：如果能用一个超曲面将正负类正确分开，则称非线性可分问题\n\n求解思路：进行非线性变换，将非线性问题变换为线性问题然后进行求解\n\n## 核技巧\n\n基本想法\n\n- 通过一个非线性变换将输入空间（欧式空间或者离散空间）对应于一个特征空间（希尔伯特空间）\n  使得输入空间中的超曲面模型对应于特征空间中的超平面模型\n- 在特征空间中求解线性支持向量机\n\n## 核函数\n\n从输入空间 X 到 特征空间 H 的映射关系为$\\phi(x)$\n\n则输入空间中的两个量的核函数值应该是映射函数的内积$K(x,z)=\\phi(x)\\cdot \\phi(z)$，K 是核函数\n\n给定核函数，特征空间和映射关系的取法不唯一\n\n## 非线性支持向量机\n\n只需要将线性支持向量机对偶形式中的内积换成核函数即可，当然实际计算过程过程麻烦了很多\n\n# 4.序列最小最优化方法\n\n支持向量机的学习问题可以转化为求解凸二次规划问题，但样本容量较大时，算法会变得低效；\n\n支持向量及的高效实现方法之一：**序列最小最优化 SMO 算法**\n\n分两步：\n\n（1）选择变量的启发式方法，将原问题不断分解为子问题 \n\n（2）求解两个变量二次规划的解析方法\n\n直到所有变量满足KKT条件为止","slug":"统计学习方法七","published":1,"updated":"2021-04-24T02:52:23.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n88c001jk8tl2agc1bby","content":"<p><strong>一句话介绍</strong></p>\n<p>支持向量机是一种分类模型，求解能够正确划分训练数据集并且几何间隔最大的分离超平面。</p>\n<hr>\n<h1 id=\"0-支持向量\"><a href=\"#0-支持向量\" class=\"headerlink\" title=\"0.支持向量\"></a>0.支持向量</h1><p>要理解什么是支持向量（support vector），首先需要理解以下几个概念：</p>\n<p>如果我们有一堆数据（二维），在二维平面上分布如下图所示：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20210424102729.jpg\" alt=\"微信图片_20210424102729\"></p>\n<p>我们可以用一条直线将这堆数据分成两个部分：</p>\n<p>【当这堆数据维数是<strong>3维</strong>，这条直线就成了<strong>平面</strong>；当数据<strong>维数更高</strong>，这条分隔线就成了<strong>超平面</strong>】以下统称超平面，数学表达为：</p>\n<p>$w^<em>\\cdot x + b^</em>=0$</p>\n<p>要说明的是，仅仅把这堆数据分离开，也许有无数个超平面可以做到；</p>\n<p>我们做一些规范，最大几何间隔的分离超平面，是唯一且存在的。</p>\n<p>很明显，分隔之后，有的点离这个超平面近，有的远，最近点到超平面的距离，称为<strong>间隔</strong>，这个最近的样本点的实例就被称为支持向量【本定义适用于线性可分情况下】。</p>\n<p>支持向量在确定分离超平面中起决定性作用（不移动支持向量，分离超平面就不会变化），所以把这种分类模型称为支持向量机。</p>\n<a id=\"more\"></a>\n<p>相关重要概念：</p>\n<p><strong>类标记</strong>概念：可以理解为因变量，但是这个量更准确地说是观测值、实际值，而不是由函数计算出来的</p>\n<p><strong>函数间隔</strong>：该点的类标记和超平面函数值的乘积$\\hat \\gamma_i=y_i(w\\cdot x_i+b)$【表示分类预测的正确性和确信度】</p>\n<p><strong>几何间隔</strong>：规定$L||w||=1$（L2范数）情况下的函数间隔$\\gamma_i=y_i(\\frac{w}{||w||}\\cdot x_i+\\frac{b}{||w||})$【实例点到超平面的带符号的距离】</p>\n<p><strong>硬间隔最大化</strong>：线性可分的训练数据集——线性可分支持向量机</p>\n<p><strong>软间隔最大化</strong>：训练数据集近似线性可分——线性支持向量机</p>\n<h1 id=\"1-线性可分支持向量机\"><a href=\"#1-线性可分支持向量机\" class=\"headerlink\" title=\"1.线性可分支持向量机\"></a>1.线性可分支持向量机</h1><p>找<strong>最大间隔分离超平面</strong>：该超平面对训练数据集的几何间隔至少应大于某个值；</p>\n<p>凸优化问题 P116 与凸二次规划问题</p>\n<h2 id=\"最大间隔法\"><a href=\"#最大间隔法\" class=\"headerlink\" title=\"最大间隔法\"></a>最大间隔法</h2><p>in：可分训练数据集，x 和对应的类标记 y</p>\n<p>out：最大间隔分离超平面（参数 w 和 b），分类决策函数（$sign$函数）</p>\n<h3 id=\"间隔边界\"><a href=\"#间隔边界\" class=\"headerlink\" title=\"间隔边界\"></a>间隔边界</h3><p>与最大间隔分离超平面相平行的平面中，有两个超平面 H1 和 H2 之间没有任何实例点，这两个超平面就是间隔边界，中间的距离就是间隔。</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/IMG_20201117_105233.jpg\" alt=\"IMG_20201117_105233\"></p>\n<h3 id=\"线性可分支持向量机的对偶算法\"><a href=\"#线性可分支持向量机的对偶算法\" class=\"headerlink\" title=\"线性可分支持向量机的对偶算法\"></a>线性可分支持向量机的对偶算法</h3><p>使用拉格朗日乘子法进行问题的转化，注意我们的目标：要使间隔最大——也就是<img src=\"http://101.133.159.251:6001/plugins/servlet/latexmath/placeholder?key=2f22ec97a5d006440605bddabf953edc&amp;vertAlign=-5px\" alt=\"img\">尽可能小</p>\n<p>分类决策函数：$f(x)=sign(\\Sigma_{i=1}^N\\alpha_i^<em>y_i(x\\cdot x_i)+b^</em>)$只依赖于输入x和训练样本输入的内积</p>\n<p>本方法中，将训练数据中对应于$\\alpha^*_i&gt;0$的样本点称为支持向量【这里的是$\\alpha_i$拉格朗日乘子】</p>\n<blockquote>\n<p>本方法核心思想是拉格朗日乘子法，在使用的过程中，将约束条件从几何间隔转化为了$\\alpha_i$的约束</p>\n</blockquote>\n<h1 id=\"2-线性支持向量机\"><a href=\"#2-线性支持向量机\" class=\"headerlink\" title=\"2.线性支持向量机\"></a>2.线性支持向量机</h1><h2 id=\"训练样本线性不可分——软间隔最大化\"><a href=\"#训练样本线性不可分——软间隔最大化\" class=\"headerlink\" title=\"训练样本线性不可分——软间隔最大化\"></a>训练样本线性不可分——软间隔最大化</h2><p>其实主要是有少量的“特异点”（outlier），将这些点去除之后，剩下的样本就线性可分了。</p>\n<p>我们并不能直接去除这些特异点，但是可以放宽标准，增加一个松弛变量，一来放宽限制，二来在目标函数中进行惩罚，确保误分类的样本尽量少。</p>\n<blockquote>\n<p>线性支持向量机包含线性可分支持向量机</p>\n</blockquote>\n<p>如果假设此处的分离超平面是$w^<em>\\cdot x+b^</em>=0$，那么 w 的解是唯一的，但是 b 的解可能不唯一，而是存在一个区间</p>\n<p>下图表示软间隔的支持向量：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/软间隔的支持向量.jpg\" alt=\"软间隔的支持向量\"></p>\n<h2 id=\"合页损失函数\"><a href=\"#合页损失函数\" class=\"headerlink\" title=\"合页损失函数\"></a>合页损失函数</h2><p>在本问题中，还有一种以合页损失函数表示的目标函数：</p>\n<p>$\\Sigma_{i=1}^N[1-y_i(w\\cdot x_i+b)]_++\\lambda||w||^2$</p>\n<p>其中前半部分称为合页损失函数(hinge loss function)：$L(y(w\\cdot x+b))=[1-y(w\\cdot x+b)]_+$</p>\n<p>其中$[z]_+=\\left \\{ \\begin{aligned} z , z&gt;0 \\\\ 0, z \\leq 0\\end{aligned} \\right.$</p>\n<p>该函数特性就是</p>\n<ul>\n<li>如果样本点被正确分类且函数间隔大于1，那么损失是0</li>\n<li>其他情况下，损失是$1-y_i(w\\cdot x_i+b)$</li>\n</ul>\n<p>下图中：</p>\n<ul>\n<li>左侧水平线是 0-1损失 的一部分【真正的二类分类问题】</li>\n<li>虚线斜线是合页损失函数（不带1时）</li>\n<li>实现是完整的合页损失函数，只有当确信度足够高时，损失才是0，要求更高</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/合页损失函数.jpg\" alt=\"合页损失函数\"></p>\n<h1 id=\"3-非线性支持向量机与核函数\"><a href=\"#3-非线性支持向量机与核函数\" class=\"headerlink\" title=\"3.非线性支持向量机与核函数\"></a>3.非线性支持向量机与核函数</h1><p>非线性可分问题：如果能用一个超曲面将正负类正确分开，则称非线性可分问题</p>\n<p>求解思路：进行非线性变换，将非线性问题变换为线性问题然后进行求解</p>\n<h2 id=\"核技巧\"><a href=\"#核技巧\" class=\"headerlink\" title=\"核技巧\"></a>核技巧</h2><p>基本想法</p>\n<ul>\n<li>通过一个非线性变换将输入空间（欧式空间或者离散空间）对应于一个特征空间（希尔伯特空间）<br>使得输入空间中的超曲面模型对应于特征空间中的超平面模型</li>\n<li>在特征空间中求解线性支持向量机</li>\n</ul>\n<h2 id=\"核函数\"><a href=\"#核函数\" class=\"headerlink\" title=\"核函数\"></a>核函数</h2><p>从输入空间 X 到 特征空间 H 的映射关系为$\\phi(x)$</p>\n<p>则输入空间中的两个量的核函数值应该是映射函数的内积$K(x,z)=\\phi(x)\\cdot \\phi(z)$，K 是核函数</p>\n<p>给定核函数，特征空间和映射关系的取法不唯一</p>\n<h2 id=\"非线性支持向量机\"><a href=\"#非线性支持向量机\" class=\"headerlink\" title=\"非线性支持向量机\"></a>非线性支持向量机</h2><p>只需要将线性支持向量机对偶形式中的内积换成核函数即可，当然实际计算过程过程麻烦了很多</p>\n<h1 id=\"4-序列最小最优化方法\"><a href=\"#4-序列最小最优化方法\" class=\"headerlink\" title=\"4.序列最小最优化方法\"></a>4.序列最小最优化方法</h1><p>支持向量机的学习问题可以转化为求解凸二次规划问题，但样本容量较大时，算法会变得低效；</p>\n<p>支持向量及的高效实现方法之一：<strong>序列最小最优化 SMO 算法</strong></p>\n<p>分两步：</p>\n<p>（1）选择变量的启发式方法，将原问题不断分解为子问题 </p>\n<p>（2）求解两个变量二次规划的解析方法</p>\n<p>直到所有变量满足KKT条件为止</p>\n","site":{"data":{}},"excerpt":"<p><strong>一句话介绍</strong></p>\n<p>支持向量机是一种分类模型，求解能够正确划分训练数据集并且几何间隔最大的分离超平面。</p>\n<hr>\n<h1 id=\"0-支持向量\"><a href=\"#0-支持向量\" class=\"headerlink\" title=\"0.支持向量\"></a>0.支持向量</h1><p>要理解什么是支持向量（support vector），首先需要理解以下几个概念：</p>\n<p>如果我们有一堆数据（二维），在二维平面上分布如下图所示：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20210424102729.jpg\" alt=\"微信图片_20210424102729\"></p>\n<p>我们可以用一条直线将这堆数据分成两个部分：</p>\n<p>【当这堆数据维数是<strong>3维</strong>，这条直线就成了<strong>平面</strong>；当数据<strong>维数更高</strong>，这条分隔线就成了<strong>超平面</strong>】以下统称超平面，数学表达为：</p>\n<p>$w^<em>\\cdot x + b^</em>=0$</p>\n<p>要说明的是，仅仅把这堆数据分离开，也许有无数个超平面可以做到；</p>\n<p>我们做一些规范，最大几何间隔的分离超平面，是唯一且存在的。</p>\n<p>很明显，分隔之后，有的点离这个超平面近，有的远，最近点到超平面的距离，称为<strong>间隔</strong>，这个最近的样本点的实例就被称为支持向量【本定义适用于线性可分情况下】。</p>\n<p>支持向量在确定分离超平面中起决定性作用（不移动支持向量，分离超平面就不会变化），所以把这种分类模型称为支持向量机。</p>","more":"<p>相关重要概念：</p>\n<p><strong>类标记</strong>概念：可以理解为因变量，但是这个量更准确地说是观测值、实际值，而不是由函数计算出来的</p>\n<p><strong>函数间隔</strong>：该点的类标记和超平面函数值的乘积$\\hat \\gamma_i=y_i(w\\cdot x_i+b)$【表示分类预测的正确性和确信度】</p>\n<p><strong>几何间隔</strong>：规定$L||w||=1$（L2范数）情况下的函数间隔$\\gamma_i=y_i(\\frac{w}{||w||}\\cdot x_i+\\frac{b}{||w||})$【实例点到超平面的带符号的距离】</p>\n<p><strong>硬间隔最大化</strong>：线性可分的训练数据集——线性可分支持向量机</p>\n<p><strong>软间隔最大化</strong>：训练数据集近似线性可分——线性支持向量机</p>\n<h1 id=\"1-线性可分支持向量机\"><a href=\"#1-线性可分支持向量机\" class=\"headerlink\" title=\"1.线性可分支持向量机\"></a>1.线性可分支持向量机</h1><p>找<strong>最大间隔分离超平面</strong>：该超平面对训练数据集的几何间隔至少应大于某个值；</p>\n<p>凸优化问题 P116 与凸二次规划问题</p>\n<h2 id=\"最大间隔法\"><a href=\"#最大间隔法\" class=\"headerlink\" title=\"最大间隔法\"></a>最大间隔法</h2><p>in：可分训练数据集，x 和对应的类标记 y</p>\n<p>out：最大间隔分离超平面（参数 w 和 b），分类决策函数（$sign$函数）</p>\n<h3 id=\"间隔边界\"><a href=\"#间隔边界\" class=\"headerlink\" title=\"间隔边界\"></a>间隔边界</h3><p>与最大间隔分离超平面相平行的平面中，有两个超平面 H1 和 H2 之间没有任何实例点，这两个超平面就是间隔边界，中间的距离就是间隔。</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/IMG_20201117_105233.jpg\" alt=\"IMG_20201117_105233\"></p>\n<h3 id=\"线性可分支持向量机的对偶算法\"><a href=\"#线性可分支持向量机的对偶算法\" class=\"headerlink\" title=\"线性可分支持向量机的对偶算法\"></a>线性可分支持向量机的对偶算法</h3><p>使用拉格朗日乘子法进行问题的转化，注意我们的目标：要使间隔最大——也就是<img src=\"http://101.133.159.251:6001/plugins/servlet/latexmath/placeholder?key=2f22ec97a5d006440605bddabf953edc&amp;vertAlign=-5px\" alt=\"img\">尽可能小</p>\n<p>分类决策函数：$f(x)=sign(\\Sigma_{i=1}^N\\alpha_i^<em>y_i(x\\cdot x_i)+b^</em>)$只依赖于输入x和训练样本输入的内积</p>\n<p>本方法中，将训练数据中对应于$\\alpha^*_i&gt;0$的样本点称为支持向量【这里的是$\\alpha_i$拉格朗日乘子】</p>\n<blockquote>\n<p>本方法核心思想是拉格朗日乘子法，在使用的过程中，将约束条件从几何间隔转化为了$\\alpha_i$的约束</p>\n</blockquote>\n<h1 id=\"2-线性支持向量机\"><a href=\"#2-线性支持向量机\" class=\"headerlink\" title=\"2.线性支持向量机\"></a>2.线性支持向量机</h1><h2 id=\"训练样本线性不可分——软间隔最大化\"><a href=\"#训练样本线性不可分——软间隔最大化\" class=\"headerlink\" title=\"训练样本线性不可分——软间隔最大化\"></a>训练样本线性不可分——软间隔最大化</h2><p>其实主要是有少量的“特异点”（outlier），将这些点去除之后，剩下的样本就线性可分了。</p>\n<p>我们并不能直接去除这些特异点，但是可以放宽标准，增加一个松弛变量，一来放宽限制，二来在目标函数中进行惩罚，确保误分类的样本尽量少。</p>\n<blockquote>\n<p>线性支持向量机包含线性可分支持向量机</p>\n</blockquote>\n<p>如果假设此处的分离超平面是$w^<em>\\cdot x+b^</em>=0$，那么 w 的解是唯一的，但是 b 的解可能不唯一，而是存在一个区间</p>\n<p>下图表示软间隔的支持向量：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/软间隔的支持向量.jpg\" alt=\"软间隔的支持向量\"></p>\n<h2 id=\"合页损失函数\"><a href=\"#合页损失函数\" class=\"headerlink\" title=\"合页损失函数\"></a>合页损失函数</h2><p>在本问题中，还有一种以合页损失函数表示的目标函数：</p>\n<p>$\\Sigma_{i=1}^N[1-y_i(w\\cdot x_i+b)]_++\\lambda||w||^2$</p>\n<p>其中前半部分称为合页损失函数(hinge loss function)：$L(y(w\\cdot x+b))=[1-y(w\\cdot x+b)]_+$</p>\n<p>其中$[z]_+=\\left \\{ \\begin{aligned} z , z&gt;0 \\\\ 0, z \\leq 0\\end{aligned} \\right.$</p>\n<p>该函数特性就是</p>\n<ul>\n<li>如果样本点被正确分类且函数间隔大于1，那么损失是0</li>\n<li>其他情况下，损失是$1-y_i(w\\cdot x_i+b)$</li>\n</ul>\n<p>下图中：</p>\n<ul>\n<li>左侧水平线是 0-1损失 的一部分【真正的二类分类问题】</li>\n<li>虚线斜线是合页损失函数（不带1时）</li>\n<li>实现是完整的合页损失函数，只有当确信度足够高时，损失才是0，要求更高</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/合页损失函数.jpg\" alt=\"合页损失函数\"></p>\n<h1 id=\"3-非线性支持向量机与核函数\"><a href=\"#3-非线性支持向量机与核函数\" class=\"headerlink\" title=\"3.非线性支持向量机与核函数\"></a>3.非线性支持向量机与核函数</h1><p>非线性可分问题：如果能用一个超曲面将正负类正确分开，则称非线性可分问题</p>\n<p>求解思路：进行非线性变换，将非线性问题变换为线性问题然后进行求解</p>\n<h2 id=\"核技巧\"><a href=\"#核技巧\" class=\"headerlink\" title=\"核技巧\"></a>核技巧</h2><p>基本想法</p>\n<ul>\n<li>通过一个非线性变换将输入空间（欧式空间或者离散空间）对应于一个特征空间（希尔伯特空间）<br>使得输入空间中的超曲面模型对应于特征空间中的超平面模型</li>\n<li>在特征空间中求解线性支持向量机</li>\n</ul>\n<h2 id=\"核函数\"><a href=\"#核函数\" class=\"headerlink\" title=\"核函数\"></a>核函数</h2><p>从输入空间 X 到 特征空间 H 的映射关系为$\\phi(x)$</p>\n<p>则输入空间中的两个量的核函数值应该是映射函数的内积$K(x,z)=\\phi(x)\\cdot \\phi(z)$，K 是核函数</p>\n<p>给定核函数，特征空间和映射关系的取法不唯一</p>\n<h2 id=\"非线性支持向量机\"><a href=\"#非线性支持向量机\" class=\"headerlink\" title=\"非线性支持向量机\"></a>非线性支持向量机</h2><p>只需要将线性支持向量机对偶形式中的内积换成核函数即可，当然实际计算过程过程麻烦了很多</p>\n<h1 id=\"4-序列最小最优化方法\"><a href=\"#4-序列最小最优化方法\" class=\"headerlink\" title=\"4.序列最小最优化方法\"></a>4.序列最小最优化方法</h1><p>支持向量机的学习问题可以转化为求解凸二次规划问题，但样本容量较大时，算法会变得低效；</p>\n<p>支持向量及的高效实现方法之一：<strong>序列最小最优化 SMO 算法</strong></p>\n<p>分两步：</p>\n<p>（1）选择变量的启发式方法，将原问题不断分解为子问题 </p>\n<p>（2）求解两个变量二次规划的解析方法</p>\n<p>直到所有变量满足KKT条件为止</p>"},{"title":"【统计学习方法】3-k近邻算法","date":"2021-01-26T02:42:00.000Z","_content":"\n一句话解释：在大样本中，找距离目标点最近的k个点。\n\n---\n\n# 什么是K近邻算法\n\n## 对两个实例点之间的距离进行度量\n\n1. 其实就是使用了范数，不同范数对应的距离度量下的最近邻点不同\n2. 可以简单理解为计算两个点之间的距离\n\n<!--more-->\n\n## K值是什么\n\n1. 在训练集T中找到与目标点 x 最邻近的 k 个点\n\n   1. k越小，模型复杂度越高，容易过拟合（因为一个点很有可能是噪声）\n2. k越大，可以减少学习的估计误差，但是也会导致学习的近似误差增大，本来不相似的东西也会被认为属于比较邻近的集合\n   \n2. 一般来说，k值是一个比较小的数值\n\n3. 采用交叉验证法来选择最优的k值\n\n## 分类决策规则\n\n1. 多数表决规则\n   1. 由k个最邻近的点中的多数来决定该点所属的类\n2. 衡量分的对不对？\n   1. 误分类概念，要使误分类概率最小\n\n![微信图片_20200303164303](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164303.jpg)\n\n# 怎么实现这个算法呢？\n\n1. 老老实实计算**每一个点与目标点之间的距离**？\n   那要是训练集非常大，岂不是非常**耗时费力**？\n2. 所以要使用**kd树方法——对k维空间中的点进行存储以便对其进行快速检索的树形数据结构。**\n\n## kd树方法\n\n**关键两点，一个是构造，另一个是搜索**\n\n1. 树方法实质\n   1. 管他什么树方法，说白了就是**不断分割；**\n   2. 刚开始整个区域，包含全部点，分一下，各区域点就少了很多，分啊分，最后的小区域点就非常少了，这样搜索效率会提高很多；\n   3. 实施起来可能和这个简单的说法略有不同，用到了坐标的中位数，形成的树中存储的是点的坐标。\n2. 如何理解这个树形结构\n   1. 要注意，这个树不是说每个实例点是一个树枝，而是数据集划分空间才是树枝；\n   2. 也就是说刚才是整个数据集——这就是根结点，然后这个数据集分了两部分，就是两个子区域，分别是一个节点……分啊分，某个小区域里面没有实例点了，这个小区域就是树的末端了（叶结点）。\n3. 搜索方法\n   1. 先从叶结点开始检查，然后回退检查父结点和父结点的其他子结点；\n   2. 我们假设一下，有个叶结点比较近，那这个叶结点肯定是目标结点的一个近邻了，然后看一下父结点，结果发现比它还近，然后再回退父结点和父结点的其他子结点，找啊找，直到检索到根结点，就找到了最近的点。要是父结点并不近，那么肯定，这个点就算是最近的了。\n\n![微信图片_20200303164338](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164339.jpg)\n\n![微信图片_20200303164418](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164418.jpg)","source":"_posts/统计学习方法三.md","raw":"---\ntitle: 【统计学习方法】3-k近邻算法\ndate: 2021-01-26 10:42:00\ncategories:\n\t- 机器学习\ntags:\n\t- 统计学习方法\n---\n\n一句话解释：在大样本中，找距离目标点最近的k个点。\n\n---\n\n# 什么是K近邻算法\n\n## 对两个实例点之间的距离进行度量\n\n1. 其实就是使用了范数，不同范数对应的距离度量下的最近邻点不同\n2. 可以简单理解为计算两个点之间的距离\n\n<!--more-->\n\n## K值是什么\n\n1. 在训练集T中找到与目标点 x 最邻近的 k 个点\n\n   1. k越小，模型复杂度越高，容易过拟合（因为一个点很有可能是噪声）\n2. k越大，可以减少学习的估计误差，但是也会导致学习的近似误差增大，本来不相似的东西也会被认为属于比较邻近的集合\n   \n2. 一般来说，k值是一个比较小的数值\n\n3. 采用交叉验证法来选择最优的k值\n\n## 分类决策规则\n\n1. 多数表决规则\n   1. 由k个最邻近的点中的多数来决定该点所属的类\n2. 衡量分的对不对？\n   1. 误分类概念，要使误分类概率最小\n\n![微信图片_20200303164303](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164303.jpg)\n\n# 怎么实现这个算法呢？\n\n1. 老老实实计算**每一个点与目标点之间的距离**？\n   那要是训练集非常大，岂不是非常**耗时费力**？\n2. 所以要使用**kd树方法——对k维空间中的点进行存储以便对其进行快速检索的树形数据结构。**\n\n## kd树方法\n\n**关键两点，一个是构造，另一个是搜索**\n\n1. 树方法实质\n   1. 管他什么树方法，说白了就是**不断分割；**\n   2. 刚开始整个区域，包含全部点，分一下，各区域点就少了很多，分啊分，最后的小区域点就非常少了，这样搜索效率会提高很多；\n   3. 实施起来可能和这个简单的说法略有不同，用到了坐标的中位数，形成的树中存储的是点的坐标。\n2. 如何理解这个树形结构\n   1. 要注意，这个树不是说每个实例点是一个树枝，而是数据集划分空间才是树枝；\n   2. 也就是说刚才是整个数据集——这就是根结点，然后这个数据集分了两部分，就是两个子区域，分别是一个节点……分啊分，某个小区域里面没有实例点了，这个小区域就是树的末端了（叶结点）。\n3. 搜索方法\n   1. 先从叶结点开始检查，然后回退检查父结点和父结点的其他子结点；\n   2. 我们假设一下，有个叶结点比较近，那这个叶结点肯定是目标结点的一个近邻了，然后看一下父结点，结果发现比它还近，然后再回退父结点和父结点的其他子结点，找啊找，直到检索到根结点，就找到了最近的点。要是父结点并不近，那么肯定，这个点就算是最近的了。\n\n![微信图片_20200303164338](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164339.jpg)\n\n![微信图片_20200303164418](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164418.jpg)","slug":"统计学习方法三","published":1,"updated":"2021-01-26T06:12:56.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n88d001nk8tl0fvxg7eo","content":"<p>一句话解释：在大样本中，找距离目标点最近的k个点。</p>\n<hr>\n<h1 id=\"什么是K近邻算法\"><a href=\"#什么是K近邻算法\" class=\"headerlink\" title=\"什么是K近邻算法\"></a>什么是K近邻算法</h1><h2 id=\"对两个实例点之间的距离进行度量\"><a href=\"#对两个实例点之间的距离进行度量\" class=\"headerlink\" title=\"对两个实例点之间的距离进行度量\"></a>对两个实例点之间的距离进行度量</h2><ol>\n<li>其实就是使用了范数，不同范数对应的距离度量下的最近邻点不同</li>\n<li>可以简单理解为计算两个点之间的距离</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"K值是什么\"><a href=\"#K值是什么\" class=\"headerlink\" title=\"K值是什么\"></a>K值是什么</h2><ol>\n<li><p>在训练集T中找到与目标点 x 最邻近的 k 个点</p>\n<ol>\n<li>k越小，模型复杂度越高，容易过拟合（因为一个点很有可能是噪声）</li>\n</ol>\n</li>\n<li><p>k越大，可以减少学习的估计误差，但是也会导致学习的近似误差增大，本来不相似的东西也会被认为属于比较邻近的集合</p>\n</li>\n<li><p>一般来说，k值是一个比较小的数值</p>\n</li>\n<li><p>采用交叉验证法来选择最优的k值</p>\n</li>\n</ol>\n<h2 id=\"分类决策规则\"><a href=\"#分类决策规则\" class=\"headerlink\" title=\"分类决策规则\"></a>分类决策规则</h2><ol>\n<li>多数表决规则<ol>\n<li>由k个最邻近的点中的多数来决定该点所属的类</li>\n</ol>\n</li>\n<li>衡量分的对不对？<ol>\n<li>误分类概念，要使误分类概率最小</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164303.jpg\" alt=\"微信图片_20200303164303\"></p>\n<h1 id=\"怎么实现这个算法呢？\"><a href=\"#怎么实现这个算法呢？\" class=\"headerlink\" title=\"怎么实现这个算法呢？\"></a>怎么实现这个算法呢？</h1><ol>\n<li>老老实实计算<strong>每一个点与目标点之间的距离</strong>？<br>那要是训练集非常大，岂不是非常<strong>耗时费力</strong>？</li>\n<li>所以要使用<strong>kd树方法——对k维空间中的点进行存储以便对其进行快速检索的树形数据结构。</strong></li>\n</ol>\n<h2 id=\"kd树方法\"><a href=\"#kd树方法\" class=\"headerlink\" title=\"kd树方法\"></a>kd树方法</h2><p><strong>关键两点，一个是构造，另一个是搜索</strong></p>\n<ol>\n<li>树方法实质<ol>\n<li>管他什么树方法，说白了就是<strong>不断分割；</strong></li>\n<li>刚开始整个区域，包含全部点，分一下，各区域点就少了很多，分啊分，最后的小区域点就非常少了，这样搜索效率会提高很多；</li>\n<li>实施起来可能和这个简单的说法略有不同，用到了坐标的中位数，形成的树中存储的是点的坐标。</li>\n</ol>\n</li>\n<li>如何理解这个树形结构<ol>\n<li>要注意，这个树不是说每个实例点是一个树枝，而是数据集划分空间才是树枝；</li>\n<li>也就是说刚才是整个数据集——这就是根结点，然后这个数据集分了两部分，就是两个子区域，分别是一个节点……分啊分，某个小区域里面没有实例点了，这个小区域就是树的末端了（叶结点）。</li>\n</ol>\n</li>\n<li>搜索方法<ol>\n<li>先从叶结点开始检查，然后回退检查父结点和父结点的其他子结点；</li>\n<li>我们假设一下，有个叶结点比较近，那这个叶结点肯定是目标结点的一个近邻了，然后看一下父结点，结果发现比它还近，然后再回退父结点和父结点的其他子结点，找啊找，直到检索到根结点，就找到了最近的点。要是父结点并不近，那么肯定，这个点就算是最近的了。</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164339.jpg\" alt=\"微信图片_20200303164338\"></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164418.jpg\" alt=\"微信图片_20200303164418\"></p>\n","site":{"data":{}},"excerpt":"<p>一句话解释：在大样本中，找距离目标点最近的k个点。</p>\n<hr>\n<h1 id=\"什么是K近邻算法\"><a href=\"#什么是K近邻算法\" class=\"headerlink\" title=\"什么是K近邻算法\"></a>什么是K近邻算法</h1><h2 id=\"对两个实例点之间的距离进行度量\"><a href=\"#对两个实例点之间的距离进行度量\" class=\"headerlink\" title=\"对两个实例点之间的距离进行度量\"></a>对两个实例点之间的距离进行度量</h2><ol>\n<li>其实就是使用了范数，不同范数对应的距离度量下的最近邻点不同</li>\n<li>可以简单理解为计算两个点之间的距离</li>\n</ol>","more":"<h2 id=\"K值是什么\"><a href=\"#K值是什么\" class=\"headerlink\" title=\"K值是什么\"></a>K值是什么</h2><ol>\n<li><p>在训练集T中找到与目标点 x 最邻近的 k 个点</p>\n<ol>\n<li>k越小，模型复杂度越高，容易过拟合（因为一个点很有可能是噪声）</li>\n</ol>\n</li>\n<li><p>k越大，可以减少学习的估计误差，但是也会导致学习的近似误差增大，本来不相似的东西也会被认为属于比较邻近的集合</p>\n</li>\n<li><p>一般来说，k值是一个比较小的数值</p>\n</li>\n<li><p>采用交叉验证法来选择最优的k值</p>\n</li>\n</ol>\n<h2 id=\"分类决策规则\"><a href=\"#分类决策规则\" class=\"headerlink\" title=\"分类决策规则\"></a>分类决策规则</h2><ol>\n<li>多数表决规则<ol>\n<li>由k个最邻近的点中的多数来决定该点所属的类</li>\n</ol>\n</li>\n<li>衡量分的对不对？<ol>\n<li>误分类概念，要使误分类概率最小</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164303.jpg\" alt=\"微信图片_20200303164303\"></p>\n<h1 id=\"怎么实现这个算法呢？\"><a href=\"#怎么实现这个算法呢？\" class=\"headerlink\" title=\"怎么实现这个算法呢？\"></a>怎么实现这个算法呢？</h1><ol>\n<li>老老实实计算<strong>每一个点与目标点之间的距离</strong>？<br>那要是训练集非常大，岂不是非常<strong>耗时费力</strong>？</li>\n<li>所以要使用<strong>kd树方法——对k维空间中的点进行存储以便对其进行快速检索的树形数据结构。</strong></li>\n</ol>\n<h2 id=\"kd树方法\"><a href=\"#kd树方法\" class=\"headerlink\" title=\"kd树方法\"></a>kd树方法</h2><p><strong>关键两点，一个是构造，另一个是搜索</strong></p>\n<ol>\n<li>树方法实质<ol>\n<li>管他什么树方法，说白了就是<strong>不断分割；</strong></li>\n<li>刚开始整个区域，包含全部点，分一下，各区域点就少了很多，分啊分，最后的小区域点就非常少了，这样搜索效率会提高很多；</li>\n<li>实施起来可能和这个简单的说法略有不同，用到了坐标的中位数，形成的树中存储的是点的坐标。</li>\n</ol>\n</li>\n<li>如何理解这个树形结构<ol>\n<li>要注意，这个树不是说每个实例点是一个树枝，而是数据集划分空间才是树枝；</li>\n<li>也就是说刚才是整个数据集——这就是根结点，然后这个数据集分了两部分，就是两个子区域，分别是一个节点……分啊分，某个小区域里面没有实例点了，这个小区域就是树的末端了（叶结点）。</li>\n</ol>\n</li>\n<li>搜索方法<ol>\n<li>先从叶结点开始检查，然后回退检查父结点和父结点的其他子结点；</li>\n<li>我们假设一下，有个叶结点比较近，那这个叶结点肯定是目标结点的一个近邻了，然后看一下父结点，结果发现比它还近，然后再回退父结点和父结点的其他子结点，找啊找，直到检索到根结点，就找到了最近的点。要是父结点并不近，那么肯定，这个点就算是最近的了。</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164339.jpg\" alt=\"微信图片_20200303164338\"></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/微信图片_20200303164418.jpg\" alt=\"微信图片_20200303164418\"></p>"},{"title":"【统计学习方法】2-感知机","date":"2021-01-23T07:12:57.000Z","_content":"\n**感知机**——二类分类的线性分类模型\n\n**特点**\n\n1. 导入基于误分类的损失函数\n2. 利用梯度下降法对损失函数进行极小化\n3. 求出将训练数据进行线性划分的分离超平面\n\n<!--more-->\n\n**重要概念表**\n\n| 定位  | 重要概念       | 符号    | 公式                    | 解释                     |\n| ----- | -------------- | ------- | ----------------------- | ------------------------ |\n| 2.2节 | 误分类点       |         |                         | 就是分类错误的点         |\n| 2.3节 | 步长（学习率） | $\\eta$  |                         | 用于更新权值$w$和偏置$b$ |\n| 2.2节 | $L_2$范数      | $||w||$ |                         | 表示 $w$ 的 $L_2$ 范数   |\n| 2.1节 | 权值           | $w$     | $f(x)=sign(w\\cdot x+b)$ | 超平面的法向量           |\n| 2.1节 | 偏置           | $b$     | $f(x)=sign(w\\cdot x+b)$ | 超平面的截距             |\n\n\n# 2.1 感知机模型\n\n感知机通过函数：\n\n$f(x)=sign(w\\cdot x+b)$\n\n来表示输入$x$到输出$f(x)$的关系。\n\n其中：\n\n1.符号函数：\n\n$sign=\\left \\{ \\begin{aligned} +1,x\\ge 0 \\\\ -1,x<0 \\end{aligned} \\right.$\n\n2.w和x是内积，b是偏置\n\n因此，感知机的意义是，输入一个 x ，通过感知机就能得到它的结果是 -1 或 1，很明显可以用于分类。\n\n补充：\n\n- 把线性方程$w\\cdot x+b=0$ 看作是一个超平面，则$w$是超平面的法向量，$b$ 是超平面的截距\n- 分类特点：超平面将特征空间划分为两个部分，位于两部分的点分别被分为正负两类\n\n------\n\n# 2.2 感知机学习策略\n\n【什么叫可以线性可分？】\n\n也就是说，存在超平面，能把**数据集的正负实例点**完全划分开。\n\n【反过来，用超平面是否能分割数据集，定义该**数据集**是不是线性可分】\n\n学习策略：\n\n- 定义一个经验损失函数——误分类点到超平面的总距离\n- 将损失函数极小化\n\n【怎么选一个好的损失函数？】\n\n此处选择的是——**误分类点到超平面的总距离**。显然，距离越大，说明误差越大。\n\n感知机$sign(w\\cdot x+b)$的损失函数是：\n\n$L(w,b)=-\\Sigma_{(x_i\\in M)}y_i(w\\cdot x_i+b)$\n\n值得注意的是 $y_i$ 只能是1或者-1，由于$y=-1$的存在，在梯度下降算法的过程中（2.3节），才会出现权重或者偏置减小的情况。\n\n【简单分析一下这个损失函数的功效】\n\n如果一个点 x 被误分类，就两种情况：\n\n$w\\cdot x_i+b>0$，但是$y_i<0$\n\n$w\\cdot x_i+b<0$，但是$y_i>0$\n\n那么这些点都满足$-y_i(w\\cdot x_i+b)>0$，**多一个误分类点，上面公式中的总和就会大一点，少一个误分类点，总和就会小一点**。\n\n------\n\n# 2.3 感知机学习算法\n\n求解损失函数的最优化问题——**随机梯度下降法（SGD：stochastic gradient descent）**\n\n1. 先任取权值$w_0$和偏置$b$，也就是选了一个任意超平面\n2. 取一个数据，判断一下$y_i(w\\cdot x_i+b)$和 0 的关系\n3. 如果$y_i(w\\cdot x_i+b)\\leq0$，说明这个点是个误分类点\n4. 那么就要调整权值和偏置，然后再到2步选个点计算，直到训练集中没有误分类点\n\n也就是用梯度下降法不断地极小化目标函数（注意：一次只是随机地选取一个误分类点使其梯度下降）\n\n这里面的核心，解决一个问题，【**怎么样调整权值和偏置？**】\n\n首先，我们要了解**损失函数的极小化和损失函数的梯度**：\n\n\n$min_{w,b} L(w,b)=-\\Sigma_{(x_i\\in M)} {y_i (w\\cdot x+b)}\\Longrightarrow \\begin{cases} \\Delta_w L(w,b)=-\\Sigma_{(x_i\\in M)} y_i x_i \\\\ \\Delta_b L(w,b)= -\\Sigma_{(x_i\\in M)}y_i \\end{cases}$\n\n我们希望的就是损失函数小，那么**损失函数的梯度**就可以用来调整**权值和偏置**了：\n\n$w+\\eta y_ix_i \\to w$\n\n$b+\\eta y_i \\to b$\n\n其中：步长 $\\eta$ (学习率)，对w和b进行更新。\n\n【最后一个问题】\n\n采用不同的初值或者选取不同的误分类点，解可以不同。\n\n【那么一定有解吗？】\n\n一定有解，但是证明比较长，直接看书吧。\n\n其他：文中还讲了原始形式和对偶形式。\n\nPS：对偶形式中，使用了**Gram矩阵**，也就是《矩阵理论与应用》（研究生教材）中**基的度量矩阵**","source":"_posts/统计学习方法二.md","raw":"---\ntitle: 【统计学习方法】2-感知机\ndate: 2021-01-23 15:12:57\ncategories:\n\t- 机器学习\ntags:\n\t- 统计学习方法\n---\n\n**感知机**——二类分类的线性分类模型\n\n**特点**\n\n1. 导入基于误分类的损失函数\n2. 利用梯度下降法对损失函数进行极小化\n3. 求出将训练数据进行线性划分的分离超平面\n\n<!--more-->\n\n**重要概念表**\n\n| 定位  | 重要概念       | 符号    | 公式                    | 解释                     |\n| ----- | -------------- | ------- | ----------------------- | ------------------------ |\n| 2.2节 | 误分类点       |         |                         | 就是分类错误的点         |\n| 2.3节 | 步长（学习率） | $\\eta$  |                         | 用于更新权值$w$和偏置$b$ |\n| 2.2节 | $L_2$范数      | $||w||$ |                         | 表示 $w$ 的 $L_2$ 范数   |\n| 2.1节 | 权值           | $w$     | $f(x)=sign(w\\cdot x+b)$ | 超平面的法向量           |\n| 2.1节 | 偏置           | $b$     | $f(x)=sign(w\\cdot x+b)$ | 超平面的截距             |\n\n\n# 2.1 感知机模型\n\n感知机通过函数：\n\n$f(x)=sign(w\\cdot x+b)$\n\n来表示输入$x$到输出$f(x)$的关系。\n\n其中：\n\n1.符号函数：\n\n$sign=\\left \\{ \\begin{aligned} +1,x\\ge 0 \\\\ -1,x<0 \\end{aligned} \\right.$\n\n2.w和x是内积，b是偏置\n\n因此，感知机的意义是，输入一个 x ，通过感知机就能得到它的结果是 -1 或 1，很明显可以用于分类。\n\n补充：\n\n- 把线性方程$w\\cdot x+b=0$ 看作是一个超平面，则$w$是超平面的法向量，$b$ 是超平面的截距\n- 分类特点：超平面将特征空间划分为两个部分，位于两部分的点分别被分为正负两类\n\n------\n\n# 2.2 感知机学习策略\n\n【什么叫可以线性可分？】\n\n也就是说，存在超平面，能把**数据集的正负实例点**完全划分开。\n\n【反过来，用超平面是否能分割数据集，定义该**数据集**是不是线性可分】\n\n学习策略：\n\n- 定义一个经验损失函数——误分类点到超平面的总距离\n- 将损失函数极小化\n\n【怎么选一个好的损失函数？】\n\n此处选择的是——**误分类点到超平面的总距离**。显然，距离越大，说明误差越大。\n\n感知机$sign(w\\cdot x+b)$的损失函数是：\n\n$L(w,b)=-\\Sigma_{(x_i\\in M)}y_i(w\\cdot x_i+b)$\n\n值得注意的是 $y_i$ 只能是1或者-1，由于$y=-1$的存在，在梯度下降算法的过程中（2.3节），才会出现权重或者偏置减小的情况。\n\n【简单分析一下这个损失函数的功效】\n\n如果一个点 x 被误分类，就两种情况：\n\n$w\\cdot x_i+b>0$，但是$y_i<0$\n\n$w\\cdot x_i+b<0$，但是$y_i>0$\n\n那么这些点都满足$-y_i(w\\cdot x_i+b)>0$，**多一个误分类点，上面公式中的总和就会大一点，少一个误分类点，总和就会小一点**。\n\n------\n\n# 2.3 感知机学习算法\n\n求解损失函数的最优化问题——**随机梯度下降法（SGD：stochastic gradient descent）**\n\n1. 先任取权值$w_0$和偏置$b$，也就是选了一个任意超平面\n2. 取一个数据，判断一下$y_i(w\\cdot x_i+b)$和 0 的关系\n3. 如果$y_i(w\\cdot x_i+b)\\leq0$，说明这个点是个误分类点\n4. 那么就要调整权值和偏置，然后再到2步选个点计算，直到训练集中没有误分类点\n\n也就是用梯度下降法不断地极小化目标函数（注意：一次只是随机地选取一个误分类点使其梯度下降）\n\n这里面的核心，解决一个问题，【**怎么样调整权值和偏置？**】\n\n首先，我们要了解**损失函数的极小化和损失函数的梯度**：\n\n\n$min_{w,b} L(w,b)=-\\Sigma_{(x_i\\in M)} {y_i (w\\cdot x+b)}\\Longrightarrow \\begin{cases} \\Delta_w L(w,b)=-\\Sigma_{(x_i\\in M)} y_i x_i \\\\ \\Delta_b L(w,b)= -\\Sigma_{(x_i\\in M)}y_i \\end{cases}$\n\n我们希望的就是损失函数小，那么**损失函数的梯度**就可以用来调整**权值和偏置**了：\n\n$w+\\eta y_ix_i \\to w$\n\n$b+\\eta y_i \\to b$\n\n其中：步长 $\\eta$ (学习率)，对w和b进行更新。\n\n【最后一个问题】\n\n采用不同的初值或者选取不同的误分类点，解可以不同。\n\n【那么一定有解吗？】\n\n一定有解，但是证明比较长，直接看书吧。\n\n其他：文中还讲了原始形式和对偶形式。\n\nPS：对偶形式中，使用了**Gram矩阵**，也就是《矩阵理论与应用》（研究生教材）中**基的度量矩阵**","slug":"统计学习方法二","published":1,"updated":"2021-01-28T07:30:03.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n88e001qk8tlafr3dmch","content":"<p><strong>感知机</strong>——二类分类的线性分类模型</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>导入基于误分类的损失函数</li>\n<li>利用梯度下降法对损失函数进行极小化</li>\n<li>求出将训练数据进行线性划分的分离超平面</li>\n</ol>\n<a id=\"more\"></a>\n<p><strong>重要概念表</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>定位</th>\n<th>重要概念</th>\n<th>符号</th>\n<th>公式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2.2节</td>\n<td>误分类点</td>\n<td></td>\n<td></td>\n<td>就是分类错误的点</td>\n</tr>\n<tr>\n<td>2.3节</td>\n<td>步长（学习率）</td>\n<td>$\\eta$</td>\n<td></td>\n<td>用于更新权值$w$和偏置$b$</td>\n</tr>\n<tr>\n<td>2.2节</td>\n<td>$L_2$范数</td>\n<td>$</td>\n<td></td>\n<td>w</td>\n<td></td>\n<td>$</td>\n<td></td>\n<td>表示 $w$ 的 $L_2$ 范数</td>\n</tr>\n<tr>\n<td>2.1节</td>\n<td>权值</td>\n<td>$w$</td>\n<td>$f(x)=sign(w\\cdot x+b)$</td>\n<td>超平面的法向量</td>\n</tr>\n<tr>\n<td>2.1节</td>\n<td>偏置</td>\n<td>$b$</td>\n<td>$f(x)=sign(w\\cdot x+b)$</td>\n<td>超平面的截距</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"2-1-感知机模型\"><a href=\"#2-1-感知机模型\" class=\"headerlink\" title=\"2.1 感知机模型\"></a>2.1 感知机模型</h1><p>感知机通过函数：</p>\n<p>$f(x)=sign(w\\cdot x+b)$</p>\n<p>来表示输入$x$到输出$f(x)$的关系。</p>\n<p>其中：</p>\n<p>1.符号函数：</p>\n<p>$sign=\\left \\{ \\begin{aligned} +1,x\\ge 0 \\\\ -1,x&lt;0 \\end{aligned} \\right.$</p>\n<p>2.w和x是内积，b是偏置</p>\n<p>因此，感知机的意义是，输入一个 x ，通过感知机就能得到它的结果是 -1 或 1，很明显可以用于分类。</p>\n<p>补充：</p>\n<ul>\n<li>把线性方程$w\\cdot x+b=0$ 看作是一个超平面，则$w$是超平面的法向量，$b$ 是超平面的截距</li>\n<li>分类特点：超平面将特征空间划分为两个部分，位于两部分的点分别被分为正负两类</li>\n</ul>\n<hr>\n<h1 id=\"2-2-感知机学习策略\"><a href=\"#2-2-感知机学习策略\" class=\"headerlink\" title=\"2.2 感知机学习策略\"></a>2.2 感知机学习策略</h1><p>【什么叫可以线性可分？】</p>\n<p>也就是说，存在超平面，能把<strong>数据集的正负实例点</strong>完全划分开。</p>\n<p>【反过来，用超平面是否能分割数据集，定义该<strong>数据集</strong>是不是线性可分】</p>\n<p>学习策略：</p>\n<ul>\n<li>定义一个经验损失函数——误分类点到超平面的总距离</li>\n<li>将损失函数极小化</li>\n</ul>\n<p>【怎么选一个好的损失函数？】</p>\n<p>此处选择的是——<strong>误分类点到超平面的总距离</strong>。显然，距离越大，说明误差越大。</p>\n<p>感知机$sign(w\\cdot x+b)$的损失函数是：</p>\n<p>$L(w,b)=-\\Sigma_{(x_i\\in M)}y_i(w\\cdot x_i+b)$</p>\n<p>值得注意的是 $y_i$ 只能是1或者-1，由于$y=-1$的存在，在梯度下降算法的过程中（2.3节），才会出现权重或者偏置减小的情况。</p>\n<p>【简单分析一下这个损失函数的功效】</p>\n<p>如果一个点 x 被误分类，就两种情况：</p>\n<p>$w\\cdot x_i+b&gt;0$，但是$y_i&lt;0$</p>\n<p>$w\\cdot x_i+b<0$，但是$y_i>0$</p>\n<p>那么这些点都满足$-y_i(w\\cdot x_i+b)&gt;0$，<strong>多一个误分类点，上面公式中的总和就会大一点，少一个误分类点，总和就会小一点</strong>。</p>\n<hr>\n<h1 id=\"2-3-感知机学习算法\"><a href=\"#2-3-感知机学习算法\" class=\"headerlink\" title=\"2.3 感知机学习算法\"></a>2.3 感知机学习算法</h1><p>求解损失函数的最优化问题——<strong>随机梯度下降法（SGD：stochastic gradient descent）</strong></p>\n<ol>\n<li>先任取权值$w_0$和偏置$b$，也就是选了一个任意超平面</li>\n<li>取一个数据，判断一下$y_i(w\\cdot x_i+b)$和 0 的关系</li>\n<li>如果$y_i(w\\cdot x_i+b)\\leq0$，说明这个点是个误分类点</li>\n<li>那么就要调整权值和偏置，然后再到2步选个点计算，直到训练集中没有误分类点</li>\n</ol>\n<p>也就是用梯度下降法不断地极小化目标函数（注意：一次只是随机地选取一个误分类点使其梯度下降）</p>\n<p>这里面的核心，解决一个问题，【<strong>怎么样调整权值和偏置？</strong>】</p>\n<p>首先，我们要了解<strong>损失函数的极小化和损失函数的梯度</strong>：</p>\n<p>$min_{w,b} L(w,b)=-\\Sigma_{(x_i\\in M)} {y_i (w\\cdot x+b)}\\Longrightarrow \\begin{cases} \\Delta_w L(w,b)=-\\Sigma_{(x_i\\in M)} y_i x_i \\\\ \\Delta_b L(w,b)= -\\Sigma_{(x_i\\in M)}y_i \\end{cases}$</p>\n<p>我们希望的就是损失函数小，那么<strong>损失函数的梯度</strong>就可以用来调整<strong>权值和偏置</strong>了：</p>\n<p>$w+\\eta y_ix_i \\to w$</p>\n<p>$b+\\eta y_i \\to b$</p>\n<p>其中：步长 $\\eta$ (学习率)，对w和b进行更新。</p>\n<p>【最后一个问题】</p>\n<p>采用不同的初值或者选取不同的误分类点，解可以不同。</p>\n<p>【那么一定有解吗？】</p>\n<p>一定有解，但是证明比较长，直接看书吧。</p>\n<p>其他：文中还讲了原始形式和对偶形式。</p>\n<p>PS：对偶形式中，使用了<strong>Gram矩阵</strong>，也就是《矩阵理论与应用》（研究生教材）中<strong>基的度量矩阵</strong></p>\n","site":{"data":{}},"excerpt":"<p><strong>感知机</strong>——二类分类的线性分类模型</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>导入基于误分类的损失函数</li>\n<li>利用梯度下降法对损失函数进行极小化</li>\n<li>求出将训练数据进行线性划分的分离超平面</li>\n</ol>","more":"<p><strong>重要概念表</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>定位</th>\n<th>重要概念</th>\n<th>符号</th>\n<th>公式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2.2节</td>\n<td>误分类点</td>\n<td></td>\n<td></td>\n<td>就是分类错误的点</td>\n</tr>\n<tr>\n<td>2.3节</td>\n<td>步长（学习率）</td>\n<td>$\\eta$</td>\n<td></td>\n<td>用于更新权值$w$和偏置$b$</td>\n</tr>\n<tr>\n<td>2.2节</td>\n<td>$L_2$范数</td>\n<td>$</td>\n<td></td>\n<td>w</td>\n<td></td>\n<td>$</td>\n<td></td>\n<td>表示 $w$ 的 $L_2$ 范数</td>\n</tr>\n<tr>\n<td>2.1节</td>\n<td>权值</td>\n<td>$w$</td>\n<td>$f(x)=sign(w\\cdot x+b)$</td>\n<td>超平面的法向量</td>\n</tr>\n<tr>\n<td>2.1节</td>\n<td>偏置</td>\n<td>$b$</td>\n<td>$f(x)=sign(w\\cdot x+b)$</td>\n<td>超平面的截距</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"2-1-感知机模型\"><a href=\"#2-1-感知机模型\" class=\"headerlink\" title=\"2.1 感知机模型\"></a>2.1 感知机模型</h1><p>感知机通过函数：</p>\n<p>$f(x)=sign(w\\cdot x+b)$</p>\n<p>来表示输入$x$到输出$f(x)$的关系。</p>\n<p>其中：</p>\n<p>1.符号函数：</p>\n<p>$sign=\\left \\{ \\begin{aligned} +1,x\\ge 0 \\\\ -1,x&lt;0 \\end{aligned} \\right.$</p>\n<p>2.w和x是内积，b是偏置</p>\n<p>因此，感知机的意义是，输入一个 x ，通过感知机就能得到它的结果是 -1 或 1，很明显可以用于分类。</p>\n<p>补充：</p>\n<ul>\n<li>把线性方程$w\\cdot x+b=0$ 看作是一个超平面，则$w$是超平面的法向量，$b$ 是超平面的截距</li>\n<li>分类特点：超平面将特征空间划分为两个部分，位于两部分的点分别被分为正负两类</li>\n</ul>\n<hr>\n<h1 id=\"2-2-感知机学习策略\"><a href=\"#2-2-感知机学习策略\" class=\"headerlink\" title=\"2.2 感知机学习策略\"></a>2.2 感知机学习策略</h1><p>【什么叫可以线性可分？】</p>\n<p>也就是说，存在超平面，能把<strong>数据集的正负实例点</strong>完全划分开。</p>\n<p>【反过来，用超平面是否能分割数据集，定义该<strong>数据集</strong>是不是线性可分】</p>\n<p>学习策略：</p>\n<ul>\n<li>定义一个经验损失函数——误分类点到超平面的总距离</li>\n<li>将损失函数极小化</li>\n</ul>\n<p>【怎么选一个好的损失函数？】</p>\n<p>此处选择的是——<strong>误分类点到超平面的总距离</strong>。显然，距离越大，说明误差越大。</p>\n<p>感知机$sign(w\\cdot x+b)$的损失函数是：</p>\n<p>$L(w,b)=-\\Sigma_{(x_i\\in M)}y_i(w\\cdot x_i+b)$</p>\n<p>值得注意的是 $y_i$ 只能是1或者-1，由于$y=-1$的存在，在梯度下降算法的过程中（2.3节），才会出现权重或者偏置减小的情况。</p>\n<p>【简单分析一下这个损失函数的功效】</p>\n<p>如果一个点 x 被误分类，就两种情况：</p>\n<p>$w\\cdot x_i+b&gt;0$，但是$y_i&lt;0$</p>\n<p>$w\\cdot x_i+b<0$，但是$y_i>0$</p>\n<p>那么这些点都满足$-y_i(w\\cdot x_i+b)&gt;0$，<strong>多一个误分类点，上面公式中的总和就会大一点，少一个误分类点，总和就会小一点</strong>。</p>\n<hr>\n<h1 id=\"2-3-感知机学习算法\"><a href=\"#2-3-感知机学习算法\" class=\"headerlink\" title=\"2.3 感知机学习算法\"></a>2.3 感知机学习算法</h1><p>求解损失函数的最优化问题——<strong>随机梯度下降法（SGD：stochastic gradient descent）</strong></p>\n<ol>\n<li>先任取权值$w_0$和偏置$b$，也就是选了一个任意超平面</li>\n<li>取一个数据，判断一下$y_i(w\\cdot x_i+b)$和 0 的关系</li>\n<li>如果$y_i(w\\cdot x_i+b)\\leq0$，说明这个点是个误分类点</li>\n<li>那么就要调整权值和偏置，然后再到2步选个点计算，直到训练集中没有误分类点</li>\n</ol>\n<p>也就是用梯度下降法不断地极小化目标函数（注意：一次只是随机地选取一个误分类点使其梯度下降）</p>\n<p>这里面的核心，解决一个问题，【<strong>怎么样调整权值和偏置？</strong>】</p>\n<p>首先，我们要了解<strong>损失函数的极小化和损失函数的梯度</strong>：</p>\n<p>$min_{w,b} L(w,b)=-\\Sigma_{(x_i\\in M)} {y_i (w\\cdot x+b)}\\Longrightarrow \\begin{cases} \\Delta_w L(w,b)=-\\Sigma_{(x_i\\in M)} y_i x_i \\\\ \\Delta_b L(w,b)= -\\Sigma_{(x_i\\in M)}y_i \\end{cases}$</p>\n<p>我们希望的就是损失函数小，那么<strong>损失函数的梯度</strong>就可以用来调整<strong>权值和偏置</strong>了：</p>\n<p>$w+\\eta y_ix_i \\to w$</p>\n<p>$b+\\eta y_i \\to b$</p>\n<p>其中：步长 $\\eta$ (学习率)，对w和b进行更新。</p>\n<p>【最后一个问题】</p>\n<p>采用不同的初值或者选取不同的误分类点，解可以不同。</p>\n<p>【那么一定有解吗？】</p>\n<p>一定有解，但是证明比较长，直接看书吧。</p>\n<p>其他：文中还讲了原始形式和对偶形式。</p>\n<p>PS：对偶形式中，使用了<strong>Gram矩阵</strong>，也就是《矩阵理论与应用》（研究生教材）中<strong>基的度量矩阵</strong></p>"},{"title":"【统计学习方法】6-回归和最大熵","date":"2021-04-17T01:36:13.000Z","_content":"\n一句话：本章提到两种应用了概率知识和最优化方法的对数线性数学模型。\n\n------\n\n首先对本章知识进行**定位**：\n\n1. 本章知识和前后联系都不是很大，但是 logistic 回归（sigmoid函数）确实十分常用的一个理论知识。\n2. 最大熵模型更是宏观地把回归和分类问题转换成最优化问题的数学模型。\n\n**本章公式极多，多为推导，在此大多数将不会列出，如果有兴趣，非常建议阅读原书。**\n\n<!-- more -->\n\n---\n\n# 1.逻辑斯谛回归\n\n我们之前接触过 sigmoid 函数，有很多视频中也叫 logistic 函数/回归等，原因大概就在本章。\n\n## 逻辑斯谛分布（logistic distribution）\n\n随机变量X如果满足：\n\n​    分布函数：$F(x)=\\frac{1}{1+e^{-(x-\\mu)/\\gamma}}$\n\n​    概率密度函数：$f(x)=\\frac{e^{-(x-\\mu)/\\gamma}}{\\gamma(1+e^{-(x-\\mu)/\\gamma})^2}$\n\n那么$x$就满足逻辑斯谛分布。\n\n(其中，$\\mu$为位置参数，$\\gamma >0$为形状参数。)\n\n\n\n分布特性：\n\n​    分布函数呈S形曲线，以点$(\\mu,\\frac{1}{2})$中心对称。\n\n​    概率密度函数，就是我们熟悉的——sigmoid函数的样子。\n\n## 二项逻辑斯谛回归模型\n\n【从分布上升到模型】\n\n满足以下公式的条件概率分布就是二项逻辑斯谛回归模型：\n\n$$P(Y=1|x)=\\frac{exp(w\\cdot x+b)}{1+exp(w\\cdot x+b)}\\\\ P(Y=1|x)=\\frac{1}{1+exp(w\\cdot x+b)}$$\n\n根据该模型，可以比较两个条件概率值的大小，从而将 x 分到概率值比较大的类别 Y（1或0）中。\n\n可以用**极大似然估计法**估计模型参数 w。\n\n\n\n一个相关的知识概念：\n\n​    几率（odds）：事件发生的概率 与 事件不发生的概率 的比值——$\\frac{p}{1-p}$\n\n​    对数几率（log odds）或 logit 函数：$logit(p)=log\\frac{p}{1-p}$ \n\n## 多项逻辑斯谛回归模型\n\n【模型推广】\n\n$$P(Y=k|x)=\\frac{exp(w_k\\cdot x)}{1+exp(w_k\\cdot x)}, k=1,2,...,K-1\\\\ P(Y=K|x)=\\frac{1}{1+\\Sigma_{k=1}^{K-1}exp(w_k\\cdot x)}$$\n\n# 2.最大熵模型\n\n**最大熵原理**：（概率模型学习的准则）\n\n​    **在所有可能的概率模型分布中，熵最大的模型是最好的模型。**\n\n​    或者描述为：在满足约束条件的模型集合中，熵最大的模型最好。\n\n\n\n回忆第5章内容：\n\n如果X的概率分布是P(X)，则**熵**为：$H(P)=-\\Sigma_xP(x)logP(x)$\n\n熵的一个特性是：$0\\leq H(P)\\leq log|X|$\n\n1. 其中，|X| 是 X 的取值的个数。\n2. 这个特性说明——熵有最大值（或者说有取值范围）。\n\n**熵取最大值的条件：**\n\n1. 当且仅当 X 的分布是均匀分布时，熵最大。\n2. 在满足约束条件的情况下，把不确定的部分认为是“等可能”的，此时熵最大。\n\n举个栗子：\n\n有两个约束条件\n\n$$P(A)+P(B)=\\frac{3}{10}\\\\ P(A)+P(B)+P(C)+P(D)+P(E)=1$$\n\n在缺少其他信息的情况下，可以认为：A 和 B 等概率，各为$\\frac{3}{20}$，C、D和E 等概率，各为$\\frac{7}{30}$\n\n\n\n**最大熵模型：**\n\n$$P_w(y|x)=\\frac{1}{Z_w(x)}exp(\\Sigma_{i=1}^nw_if_i(x,y))\\\\Z_w(w)=\\Sigma_yexp(\\Sigma_{i=1}^nw_if_i(x,y))$$\n\n​    其中，x 为输入，y 为输出， Zw 函数又叫规范化因子，fi 函数为任意实数值特征函数，w 是权值向量。\n\n\n\n# 3.模型学习\n书中使用了很大篇幅证明：最大熵模型学习中的**对偶函数极大化**等价于最大熵模型的极大似然估计（在此不搬运公式了）。\n\n可以将模型学习总结如下：\n\n![模型学习](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/模型学习.png)","source":"_posts/统计学习方法六.md","raw":"---\ntitle: 【统计学习方法】6-回归和最大熵\ndate: 2021-04-17 09:36:13\ncategories:\n\t- 机器学习\ntags:\n\t- 统计学习方法\n---\n\n一句话：本章提到两种应用了概率知识和最优化方法的对数线性数学模型。\n\n------\n\n首先对本章知识进行**定位**：\n\n1. 本章知识和前后联系都不是很大，但是 logistic 回归（sigmoid函数）确实十分常用的一个理论知识。\n2. 最大熵模型更是宏观地把回归和分类问题转换成最优化问题的数学模型。\n\n**本章公式极多，多为推导，在此大多数将不会列出，如果有兴趣，非常建议阅读原书。**\n\n<!-- more -->\n\n---\n\n# 1.逻辑斯谛回归\n\n我们之前接触过 sigmoid 函数，有很多视频中也叫 logistic 函数/回归等，原因大概就在本章。\n\n## 逻辑斯谛分布（logistic distribution）\n\n随机变量X如果满足：\n\n​    分布函数：$F(x)=\\frac{1}{1+e^{-(x-\\mu)/\\gamma}}$\n\n​    概率密度函数：$f(x)=\\frac{e^{-(x-\\mu)/\\gamma}}{\\gamma(1+e^{-(x-\\mu)/\\gamma})^2}$\n\n那么$x$就满足逻辑斯谛分布。\n\n(其中，$\\mu$为位置参数，$\\gamma >0$为形状参数。)\n\n\n\n分布特性：\n\n​    分布函数呈S形曲线，以点$(\\mu,\\frac{1}{2})$中心对称。\n\n​    概率密度函数，就是我们熟悉的——sigmoid函数的样子。\n\n## 二项逻辑斯谛回归模型\n\n【从分布上升到模型】\n\n满足以下公式的条件概率分布就是二项逻辑斯谛回归模型：\n\n$$P(Y=1|x)=\\frac{exp(w\\cdot x+b)}{1+exp(w\\cdot x+b)}\\\\ P(Y=1|x)=\\frac{1}{1+exp(w\\cdot x+b)}$$\n\n根据该模型，可以比较两个条件概率值的大小，从而将 x 分到概率值比较大的类别 Y（1或0）中。\n\n可以用**极大似然估计法**估计模型参数 w。\n\n\n\n一个相关的知识概念：\n\n​    几率（odds）：事件发生的概率 与 事件不发生的概率 的比值——$\\frac{p}{1-p}$\n\n​    对数几率（log odds）或 logit 函数：$logit(p)=log\\frac{p}{1-p}$ \n\n## 多项逻辑斯谛回归模型\n\n【模型推广】\n\n$$P(Y=k|x)=\\frac{exp(w_k\\cdot x)}{1+exp(w_k\\cdot x)}, k=1,2,...,K-1\\\\ P(Y=K|x)=\\frac{1}{1+\\Sigma_{k=1}^{K-1}exp(w_k\\cdot x)}$$\n\n# 2.最大熵模型\n\n**最大熵原理**：（概率模型学习的准则）\n\n​    **在所有可能的概率模型分布中，熵最大的模型是最好的模型。**\n\n​    或者描述为：在满足约束条件的模型集合中，熵最大的模型最好。\n\n\n\n回忆第5章内容：\n\n如果X的概率分布是P(X)，则**熵**为：$H(P)=-\\Sigma_xP(x)logP(x)$\n\n熵的一个特性是：$0\\leq H(P)\\leq log|X|$\n\n1. 其中，|X| 是 X 的取值的个数。\n2. 这个特性说明——熵有最大值（或者说有取值范围）。\n\n**熵取最大值的条件：**\n\n1. 当且仅当 X 的分布是均匀分布时，熵最大。\n2. 在满足约束条件的情况下，把不确定的部分认为是“等可能”的，此时熵最大。\n\n举个栗子：\n\n有两个约束条件\n\n$$P(A)+P(B)=\\frac{3}{10}\\\\ P(A)+P(B)+P(C)+P(D)+P(E)=1$$\n\n在缺少其他信息的情况下，可以认为：A 和 B 等概率，各为$\\frac{3}{20}$，C、D和E 等概率，各为$\\frac{7}{30}$\n\n\n\n**最大熵模型：**\n\n$$P_w(y|x)=\\frac{1}{Z_w(x)}exp(\\Sigma_{i=1}^nw_if_i(x,y))\\\\Z_w(w)=\\Sigma_yexp(\\Sigma_{i=1}^nw_if_i(x,y))$$\n\n​    其中，x 为输入，y 为输出， Zw 函数又叫规范化因子，fi 函数为任意实数值特征函数，w 是权值向量。\n\n\n\n# 3.模型学习\n书中使用了很大篇幅证明：最大熵模型学习中的**对偶函数极大化**等价于最大熵模型的极大似然估计（在此不搬运公式了）。\n\n可以将模型学习总结如下：\n\n![模型学习](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/模型学习.png)","slug":"统计学习方法六","published":1,"updated":"2021-04-17T01:51:13.621Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n88z0038k8tl2jtu3lz1","content":"<p>一句话：本章提到两种应用了概率知识和最优化方法的对数线性数学模型。</p>\n<hr>\n<p>首先对本章知识进行<strong>定位</strong>：</p>\n<ol>\n<li>本章知识和前后联系都不是很大，但是 logistic 回归（sigmoid函数）确实十分常用的一个理论知识。</li>\n<li>最大熵模型更是宏观地把回归和分类问题转换成最优化问题的数学模型。</li>\n</ol>\n<p><strong>本章公式极多，多为推导，在此大多数将不会列出，如果有兴趣，非常建议阅读原书。</strong></p>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"1-逻辑斯谛回归\"><a href=\"#1-逻辑斯谛回归\" class=\"headerlink\" title=\"1.逻辑斯谛回归\"></a>1.逻辑斯谛回归</h1><p>我们之前接触过 sigmoid 函数，有很多视频中也叫 logistic 函数/回归等，原因大概就在本章。</p>\n<h2 id=\"逻辑斯谛分布（logistic-distribution）\"><a href=\"#逻辑斯谛分布（logistic-distribution）\" class=\"headerlink\" title=\"逻辑斯谛分布（logistic distribution）\"></a>逻辑斯谛分布（logistic distribution）</h2><p>随机变量X如果满足：</p>\n<p>​    分布函数：$F(x)=\\frac{1}{1+e^{-(x-\\mu)/\\gamma}}$</p>\n<p>​    概率密度函数：$f(x)=\\frac{e^{-(x-\\mu)/\\gamma}}{\\gamma(1+e^{-(x-\\mu)/\\gamma})^2}$</p>\n<p>那么$x$就满足逻辑斯谛分布。</p>\n<p>(其中，$\\mu$为位置参数，$\\gamma &gt;0$为形状参数。)</p>\n<p>分布特性：</p>\n<p>​    分布函数呈S形曲线，以点$(\\mu,\\frac{1}{2})$中心对称。</p>\n<p>​    概率密度函数，就是我们熟悉的——sigmoid函数的样子。</p>\n<h2 id=\"二项逻辑斯谛回归模型\"><a href=\"#二项逻辑斯谛回归模型\" class=\"headerlink\" title=\"二项逻辑斯谛回归模型\"></a>二项逻辑斯谛回归模型</h2><p>【从分布上升到模型】</p>\n<p>满足以下公式的条件概率分布就是二项逻辑斯谛回归模型：</p>\n<script type=\"math/tex; mode=display\">P(Y=1|x)=\\frac{exp(w\\cdot x+b)}{1+exp(w\\cdot x+b)}\\\\ P(Y=1|x)=\\frac{1}{1+exp(w\\cdot x+b)}</script><p>根据该模型，可以比较两个条件概率值的大小，从而将 x 分到概率值比较大的类别 Y（1或0）中。</p>\n<p>可以用<strong>极大似然估计法</strong>估计模型参数 w。</p>\n<p>一个相关的知识概念：</p>\n<p>​    几率（odds）：事件发生的概率 与 事件不发生的概率 的比值——$\\frac{p}{1-p}$</p>\n<p>​    对数几率（log odds）或 logit 函数：$logit(p)=log\\frac{p}{1-p}$ </p>\n<h2 id=\"多项逻辑斯谛回归模型\"><a href=\"#多项逻辑斯谛回归模型\" class=\"headerlink\" title=\"多项逻辑斯谛回归模型\"></a>多项逻辑斯谛回归模型</h2><p>【模型推广】</p>\n<script type=\"math/tex; mode=display\">P(Y=k|x)=\\frac{exp(w_k\\cdot x)}{1+exp(w_k\\cdot x)}, k=1,2,...,K-1\\\\ P(Y=K|x)=\\frac{1}{1+\\Sigma_{k=1}^{K-1}exp(w_k\\cdot x)}</script><h1 id=\"2-最大熵模型\"><a href=\"#2-最大熵模型\" class=\"headerlink\" title=\"2.最大熵模型\"></a>2.最大熵模型</h1><p><strong>最大熵原理</strong>：（概率模型学习的准则）</p>\n<p>​    <strong>在所有可能的概率模型分布中，熵最大的模型是最好的模型。</strong></p>\n<p>​    或者描述为：在满足约束条件的模型集合中，熵最大的模型最好。</p>\n<p>回忆第5章内容：</p>\n<p>如果X的概率分布是P(X)，则<strong>熵</strong>为：$H(P)=-\\Sigma_xP(x)logP(x)$</p>\n<p>熵的一个特性是：$0\\leq H(P)\\leq log|X|$</p>\n<ol>\n<li>其中，|X| 是 X 的取值的个数。</li>\n<li>这个特性说明——熵有最大值（或者说有取值范围）。</li>\n</ol>\n<p><strong>熵取最大值的条件：</strong></p>\n<ol>\n<li>当且仅当 X 的分布是均匀分布时，熵最大。</li>\n<li>在满足约束条件的情况下，把不确定的部分认为是“等可能”的，此时熵最大。</li>\n</ol>\n<p>举个栗子：</p>\n<p>有两个约束条件</p>\n<script type=\"math/tex; mode=display\">P(A)+P(B)=\\frac{3}{10}\\\\ P(A)+P(B)+P(C)+P(D)+P(E)=1</script><p>在缺少其他信息的情况下，可以认为：A 和 B 等概率，各为$\\frac{3}{20}$，C、D和E 等概率，各为$\\frac{7}{30}$</p>\n<p><strong>最大熵模型：</strong></p>\n<script type=\"math/tex; mode=display\">P_w(y|x)=\\frac{1}{Z_w(x)}exp(\\Sigma_{i=1}^nw_if_i(x,y))\\\\Z_w(w)=\\Sigma_yexp(\\Sigma_{i=1}^nw_if_i(x,y))</script><p>​    其中，x 为输入，y 为输出， Zw 函数又叫规范化因子，fi 函数为任意实数值特征函数，w 是权值向量。</p>\n<h1 id=\"3-模型学习\"><a href=\"#3-模型学习\" class=\"headerlink\" title=\"3.模型学习\"></a>3.模型学习</h1><p>书中使用了很大篇幅证明：最大熵模型学习中的<strong>对偶函数极大化</strong>等价于最大熵模型的极大似然估计（在此不搬运公式了）。</p>\n<p>可以将模型学习总结如下：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/模型学习.png\" alt=\"模型学习\"></p>\n","site":{"data":{}},"excerpt":"<p>一句话：本章提到两种应用了概率知识和最优化方法的对数线性数学模型。</p>\n<hr>\n<p>首先对本章知识进行<strong>定位</strong>：</p>\n<ol>\n<li>本章知识和前后联系都不是很大，但是 logistic 回归（sigmoid函数）确实十分常用的一个理论知识。</li>\n<li>最大熵模型更是宏观地把回归和分类问题转换成最优化问题的数学模型。</li>\n</ol>\n<p><strong>本章公式极多，多为推导，在此大多数将不会列出，如果有兴趣，非常建议阅读原书。</strong></p>","more":"<hr>\n<h1 id=\"1-逻辑斯谛回归\"><a href=\"#1-逻辑斯谛回归\" class=\"headerlink\" title=\"1.逻辑斯谛回归\"></a>1.逻辑斯谛回归</h1><p>我们之前接触过 sigmoid 函数，有很多视频中也叫 logistic 函数/回归等，原因大概就在本章。</p>\n<h2 id=\"逻辑斯谛分布（logistic-distribution）\"><a href=\"#逻辑斯谛分布（logistic-distribution）\" class=\"headerlink\" title=\"逻辑斯谛分布（logistic distribution）\"></a>逻辑斯谛分布（logistic distribution）</h2><p>随机变量X如果满足：</p>\n<p>​    分布函数：$F(x)=\\frac{1}{1+e^{-(x-\\mu)/\\gamma}}$</p>\n<p>​    概率密度函数：$f(x)=\\frac{e^{-(x-\\mu)/\\gamma}}{\\gamma(1+e^{-(x-\\mu)/\\gamma})^2}$</p>\n<p>那么$x$就满足逻辑斯谛分布。</p>\n<p>(其中，$\\mu$为位置参数，$\\gamma &gt;0$为形状参数。)</p>\n<p>分布特性：</p>\n<p>​    分布函数呈S形曲线，以点$(\\mu,\\frac{1}{2})$中心对称。</p>\n<p>​    概率密度函数，就是我们熟悉的——sigmoid函数的样子。</p>\n<h2 id=\"二项逻辑斯谛回归模型\"><a href=\"#二项逻辑斯谛回归模型\" class=\"headerlink\" title=\"二项逻辑斯谛回归模型\"></a>二项逻辑斯谛回归模型</h2><p>【从分布上升到模型】</p>\n<p>满足以下公式的条件概率分布就是二项逻辑斯谛回归模型：</p>\n<script type=\"math/tex; mode=display\">P(Y=1|x)=\\frac{exp(w\\cdot x+b)}{1+exp(w\\cdot x+b)}\\\\ P(Y=1|x)=\\frac{1}{1+exp(w\\cdot x+b)}</script><p>根据该模型，可以比较两个条件概率值的大小，从而将 x 分到概率值比较大的类别 Y（1或0）中。</p>\n<p>可以用<strong>极大似然估计法</strong>估计模型参数 w。</p>\n<p>一个相关的知识概念：</p>\n<p>​    几率（odds）：事件发生的概率 与 事件不发生的概率 的比值——$\\frac{p}{1-p}$</p>\n<p>​    对数几率（log odds）或 logit 函数：$logit(p)=log\\frac{p}{1-p}$ </p>\n<h2 id=\"多项逻辑斯谛回归模型\"><a href=\"#多项逻辑斯谛回归模型\" class=\"headerlink\" title=\"多项逻辑斯谛回归模型\"></a>多项逻辑斯谛回归模型</h2><p>【模型推广】</p>\n<script type=\"math/tex; mode=display\">P(Y=k|x)=\\frac{exp(w_k\\cdot x)}{1+exp(w_k\\cdot x)}, k=1,2,...,K-1\\\\ P(Y=K|x)=\\frac{1}{1+\\Sigma_{k=1}^{K-1}exp(w_k\\cdot x)}</script><h1 id=\"2-最大熵模型\"><a href=\"#2-最大熵模型\" class=\"headerlink\" title=\"2.最大熵模型\"></a>2.最大熵模型</h1><p><strong>最大熵原理</strong>：（概率模型学习的准则）</p>\n<p>​    <strong>在所有可能的概率模型分布中，熵最大的模型是最好的模型。</strong></p>\n<p>​    或者描述为：在满足约束条件的模型集合中，熵最大的模型最好。</p>\n<p>回忆第5章内容：</p>\n<p>如果X的概率分布是P(X)，则<strong>熵</strong>为：$H(P)=-\\Sigma_xP(x)logP(x)$</p>\n<p>熵的一个特性是：$0\\leq H(P)\\leq log|X|$</p>\n<ol>\n<li>其中，|X| 是 X 的取值的个数。</li>\n<li>这个特性说明——熵有最大值（或者说有取值范围）。</li>\n</ol>\n<p><strong>熵取最大值的条件：</strong></p>\n<ol>\n<li>当且仅当 X 的分布是均匀分布时，熵最大。</li>\n<li>在满足约束条件的情况下，把不确定的部分认为是“等可能”的，此时熵最大。</li>\n</ol>\n<p>举个栗子：</p>\n<p>有两个约束条件</p>\n<script type=\"math/tex; mode=display\">P(A)+P(B)=\\frac{3}{10}\\\\ P(A)+P(B)+P(C)+P(D)+P(E)=1</script><p>在缺少其他信息的情况下，可以认为：A 和 B 等概率，各为$\\frac{3}{20}$，C、D和E 等概率，各为$\\frac{7}{30}$</p>\n<p><strong>最大熵模型：</strong></p>\n<script type=\"math/tex; mode=display\">P_w(y|x)=\\frac{1}{Z_w(x)}exp(\\Sigma_{i=1}^nw_if_i(x,y))\\\\Z_w(w)=\\Sigma_yexp(\\Sigma_{i=1}^nw_if_i(x,y))</script><p>​    其中，x 为输入，y 为输出， Zw 函数又叫规范化因子，fi 函数为任意实数值特征函数，w 是权值向量。</p>\n<h1 id=\"3-模型学习\"><a href=\"#3-模型学习\" class=\"headerlink\" title=\"3.模型学习\"></a>3.模型学习</h1><p>书中使用了很大篇幅证明：最大熵模型学习中的<strong>对偶函数极大化</strong>等价于最大熵模型的极大似然估计（在此不搬运公式了）。</p>\n<p>可以将模型学习总结如下：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/模型学习.png\" alt=\"模型学习\"></p>"},{"title":"【统计学习方法】4-朴素贝叶斯法分类","date":"2021-01-27T02:26:35.000Z","_content":"\n一句话介绍：对给定的输入x，结合贝叶斯概率理论，通过学习到的模型，将**后验概率最大的类**作为x的类输出。\n\n------\n\n最好学习过贝叶斯估计方法。\n\n在本科阶段的**概率论**或研究生阶段的**数理统计**中，都有对贝叶斯估计方法的介绍，与其他估计方法的最大不同是——加入了**先验估计**概念。\n\n# 基础知识\n\n部分公式：\n\n- **先验概率分布$P(Y=c_k),k=1,2,...,K$**\n- **条件概率分布**$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k),k=1,2,...,K$\n- **后验概率分布（贝叶斯定理）$P(Y=c_k|X=x)=\\frac{P(X=x|Y=c_k)P(Y=c_k)}{\\Sigma_k P(X=x|Y=c_k)P(Y=c_k)}$**\n\n**补充一个忽略了很久的知识点：**\n\n**arg max(f(x)) 函数：**得到的结果是使得 f(x)取得最大值所对应的变量点x(或x的集合)。arg即argument，自变量。\n\n<!-- more -->\n\n首先有一个**训练数据集**$T=\\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\\}$，是由**X**和**Y**的联合概率分布$P(X,Y)$独立同分布产生。\n\n **【需要注意的是，这个联合概率分布是用朴素贝叶斯法训练出来的】**\n\n在朴素贝叶斯法中，对条件概率分布做了**条件独立性的假设：**\n\n$P(X=x|Y=c_k) = P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k) = \\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)$\n\n那么，朴素贝叶斯法分类的基本公式就是\n\n$P(Y=c_k|X=x)=\\frac{P(Y=c_k)\\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)}{\\Sigma_k P(Y=c_k)\\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)},k=1,2,...,K$\n\n**分母都是相同的，只考虑分子即可，**选择分子最大的那个就是概率最大的，也就是后验概率最大的类了：\n\n$y=arg\\ max_{c_k}{P(Y=c_k)\\prod^n_{j=1} P(X^{(j)}=x^{(j)}|Y=c_k)}$\n\n------\n\n以上内容确实就是**朴素贝叶斯学习和分类算法**的全部了，但是想必还是不太好理解。\n\n一方面，**先验分布和条件分布假设**可能需要使用极大似然估计的方法求取，或者使用贝叶斯估计的方法求取，这又是好几个公式。\n\n另一方面，还不如直接看一个例子！\n\n------\n\n# 举个栗子!\n\n我们有一个训练数据集：\n\n|           | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 1    |      |\n| :-------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| $X^{(1)}$ | 1    | 1    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    |\n| $X^{(2)}$ | $S$  | $M$  | $M$  | $S$  | $S$  | $S$  | $M$  | $M$  | $L$  | $L$  | $L$  | $M$  | $M$  | $L$  | $L$  |\n| $Y$       | -1   | -1   | 1    | 1    | -1   | -1   | -1   | 1    | 1    | 1    | 1    | 1    | 1    | 1    | -1   |\n\n这个数据集是什么意思呢？\n\n$X^{(1)}$和$X^{(2)}$是特征。\n\n- $X^{(1)}$ 取值集合是$A_1={1,2,3}$\n- $X^{(2)}$ 取值集合是$A_2={S,M,L}$\n\n$Y$ 就是类标记了，两个类，1和-1.\n\n**现在的目的是，学习一个朴素贝叶斯分类器，并且确定 $x=(2,S)^T$ 的类标记 $y$ 是多少？**\n\n开始计算一堆概率：\n\n$P(Y=1)=\\frac{9}{15},P(Y=-1)=\\frac{6}{15}$\n\n$P(X^{(1)}=1|Y=1)=\\frac{2}{9},P(X^{(1)}=2|Y=1)=\\frac{3}{9},P(X^{(1)}=3|Y=1)=\\frac{4}{9}$\n\n其实还是挺好算的，就是有点多，要把先验概率和条件概率全部算完：\n\n$P(X^{(2)}=S|Y=1)=\\frac{1}{9},P(X^{(2)}=M|Y=1)=\\frac{4}{9},P(X^{(2)}=L|Y=1)=\\frac{4}{9}$\n\n$P(X^{(1)}=1|Y=-1)=\\frac{3}{6},P(X^{(1)}=2|Y=-1)=\\frac{2}{6},P(X^{(1)}=3|Y=-1)=\\frac{1}{6}$\n\n$P(X^{(2)}=S|Y=-1)=\\frac{3}{6},P(X^{(2)}=M|Y=-1)=\\frac{2}{6},P(X^{(2)}=L|Y=-1)=\\frac{1}{6}$\n\n那么接下来根据**朴素贝叶斯分类**的**基本公式**，我们就是要看**$x=(2,S)^T$的后验概率在哪一类（y=1还是-1）的条件下更大，**我们**只计算分子即可：**\n\n**这里很明显，目标的特征是：$X^{(1)}=2,X^{(2)}=S$**\n\n​    $P(Y=1)P(X^{(1)}=2|Y=1)P(X^{(2)}=S|Y=1)=\\frac{9}{15} \\cdot \\frac{3}{9}\\cdot\\frac{4}{9}=\\frac{1}{45}$\n\n​    $P(Y=-1)P(X^{(1)}=2|Y=-1)P(X^{(2)}=S|Y=-1)=\\frac{6}{15} \\cdot \\frac{2}{6}\\cdot\\frac{3}{6}=\\frac{1}{15}$\n\n**经过计算，Y=-1的情况概率更大，所以y=-1.**\n\n\n\n非常典型的贝叶斯概率估计。\n\n这一页的公式确实打的很费劲。","source":"_posts/统计学习方法四.md","raw":"---\ntitle: 【统计学习方法】4-朴素贝叶斯法分类\ndate: 2021-01-27 10:26:35\ncategories:\n\t- 机器学习\ntags:\n\t- 统计学习方法\n---\n\n一句话介绍：对给定的输入x，结合贝叶斯概率理论，通过学习到的模型，将**后验概率最大的类**作为x的类输出。\n\n------\n\n最好学习过贝叶斯估计方法。\n\n在本科阶段的**概率论**或研究生阶段的**数理统计**中，都有对贝叶斯估计方法的介绍，与其他估计方法的最大不同是——加入了**先验估计**概念。\n\n# 基础知识\n\n部分公式：\n\n- **先验概率分布$P(Y=c_k),k=1,2,...,K$**\n- **条件概率分布**$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k),k=1,2,...,K$\n- **后验概率分布（贝叶斯定理）$P(Y=c_k|X=x)=\\frac{P(X=x|Y=c_k)P(Y=c_k)}{\\Sigma_k P(X=x|Y=c_k)P(Y=c_k)}$**\n\n**补充一个忽略了很久的知识点：**\n\n**arg max(f(x)) 函数：**得到的结果是使得 f(x)取得最大值所对应的变量点x(或x的集合)。arg即argument，自变量。\n\n<!-- more -->\n\n首先有一个**训练数据集**$T=\\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\\}$，是由**X**和**Y**的联合概率分布$P(X,Y)$独立同分布产生。\n\n **【需要注意的是，这个联合概率分布是用朴素贝叶斯法训练出来的】**\n\n在朴素贝叶斯法中，对条件概率分布做了**条件独立性的假设：**\n\n$P(X=x|Y=c_k) = P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k) = \\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)$\n\n那么，朴素贝叶斯法分类的基本公式就是\n\n$P(Y=c_k|X=x)=\\frac{P(Y=c_k)\\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)}{\\Sigma_k P(Y=c_k)\\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)},k=1,2,...,K$\n\n**分母都是相同的，只考虑分子即可，**选择分子最大的那个就是概率最大的，也就是后验概率最大的类了：\n\n$y=arg\\ max_{c_k}{P(Y=c_k)\\prod^n_{j=1} P(X^{(j)}=x^{(j)}|Y=c_k)}$\n\n------\n\n以上内容确实就是**朴素贝叶斯学习和分类算法**的全部了，但是想必还是不太好理解。\n\n一方面，**先验分布和条件分布假设**可能需要使用极大似然估计的方法求取，或者使用贝叶斯估计的方法求取，这又是好几个公式。\n\n另一方面，还不如直接看一个例子！\n\n------\n\n# 举个栗子!\n\n我们有一个训练数据集：\n\n|           | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 1    |      |\n| :-------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| $X^{(1)}$ | 1    | 1    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    |\n| $X^{(2)}$ | $S$  | $M$  | $M$  | $S$  | $S$  | $S$  | $M$  | $M$  | $L$  | $L$  | $L$  | $M$  | $M$  | $L$  | $L$  |\n| $Y$       | -1   | -1   | 1    | 1    | -1   | -1   | -1   | 1    | 1    | 1    | 1    | 1    | 1    | 1    | -1   |\n\n这个数据集是什么意思呢？\n\n$X^{(1)}$和$X^{(2)}$是特征。\n\n- $X^{(1)}$ 取值集合是$A_1={1,2,3}$\n- $X^{(2)}$ 取值集合是$A_2={S,M,L}$\n\n$Y$ 就是类标记了，两个类，1和-1.\n\n**现在的目的是，学习一个朴素贝叶斯分类器，并且确定 $x=(2,S)^T$ 的类标记 $y$ 是多少？**\n\n开始计算一堆概率：\n\n$P(Y=1)=\\frac{9}{15},P(Y=-1)=\\frac{6}{15}$\n\n$P(X^{(1)}=1|Y=1)=\\frac{2}{9},P(X^{(1)}=2|Y=1)=\\frac{3}{9},P(X^{(1)}=3|Y=1)=\\frac{4}{9}$\n\n其实还是挺好算的，就是有点多，要把先验概率和条件概率全部算完：\n\n$P(X^{(2)}=S|Y=1)=\\frac{1}{9},P(X^{(2)}=M|Y=1)=\\frac{4}{9},P(X^{(2)}=L|Y=1)=\\frac{4}{9}$\n\n$P(X^{(1)}=1|Y=-1)=\\frac{3}{6},P(X^{(1)}=2|Y=-1)=\\frac{2}{6},P(X^{(1)}=3|Y=-1)=\\frac{1}{6}$\n\n$P(X^{(2)}=S|Y=-1)=\\frac{3}{6},P(X^{(2)}=M|Y=-1)=\\frac{2}{6},P(X^{(2)}=L|Y=-1)=\\frac{1}{6}$\n\n那么接下来根据**朴素贝叶斯分类**的**基本公式**，我们就是要看**$x=(2,S)^T$的后验概率在哪一类（y=1还是-1）的条件下更大，**我们**只计算分子即可：**\n\n**这里很明显，目标的特征是：$X^{(1)}=2,X^{(2)}=S$**\n\n​    $P(Y=1)P(X^{(1)}=2|Y=1)P(X^{(2)}=S|Y=1)=\\frac{9}{15} \\cdot \\frac{3}{9}\\cdot\\frac{4}{9}=\\frac{1}{45}$\n\n​    $P(Y=-1)P(X^{(1)}=2|Y=-1)P(X^{(2)}=S|Y=-1)=\\frac{6}{15} \\cdot \\frac{2}{6}\\cdot\\frac{3}{6}=\\frac{1}{15}$\n\n**经过计算，Y=-1的情况概率更大，所以y=-1.**\n\n\n\n非常典型的贝叶斯概率估计。\n\n这一页的公式确实打的很费劲。","slug":"统计学习方法四","published":1,"updated":"2021-01-28T07:23:51.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n890003ak8tl4q2x0mtp","content":"<p>一句话介绍：对给定的输入x，结合贝叶斯概率理论，通过学习到的模型，将<strong>后验概率最大的类</strong>作为x的类输出。</p>\n<hr>\n<p>最好学习过贝叶斯估计方法。</p>\n<p>在本科阶段的<strong>概率论</strong>或研究生阶段的<strong>数理统计</strong>中，都有对贝叶斯估计方法的介绍，与其他估计方法的最大不同是——加入了<strong>先验估计</strong>概念。</p>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>部分公式：</p>\n<ul>\n<li><strong>先验概率分布$P(Y=c_k),k=1,2,…,K$</strong></li>\n<li><strong>条件概率分布</strong>$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},…,X^{(n)}=x^{(n)}|Y=c_k),k=1,2,…,K$</li>\n<li><strong>后验概率分布（贝叶斯定理）$P(Y=c_k|X=x)=\\frac{P(X=x|Y=c_k)P(Y=c_k)}{\\Sigma_k P(X=x|Y=c_k)P(Y=c_k)}$</strong></li>\n</ul>\n<p><strong>补充一个忽略了很久的知识点：</strong></p>\n<p><strong>arg max(f(x)) 函数：</strong>得到的结果是使得 f(x)取得最大值所对应的变量点x(或x的集合)。arg即argument，自变量。</p>\n<a id=\"more\"></a>\n<p>首先有一个<strong>训练数据集</strong>$T=\\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\\}$，是由<strong>X</strong>和<strong>Y</strong>的联合概率分布$P(X,Y)$独立同分布产生。</p>\n<p> <strong>【需要注意的是，这个联合概率分布是用朴素贝叶斯法训练出来的】</strong></p>\n<p>在朴素贝叶斯法中，对条件概率分布做了<strong>条件独立性的假设：</strong></p>\n<p>$P(X=x|Y=c_k) = P(X^{(1)}=x^{(1)},…,X^{(n)}=x^{(n)}|Y=c_k) = \\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)$</p>\n<p>那么，朴素贝叶斯法分类的基本公式就是</p>\n<p>$P(Y=c_k|X=x)=\\frac{P(Y=c_k)\\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)}{\\Sigma_k P(Y=c_k)\\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)},k=1,2,…,K$</p>\n<p><strong>分母都是相同的，只考虑分子即可，</strong>选择分子最大的那个就是概率最大的，也就是后验概率最大的类了：</p>\n<p>$y=arg\\ max_{c_k}{P(Y=c_k)\\prod^n_{j=1} P(X^{(j)}=x^{(j)}|Y=c_k)}$</p>\n<hr>\n<p>以上内容确实就是<strong>朴素贝叶斯学习和分类算法</strong>的全部了，但是想必还是不太好理解。</p>\n<p>一方面，<strong>先验分布和条件分布假设</strong>可能需要使用极大似然估计的方法求取，或者使用贝叶斯估计的方法求取，这又是好几个公式。</p>\n<p>另一方面，还不如直接看一个例子！</p>\n<hr>\n<h1 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子!\"></a>举个栗子!</h1><p>我们有一个训练数据集：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">1</th>\n<th style=\"text-align:left\">2</th>\n<th style=\"text-align:left\">3</th>\n<th style=\"text-align:left\">4</th>\n<th style=\"text-align:left\">5</th>\n<th style=\"text-align:left\">6</th>\n<th style=\"text-align:left\">7</th>\n<th style=\"text-align:left\">8</th>\n<th style=\"text-align:left\">9</th>\n<th style=\"text-align:left\">10</th>\n<th style=\"text-align:left\">11</th>\n<th style=\"text-align:left\">12</th>\n<th style=\"text-align:left\">13</th>\n<th style=\"text-align:left\">1</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$X^{(1)}$</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$X^{(2)}$</td>\n<td style=\"text-align:left\">$S$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$S$</td>\n<td style=\"text-align:left\">$S$</td>\n<td style=\"text-align:left\">$S$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$L$</td>\n<td style=\"text-align:left\">$L$</td>\n<td style=\"text-align:left\">$L$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$L$</td>\n<td style=\"text-align:left\">$L$</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$Y$</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">-1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这个数据集是什么意思呢？</p>\n<p>$X^{(1)}$和$X^{(2)}$是特征。</p>\n<ul>\n<li>$X^{(1)}$ 取值集合是$A_1={1,2,3}$</li>\n<li>$X^{(2)}$ 取值集合是$A_2={S,M,L}$</li>\n</ul>\n<p>$Y$ 就是类标记了，两个类，1和-1.</p>\n<p><strong>现在的目的是，学习一个朴素贝叶斯分类器，并且确定 $x=(2,S)^T$ 的类标记 $y$ 是多少？</strong></p>\n<p>开始计算一堆概率：</p>\n<p>$P(Y=1)=\\frac{9}{15},P(Y=-1)=\\frac{6}{15}$</p>\n<p>$P(X^{(1)}=1|Y=1)=\\frac{2}{9},P(X^{(1)}=2|Y=1)=\\frac{3}{9},P(X^{(1)}=3|Y=1)=\\frac{4}{9}$</p>\n<p>其实还是挺好算的，就是有点多，要把先验概率和条件概率全部算完：</p>\n<p>$P(X^{(2)}=S|Y=1)=\\frac{1}{9},P(X^{(2)}=M|Y=1)=\\frac{4}{9},P(X^{(2)}=L|Y=1)=\\frac{4}{9}$</p>\n<p>$P(X^{(1)}=1|Y=-1)=\\frac{3}{6},P(X^{(1)}=2|Y=-1)=\\frac{2}{6},P(X^{(1)}=3|Y=-1)=\\frac{1}{6}$</p>\n<p>$P(X^{(2)}=S|Y=-1)=\\frac{3}{6},P(X^{(2)}=M|Y=-1)=\\frac{2}{6},P(X^{(2)}=L|Y=-1)=\\frac{1}{6}$</p>\n<p>那么接下来根据<strong>朴素贝叶斯分类</strong>的<strong>基本公式</strong>，我们就是要看<strong>$x=(2,S)^T$的后验概率在哪一类（y=1还是-1）的条件下更大，</strong>我们<strong>只计算分子即可：</strong></p>\n<p><strong>这里很明显，目标的特征是：$X^{(1)}=2,X^{(2)}=S$</strong></p>\n<p>​    $P(Y=1)P(X^{(1)}=2|Y=1)P(X^{(2)}=S|Y=1)=\\frac{9}{15} \\cdot \\frac{3}{9}\\cdot\\frac{4}{9}=\\frac{1}{45}$</p>\n<p>​    $P(Y=-1)P(X^{(1)}=2|Y=-1)P(X^{(2)}=S|Y=-1)=\\frac{6}{15} \\cdot \\frac{2}{6}\\cdot\\frac{3}{6}=\\frac{1}{15}$</p>\n<p><strong>经过计算，Y=-1的情况概率更大，所以y=-1.</strong></p>\n<p>非常典型的贝叶斯概率估计。</p>\n<p>这一页的公式确实打的很费劲。</p>\n","site":{"data":{}},"excerpt":"<p>一句话介绍：对给定的输入x，结合贝叶斯概率理论，通过学习到的模型，将<strong>后验概率最大的类</strong>作为x的类输出。</p>\n<hr>\n<p>最好学习过贝叶斯估计方法。</p>\n<p>在本科阶段的<strong>概率论</strong>或研究生阶段的<strong>数理统计</strong>中，都有对贝叶斯估计方法的介绍，与其他估计方法的最大不同是——加入了<strong>先验估计</strong>概念。</p>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>部分公式：</p>\n<ul>\n<li><strong>先验概率分布$P(Y=c_k),k=1,2,…,K$</strong></li>\n<li><strong>条件概率分布</strong>$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},…,X^{(n)}=x^{(n)}|Y=c_k),k=1,2,…,K$</li>\n<li><strong>后验概率分布（贝叶斯定理）$P(Y=c_k|X=x)=\\frac{P(X=x|Y=c_k)P(Y=c_k)}{\\Sigma_k P(X=x|Y=c_k)P(Y=c_k)}$</strong></li>\n</ul>\n<p><strong>补充一个忽略了很久的知识点：</strong></p>\n<p><strong>arg max(f(x)) 函数：</strong>得到的结果是使得 f(x)取得最大值所对应的变量点x(或x的集合)。arg即argument，自变量。</p>","more":"<p>首先有一个<strong>训练数据集</strong>$T=\\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\\}$，是由<strong>X</strong>和<strong>Y</strong>的联合概率分布$P(X,Y)$独立同分布产生。</p>\n<p> <strong>【需要注意的是，这个联合概率分布是用朴素贝叶斯法训练出来的】</strong></p>\n<p>在朴素贝叶斯法中，对条件概率分布做了<strong>条件独立性的假设：</strong></p>\n<p>$P(X=x|Y=c_k) = P(X^{(1)}=x^{(1)},…,X^{(n)}=x^{(n)}|Y=c_k) = \\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)$</p>\n<p>那么，朴素贝叶斯法分类的基本公式就是</p>\n<p>$P(Y=c_k|X=x)=\\frac{P(Y=c_k)\\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)}{\\Sigma_k P(Y=c_k)\\prod_j P(X^{(j)}=x^{(j)}|Y=c_k)},k=1,2,…,K$</p>\n<p><strong>分母都是相同的，只考虑分子即可，</strong>选择分子最大的那个就是概率最大的，也就是后验概率最大的类了：</p>\n<p>$y=arg\\ max_{c_k}{P(Y=c_k)\\prod^n_{j=1} P(X^{(j)}=x^{(j)}|Y=c_k)}$</p>\n<hr>\n<p>以上内容确实就是<strong>朴素贝叶斯学习和分类算法</strong>的全部了，但是想必还是不太好理解。</p>\n<p>一方面，<strong>先验分布和条件分布假设</strong>可能需要使用极大似然估计的方法求取，或者使用贝叶斯估计的方法求取，这又是好几个公式。</p>\n<p>另一方面，还不如直接看一个例子！</p>\n<hr>\n<h1 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子!\"></a>举个栗子!</h1><p>我们有一个训练数据集：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">1</th>\n<th style=\"text-align:left\">2</th>\n<th style=\"text-align:left\">3</th>\n<th style=\"text-align:left\">4</th>\n<th style=\"text-align:left\">5</th>\n<th style=\"text-align:left\">6</th>\n<th style=\"text-align:left\">7</th>\n<th style=\"text-align:left\">8</th>\n<th style=\"text-align:left\">9</th>\n<th style=\"text-align:left\">10</th>\n<th style=\"text-align:left\">11</th>\n<th style=\"text-align:left\">12</th>\n<th style=\"text-align:left\">13</th>\n<th style=\"text-align:left\">1</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$X^{(1)}$</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$X^{(2)}$</td>\n<td style=\"text-align:left\">$S$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$S$</td>\n<td style=\"text-align:left\">$S$</td>\n<td style=\"text-align:left\">$S$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$L$</td>\n<td style=\"text-align:left\">$L$</td>\n<td style=\"text-align:left\">$L$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$M$</td>\n<td style=\"text-align:left\">$L$</td>\n<td style=\"text-align:left\">$L$</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$Y$</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">-1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">-1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这个数据集是什么意思呢？</p>\n<p>$X^{(1)}$和$X^{(2)}$是特征。</p>\n<ul>\n<li>$X^{(1)}$ 取值集合是$A_1={1,2,3}$</li>\n<li>$X^{(2)}$ 取值集合是$A_2={S,M,L}$</li>\n</ul>\n<p>$Y$ 就是类标记了，两个类，1和-1.</p>\n<p><strong>现在的目的是，学习一个朴素贝叶斯分类器，并且确定 $x=(2,S)^T$ 的类标记 $y$ 是多少？</strong></p>\n<p>开始计算一堆概率：</p>\n<p>$P(Y=1)=\\frac{9}{15},P(Y=-1)=\\frac{6}{15}$</p>\n<p>$P(X^{(1)}=1|Y=1)=\\frac{2}{9},P(X^{(1)}=2|Y=1)=\\frac{3}{9},P(X^{(1)}=3|Y=1)=\\frac{4}{9}$</p>\n<p>其实还是挺好算的，就是有点多，要把先验概率和条件概率全部算完：</p>\n<p>$P(X^{(2)}=S|Y=1)=\\frac{1}{9},P(X^{(2)}=M|Y=1)=\\frac{4}{9},P(X^{(2)}=L|Y=1)=\\frac{4}{9}$</p>\n<p>$P(X^{(1)}=1|Y=-1)=\\frac{3}{6},P(X^{(1)}=2|Y=-1)=\\frac{2}{6},P(X^{(1)}=3|Y=-1)=\\frac{1}{6}$</p>\n<p>$P(X^{(2)}=S|Y=-1)=\\frac{3}{6},P(X^{(2)}=M|Y=-1)=\\frac{2}{6},P(X^{(2)}=L|Y=-1)=\\frac{1}{6}$</p>\n<p>那么接下来根据<strong>朴素贝叶斯分类</strong>的<strong>基本公式</strong>，我们就是要看<strong>$x=(2,S)^T$的后验概率在哪一类（y=1还是-1）的条件下更大，</strong>我们<strong>只计算分子即可：</strong></p>\n<p><strong>这里很明显，目标的特征是：$X^{(1)}=2,X^{(2)}=S$</strong></p>\n<p>​    $P(Y=1)P(X^{(1)}=2|Y=1)P(X^{(2)}=S|Y=1)=\\frac{9}{15} \\cdot \\frac{3}{9}\\cdot\\frac{4}{9}=\\frac{1}{45}$</p>\n<p>​    $P(Y=-1)P(X^{(1)}=2|Y=-1)P(X^{(2)}=S|Y=-1)=\\frac{6}{15} \\cdot \\frac{2}{6}\\cdot\\frac{3}{6}=\\frac{1}{15}$</p>\n<p><strong>经过计算，Y=-1的情况概率更大，所以y=-1.</strong></p>\n<p>非常典型的贝叶斯概率估计。</p>\n<p>这一页的公式确实打的很费劲。</p>"},{"title":"OpenCV常用方法","date":"2020-09-26T01:36:27.000Z","_content":"\n## 安装\n\npip install opencv-python\n\n> 参考：[Py之cv2：cv2库(OpenCV，opencv-python)的简介、安装、使用方法(常见函数、方法等)最强详细攻略](https://blog.csdn.net/qq_41185868/article/details/79675875#%E5%AE%89%E8%A3%85OpenCV%E7%9A%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95)\n\n注意，基于pip安装，有多种方式，上面讲的opencv-python包含主要的modules，此外还有四个opencv的版本在pip可以获得：\n\n- [opencv-python](https://pypi.org/project/opencv-python/)包含opencv的主要modules\n- [opencv-contrib-python](https://pypi.org/project/opencv-contrib-python/) 包含opencv的主要modules以及contrib modules\n- [opencv-python-headless](https://pypi.org/project/opencv-python-headless/): 和opencv-python相同，但是没有GUI功能\n- [opencv-contrib-python-headless](https://pypi.org/project/opencv-contrib-python-headless/):与opencv-contrib-python相同，但是没有GUI功能。\n\n推荐在虚拟环境（conda环境）中安装第二种。\n\n<!--more-->\n\n此外还有安装方式：\n\n【conda安装】\n\n```bash\nconda install -c https://conda.anaconda.org/menpo opencv3 #安装opencv3\n#如果要安装opencv4将opencv3改成如下命令\nconda install -c https://conda.anaconda.org/menpo opencv #安装最新版opencv4\n#也可通过conda search -c https://conda.anaconda.org/menpo opencv*来搜索所有opencv版本\n```\n\n卸载：\n\n```bash\nconda unstall opencv3 #卸载opencv3\nconda deactivate #退出虚拟环境\nconda remove -n vm --all #删除虚拟环境conda unstall opencv3 #卸载opencv3\n```\n\n> 参考：[【opencv】1.opencv安装之使用pip或conda安装opencv](https://blog.csdn.net/u011119817/article/details/100110495)\n\n## 图片相关\n\n`cv2.imread()`\n\nOpenCV定义了，图像的原点（0，0）在图片的左上角，横轴为X，朝右，纵轴为Y，朝下，如下图所示。\n\n![image-20200902213453711](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200902213453711.png)\n\n需要注意的是，由于OpenCV的早期开发者习惯于使用BGR顺序的颜色模型，因此使用OpenCV的imread()读到的像素，每个像素的排列是按BGR，而不是常见的RGB，代码编写时需要注意。\n\n`cv2.namedWindow('', cv2.WINDOW_KEEPRATIO)`\n\n对视窗进行命名\n\n`cv2.resizeWindow('', 0, 0)`\n\n调整图像大小\n\n`cv2.moveWindow('', 0, 0)`\n\n移动视窗到合适的位置\n\n#### 图片缩放\n\n`cv2.resize(img, (int(y/2), int(x/2)))`\n\n设置参数为图片的高和宽，定义后直接输出尺寸为宽和高\n\n`cv2.resize(img, (0,0), fx=0.25, fy=0.25, interpolation=cv2.INTER_NEAREST)`\n\n使用最近邻插值法缩放到原来图片的四分之一\n\n> 参考：[cv2.resize()](https://blog.csdn.net/wzhrsh/article/details/101630396)\n\n## 画图 \n\nOpenCV的画图确实要比matplotlib.pyplot()高级一点\n\n> 参考：[matplotlib画直线](https://blog.csdn.net/skyli114/article/details/77508136)\n\n比如画直线等\n\n> 参考：[Python 用 OpenCV 画直线 (3)](https://blog.csdn.net/u011520181/article/details/83999786)\n>\n> 该博客系列还有画点、圆、矩形、椭圆，写文字、显示图像等内容\n\n`cv2.line(img, pt1, pt2, color[, thickness[, lineType[, shift]]])`\n\nimg：要画的圆所在的矩形或图像\n\npt1：直线起点\n\npt2：直线终点\n\ncolor：线条颜色\n\nthickness：线条宽度\n\nlineType：\n\n- 8：8-connected line\n- 4：4-connected line\n- CV_AA：antialiased line\n\nshift：坐标点小数点位数\n\n`cv2.polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]])`\n\n- img - 图片\n- pts - 多边形顶点（这个该如何写，很有意思，可以用np.array定义变量，但是最后加入到函数中时，还需要再次使用[]将变量括起来）\n- isClosed - 是否闭合线段\n- color - 颜色\n\n> 参考：[cv2.polylines()绘制多边形](https://drivingc.com/p/5af8f4962392ec4f4727ccce)\n\n`cv2.fillpoly()`\n\n可以填充任意形状的图形\n\n一次可以填充多个图形\n\n`cv2.fillConvexPoly()`\n\n可以用来**填充**凸多边形，只需要提供凸多边形的顶点\n\n> 参考：[cv2.fillConvexPoly()与cv2.fillPoly()填充多边形](https://blog.csdn.net/u012135425/article/details/84983265)\n\n## 视频相关\n\n`cv = cv2.VideoCapture('/dev/video10')`\n\n表示打开摄像头\n\n如果括号里面是视频的文件名（也可以是绝对、相对路径），那么就会调用视频，但是需要注意视频位置需要和python脚本的位置在同一个文件夹中\n\n`ret, frame = cv.read()`\n\n按帧读取视频，有两个返回值:\n\n- ret 是布尔值，如果读取帧正确，会返回true，如果读取到结尾，则返回false\n\n- frame 是每一帧的图像，是一个三维矩阵\n\n`cv2.waitKey()`\n\n等待键盘输入\n\n参数：\n\n- 1：表示延时1ms切换到下一帧\n- 0，只显示当前帧，相当于暂停\n- 参数过大会因为延时较久而卡顿\n\n`cv2.realse()`\n\n释放摄像头\n\n`cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)`\n\ncvtColor函数用于在图像中不同的色彩空间进行转换，用于后续处理\n\n有RGB、HSV、HSI、LAB、YUV，彩色或者灰度图\n\n灰度图\n\n![灰度图计算](https://pic3.zhimg.com/v2-ddeaaaeab138b73aedecf3e0fad56aba_r.jpg)\n\n位图模式（像素只有0或者1），\n\n`cv2.imshow()`\n\n将图片展示出来\n\n`cv2.erode()`和`cv2.dilate()`\n\n图像的形态学操作，腐蚀和膨胀\n\n- 腐蚀 erode = 变瘦\n  - 使用腐蚀可以将图片中的一些毛刺或细小的东西去掉\n  - 在原图中的每一个小区域里面取最小值，二值化图像，只要有一个点为0，则都为0\n  - 参数\n    - 图像\n    - kernel\n    - iterations，该值越高，图像腐蚀程度越高，只能为整数\n- 膨胀 dilate = 变胖\n  - 取得局部最大值\n  - 参数\n    - 图像\n    - kernel\n    - iterations，该值越高，效果越明显，越胖\n\n![image-20200901161845805](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200901161845805.png)\n\n`cv2.destroyAllWindows()`\n\nwarp：经，经线\n\n`cv2.warpAffine()`\n\n仿射变换函数\n\n可以实现旋转、平移、缩放\n\n变换后的平行线依然是平行的\n\n其变换矩阵至少需要获取三组变换前后对应的点坐标，实现变换\n\n`cv2.warpPerspective(src, M, dsize, dst=None, flags=None, borderMode=None， borderValu=None)`\n\n==透视变换函数==\n\n**可以保持直线不变性，但是平行线可能不再平行**\n\n参数：\n\n- src，输入图像\n- dst，输出图像\n- **M：2x3的变换矩阵**\n- dsize：**变换后输出图像尺寸**\n- flag：插值方法,`cv2.INTER_LINEAR`是默认的插值方法，可以调整输入图像的大小；cv2.INTER_AREA 表示收缩，缩小尺寸；如果是放大建议使用cv2.INTER_CUBIC和cv2.INTER_LINEAR\n- borderMode：边界像素外扩方式\n- borderValue：边界像素插值，默认为0\n\n其**==变换矩阵M==**至少需要**四组**变换前后对应的点坐标\n\n其变换矩阵可以通过`cv2.getPerspectiveTransform()`函数获得\n\n> 参考：[python的cv2.warpAffine()和cv2.warpPerspective()解析对比](https://blog.csdn.net/u012114438/article/details/102613492)\n>\n> 其变换矩阵也可以通过`cv2.getRotationMatrix2D(center, angle, scale)`函数先获得旋转缩放变换，然后再通过`cv2.warpAffine()`函数对图像进行旋转缩放变换\n>\n> center：旋转中心坐标\n>\n> angle：旋转角度\n>\n> scale：缩放尺度\n\n仿射变换——affine transformation\n\n包括平移translation、旋转rotation、放缩isotropic uniform scaling、剪切、反射reflection\n\n欧式变换：euclidean transformation  刚体变换 rigid transformation，包括平移和旋转\n\n> 参考：[仿射变换及其变换矩阵的理解](https://www.cnblogs.com/shine-lee/p/10950963.html)\n\n## 算法\n\n### 基础\n\n`cv2.split()` 拆分（通道分离）\n\n`cv2.merge()`合并（通道合并）\n\n### 霍夫检测\n\n`cv2.HoughLines()` —— 标准\n\n- dst：输出图像，二值化图像\n- **lines：存储着检测到的直线的参数对**，该参数似乎不是必须的\n- rho：参数极径 r 以像素值为单位的分辨率，一般是1\n- theta：参数极角 \\theta 以弧度为单位的分辨率，我们使用 1度（`CV_PI/180`）\n- threshold：阈值，一条直线所需的最少的曲线交点\n- srn and stn：默认为0\n\n`cv2.HoughLinesp(image, rho, theta, threshold[, lines[, minLineLength[, maxlineGap]]])` —— 基于统计\n\n- image 输入图像，必须是二值图像，推荐使用canny边缘检测的结果图像\n- rho累加器的距离分辨率，以像素为单位（参数极径 r）\n- theta：累加器的角度分辨率，以弧度标识（参数极角 $\\theta$）\n- threshold：累加器阈值，int，超过设定阈值才被检测为线段\n- **lines：储存着检测到的直线参数对的容器（这里存储的是起始终止点坐标【但是似乎并不会读取，在很多使用中甚至没有出现在参数列表中】）**， 该参数 非必须\n- minLineLength：检测线段的最小长度\n- maxLineGap：同一方向上，两条线段判断定一条线段的最大允许间隔，超多了设定值，则把两条线段当成一条线段，值越大，允许线段上的断裂越大，越有可能检出潜在的直线\n\n> 参考：[OpenCV-Python 霍夫变换 检测直线，圆形](https://blog.csdn.net/wsp_1138886114/article/details/82936218)\n>\n> 应用案例：[简易车道线识别（图像与计算机视觉）](https://www.jianshu.com/p/15e3f9d8c121)\n>\n> ```python\n> class HoughLinesP():\n>  def __init__(self):\n>      # 霍夫\n>      self.rho = 1  # distance resolution in pixels of the Hough grid\n>      self.theta = np.pi / 180  # angular resolution in radians of the Hough grid\n>      self.threshold = 30  # minimum number of votes (intersections in Hough grid cell)\n>      self.min_line_length = 30  # minimum number of pixels making up a line\n>      self.max_line_gap = 30  # maximum gap in pixels between connectable line segments\n>      # line_image = np.copy(image)*0 # creating a blank to draw lines on\n> \n>  def houghlinesP(self, img):\n>      # return (n,4)\n>      try:\n>          return cv2.HoughLinesP(img, self.rho, self.theta, self.threshold, np.array([]), self.min_line_length, self.max_line_gap)[:, 0, :]\n>      except TypeError:\n>          return None\n> ```\n>\n> 从多个使用来看，输出结果似乎是直线的起点和终点，但又好像是直线的斜率和截距\n\n### 滤波\n\n阈值与平滑的实现\n\n`cv2.blur(img, (3, 3))`均值滤波\n\n(3, 3) 是均值滤波的方框的大小\n\n`cv2.boxfilter(img, -1, (3, 3), normalize=True)`方框滤波\n\nnormalize=True时，结果与均值滤波结果相同\n\nFalse，表示对加和后的结果不进行平均操作，大于255的使用255表示\n\n`cv2.Guassiannblur(img, (3, 3), 1)`高斯滤波\n\n1表示$\\sigma$，x表示与当前值 的距离，计算出的G(x)表示权重值\n\n`cv2.medianBlur(img, 3)`中值滤波\n\n3表示当前的方框尺寸\n\n该函数用于将9个值进行排序，取中值作为当前值\n\n#### 平滑边缘锯齿 —— 中值滤波\n\n两种滤波：中值滤波、高斯滤波\n\n平滑边缘锯齿\n\n主要步骤：找出轮廓，对轮廓进行处理\n\n`cv2.medianBlur()`\n\n> 参考：[机器学习进阶-阈值与平滑-图像平滑操作(去噪操作) ](https://www.cnblogs.com/my-love-is-python/p/10391923.html)\n>\n> [3 opencv平滑边缘锯齿代码](https://blog.csdn.net/qq_16949707/article/details/70340090)\n\n## CV_bridge\n\n和ROS相关的OpenCV使用\n\n## 车道线识别\n\n> 参考：\n>\n> [无人驾驶之车道线检测（一）](https://blog.csdn.net/gavinmiaoc/article/details/88786229)\n>\n> [无人驾驶技术入门（十四）| 初识图像之初级车道线检测](https://zhuanlan.zhihu.com/p/52623916)\n\n### 关于图片中的车道识别\n\n（1）可以首先进行灰度处理\n\n（2）然后进行边缘提取，突出车道线\n\n- 方法：Canny算法和Sobel算法\n\n（3）感兴趣区域选择（Region of Interest）\n\n- 截取\n- 似乎直接选择了一个三角形区域\n\n![image-20200902214326070](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200902214326070.png)\n\n（4）经典霍夫变换，将左右车道线从复杂的图像中提取出来\n\n> 参考：[经典霍夫变换](https://blog.csdn.net/yuyuntan/article/details/80141392)\n\n图像中使用霍夫变换\n\n- 识别直线；`cv2.HoughLines()`，可以检测不同长度的线段\n\n- 还可以识别圆、椭圆等图形\n\n（5）数据后处理\n\n计算左右车道线的直线方程\n\n- 根据每个线段在图像坐标系下的斜率，判断为左车道线还是优车道线\n- 最小二乘拟合\n\n计算左右车道线的上下边界\n\n- 现实世界中左右车道线平行 =》 认为左右车道线**最上和最下的点**对应的y值，就是左右车道线的边界\n\n（6）处理视频\n\n也就是把视频变成一帧帧图像，然后进行处理\n\n> 参考：[无人驾驶技术入门（十五）| 再识图像之高级车道线检测](","source":"_posts/OpenCV常用方法.md","raw":"---\ntitle: OpenCV常用方法\ndate: 2020-09-26 09:36:27\ncategories: \n\t- [Tools]\n\t- [机器视觉]\ntags:\n\t- OpenCV\t\n\t- 华为云无人车\n---\n\n## 安装\n\npip install opencv-python\n\n> 参考：[Py之cv2：cv2库(OpenCV，opencv-python)的简介、安装、使用方法(常见函数、方法等)最强详细攻略](https://blog.csdn.net/qq_41185868/article/details/79675875#%E5%AE%89%E8%A3%85OpenCV%E7%9A%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95)\n\n注意，基于pip安装，有多种方式，上面讲的opencv-python包含主要的modules，此外还有四个opencv的版本在pip可以获得：\n\n- [opencv-python](https://pypi.org/project/opencv-python/)包含opencv的主要modules\n- [opencv-contrib-python](https://pypi.org/project/opencv-contrib-python/) 包含opencv的主要modules以及contrib modules\n- [opencv-python-headless](https://pypi.org/project/opencv-python-headless/): 和opencv-python相同，但是没有GUI功能\n- [opencv-contrib-python-headless](https://pypi.org/project/opencv-contrib-python-headless/):与opencv-contrib-python相同，但是没有GUI功能。\n\n推荐在虚拟环境（conda环境）中安装第二种。\n\n<!--more-->\n\n此外还有安装方式：\n\n【conda安装】\n\n```bash\nconda install -c https://conda.anaconda.org/menpo opencv3 #安装opencv3\n#如果要安装opencv4将opencv3改成如下命令\nconda install -c https://conda.anaconda.org/menpo opencv #安装最新版opencv4\n#也可通过conda search -c https://conda.anaconda.org/menpo opencv*来搜索所有opencv版本\n```\n\n卸载：\n\n```bash\nconda unstall opencv3 #卸载opencv3\nconda deactivate #退出虚拟环境\nconda remove -n vm --all #删除虚拟环境conda unstall opencv3 #卸载opencv3\n```\n\n> 参考：[【opencv】1.opencv安装之使用pip或conda安装opencv](https://blog.csdn.net/u011119817/article/details/100110495)\n\n## 图片相关\n\n`cv2.imread()`\n\nOpenCV定义了，图像的原点（0，0）在图片的左上角，横轴为X，朝右，纵轴为Y，朝下，如下图所示。\n\n![image-20200902213453711](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200902213453711.png)\n\n需要注意的是，由于OpenCV的早期开发者习惯于使用BGR顺序的颜色模型，因此使用OpenCV的imread()读到的像素，每个像素的排列是按BGR，而不是常见的RGB，代码编写时需要注意。\n\n`cv2.namedWindow('', cv2.WINDOW_KEEPRATIO)`\n\n对视窗进行命名\n\n`cv2.resizeWindow('', 0, 0)`\n\n调整图像大小\n\n`cv2.moveWindow('', 0, 0)`\n\n移动视窗到合适的位置\n\n#### 图片缩放\n\n`cv2.resize(img, (int(y/2), int(x/2)))`\n\n设置参数为图片的高和宽，定义后直接输出尺寸为宽和高\n\n`cv2.resize(img, (0,0), fx=0.25, fy=0.25, interpolation=cv2.INTER_NEAREST)`\n\n使用最近邻插值法缩放到原来图片的四分之一\n\n> 参考：[cv2.resize()](https://blog.csdn.net/wzhrsh/article/details/101630396)\n\n## 画图 \n\nOpenCV的画图确实要比matplotlib.pyplot()高级一点\n\n> 参考：[matplotlib画直线](https://blog.csdn.net/skyli114/article/details/77508136)\n\n比如画直线等\n\n> 参考：[Python 用 OpenCV 画直线 (3)](https://blog.csdn.net/u011520181/article/details/83999786)\n>\n> 该博客系列还有画点、圆、矩形、椭圆，写文字、显示图像等内容\n\n`cv2.line(img, pt1, pt2, color[, thickness[, lineType[, shift]]])`\n\nimg：要画的圆所在的矩形或图像\n\npt1：直线起点\n\npt2：直线终点\n\ncolor：线条颜色\n\nthickness：线条宽度\n\nlineType：\n\n- 8：8-connected line\n- 4：4-connected line\n- CV_AA：antialiased line\n\nshift：坐标点小数点位数\n\n`cv2.polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]])`\n\n- img - 图片\n- pts - 多边形顶点（这个该如何写，很有意思，可以用np.array定义变量，但是最后加入到函数中时，还需要再次使用[]将变量括起来）\n- isClosed - 是否闭合线段\n- color - 颜色\n\n> 参考：[cv2.polylines()绘制多边形](https://drivingc.com/p/5af8f4962392ec4f4727ccce)\n\n`cv2.fillpoly()`\n\n可以填充任意形状的图形\n\n一次可以填充多个图形\n\n`cv2.fillConvexPoly()`\n\n可以用来**填充**凸多边形，只需要提供凸多边形的顶点\n\n> 参考：[cv2.fillConvexPoly()与cv2.fillPoly()填充多边形](https://blog.csdn.net/u012135425/article/details/84983265)\n\n## 视频相关\n\n`cv = cv2.VideoCapture('/dev/video10')`\n\n表示打开摄像头\n\n如果括号里面是视频的文件名（也可以是绝对、相对路径），那么就会调用视频，但是需要注意视频位置需要和python脚本的位置在同一个文件夹中\n\n`ret, frame = cv.read()`\n\n按帧读取视频，有两个返回值:\n\n- ret 是布尔值，如果读取帧正确，会返回true，如果读取到结尾，则返回false\n\n- frame 是每一帧的图像，是一个三维矩阵\n\n`cv2.waitKey()`\n\n等待键盘输入\n\n参数：\n\n- 1：表示延时1ms切换到下一帧\n- 0，只显示当前帧，相当于暂停\n- 参数过大会因为延时较久而卡顿\n\n`cv2.realse()`\n\n释放摄像头\n\n`cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)`\n\ncvtColor函数用于在图像中不同的色彩空间进行转换，用于后续处理\n\n有RGB、HSV、HSI、LAB、YUV，彩色或者灰度图\n\n灰度图\n\n![灰度图计算](https://pic3.zhimg.com/v2-ddeaaaeab138b73aedecf3e0fad56aba_r.jpg)\n\n位图模式（像素只有0或者1），\n\n`cv2.imshow()`\n\n将图片展示出来\n\n`cv2.erode()`和`cv2.dilate()`\n\n图像的形态学操作，腐蚀和膨胀\n\n- 腐蚀 erode = 变瘦\n  - 使用腐蚀可以将图片中的一些毛刺或细小的东西去掉\n  - 在原图中的每一个小区域里面取最小值，二值化图像，只要有一个点为0，则都为0\n  - 参数\n    - 图像\n    - kernel\n    - iterations，该值越高，图像腐蚀程度越高，只能为整数\n- 膨胀 dilate = 变胖\n  - 取得局部最大值\n  - 参数\n    - 图像\n    - kernel\n    - iterations，该值越高，效果越明显，越胖\n\n![image-20200901161845805](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200901161845805.png)\n\n`cv2.destroyAllWindows()`\n\nwarp：经，经线\n\n`cv2.warpAffine()`\n\n仿射变换函数\n\n可以实现旋转、平移、缩放\n\n变换后的平行线依然是平行的\n\n其变换矩阵至少需要获取三组变换前后对应的点坐标，实现变换\n\n`cv2.warpPerspective(src, M, dsize, dst=None, flags=None, borderMode=None， borderValu=None)`\n\n==透视变换函数==\n\n**可以保持直线不变性，但是平行线可能不再平行**\n\n参数：\n\n- src，输入图像\n- dst，输出图像\n- **M：2x3的变换矩阵**\n- dsize：**变换后输出图像尺寸**\n- flag：插值方法,`cv2.INTER_LINEAR`是默认的插值方法，可以调整输入图像的大小；cv2.INTER_AREA 表示收缩，缩小尺寸；如果是放大建议使用cv2.INTER_CUBIC和cv2.INTER_LINEAR\n- borderMode：边界像素外扩方式\n- borderValue：边界像素插值，默认为0\n\n其**==变换矩阵M==**至少需要**四组**变换前后对应的点坐标\n\n其变换矩阵可以通过`cv2.getPerspectiveTransform()`函数获得\n\n> 参考：[python的cv2.warpAffine()和cv2.warpPerspective()解析对比](https://blog.csdn.net/u012114438/article/details/102613492)\n>\n> 其变换矩阵也可以通过`cv2.getRotationMatrix2D(center, angle, scale)`函数先获得旋转缩放变换，然后再通过`cv2.warpAffine()`函数对图像进行旋转缩放变换\n>\n> center：旋转中心坐标\n>\n> angle：旋转角度\n>\n> scale：缩放尺度\n\n仿射变换——affine transformation\n\n包括平移translation、旋转rotation、放缩isotropic uniform scaling、剪切、反射reflection\n\n欧式变换：euclidean transformation  刚体变换 rigid transformation，包括平移和旋转\n\n> 参考：[仿射变换及其变换矩阵的理解](https://www.cnblogs.com/shine-lee/p/10950963.html)\n\n## 算法\n\n### 基础\n\n`cv2.split()` 拆分（通道分离）\n\n`cv2.merge()`合并（通道合并）\n\n### 霍夫检测\n\n`cv2.HoughLines()` —— 标准\n\n- dst：输出图像，二值化图像\n- **lines：存储着检测到的直线的参数对**，该参数似乎不是必须的\n- rho：参数极径 r 以像素值为单位的分辨率，一般是1\n- theta：参数极角 \\theta 以弧度为单位的分辨率，我们使用 1度（`CV_PI/180`）\n- threshold：阈值，一条直线所需的最少的曲线交点\n- srn and stn：默认为0\n\n`cv2.HoughLinesp(image, rho, theta, threshold[, lines[, minLineLength[, maxlineGap]]])` —— 基于统计\n\n- image 输入图像，必须是二值图像，推荐使用canny边缘检测的结果图像\n- rho累加器的距离分辨率，以像素为单位（参数极径 r）\n- theta：累加器的角度分辨率，以弧度标识（参数极角 $\\theta$）\n- threshold：累加器阈值，int，超过设定阈值才被检测为线段\n- **lines：储存着检测到的直线参数对的容器（这里存储的是起始终止点坐标【但是似乎并不会读取，在很多使用中甚至没有出现在参数列表中】）**， 该参数 非必须\n- minLineLength：检测线段的最小长度\n- maxLineGap：同一方向上，两条线段判断定一条线段的最大允许间隔，超多了设定值，则把两条线段当成一条线段，值越大，允许线段上的断裂越大，越有可能检出潜在的直线\n\n> 参考：[OpenCV-Python 霍夫变换 检测直线，圆形](https://blog.csdn.net/wsp_1138886114/article/details/82936218)\n>\n> 应用案例：[简易车道线识别（图像与计算机视觉）](https://www.jianshu.com/p/15e3f9d8c121)\n>\n> ```python\n> class HoughLinesP():\n>  def __init__(self):\n>      # 霍夫\n>      self.rho = 1  # distance resolution in pixels of the Hough grid\n>      self.theta = np.pi / 180  # angular resolution in radians of the Hough grid\n>      self.threshold = 30  # minimum number of votes (intersections in Hough grid cell)\n>      self.min_line_length = 30  # minimum number of pixels making up a line\n>      self.max_line_gap = 30  # maximum gap in pixels between connectable line segments\n>      # line_image = np.copy(image)*0 # creating a blank to draw lines on\n> \n>  def houghlinesP(self, img):\n>      # return (n,4)\n>      try:\n>          return cv2.HoughLinesP(img, self.rho, self.theta, self.threshold, np.array([]), self.min_line_length, self.max_line_gap)[:, 0, :]\n>      except TypeError:\n>          return None\n> ```\n>\n> 从多个使用来看，输出结果似乎是直线的起点和终点，但又好像是直线的斜率和截距\n\n### 滤波\n\n阈值与平滑的实现\n\n`cv2.blur(img, (3, 3))`均值滤波\n\n(3, 3) 是均值滤波的方框的大小\n\n`cv2.boxfilter(img, -1, (3, 3), normalize=True)`方框滤波\n\nnormalize=True时，结果与均值滤波结果相同\n\nFalse，表示对加和后的结果不进行平均操作，大于255的使用255表示\n\n`cv2.Guassiannblur(img, (3, 3), 1)`高斯滤波\n\n1表示$\\sigma$，x表示与当前值 的距离，计算出的G(x)表示权重值\n\n`cv2.medianBlur(img, 3)`中值滤波\n\n3表示当前的方框尺寸\n\n该函数用于将9个值进行排序，取中值作为当前值\n\n#### 平滑边缘锯齿 —— 中值滤波\n\n两种滤波：中值滤波、高斯滤波\n\n平滑边缘锯齿\n\n主要步骤：找出轮廓，对轮廓进行处理\n\n`cv2.medianBlur()`\n\n> 参考：[机器学习进阶-阈值与平滑-图像平滑操作(去噪操作) ](https://www.cnblogs.com/my-love-is-python/p/10391923.html)\n>\n> [3 opencv平滑边缘锯齿代码](https://blog.csdn.net/qq_16949707/article/details/70340090)\n\n## CV_bridge\n\n和ROS相关的OpenCV使用\n\n## 车道线识别\n\n> 参考：\n>\n> [无人驾驶之车道线检测（一）](https://blog.csdn.net/gavinmiaoc/article/details/88786229)\n>\n> [无人驾驶技术入门（十四）| 初识图像之初级车道线检测](https://zhuanlan.zhihu.com/p/52623916)\n\n### 关于图片中的车道识别\n\n（1）可以首先进行灰度处理\n\n（2）然后进行边缘提取，突出车道线\n\n- 方法：Canny算法和Sobel算法\n\n（3）感兴趣区域选择（Region of Interest）\n\n- 截取\n- 似乎直接选择了一个三角形区域\n\n![image-20200902214326070](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200902214326070.png)\n\n（4）经典霍夫变换，将左右车道线从复杂的图像中提取出来\n\n> 参考：[经典霍夫变换](https://blog.csdn.net/yuyuntan/article/details/80141392)\n\n图像中使用霍夫变换\n\n- 识别直线；`cv2.HoughLines()`，可以检测不同长度的线段\n\n- 还可以识别圆、椭圆等图形\n\n（5）数据后处理\n\n计算左右车道线的直线方程\n\n- 根据每个线段在图像坐标系下的斜率，判断为左车道线还是优车道线\n- 最小二乘拟合\n\n计算左右车道线的上下边界\n\n- 现实世界中左右车道线平行 =》 认为左右车道线**最上和最下的点**对应的y值，就是左右车道线的边界\n\n（6）处理视频\n\n也就是把视频变成一帧帧图像，然后进行处理\n\n> 参考：[无人驾驶技术入门（十五）| 再识图像之高级车道线检测](","slug":"OpenCV常用方法","published":1,"updated":"2021-01-26T06:21:29.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n891003dk8tl1bl08bhy","content":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>pip install opencv-python</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/qq_41185868/article/details/79675875#%E5%AE%89%E8%A3%85OpenCV%E7%9A%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">Py之cv2：cv2库(OpenCV，opencv-python)的简介、安装、使用方法(常见函数、方法等)最强详细攻略</a></p>\n</blockquote>\n<p>注意，基于pip安装，有多种方式，上面讲的opencv-python包含主要的modules，此外还有四个opencv的版本在pip可以获得：</p>\n<ul>\n<li><a href=\"https://pypi.org/project/opencv-python/\" target=\"_blank\" rel=\"noopener\">opencv-python</a>包含opencv的主要modules</li>\n<li><a href=\"https://pypi.org/project/opencv-contrib-python/\" target=\"_blank\" rel=\"noopener\">opencv-contrib-python</a> 包含opencv的主要modules以及contrib modules</li>\n<li><a href=\"https://pypi.org/project/opencv-python-headless/\" target=\"_blank\" rel=\"noopener\">opencv-python-headless</a>: 和opencv-python相同，但是没有GUI功能</li>\n<li><a href=\"https://pypi.org/project/opencv-contrib-python-headless/\" target=\"_blank\" rel=\"noopener\">opencv-contrib-python-headless</a>:与opencv-contrib-python相同，但是没有GUI功能。</li>\n</ul>\n<p>推荐在虚拟环境（conda环境）中安装第二种。</p>\n<a id=\"more\"></a>\n<p>此外还有安装方式：</p>\n<p>【conda安装】</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install -c https://conda.anaconda.org/menpo opencv3 <span class=\"comment\">#安装opencv3</span></span><br><span class=\"line\"><span class=\"comment\">#如果要安装opencv4将opencv3改成如下命令</span></span><br><span class=\"line\">conda install -c https://conda.anaconda.org/menpo opencv <span class=\"comment\">#安装最新版opencv4</span></span><br><span class=\"line\"><span class=\"comment\">#也可通过conda search -c https://conda.anaconda.org/menpo opencv*来搜索所有opencv版本</span></span><br></pre></td></tr></table></figure>\n<p>卸载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda unstall opencv3 <span class=\"comment\">#卸载opencv3</span></span><br><span class=\"line\">conda deactivate <span class=\"comment\">#退出虚拟环境</span></span><br><span class=\"line\">conda remove -n vm --all <span class=\"comment\">#删除虚拟环境conda unstall opencv3 #卸载opencv3</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/u011119817/article/details/100110495\" target=\"_blank\" rel=\"noopener\">【opencv】1.opencv安装之使用pip或conda安装opencv</a></p>\n</blockquote>\n<h2 id=\"图片相关\"><a href=\"#图片相关\" class=\"headerlink\" title=\"图片相关\"></a>图片相关</h2><p><code>cv2.imread()</code></p>\n<p>OpenCV定义了，图像的原点（0，0）在图片的左上角，横轴为X，朝右，纵轴为Y，朝下，如下图所示。</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200902213453711.png\" alt=\"image-20200902213453711\"></p>\n<p>需要注意的是，由于OpenCV的早期开发者习惯于使用BGR顺序的颜色模型，因此使用OpenCV的imread()读到的像素，每个像素的排列是按BGR，而不是常见的RGB，代码编写时需要注意。</p>\n<p><code>cv2.namedWindow(&#39;&#39;, cv2.WINDOW_KEEPRATIO)</code></p>\n<p>对视窗进行命名</p>\n<p><code>cv2.resizeWindow(&#39;&#39;, 0, 0)</code></p>\n<p>调整图像大小</p>\n<p><code>cv2.moveWindow(&#39;&#39;, 0, 0)</code></p>\n<p>移动视窗到合适的位置</p>\n<h4 id=\"图片缩放\"><a href=\"#图片缩放\" class=\"headerlink\" title=\"图片缩放\"></a>图片缩放</h4><p><code>cv2.resize(img, (int(y/2), int(x/2)))</code></p>\n<p>设置参数为图片的高和宽，定义后直接输出尺寸为宽和高</p>\n<p><code>cv2.resize(img, (0,0), fx=0.25, fy=0.25, interpolation=cv2.INTER_NEAREST)</code></p>\n<p>使用最近邻插值法缩放到原来图片的四分之一</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/wzhrsh/article/details/101630396\" target=\"_blank\" rel=\"noopener\">cv2.resize()</a></p>\n</blockquote>\n<h2 id=\"画图\"><a href=\"#画图\" class=\"headerlink\" title=\"画图\"></a>画图</h2><p>OpenCV的画图确实要比matplotlib.pyplot()高级一点</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/skyli114/article/details/77508136\" target=\"_blank\" rel=\"noopener\">matplotlib画直线</a></p>\n</blockquote>\n<p>比如画直线等</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/u011520181/article/details/83999786\" target=\"_blank\" rel=\"noopener\">Python 用 OpenCV 画直线 (3)</a></p>\n<p>该博客系列还有画点、圆、矩形、椭圆，写文字、显示图像等内容</p>\n</blockquote>\n<p><code>cv2.line(img, pt1, pt2, color[, thickness[, lineType[, shift]]])</code></p>\n<p>img：要画的圆所在的矩形或图像</p>\n<p>pt1：直线起点</p>\n<p>pt2：直线终点</p>\n<p>color：线条颜色</p>\n<p>thickness：线条宽度</p>\n<p>lineType：</p>\n<ul>\n<li>8：8-connected line</li>\n<li>4：4-connected line</li>\n<li>CV_AA：antialiased line</li>\n</ul>\n<p>shift：坐标点小数点位数</p>\n<p><code>cv2.polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]])</code></p>\n<ul>\n<li>img - 图片</li>\n<li>pts - 多边形顶点（这个该如何写，很有意思，可以用np.array定义变量，但是最后加入到函数中时，还需要再次使用[]将变量括起来）</li>\n<li>isClosed - 是否闭合线段</li>\n<li>color - 颜色</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://drivingc.com/p/5af8f4962392ec4f4727ccce\" target=\"_blank\" rel=\"noopener\">cv2.polylines()绘制多边形</a></p>\n</blockquote>\n<p><code>cv2.fillpoly()</code></p>\n<p>可以填充任意形状的图形</p>\n<p>一次可以填充多个图形</p>\n<p><code>cv2.fillConvexPoly()</code></p>\n<p>可以用来<strong>填充</strong>凸多边形，只需要提供凸多边形的顶点</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/u012135425/article/details/84983265\" target=\"_blank\" rel=\"noopener\">cv2.fillConvexPoly()与cv2.fillPoly()填充多边形</a></p>\n</blockquote>\n<h2 id=\"视频相关\"><a href=\"#视频相关\" class=\"headerlink\" title=\"视频相关\"></a>视频相关</h2><p><code>cv = cv2.VideoCapture(&#39;/dev/video10&#39;)</code></p>\n<p>表示打开摄像头</p>\n<p>如果括号里面是视频的文件名（也可以是绝对、相对路径），那么就会调用视频，但是需要注意视频位置需要和python脚本的位置在同一个文件夹中</p>\n<p><code>ret, frame = cv.read()</code></p>\n<p>按帧读取视频，有两个返回值:</p>\n<ul>\n<li><p>ret 是布尔值，如果读取帧正确，会返回true，如果读取到结尾，则返回false</p>\n</li>\n<li><p>frame 是每一帧的图像，是一个三维矩阵</p>\n</li>\n</ul>\n<p><code>cv2.waitKey()</code></p>\n<p>等待键盘输入</p>\n<p>参数：</p>\n<ul>\n<li>1：表示延时1ms切换到下一帧</li>\n<li>0，只显示当前帧，相当于暂停</li>\n<li>参数过大会因为延时较久而卡顿</li>\n</ul>\n<p><code>cv2.realse()</code></p>\n<p>释放摄像头</p>\n<p><code>cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</code></p>\n<p>cvtColor函数用于在图像中不同的色彩空间进行转换，用于后续处理</p>\n<p>有RGB、HSV、HSI、LAB、YUV，彩色或者灰度图</p>\n<p>灰度图</p>\n<p><img src=\"https://pic3.zhimg.com/v2-ddeaaaeab138b73aedecf3e0fad56aba_r.jpg\" alt=\"灰度图计算\"></p>\n<p>位图模式（像素只有0或者1），</p>\n<p><code>cv2.imshow()</code></p>\n<p>将图片展示出来</p>\n<p><code>cv2.erode()</code>和<code>cv2.dilate()</code></p>\n<p>图像的形态学操作，腐蚀和膨胀</p>\n<ul>\n<li>腐蚀 erode = 变瘦<ul>\n<li>使用腐蚀可以将图片中的一些毛刺或细小的东西去掉</li>\n<li>在原图中的每一个小区域里面取最小值，二值化图像，只要有一个点为0，则都为0</li>\n<li>参数<ul>\n<li>图像</li>\n<li>kernel</li>\n<li>iterations，该值越高，图像腐蚀程度越高，只能为整数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>膨胀 dilate = 变胖<ul>\n<li>取得局部最大值</li>\n<li>参数<ul>\n<li>图像</li>\n<li>kernel</li>\n<li>iterations，该值越高，效果越明显，越胖</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200901161845805.png\" alt=\"image-20200901161845805\"></p>\n<p><code>cv2.destroyAllWindows()</code></p>\n<p>warp：经，经线</p>\n<p><code>cv2.warpAffine()</code></p>\n<p>仿射变换函数</p>\n<p>可以实现旋转、平移、缩放</p>\n<p>变换后的平行线依然是平行的</p>\n<p>其变换矩阵至少需要获取三组变换前后对应的点坐标，实现变换</p>\n<p><code>cv2.warpPerspective(src, M, dsize, dst=None, flags=None, borderMode=None， borderValu=None)</code></p>\n<p>==透视变换函数==</p>\n<p><strong>可以保持直线不变性，但是平行线可能不再平行</strong></p>\n<p>参数：</p>\n<ul>\n<li>src，输入图像</li>\n<li>dst，输出图像</li>\n<li><strong>M：2x3的变换矩阵</strong></li>\n<li>dsize：<strong>变换后输出图像尺寸</strong></li>\n<li>flag：插值方法,<code>cv2.INTER_LINEAR</code>是默认的插值方法，可以调整输入图像的大小；cv2.INTER_AREA 表示收缩，缩小尺寸；如果是放大建议使用cv2.INTER_CUBIC和cv2.INTER_LINEAR</li>\n<li>borderMode：边界像素外扩方式</li>\n<li>borderValue：边界像素插值，默认为0</li>\n</ul>\n<p>其<strong>==变换矩阵M==</strong>至少需要<strong>四组</strong>变换前后对应的点坐标</p>\n<p>其变换矩阵可以通过<code>cv2.getPerspectiveTransform()</code>函数获得</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/u012114438/article/details/102613492\" target=\"_blank\" rel=\"noopener\">python的cv2.warpAffine()和cv2.warpPerspective()解析对比</a></p>\n<p>其变换矩阵也可以通过<code>cv2.getRotationMatrix2D(center, angle, scale)</code>函数先获得旋转缩放变换，然后再通过<code>cv2.warpAffine()</code>函数对图像进行旋转缩放变换</p>\n<p>center：旋转中心坐标</p>\n<p>angle：旋转角度</p>\n<p>scale：缩放尺度</p>\n</blockquote>\n<p>仿射变换——affine transformation</p>\n<p>包括平移translation、旋转rotation、放缩isotropic uniform scaling、剪切、反射reflection</p>\n<p>欧式变换：euclidean transformation  刚体变换 rigid transformation，包括平移和旋转</p>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/shine-lee/p/10950963.html\" target=\"_blank\" rel=\"noopener\">仿射变换及其变换矩阵的理解</a></p>\n</blockquote>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p><code>cv2.split()</code> 拆分（通道分离）</p>\n<p><code>cv2.merge()</code>合并（通道合并）</p>\n<h3 id=\"霍夫检测\"><a href=\"#霍夫检测\" class=\"headerlink\" title=\"霍夫检测\"></a>霍夫检测</h3><p><code>cv2.HoughLines()</code> —— 标准</p>\n<ul>\n<li>dst：输出图像，二值化图像</li>\n<li><strong>lines：存储着检测到的直线的参数对</strong>，该参数似乎不是必须的</li>\n<li>rho：参数极径 r 以像素值为单位的分辨率，一般是1</li>\n<li>theta：参数极角 \\theta 以弧度为单位的分辨率，我们使用 1度（<code>CV_PI/180</code>）</li>\n<li>threshold：阈值，一条直线所需的最少的曲线交点</li>\n<li>srn and stn：默认为0</li>\n</ul>\n<p><code>cv2.HoughLinesp(image, rho, theta, threshold[, lines[, minLineLength[, maxlineGap]]])</code> —— 基于统计</p>\n<ul>\n<li>image 输入图像，必须是二值图像，推荐使用canny边缘检测的结果图像</li>\n<li>rho累加器的距离分辨率，以像素为单位（参数极径 r）</li>\n<li>theta：累加器的角度分辨率，以弧度标识（参数极角 $\\theta$）</li>\n<li>threshold：累加器阈值，int，超过设定阈值才被检测为线段</li>\n<li><strong>lines：储存着检测到的直线参数对的容器（这里存储的是起始终止点坐标【但是似乎并不会读取，在很多使用中甚至没有出现在参数列表中】）</strong>， 该参数 非必须</li>\n<li>minLineLength：检测线段的最小长度</li>\n<li>maxLineGap：同一方向上，两条线段判断定一条线段的最大允许间隔，超多了设定值，则把两条线段当成一条线段，值越大，允许线段上的断裂越大，越有可能检出潜在的直线</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/wsp_1138886114/article/details/82936218\" target=\"_blank\" rel=\"noopener\">OpenCV-Python 霍夫变换 检测直线，圆形</a></p>\n<p>应用案例：<a href=\"https://www.jianshu.com/p/15e3f9d8c121\" target=\"_blank\" rel=\"noopener\">简易车道线识别（图像与计算机视觉）</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HoughLinesP</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">     <span class=\"comment\"># 霍夫</span></span><br><span class=\"line\">     self.rho = <span class=\"number\">1</span>  <span class=\"comment\"># distance resolution in pixels of the Hough grid</span></span><br><span class=\"line\">     self.theta = np.pi / <span class=\"number\">180</span>  <span class=\"comment\"># angular resolution in radians of the Hough grid</span></span><br><span class=\"line\">     self.threshold = <span class=\"number\">30</span>  <span class=\"comment\"># minimum number of votes (intersections in Hough grid cell)</span></span><br><span class=\"line\">     self.min_line_length = <span class=\"number\">30</span>  <span class=\"comment\"># minimum number of pixels making up a line</span></span><br><span class=\"line\">     self.max_line_gap = <span class=\"number\">30</span>  <span class=\"comment\"># maximum gap in pixels between connectable line segments</span></span><br><span class=\"line\">     <span class=\"comment\"># line_image = np.copy(image)*0 # creating a blank to draw lines on</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">houghlinesP</span><span class=\"params\">(self, img)</span>:</span></span><br><span class=\"line\">     <span class=\"comment\"># return (n,4)</span></span><br><span class=\"line\">     <span class=\"keyword\">try</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> cv2.HoughLinesP(img, self.rho, self.theta, self.threshold, np.array([]), self.min_line_length, self.max_line_gap)[:, <span class=\"number\">0</span>, :]</span><br><span class=\"line\">     <span class=\"keyword\">except</span> TypeError:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>从多个使用来看，输出结果似乎是直线的起点和终点，但又好像是直线的斜率和截距</p>\n</blockquote>\n<h3 id=\"滤波\"><a href=\"#滤波\" class=\"headerlink\" title=\"滤波\"></a>滤波</h3><p>阈值与平滑的实现</p>\n<p><code>cv2.blur(img, (3, 3))</code>均值滤波</p>\n<p>(3, 3) 是均值滤波的方框的大小</p>\n<p><code>cv2.boxfilter(img, -1, (3, 3), normalize=True)</code>方框滤波</p>\n<p>normalize=True时，结果与均值滤波结果相同</p>\n<p>False，表示对加和后的结果不进行平均操作，大于255的使用255表示</p>\n<p><code>cv2.Guassiannblur(img, (3, 3), 1)</code>高斯滤波</p>\n<p>1表示$\\sigma$，x表示与当前值 的距离，计算出的G(x)表示权重值</p>\n<p><code>cv2.medianBlur(img, 3)</code>中值滤波</p>\n<p>3表示当前的方框尺寸</p>\n<p>该函数用于将9个值进行排序，取中值作为当前值</p>\n<h4 id=\"平滑边缘锯齿-——-中值滤波\"><a href=\"#平滑边缘锯齿-——-中值滤波\" class=\"headerlink\" title=\"平滑边缘锯齿 —— 中值滤波\"></a>平滑边缘锯齿 —— 中值滤波</h4><p>两种滤波：中值滤波、高斯滤波</p>\n<p>平滑边缘锯齿</p>\n<p>主要步骤：找出轮廓，对轮廓进行处理</p>\n<p><code>cv2.medianBlur()</code></p>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/my-love-is-python/p/10391923.html\" target=\"_blank\" rel=\"noopener\">机器学习进阶-阈值与平滑-图像平滑操作(去噪操作) </a></p>\n<p><a href=\"https://blog.csdn.net/qq_16949707/article/details/70340090\" target=\"_blank\" rel=\"noopener\">3 opencv平滑边缘锯齿代码</a></p>\n</blockquote>\n<h2 id=\"CV-bridge\"><a href=\"#CV-bridge\" class=\"headerlink\" title=\"CV_bridge\"></a>CV_bridge</h2><p>和ROS相关的OpenCV使用</p>\n<h2 id=\"车道线识别\"><a href=\"#车道线识别\" class=\"headerlink\" title=\"车道线识别\"></a>车道线识别</h2><blockquote>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/gavinmiaoc/article/details/88786229\" target=\"_blank\" rel=\"noopener\">无人驾驶之车道线检测（一）</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/52623916\" target=\"_blank\" rel=\"noopener\">无人驾驶技术入门（十四）| 初识图像之初级车道线检测</a></p>\n</blockquote>\n<h3 id=\"关于图片中的车道识别\"><a href=\"#关于图片中的车道识别\" class=\"headerlink\" title=\"关于图片中的车道识别\"></a>关于图片中的车道识别</h3><p>（1）可以首先进行灰度处理</p>\n<p>（2）然后进行边缘提取，突出车道线</p>\n<ul>\n<li>方法：Canny算法和Sobel算法</li>\n</ul>\n<p>（3）感兴趣区域选择（Region of Interest）</p>\n<ul>\n<li>截取</li>\n<li>似乎直接选择了一个三角形区域</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200902214326070.png\" alt=\"image-20200902214326070\"></p>\n<p>（4）经典霍夫变换，将左右车道线从复杂的图像中提取出来</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/yuyuntan/article/details/80141392\" target=\"_blank\" rel=\"noopener\">经典霍夫变换</a></p>\n</blockquote>\n<p>图像中使用霍夫变换</p>\n<ul>\n<li><p>识别直线；<code>cv2.HoughLines()</code>，可以检测不同长度的线段</p>\n</li>\n<li><p>还可以识别圆、椭圆等图形</p>\n</li>\n</ul>\n<p>（5）数据后处理</p>\n<p>计算左右车道线的直线方程</p>\n<ul>\n<li>根据每个线段在图像坐标系下的斜率，判断为左车道线还是优车道线</li>\n<li>最小二乘拟合</li>\n</ul>\n<p>计算左右车道线的上下边界</p>\n<ul>\n<li>现实世界中左右车道线平行 =》 认为左右车道线<strong>最上和最下的点</strong>对应的y值，就是左右车道线的边界</li>\n</ul>\n<p>（6）处理视频</p>\n<p>也就是把视频变成一帧帧图像，然后进行处理</p>\n<blockquote>\n<p>参考：[无人驾驶技术入门（十五）| 再识图像之高级车道线检测](</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>pip install opencv-python</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/qq_41185868/article/details/79675875#%E5%AE%89%E8%A3%85OpenCV%E7%9A%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">Py之cv2：cv2库(OpenCV，opencv-python)的简介、安装、使用方法(常见函数、方法等)最强详细攻略</a></p>\n</blockquote>\n<p>注意，基于pip安装，有多种方式，上面讲的opencv-python包含主要的modules，此外还有四个opencv的版本在pip可以获得：</p>\n<ul>\n<li><a href=\"https://pypi.org/project/opencv-python/\" target=\"_blank\" rel=\"noopener\">opencv-python</a>包含opencv的主要modules</li>\n<li><a href=\"https://pypi.org/project/opencv-contrib-python/\" target=\"_blank\" rel=\"noopener\">opencv-contrib-python</a> 包含opencv的主要modules以及contrib modules</li>\n<li><a href=\"https://pypi.org/project/opencv-python-headless/\" target=\"_blank\" rel=\"noopener\">opencv-python-headless</a>: 和opencv-python相同，但是没有GUI功能</li>\n<li><a href=\"https://pypi.org/project/opencv-contrib-python-headless/\" target=\"_blank\" rel=\"noopener\">opencv-contrib-python-headless</a>:与opencv-contrib-python相同，但是没有GUI功能。</li>\n</ul>\n<p>推荐在虚拟环境（conda环境）中安装第二种。</p>","more":"<p>此外还有安装方式：</p>\n<p>【conda安装】</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install -c https://conda.anaconda.org/menpo opencv3 <span class=\"comment\">#安装opencv3</span></span><br><span class=\"line\"><span class=\"comment\">#如果要安装opencv4将opencv3改成如下命令</span></span><br><span class=\"line\">conda install -c https://conda.anaconda.org/menpo opencv <span class=\"comment\">#安装最新版opencv4</span></span><br><span class=\"line\"><span class=\"comment\">#也可通过conda search -c https://conda.anaconda.org/menpo opencv*来搜索所有opencv版本</span></span><br></pre></td></tr></table></figure>\n<p>卸载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda unstall opencv3 <span class=\"comment\">#卸载opencv3</span></span><br><span class=\"line\">conda deactivate <span class=\"comment\">#退出虚拟环境</span></span><br><span class=\"line\">conda remove -n vm --all <span class=\"comment\">#删除虚拟环境conda unstall opencv3 #卸载opencv3</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/u011119817/article/details/100110495\" target=\"_blank\" rel=\"noopener\">【opencv】1.opencv安装之使用pip或conda安装opencv</a></p>\n</blockquote>\n<h2 id=\"图片相关\"><a href=\"#图片相关\" class=\"headerlink\" title=\"图片相关\"></a>图片相关</h2><p><code>cv2.imread()</code></p>\n<p>OpenCV定义了，图像的原点（0，0）在图片的左上角，横轴为X，朝右，纵轴为Y，朝下，如下图所示。</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200902213453711.png\" alt=\"image-20200902213453711\"></p>\n<p>需要注意的是，由于OpenCV的早期开发者习惯于使用BGR顺序的颜色模型，因此使用OpenCV的imread()读到的像素，每个像素的排列是按BGR，而不是常见的RGB，代码编写时需要注意。</p>\n<p><code>cv2.namedWindow(&#39;&#39;, cv2.WINDOW_KEEPRATIO)</code></p>\n<p>对视窗进行命名</p>\n<p><code>cv2.resizeWindow(&#39;&#39;, 0, 0)</code></p>\n<p>调整图像大小</p>\n<p><code>cv2.moveWindow(&#39;&#39;, 0, 0)</code></p>\n<p>移动视窗到合适的位置</p>\n<h4 id=\"图片缩放\"><a href=\"#图片缩放\" class=\"headerlink\" title=\"图片缩放\"></a>图片缩放</h4><p><code>cv2.resize(img, (int(y/2), int(x/2)))</code></p>\n<p>设置参数为图片的高和宽，定义后直接输出尺寸为宽和高</p>\n<p><code>cv2.resize(img, (0,0), fx=0.25, fy=0.25, interpolation=cv2.INTER_NEAREST)</code></p>\n<p>使用最近邻插值法缩放到原来图片的四分之一</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/wzhrsh/article/details/101630396\" target=\"_blank\" rel=\"noopener\">cv2.resize()</a></p>\n</blockquote>\n<h2 id=\"画图\"><a href=\"#画图\" class=\"headerlink\" title=\"画图\"></a>画图</h2><p>OpenCV的画图确实要比matplotlib.pyplot()高级一点</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/skyli114/article/details/77508136\" target=\"_blank\" rel=\"noopener\">matplotlib画直线</a></p>\n</blockquote>\n<p>比如画直线等</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/u011520181/article/details/83999786\" target=\"_blank\" rel=\"noopener\">Python 用 OpenCV 画直线 (3)</a></p>\n<p>该博客系列还有画点、圆、矩形、椭圆，写文字、显示图像等内容</p>\n</blockquote>\n<p><code>cv2.line(img, pt1, pt2, color[, thickness[, lineType[, shift]]])</code></p>\n<p>img：要画的圆所在的矩形或图像</p>\n<p>pt1：直线起点</p>\n<p>pt2：直线终点</p>\n<p>color：线条颜色</p>\n<p>thickness：线条宽度</p>\n<p>lineType：</p>\n<ul>\n<li>8：8-connected line</li>\n<li>4：4-connected line</li>\n<li>CV_AA：antialiased line</li>\n</ul>\n<p>shift：坐标点小数点位数</p>\n<p><code>cv2.polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]])</code></p>\n<ul>\n<li>img - 图片</li>\n<li>pts - 多边形顶点（这个该如何写，很有意思，可以用np.array定义变量，但是最后加入到函数中时，还需要再次使用[]将变量括起来）</li>\n<li>isClosed - 是否闭合线段</li>\n<li>color - 颜色</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://drivingc.com/p/5af8f4962392ec4f4727ccce\" target=\"_blank\" rel=\"noopener\">cv2.polylines()绘制多边形</a></p>\n</blockquote>\n<p><code>cv2.fillpoly()</code></p>\n<p>可以填充任意形状的图形</p>\n<p>一次可以填充多个图形</p>\n<p><code>cv2.fillConvexPoly()</code></p>\n<p>可以用来<strong>填充</strong>凸多边形，只需要提供凸多边形的顶点</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/u012135425/article/details/84983265\" target=\"_blank\" rel=\"noopener\">cv2.fillConvexPoly()与cv2.fillPoly()填充多边形</a></p>\n</blockquote>\n<h2 id=\"视频相关\"><a href=\"#视频相关\" class=\"headerlink\" title=\"视频相关\"></a>视频相关</h2><p><code>cv = cv2.VideoCapture(&#39;/dev/video10&#39;)</code></p>\n<p>表示打开摄像头</p>\n<p>如果括号里面是视频的文件名（也可以是绝对、相对路径），那么就会调用视频，但是需要注意视频位置需要和python脚本的位置在同一个文件夹中</p>\n<p><code>ret, frame = cv.read()</code></p>\n<p>按帧读取视频，有两个返回值:</p>\n<ul>\n<li><p>ret 是布尔值，如果读取帧正确，会返回true，如果读取到结尾，则返回false</p>\n</li>\n<li><p>frame 是每一帧的图像，是一个三维矩阵</p>\n</li>\n</ul>\n<p><code>cv2.waitKey()</code></p>\n<p>等待键盘输入</p>\n<p>参数：</p>\n<ul>\n<li>1：表示延时1ms切换到下一帧</li>\n<li>0，只显示当前帧，相当于暂停</li>\n<li>参数过大会因为延时较久而卡顿</li>\n</ul>\n<p><code>cv2.realse()</code></p>\n<p>释放摄像头</p>\n<p><code>cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</code></p>\n<p>cvtColor函数用于在图像中不同的色彩空间进行转换，用于后续处理</p>\n<p>有RGB、HSV、HSI、LAB、YUV，彩色或者灰度图</p>\n<p>灰度图</p>\n<p><img src=\"https://pic3.zhimg.com/v2-ddeaaaeab138b73aedecf3e0fad56aba_r.jpg\" alt=\"灰度图计算\"></p>\n<p>位图模式（像素只有0或者1），</p>\n<p><code>cv2.imshow()</code></p>\n<p>将图片展示出来</p>\n<p><code>cv2.erode()</code>和<code>cv2.dilate()</code></p>\n<p>图像的形态学操作，腐蚀和膨胀</p>\n<ul>\n<li>腐蚀 erode = 变瘦<ul>\n<li>使用腐蚀可以将图片中的一些毛刺或细小的东西去掉</li>\n<li>在原图中的每一个小区域里面取最小值，二值化图像，只要有一个点为0，则都为0</li>\n<li>参数<ul>\n<li>图像</li>\n<li>kernel</li>\n<li>iterations，该值越高，图像腐蚀程度越高，只能为整数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>膨胀 dilate = 变胖<ul>\n<li>取得局部最大值</li>\n<li>参数<ul>\n<li>图像</li>\n<li>kernel</li>\n<li>iterations，该值越高，效果越明显，越胖</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200901161845805.png\" alt=\"image-20200901161845805\"></p>\n<p><code>cv2.destroyAllWindows()</code></p>\n<p>warp：经，经线</p>\n<p><code>cv2.warpAffine()</code></p>\n<p>仿射变换函数</p>\n<p>可以实现旋转、平移、缩放</p>\n<p>变换后的平行线依然是平行的</p>\n<p>其变换矩阵至少需要获取三组变换前后对应的点坐标，实现变换</p>\n<p><code>cv2.warpPerspective(src, M, dsize, dst=None, flags=None, borderMode=None， borderValu=None)</code></p>\n<p>==透视变换函数==</p>\n<p><strong>可以保持直线不变性，但是平行线可能不再平行</strong></p>\n<p>参数：</p>\n<ul>\n<li>src，输入图像</li>\n<li>dst，输出图像</li>\n<li><strong>M：2x3的变换矩阵</strong></li>\n<li>dsize：<strong>变换后输出图像尺寸</strong></li>\n<li>flag：插值方法,<code>cv2.INTER_LINEAR</code>是默认的插值方法，可以调整输入图像的大小；cv2.INTER_AREA 表示收缩，缩小尺寸；如果是放大建议使用cv2.INTER_CUBIC和cv2.INTER_LINEAR</li>\n<li>borderMode：边界像素外扩方式</li>\n<li>borderValue：边界像素插值，默认为0</li>\n</ul>\n<p>其<strong>==变换矩阵M==</strong>至少需要<strong>四组</strong>变换前后对应的点坐标</p>\n<p>其变换矩阵可以通过<code>cv2.getPerspectiveTransform()</code>函数获得</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/u012114438/article/details/102613492\" target=\"_blank\" rel=\"noopener\">python的cv2.warpAffine()和cv2.warpPerspective()解析对比</a></p>\n<p>其变换矩阵也可以通过<code>cv2.getRotationMatrix2D(center, angle, scale)</code>函数先获得旋转缩放变换，然后再通过<code>cv2.warpAffine()</code>函数对图像进行旋转缩放变换</p>\n<p>center：旋转中心坐标</p>\n<p>angle：旋转角度</p>\n<p>scale：缩放尺度</p>\n</blockquote>\n<p>仿射变换——affine transformation</p>\n<p>包括平移translation、旋转rotation、放缩isotropic uniform scaling、剪切、反射reflection</p>\n<p>欧式变换：euclidean transformation  刚体变换 rigid transformation，包括平移和旋转</p>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/shine-lee/p/10950963.html\" target=\"_blank\" rel=\"noopener\">仿射变换及其变换矩阵的理解</a></p>\n</blockquote>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p><code>cv2.split()</code> 拆分（通道分离）</p>\n<p><code>cv2.merge()</code>合并（通道合并）</p>\n<h3 id=\"霍夫检测\"><a href=\"#霍夫检测\" class=\"headerlink\" title=\"霍夫检测\"></a>霍夫检测</h3><p><code>cv2.HoughLines()</code> —— 标准</p>\n<ul>\n<li>dst：输出图像，二值化图像</li>\n<li><strong>lines：存储着检测到的直线的参数对</strong>，该参数似乎不是必须的</li>\n<li>rho：参数极径 r 以像素值为单位的分辨率，一般是1</li>\n<li>theta：参数极角 \\theta 以弧度为单位的分辨率，我们使用 1度（<code>CV_PI/180</code>）</li>\n<li>threshold：阈值，一条直线所需的最少的曲线交点</li>\n<li>srn and stn：默认为0</li>\n</ul>\n<p><code>cv2.HoughLinesp(image, rho, theta, threshold[, lines[, minLineLength[, maxlineGap]]])</code> —— 基于统计</p>\n<ul>\n<li>image 输入图像，必须是二值图像，推荐使用canny边缘检测的结果图像</li>\n<li>rho累加器的距离分辨率，以像素为单位（参数极径 r）</li>\n<li>theta：累加器的角度分辨率，以弧度标识（参数极角 $\\theta$）</li>\n<li>threshold：累加器阈值，int，超过设定阈值才被检测为线段</li>\n<li><strong>lines：储存着检测到的直线参数对的容器（这里存储的是起始终止点坐标【但是似乎并不会读取，在很多使用中甚至没有出现在参数列表中】）</strong>， 该参数 非必须</li>\n<li>minLineLength：检测线段的最小长度</li>\n<li>maxLineGap：同一方向上，两条线段判断定一条线段的最大允许间隔，超多了设定值，则把两条线段当成一条线段，值越大，允许线段上的断裂越大，越有可能检出潜在的直线</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/wsp_1138886114/article/details/82936218\" target=\"_blank\" rel=\"noopener\">OpenCV-Python 霍夫变换 检测直线，圆形</a></p>\n<p>应用案例：<a href=\"https://www.jianshu.com/p/15e3f9d8c121\" target=\"_blank\" rel=\"noopener\">简易车道线识别（图像与计算机视觉）</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HoughLinesP</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">     <span class=\"comment\"># 霍夫</span></span><br><span class=\"line\">     self.rho = <span class=\"number\">1</span>  <span class=\"comment\"># distance resolution in pixels of the Hough grid</span></span><br><span class=\"line\">     self.theta = np.pi / <span class=\"number\">180</span>  <span class=\"comment\"># angular resolution in radians of the Hough grid</span></span><br><span class=\"line\">     self.threshold = <span class=\"number\">30</span>  <span class=\"comment\"># minimum number of votes (intersections in Hough grid cell)</span></span><br><span class=\"line\">     self.min_line_length = <span class=\"number\">30</span>  <span class=\"comment\"># minimum number of pixels making up a line</span></span><br><span class=\"line\">     self.max_line_gap = <span class=\"number\">30</span>  <span class=\"comment\"># maximum gap in pixels between connectable line segments</span></span><br><span class=\"line\">     <span class=\"comment\"># line_image = np.copy(image)*0 # creating a blank to draw lines on</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">houghlinesP</span><span class=\"params\">(self, img)</span>:</span></span><br><span class=\"line\">     <span class=\"comment\"># return (n,4)</span></span><br><span class=\"line\">     <span class=\"keyword\">try</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> cv2.HoughLinesP(img, self.rho, self.theta, self.threshold, np.array([]), self.min_line_length, self.max_line_gap)[:, <span class=\"number\">0</span>, :]</span><br><span class=\"line\">     <span class=\"keyword\">except</span> TypeError:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>从多个使用来看，输出结果似乎是直线的起点和终点，但又好像是直线的斜率和截距</p>\n</blockquote>\n<h3 id=\"滤波\"><a href=\"#滤波\" class=\"headerlink\" title=\"滤波\"></a>滤波</h3><p>阈值与平滑的实现</p>\n<p><code>cv2.blur(img, (3, 3))</code>均值滤波</p>\n<p>(3, 3) 是均值滤波的方框的大小</p>\n<p><code>cv2.boxfilter(img, -1, (3, 3), normalize=True)</code>方框滤波</p>\n<p>normalize=True时，结果与均值滤波结果相同</p>\n<p>False，表示对加和后的结果不进行平均操作，大于255的使用255表示</p>\n<p><code>cv2.Guassiannblur(img, (3, 3), 1)</code>高斯滤波</p>\n<p>1表示$\\sigma$，x表示与当前值 的距离，计算出的G(x)表示权重值</p>\n<p><code>cv2.medianBlur(img, 3)</code>中值滤波</p>\n<p>3表示当前的方框尺寸</p>\n<p>该函数用于将9个值进行排序，取中值作为当前值</p>\n<h4 id=\"平滑边缘锯齿-——-中值滤波\"><a href=\"#平滑边缘锯齿-——-中值滤波\" class=\"headerlink\" title=\"平滑边缘锯齿 —— 中值滤波\"></a>平滑边缘锯齿 —— 中值滤波</h4><p>两种滤波：中值滤波、高斯滤波</p>\n<p>平滑边缘锯齿</p>\n<p>主要步骤：找出轮廓，对轮廓进行处理</p>\n<p><code>cv2.medianBlur()</code></p>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/my-love-is-python/p/10391923.html\" target=\"_blank\" rel=\"noopener\">机器学习进阶-阈值与平滑-图像平滑操作(去噪操作) </a></p>\n<p><a href=\"https://blog.csdn.net/qq_16949707/article/details/70340090\" target=\"_blank\" rel=\"noopener\">3 opencv平滑边缘锯齿代码</a></p>\n</blockquote>\n<h2 id=\"CV-bridge\"><a href=\"#CV-bridge\" class=\"headerlink\" title=\"CV_bridge\"></a>CV_bridge</h2><p>和ROS相关的OpenCV使用</p>\n<h2 id=\"车道线识别\"><a href=\"#车道线识别\" class=\"headerlink\" title=\"车道线识别\"></a>车道线识别</h2><blockquote>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/gavinmiaoc/article/details/88786229\" target=\"_blank\" rel=\"noopener\">无人驾驶之车道线检测（一）</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/52623916\" target=\"_blank\" rel=\"noopener\">无人驾驶技术入门（十四）| 初识图像之初级车道线检测</a></p>\n</blockquote>\n<h3 id=\"关于图片中的车道识别\"><a href=\"#关于图片中的车道识别\" class=\"headerlink\" title=\"关于图片中的车道识别\"></a>关于图片中的车道识别</h3><p>（1）可以首先进行灰度处理</p>\n<p>（2）然后进行边缘提取，突出车道线</p>\n<ul>\n<li>方法：Canny算法和Sobel算法</li>\n</ul>\n<p>（3）感兴趣区域选择（Region of Interest）</p>\n<ul>\n<li>截取</li>\n<li>似乎直接选择了一个三角形区域</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200902214326070.png\" alt=\"image-20200902214326070\"></p>\n<p>（4）经典霍夫变换，将左右车道线从复杂的图像中提取出来</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/yuyuntan/article/details/80141392\" target=\"_blank\" rel=\"noopener\">经典霍夫变换</a></p>\n</blockquote>\n<p>图像中使用霍夫变换</p>\n<ul>\n<li><p>识别直线；<code>cv2.HoughLines()</code>，可以检测不同长度的线段</p>\n</li>\n<li><p>还可以识别圆、椭圆等图形</p>\n</li>\n</ul>\n<p>（5）数据后处理</p>\n<p>计算左右车道线的直线方程</p>\n<ul>\n<li>根据每个线段在图像坐标系下的斜率，判断为左车道线还是优车道线</li>\n<li>最小二乘拟合</li>\n</ul>\n<p>计算左右车道线的上下边界</p>\n<ul>\n<li>现实世界中左右车道线平行 =》 认为左右车道线<strong>最上和最下的点</strong>对应的y值，就是左右车道线的边界</li>\n</ul>\n<p>（6）处理视频</p>\n<p>也就是把视频变成一帧帧图像，然后进行处理</p>\n<blockquote>\n<p>参考：[无人驾驶技术入门（十五）| 再识图像之高级车道线检测](</p>\n</blockquote>"},{"title":"华为云无人车参赛笔记一","date":"2020-09-27T12:59:40.000Z","_content":"\n2020年华为无人车比赛，起始于6月底，至8月20日角逐出40支队伍参加半决赛，9月24日角逐出20支队伍参加决赛，26日最终决赛。有幸走到决赛现场，但是没有取得理想成绩，在此整理参赛笔记，希望来年一战！\n\n## 分工\n\n为了实现无人车的运行，本次赛事中本小组分为机器视觉（负责modelarts和hilens）、车道线识别、激光雷达等三个部分，本人负责车道线识别部分。\n\n<!--more-->\n\n## 车道线的识别\n\n### 技术点\n\n使用OpenCV进行视觉识别\n\n排除斑马线的干扰\n\n根据识别的车道线计算斜率，控制小车转向角度\n\n### 主要技术方法\n\n首先对图片进行处理：\n\n转为灰度图 =》 转为二值图像 =》 计算一些最大值，确定两侧车道线的位置\n\n使用直方图（histogram）方法，主要函数来自OpenCV包。\n\n```mermaid\ngraph TD\nimg1(gray_img) -- erode --> img2(gray_img)\nimg2 --> img3(origin_thr)\nimg3 -- warpPerspective --> array1(binary_warped)\narray1 --> x1[histogram_x]\narray1 --> x2[histogram_y]\nx1 --> lane_base\nx2 --> l(lower)\nx2 --> r(upper)\nl --> ratio(hist_sum_y_ratio)\nr --> ratio\n```\n\n然后将窗口分割，从下而上计算车道线所在位置，并计算车道线的斜率。\n\n车道线斜率的计算主要使用的是纯几何跟踪的方法。\n\n## 难点一：斑马线\n\n由于车道线识别的过程中主要是对图像中的白色像素进行判断，斑马线对车道线的识别有一定的影响。\n\n如果检测到斑马线呢？看宽度是不是太宽吗？\n\n- 当宽度比较宽的时候，可能就是到了斑马线区域\n- 也有可能是一些反光区域\n- 这个时候，首先需要保持之前的角度变换值不要随意改变\n- 另外，降低反光，以及取右侧边缘进行检测\n\n如果车道线横在了屏幕中间？这个首先需要避免车道线通过了视野的中间吧\n\n应该将车辆的姿态信息和车道线的信息充分融合进行判断\n\n> 参考：[python+opencv车道线检测（简易实现）](https://www.pythonheidong.com/blog/article/324414/)\n>\n> 我觉得这里面给的思路不错，就是看白色像素点所占的比例，来判断是不是斑马线\n>\n> 然后关于车道线直接绘制、mask掩块也有介绍，可以简单看一看\n>\n> [OpenCV检测斑马线](https://blog.csdn.net/dawn1227/article/details/64125542)\n\n**问题：白色像素点的占比：**\n\n首先二值区域的像素点以及找出来了\n\nnonzero的大小也是有的\n\n**那么下来就看一下斑马线处nonzero的值是不是过分偏大？**\n\n然后通过这个方法增加一个阈值\n\n但是似乎并不是真的偏大\n\npython 获取列表中的最大值：`max(list)`即可返回列表list中的最大值\n\n通过最大值判断右边界，仍然不完整，因为有可能右侧出现漏光等现象，那么这些白色像素点就是多余的，而不是所需要的了\n\n==通过直接检测白色像素点的最大值，需要保证没有任何干扰，需要保证滤波效果==\n\n对他们进行规避：\n\n- 非全局采样\n- 这些点是不是集中在某个角落，考虑进行分离\n  - 例如可以使用黑色遮盖\n  - 或者使用**霍夫变换**进行**识别后分割**\n\n**突然想到一个问题，我确实可能没有办法识别弯道，但是我可以识别直线的车道线，然后把它盖住**\n\n新方法：使用霍夫变换检测直的车道线，并将其遮盖\n\n> [简易车道线识别（图像与计算机视觉）](https://www.jianshu.com/p/15e3f9d8c121)\n>\n> 本文思路：\n>\n> 1. 获取图像\n> 2. 调整大小\n> 3. MySetting类：初始化\n>    1. 做了一些画图错做\n>    2. 高斯滤波\n>    3. Canny边缘检测\n>    4. roi区域\n>    5. open和close\n>    6. huogh检测\n> 4. 找出左右车道线，霍夫变换确定直线的斜率，确定直线，画图\n>\n> 比较感兴趣的是ROI区域的选择，很有意思\n>\n> `ROI_Based_Edge_Filtering()`\n>\n> 膨胀和腐蚀基本上是一样的\n\n### 霍夫变换\n\n**检测直线：**\n\n这个霍夫变换有点意思，就是过每个点的直线的斜率和截距构成一个二维区域，如果某些点的区域刚好重合在这个点，那么这些点就在该点的斜率和截距所代表的直线上\n\n**检测圆：**\n\n三点可以确定一个圆\n\n以这三点做所有半径的圆则必有一个公共交点，这个交点就是 以此三点为圆的圆心\n\n霍夫圆检测对噪声比较敏感，首先要对图像做中值滤波\n\n#### 步骤\n\n（1）**使用霍夫检测对整体进行了检测**\n\n输出了画有结果直线的图像，但问题是得出的所需要的线不足，尤其是边缘检测出来的线据称情况过于严重\n\n**（2）调整霍夫检测的参数，增加中值滤波**\n\n通过调试，首先找出斑马线上独特的点：\n\n![image-20200912212448690](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200912212448690.png)\n\n这里我专门取了斜率为负值的点，从而将他们画出来\n\n横向斑马线以 -1 为主要斜率\n\n纵向斑马线的斜率也都主要是 1，这没有办法使用\n\n![image-20200912215910447](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200912215910447.png)\n\n但是还有一点问题：\n\n1. 离群点或者直线的剔除\n2. 横向线好判断，但是竖向的线不好判断\n\n**（3）然后找这些点的包络点**\n\n找四个点：\n\nx 最大的 - 右上角\n\nx 最小的 - 左下角\n\n~~**y 最大的 - 右下角 - 这个点可以不要，直接按上面的线向下覆盖到最低端**~~\n\ny 最小的 - 左上角\n\n注意离的太远的不能要！就是右下角那里\n\n然后把包络点区域内全部涂黑\n\n问题是：\n\n- 怎么样找到所需的点？\n\nnp.array 类型的变量 - lines没有index方法， list有index方法\n\nnp.array类型的变量应该使用where方法\n\n> 参考：[找出numpy array数组的最值及其索引](https://www.cnblogs.com/nxf-rabbit75/p/10073916.html)\n>\n> [查找列表中某个值的位置（python）](https://blog.csdn.net/lcl497049972/article/details/89386293)\n>\n> [使用python中的max函数找到最大值](https://www.runoob.com/python/func-number-max.html)\n\n- 离群点的去除\n\n可能需要加大阈值，但是说真的没有看到阈值的效果\n\n**最后使用的方法**\n\n- 将所有检测出的特征点的x和y坐标分别放入列表\n- 然后按照所需寻找想要的点\n- 最后根据找出的点进行画图\n\n**问题是感觉计算量一下子大了很多**\n\n比较明显的区域：\n\n直接可以把斑马线去除，但是这个地方其实不是很影响\n\n![image-20200913154825876](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913154825876.png)\n\n真正比较有影响的是出斑马线的部分，遮盖有效果\n\n![image-20200913160049787](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913160049787.png)\n\n原图 =》 binary_wraped =》 canny边缘检测 =》 霍夫直线检测 =》 黑色覆盖斑马线区域\n\n![image-20200913162727339](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/斑马线覆盖.png)\n\n![image-20200913162918804](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913162918804.png)\n\n**接下来，调整霍夫变换，避免边缘点的检测**\n\n> 本质问题上，车道线的目标是提速，能够提升速度的情况下，仍然能够流畅地运行\n\n## 难点二：IMU的使用\n\nIMU - 惯性测量单元\n\n测量物体三轴姿态角（或角速率）以及加速度的装置，一般来说，IMU安装在被测物体的重心上，用字啊需要进行运动控制的设备上，也用在需要用姿态进行精密位移推算的场合\n\n在串口节点中发布的有关超声波和IMU消息的主题：\n\n类型都是 int32 的类型，但是单位也各有不同\n\n| 话题                        | 意义         | 单位          |\n| --------------------------- | ------------ | ------------- |\n| /vcu/ActualMotorSpeed       | 实际电机转速 | 转/s          |\n| /vcu/ActualVechileMode      | 实际挡位信号 |               |\n| /vcu/ActualVechileDirection | 实际方向     |               |\n| /vcu/SupersonicDistance     | 超声波距离   | mm            |\n| /vcu/aX                     | IMU加速度X   | g 重力加速度  |\n| /vcu/aY                     | IMU加速度Y   | 重力加速度    |\n| /vcu/aZ                     | IMU加速度Z   | 重力加速度    |\n| /vcu/alphaX                 | IMU角速度X   | 度/秒         |\n| /vcu/alphaY                 | IMU角速度Y   | 度/秒         |\n| /vcu/alphaZ                 | IMU角速度Z   | 度/秒         |\n| /vcu/BX                     | IMU磁场X     | mGS（毫高斯） |\n| /vcu/BY                     | IMU磁场Y     | mGS           |\n| /vcu/BZ                     | IMU磁场Z     | mGS           |\n| /vcu/thetaX                 | IMU角度X     | 度            |\n| /vcu/thetaY                 | IMU角度Y     | 度            |\n| /vcu/thetaZ                 | IMU角度Z     | 度            |\n| /vcu/batteryVoltage         | 电池电压     | V             |\n| /vcu/motorTemperature       | 电机温度     | 摄氏度        |\n\n> 参考：\n>\n> [移动机器人轮式里程计](https://blog.csdn.net/u013468614/article/details/106724804?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-16-106724804.nonecase&utm_term=imu%E9%87%8C%E7%A8%8B%E8%AE%A1)\n>\n> [里程计航迹推演与IMU预积分](https://blog.csdn.net/hzwwpgmwy/article/details/85086393?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-85086393.nonecase&utm_term=imu%E9%87%8C%E7%A8%8B%E8%AE%A1)\n>\n> [IMU与里程计融合](https://blog.csdn.net/baimei4833953/article/details/80768762)\n>\n> [从零手写VIO——（三）基于优化的 IMU 与视觉信息融合（下篇）](https://zhuanlan.zhihu.com/p/164778891)\n>\n> VIO相关知识","source":"_posts/华为云无人车参赛笔记一.md","raw":"---\ntitle: 华为云无人车参赛笔记一\ndate: 2020-09-27 20:59:40\ncategories:\n\t- 机器视觉\ntags:\n\t- 华为云无人车\t\n\t- OpenCV\n---\n\n2020年华为无人车比赛，起始于6月底，至8月20日角逐出40支队伍参加半决赛，9月24日角逐出20支队伍参加决赛，26日最终决赛。有幸走到决赛现场，但是没有取得理想成绩，在此整理参赛笔记，希望来年一战！\n\n## 分工\n\n为了实现无人车的运行，本次赛事中本小组分为机器视觉（负责modelarts和hilens）、车道线识别、激光雷达等三个部分，本人负责车道线识别部分。\n\n<!--more-->\n\n## 车道线的识别\n\n### 技术点\n\n使用OpenCV进行视觉识别\n\n排除斑马线的干扰\n\n根据识别的车道线计算斜率，控制小车转向角度\n\n### 主要技术方法\n\n首先对图片进行处理：\n\n转为灰度图 =》 转为二值图像 =》 计算一些最大值，确定两侧车道线的位置\n\n使用直方图（histogram）方法，主要函数来自OpenCV包。\n\n```mermaid\ngraph TD\nimg1(gray_img) -- erode --> img2(gray_img)\nimg2 --> img3(origin_thr)\nimg3 -- warpPerspective --> array1(binary_warped)\narray1 --> x1[histogram_x]\narray1 --> x2[histogram_y]\nx1 --> lane_base\nx2 --> l(lower)\nx2 --> r(upper)\nl --> ratio(hist_sum_y_ratio)\nr --> ratio\n```\n\n然后将窗口分割，从下而上计算车道线所在位置，并计算车道线的斜率。\n\n车道线斜率的计算主要使用的是纯几何跟踪的方法。\n\n## 难点一：斑马线\n\n由于车道线识别的过程中主要是对图像中的白色像素进行判断，斑马线对车道线的识别有一定的影响。\n\n如果检测到斑马线呢？看宽度是不是太宽吗？\n\n- 当宽度比较宽的时候，可能就是到了斑马线区域\n- 也有可能是一些反光区域\n- 这个时候，首先需要保持之前的角度变换值不要随意改变\n- 另外，降低反光，以及取右侧边缘进行检测\n\n如果车道线横在了屏幕中间？这个首先需要避免车道线通过了视野的中间吧\n\n应该将车辆的姿态信息和车道线的信息充分融合进行判断\n\n> 参考：[python+opencv车道线检测（简易实现）](https://www.pythonheidong.com/blog/article/324414/)\n>\n> 我觉得这里面给的思路不错，就是看白色像素点所占的比例，来判断是不是斑马线\n>\n> 然后关于车道线直接绘制、mask掩块也有介绍，可以简单看一看\n>\n> [OpenCV检测斑马线](https://blog.csdn.net/dawn1227/article/details/64125542)\n\n**问题：白色像素点的占比：**\n\n首先二值区域的像素点以及找出来了\n\nnonzero的大小也是有的\n\n**那么下来就看一下斑马线处nonzero的值是不是过分偏大？**\n\n然后通过这个方法增加一个阈值\n\n但是似乎并不是真的偏大\n\npython 获取列表中的最大值：`max(list)`即可返回列表list中的最大值\n\n通过最大值判断右边界，仍然不完整，因为有可能右侧出现漏光等现象，那么这些白色像素点就是多余的，而不是所需要的了\n\n==通过直接检测白色像素点的最大值，需要保证没有任何干扰，需要保证滤波效果==\n\n对他们进行规避：\n\n- 非全局采样\n- 这些点是不是集中在某个角落，考虑进行分离\n  - 例如可以使用黑色遮盖\n  - 或者使用**霍夫变换**进行**识别后分割**\n\n**突然想到一个问题，我确实可能没有办法识别弯道，但是我可以识别直线的车道线，然后把它盖住**\n\n新方法：使用霍夫变换检测直的车道线，并将其遮盖\n\n> [简易车道线识别（图像与计算机视觉）](https://www.jianshu.com/p/15e3f9d8c121)\n>\n> 本文思路：\n>\n> 1. 获取图像\n> 2. 调整大小\n> 3. MySetting类：初始化\n>    1. 做了一些画图错做\n>    2. 高斯滤波\n>    3. Canny边缘检测\n>    4. roi区域\n>    5. open和close\n>    6. huogh检测\n> 4. 找出左右车道线，霍夫变换确定直线的斜率，确定直线，画图\n>\n> 比较感兴趣的是ROI区域的选择，很有意思\n>\n> `ROI_Based_Edge_Filtering()`\n>\n> 膨胀和腐蚀基本上是一样的\n\n### 霍夫变换\n\n**检测直线：**\n\n这个霍夫变换有点意思，就是过每个点的直线的斜率和截距构成一个二维区域，如果某些点的区域刚好重合在这个点，那么这些点就在该点的斜率和截距所代表的直线上\n\n**检测圆：**\n\n三点可以确定一个圆\n\n以这三点做所有半径的圆则必有一个公共交点，这个交点就是 以此三点为圆的圆心\n\n霍夫圆检测对噪声比较敏感，首先要对图像做中值滤波\n\n#### 步骤\n\n（1）**使用霍夫检测对整体进行了检测**\n\n输出了画有结果直线的图像，但问题是得出的所需要的线不足，尤其是边缘检测出来的线据称情况过于严重\n\n**（2）调整霍夫检测的参数，增加中值滤波**\n\n通过调试，首先找出斑马线上独特的点：\n\n![image-20200912212448690](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200912212448690.png)\n\n这里我专门取了斜率为负值的点，从而将他们画出来\n\n横向斑马线以 -1 为主要斜率\n\n纵向斑马线的斜率也都主要是 1，这没有办法使用\n\n![image-20200912215910447](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200912215910447.png)\n\n但是还有一点问题：\n\n1. 离群点或者直线的剔除\n2. 横向线好判断，但是竖向的线不好判断\n\n**（3）然后找这些点的包络点**\n\n找四个点：\n\nx 最大的 - 右上角\n\nx 最小的 - 左下角\n\n~~**y 最大的 - 右下角 - 这个点可以不要，直接按上面的线向下覆盖到最低端**~~\n\ny 最小的 - 左上角\n\n注意离的太远的不能要！就是右下角那里\n\n然后把包络点区域内全部涂黑\n\n问题是：\n\n- 怎么样找到所需的点？\n\nnp.array 类型的变量 - lines没有index方法， list有index方法\n\nnp.array类型的变量应该使用where方法\n\n> 参考：[找出numpy array数组的最值及其索引](https://www.cnblogs.com/nxf-rabbit75/p/10073916.html)\n>\n> [查找列表中某个值的位置（python）](https://blog.csdn.net/lcl497049972/article/details/89386293)\n>\n> [使用python中的max函数找到最大值](https://www.runoob.com/python/func-number-max.html)\n\n- 离群点的去除\n\n可能需要加大阈值，但是说真的没有看到阈值的效果\n\n**最后使用的方法**\n\n- 将所有检测出的特征点的x和y坐标分别放入列表\n- 然后按照所需寻找想要的点\n- 最后根据找出的点进行画图\n\n**问题是感觉计算量一下子大了很多**\n\n比较明显的区域：\n\n直接可以把斑马线去除，但是这个地方其实不是很影响\n\n![image-20200913154825876](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913154825876.png)\n\n真正比较有影响的是出斑马线的部分，遮盖有效果\n\n![image-20200913160049787](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913160049787.png)\n\n原图 =》 binary_wraped =》 canny边缘检测 =》 霍夫直线检测 =》 黑色覆盖斑马线区域\n\n![image-20200913162727339](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/斑马线覆盖.png)\n\n![image-20200913162918804](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913162918804.png)\n\n**接下来，调整霍夫变换，避免边缘点的检测**\n\n> 本质问题上，车道线的目标是提速，能够提升速度的情况下，仍然能够流畅地运行\n\n## 难点二：IMU的使用\n\nIMU - 惯性测量单元\n\n测量物体三轴姿态角（或角速率）以及加速度的装置，一般来说，IMU安装在被测物体的重心上，用字啊需要进行运动控制的设备上，也用在需要用姿态进行精密位移推算的场合\n\n在串口节点中发布的有关超声波和IMU消息的主题：\n\n类型都是 int32 的类型，但是单位也各有不同\n\n| 话题                        | 意义         | 单位          |\n| --------------------------- | ------------ | ------------- |\n| /vcu/ActualMotorSpeed       | 实际电机转速 | 转/s          |\n| /vcu/ActualVechileMode      | 实际挡位信号 |               |\n| /vcu/ActualVechileDirection | 实际方向     |               |\n| /vcu/SupersonicDistance     | 超声波距离   | mm            |\n| /vcu/aX                     | IMU加速度X   | g 重力加速度  |\n| /vcu/aY                     | IMU加速度Y   | 重力加速度    |\n| /vcu/aZ                     | IMU加速度Z   | 重力加速度    |\n| /vcu/alphaX                 | IMU角速度X   | 度/秒         |\n| /vcu/alphaY                 | IMU角速度Y   | 度/秒         |\n| /vcu/alphaZ                 | IMU角速度Z   | 度/秒         |\n| /vcu/BX                     | IMU磁场X     | mGS（毫高斯） |\n| /vcu/BY                     | IMU磁场Y     | mGS           |\n| /vcu/BZ                     | IMU磁场Z     | mGS           |\n| /vcu/thetaX                 | IMU角度X     | 度            |\n| /vcu/thetaY                 | IMU角度Y     | 度            |\n| /vcu/thetaZ                 | IMU角度Z     | 度            |\n| /vcu/batteryVoltage         | 电池电压     | V             |\n| /vcu/motorTemperature       | 电机温度     | 摄氏度        |\n\n> 参考：\n>\n> [移动机器人轮式里程计](https://blog.csdn.net/u013468614/article/details/106724804?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-16-106724804.nonecase&utm_term=imu%E9%87%8C%E7%A8%8B%E8%AE%A1)\n>\n> [里程计航迹推演与IMU预积分](https://blog.csdn.net/hzwwpgmwy/article/details/85086393?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-85086393.nonecase&utm_term=imu%E9%87%8C%E7%A8%8B%E8%AE%A1)\n>\n> [IMU与里程计融合](https://blog.csdn.net/baimei4833953/article/details/80768762)\n>\n> [从零手写VIO——（三）基于优化的 IMU 与视觉信息融合（下篇）](https://zhuanlan.zhihu.com/p/164778891)\n>\n> VIO相关知识","slug":"华为云无人车参赛笔记一","published":1,"updated":"2021-01-26T06:22:49.821Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n893003fk8tl4jyn7loi","content":"<p>2020年华为无人车比赛，起始于6月底，至8月20日角逐出40支队伍参加半决赛，9月24日角逐出20支队伍参加决赛，26日最终决赛。有幸走到决赛现场，但是没有取得理想成绩，在此整理参赛笔记，希望来年一战！</p>\n<h2 id=\"分工\"><a href=\"#分工\" class=\"headerlink\" title=\"分工\"></a>分工</h2><p>为了实现无人车的运行，本次赛事中本小组分为机器视觉（负责modelarts和hilens）、车道线识别、激光雷达等三个部分，本人负责车道线识别部分。</p>\n<a id=\"more\"></a>\n<h2 id=\"车道线的识别\"><a href=\"#车道线的识别\" class=\"headerlink\" title=\"车道线的识别\"></a>车道线的识别</h2><h3 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点\"></a>技术点</h3><p>使用OpenCV进行视觉识别</p>\n<p>排除斑马线的干扰</p>\n<p>根据识别的车道线计算斜率，控制小车转向角度</p>\n<h3 id=\"主要技术方法\"><a href=\"#主要技术方法\" class=\"headerlink\" title=\"主要技术方法\"></a>主要技术方法</h3><p>首先对图片进行处理：</p>\n<p>转为灰度图 =》 转为二值图像 =》 计算一些最大值，确定两侧车道线的位置</p>\n<p>使用直方图（histogram）方法，主要函数来自OpenCV包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">img1(gray_img) -- erode --&gt; img2(gray_img)</span><br><span class=\"line\">img2 --&gt; img3(origin_thr)</span><br><span class=\"line\">img3 -- warpPerspective --&gt; array1(binary_warped)</span><br><span class=\"line\">array1 --&gt; x1[histogram_x]</span><br><span class=\"line\">array1 --&gt; x2[histogram_y]</span><br><span class=\"line\">x1 --&gt; lane_base</span><br><span class=\"line\">x2 --&gt; l(lower)</span><br><span class=\"line\">x2 --&gt; r(upper)</span><br><span class=\"line\">l --&gt; ratio(hist_sum_y_ratio)</span><br><span class=\"line\">r --&gt; ratio</span><br></pre></td></tr></table></figure>\n<p>然后将窗口分割，从下而上计算车道线所在位置，并计算车道线的斜率。</p>\n<p>车道线斜率的计算主要使用的是纯几何跟踪的方法。</p>\n<h2 id=\"难点一：斑马线\"><a href=\"#难点一：斑马线\" class=\"headerlink\" title=\"难点一：斑马线\"></a>难点一：斑马线</h2><p>由于车道线识别的过程中主要是对图像中的白色像素进行判断，斑马线对车道线的识别有一定的影响。</p>\n<p>如果检测到斑马线呢？看宽度是不是太宽吗？</p>\n<ul>\n<li>当宽度比较宽的时候，可能就是到了斑马线区域</li>\n<li>也有可能是一些反光区域</li>\n<li>这个时候，首先需要保持之前的角度变换值不要随意改变</li>\n<li>另外，降低反光，以及取右侧边缘进行检测</li>\n</ul>\n<p>如果车道线横在了屏幕中间？这个首先需要避免车道线通过了视野的中间吧</p>\n<p>应该将车辆的姿态信息和车道线的信息充分融合进行判断</p>\n<blockquote>\n<p>参考：<a href=\"https://www.pythonheidong.com/blog/article/324414/\" target=\"_blank\" rel=\"noopener\">python+opencv车道线检测（简易实现）</a></p>\n<p>我觉得这里面给的思路不错，就是看白色像素点所占的比例，来判断是不是斑马线</p>\n<p>然后关于车道线直接绘制、mask掩块也有介绍，可以简单看一看</p>\n<p><a href=\"https://blog.csdn.net/dawn1227/article/details/64125542\" target=\"_blank\" rel=\"noopener\">OpenCV检测斑马线</a></p>\n</blockquote>\n<p><strong>问题：白色像素点的占比：</strong></p>\n<p>首先二值区域的像素点以及找出来了</p>\n<p>nonzero的大小也是有的</p>\n<p><strong>那么下来就看一下斑马线处nonzero的值是不是过分偏大？</strong></p>\n<p>然后通过这个方法增加一个阈值</p>\n<p>但是似乎并不是真的偏大</p>\n<p>python 获取列表中的最大值：<code>max(list)</code>即可返回列表list中的最大值</p>\n<p>通过最大值判断右边界，仍然不完整，因为有可能右侧出现漏光等现象，那么这些白色像素点就是多余的，而不是所需要的了</p>\n<p>==通过直接检测白色像素点的最大值，需要保证没有任何干扰，需要保证滤波效果==</p>\n<p>对他们进行规避：</p>\n<ul>\n<li>非全局采样</li>\n<li>这些点是不是集中在某个角落，考虑进行分离<ul>\n<li>例如可以使用黑色遮盖</li>\n<li>或者使用<strong>霍夫变换</strong>进行<strong>识别后分割</strong></li>\n</ul>\n</li>\n</ul>\n<p><strong>突然想到一个问题，我确实可能没有办法识别弯道，但是我可以识别直线的车道线，然后把它盖住</strong></p>\n<p>新方法：使用霍夫变换检测直的车道线，并将其遮盖</p>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/15e3f9d8c121\" target=\"_blank\" rel=\"noopener\">简易车道线识别（图像与计算机视觉）</a></p>\n<p>本文思路：</p>\n<ol>\n<li>获取图像</li>\n<li>调整大小</li>\n<li>MySetting类：初始化<ol>\n<li>做了一些画图错做</li>\n<li>高斯滤波</li>\n<li>Canny边缘检测</li>\n<li>roi区域</li>\n<li>open和close</li>\n<li>huogh检测</li>\n</ol>\n</li>\n<li>找出左右车道线，霍夫变换确定直线的斜率，确定直线，画图</li>\n</ol>\n<p>比较感兴趣的是ROI区域的选择，很有意思</p>\n<p><code>ROI_Based_Edge_Filtering()</code></p>\n<p>膨胀和腐蚀基本上是一样的</p>\n</blockquote>\n<h3 id=\"霍夫变换\"><a href=\"#霍夫变换\" class=\"headerlink\" title=\"霍夫变换\"></a>霍夫变换</h3><p><strong>检测直线：</strong></p>\n<p>这个霍夫变换有点意思，就是过每个点的直线的斜率和截距构成一个二维区域，如果某些点的区域刚好重合在这个点，那么这些点就在该点的斜率和截距所代表的直线上</p>\n<p><strong>检测圆：</strong></p>\n<p>三点可以确定一个圆</p>\n<p>以这三点做所有半径的圆则必有一个公共交点，这个交点就是 以此三点为圆的圆心</p>\n<p>霍夫圆检测对噪声比较敏感，首先要对图像做中值滤波</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>（1）<strong>使用霍夫检测对整体进行了检测</strong></p>\n<p>输出了画有结果直线的图像，但问题是得出的所需要的线不足，尤其是边缘检测出来的线据称情况过于严重</p>\n<p><strong>（2）调整霍夫检测的参数，增加中值滤波</strong></p>\n<p>通过调试，首先找出斑马线上独特的点：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200912212448690.png\" alt=\"image-20200912212448690\"></p>\n<p>这里我专门取了斜率为负值的点，从而将他们画出来</p>\n<p>横向斑马线以 -1 为主要斜率</p>\n<p>纵向斑马线的斜率也都主要是 1，这没有办法使用</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200912215910447.png\" alt=\"image-20200912215910447\"></p>\n<p>但是还有一点问题：</p>\n<ol>\n<li>离群点或者直线的剔除</li>\n<li>横向线好判断，但是竖向的线不好判断</li>\n</ol>\n<p><strong>（3）然后找这些点的包络点</strong></p>\n<p>找四个点：</p>\n<p>x 最大的 - 右上角</p>\n<p>x 最小的 - 左下角</p>\n<p><del><strong>y 最大的 - 右下角 - 这个点可以不要，直接按上面的线向下覆盖到最低端</strong></del></p>\n<p>y 最小的 - 左上角</p>\n<p>注意离的太远的不能要！就是右下角那里</p>\n<p>然后把包络点区域内全部涂黑</p>\n<p>问题是：</p>\n<ul>\n<li>怎么样找到所需的点？</li>\n</ul>\n<p>np.array 类型的变量 - lines没有index方法， list有index方法</p>\n<p>np.array类型的变量应该使用where方法</p>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/nxf-rabbit75/p/10073916.html\" target=\"_blank\" rel=\"noopener\">找出numpy array数组的最值及其索引</a></p>\n<p><a href=\"https://blog.csdn.net/lcl497049972/article/details/89386293\" target=\"_blank\" rel=\"noopener\">查找列表中某个值的位置（python）</a></p>\n<p><a href=\"https://www.runoob.com/python/func-number-max.html\" target=\"_blank\" rel=\"noopener\">使用python中的max函数找到最大值</a></p>\n</blockquote>\n<ul>\n<li>离群点的去除</li>\n</ul>\n<p>可能需要加大阈值，但是说真的没有看到阈值的效果</p>\n<p><strong>最后使用的方法</strong></p>\n<ul>\n<li>将所有检测出的特征点的x和y坐标分别放入列表</li>\n<li>然后按照所需寻找想要的点</li>\n<li>最后根据找出的点进行画图</li>\n</ul>\n<p><strong>问题是感觉计算量一下子大了很多</strong></p>\n<p>比较明显的区域：</p>\n<p>直接可以把斑马线去除，但是这个地方其实不是很影响</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913154825876.png\" alt=\"image-20200913154825876\"></p>\n<p>真正比较有影响的是出斑马线的部分，遮盖有效果</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913160049787.png\" alt=\"image-20200913160049787\"></p>\n<p>原图 =》 binary_wraped =》 canny边缘检测 =》 霍夫直线检测 =》 黑色覆盖斑马线区域</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/斑马线覆盖.png\" alt=\"image-20200913162727339\"></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913162918804.png\" alt=\"image-20200913162918804\"></p>\n<p><strong>接下来，调整霍夫变换，避免边缘点的检测</strong></p>\n<blockquote>\n<p>本质问题上，车道线的目标是提速，能够提升速度的情况下，仍然能够流畅地运行</p>\n</blockquote>\n<h2 id=\"难点二：IMU的使用\"><a href=\"#难点二：IMU的使用\" class=\"headerlink\" title=\"难点二：IMU的使用\"></a>难点二：IMU的使用</h2><p>IMU - 惯性测量单元</p>\n<p>测量物体三轴姿态角（或角速率）以及加速度的装置，一般来说，IMU安装在被测物体的重心上，用字啊需要进行运动控制的设备上，也用在需要用姿态进行精密位移推算的场合</p>\n<p>在串口节点中发布的有关超声波和IMU消息的主题：</p>\n<p>类型都是 int32 的类型，但是单位也各有不同</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>话题</th>\n<th>意义</th>\n<th>单位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/vcu/ActualMotorSpeed</td>\n<td>实际电机转速</td>\n<td>转/s</td>\n</tr>\n<tr>\n<td>/vcu/ActualVechileMode</td>\n<td>实际挡位信号</td>\n<td></td>\n</tr>\n<tr>\n<td>/vcu/ActualVechileDirection</td>\n<td>实际方向</td>\n<td></td>\n</tr>\n<tr>\n<td>/vcu/SupersonicDistance</td>\n<td>超声波距离</td>\n<td>mm</td>\n</tr>\n<tr>\n<td>/vcu/aX</td>\n<td>IMU加速度X</td>\n<td>g 重力加速度</td>\n</tr>\n<tr>\n<td>/vcu/aY</td>\n<td>IMU加速度Y</td>\n<td>重力加速度</td>\n</tr>\n<tr>\n<td>/vcu/aZ</td>\n<td>IMU加速度Z</td>\n<td>重力加速度</td>\n</tr>\n<tr>\n<td>/vcu/alphaX</td>\n<td>IMU角速度X</td>\n<td>度/秒</td>\n</tr>\n<tr>\n<td>/vcu/alphaY</td>\n<td>IMU角速度Y</td>\n<td>度/秒</td>\n</tr>\n<tr>\n<td>/vcu/alphaZ</td>\n<td>IMU角速度Z</td>\n<td>度/秒</td>\n</tr>\n<tr>\n<td>/vcu/BX</td>\n<td>IMU磁场X</td>\n<td>mGS（毫高斯）</td>\n</tr>\n<tr>\n<td>/vcu/BY</td>\n<td>IMU磁场Y</td>\n<td>mGS</td>\n</tr>\n<tr>\n<td>/vcu/BZ</td>\n<td>IMU磁场Z</td>\n<td>mGS</td>\n</tr>\n<tr>\n<td>/vcu/thetaX</td>\n<td>IMU角度X</td>\n<td>度</td>\n</tr>\n<tr>\n<td>/vcu/thetaY</td>\n<td>IMU角度Y</td>\n<td>度</td>\n</tr>\n<tr>\n<td>/vcu/thetaZ</td>\n<td>IMU角度Z</td>\n<td>度</td>\n</tr>\n<tr>\n<td>/vcu/batteryVoltage</td>\n<td>电池电压</td>\n<td>V</td>\n</tr>\n<tr>\n<td>/vcu/motorTemperature</td>\n<td>电机温度</td>\n<td>摄氏度</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/u013468614/article/details/106724804?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-16-106724804.nonecase&amp;utm_term=imu%E9%87%8C%E7%A8%8B%E8%AE%A1\" target=\"_blank\" rel=\"noopener\">移动机器人轮式里程计</a></p>\n<p><a href=\"https://blog.csdn.net/hzwwpgmwy/article/details/85086393?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-85086393.nonecase&amp;utm_term=imu%E9%87%8C%E7%A8%8B%E8%AE%A1\" target=\"_blank\" rel=\"noopener\">里程计航迹推演与IMU预积分</a></p>\n<p><a href=\"https://blog.csdn.net/baimei4833953/article/details/80768762\" target=\"_blank\" rel=\"noopener\">IMU与里程计融合</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/164778891\" target=\"_blank\" rel=\"noopener\">从零手写VIO——（三）基于优化的 IMU 与视觉信息融合（下篇）</a></p>\n<p>VIO相关知识</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>2020年华为无人车比赛，起始于6月底，至8月20日角逐出40支队伍参加半决赛，9月24日角逐出20支队伍参加决赛，26日最终决赛。有幸走到决赛现场，但是没有取得理想成绩，在此整理参赛笔记，希望来年一战！</p>\n<h2 id=\"分工\"><a href=\"#分工\" class=\"headerlink\" title=\"分工\"></a>分工</h2><p>为了实现无人车的运行，本次赛事中本小组分为机器视觉（负责modelarts和hilens）、车道线识别、激光雷达等三个部分，本人负责车道线识别部分。</p>","more":"<h2 id=\"车道线的识别\"><a href=\"#车道线的识别\" class=\"headerlink\" title=\"车道线的识别\"></a>车道线的识别</h2><h3 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点\"></a>技术点</h3><p>使用OpenCV进行视觉识别</p>\n<p>排除斑马线的干扰</p>\n<p>根据识别的车道线计算斜率，控制小车转向角度</p>\n<h3 id=\"主要技术方法\"><a href=\"#主要技术方法\" class=\"headerlink\" title=\"主要技术方法\"></a>主要技术方法</h3><p>首先对图片进行处理：</p>\n<p>转为灰度图 =》 转为二值图像 =》 计算一些最大值，确定两侧车道线的位置</p>\n<p>使用直方图（histogram）方法，主要函数来自OpenCV包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">img1(gray_img) -- erode --&gt; img2(gray_img)</span><br><span class=\"line\">img2 --&gt; img3(origin_thr)</span><br><span class=\"line\">img3 -- warpPerspective --&gt; array1(binary_warped)</span><br><span class=\"line\">array1 --&gt; x1[histogram_x]</span><br><span class=\"line\">array1 --&gt; x2[histogram_y]</span><br><span class=\"line\">x1 --&gt; lane_base</span><br><span class=\"line\">x2 --&gt; l(lower)</span><br><span class=\"line\">x2 --&gt; r(upper)</span><br><span class=\"line\">l --&gt; ratio(hist_sum_y_ratio)</span><br><span class=\"line\">r --&gt; ratio</span><br></pre></td></tr></table></figure>\n<p>然后将窗口分割，从下而上计算车道线所在位置，并计算车道线的斜率。</p>\n<p>车道线斜率的计算主要使用的是纯几何跟踪的方法。</p>\n<h2 id=\"难点一：斑马线\"><a href=\"#难点一：斑马线\" class=\"headerlink\" title=\"难点一：斑马线\"></a>难点一：斑马线</h2><p>由于车道线识别的过程中主要是对图像中的白色像素进行判断，斑马线对车道线的识别有一定的影响。</p>\n<p>如果检测到斑马线呢？看宽度是不是太宽吗？</p>\n<ul>\n<li>当宽度比较宽的时候，可能就是到了斑马线区域</li>\n<li>也有可能是一些反光区域</li>\n<li>这个时候，首先需要保持之前的角度变换值不要随意改变</li>\n<li>另外，降低反光，以及取右侧边缘进行检测</li>\n</ul>\n<p>如果车道线横在了屏幕中间？这个首先需要避免车道线通过了视野的中间吧</p>\n<p>应该将车辆的姿态信息和车道线的信息充分融合进行判断</p>\n<blockquote>\n<p>参考：<a href=\"https://www.pythonheidong.com/blog/article/324414/\" target=\"_blank\" rel=\"noopener\">python+opencv车道线检测（简易实现）</a></p>\n<p>我觉得这里面给的思路不错，就是看白色像素点所占的比例，来判断是不是斑马线</p>\n<p>然后关于车道线直接绘制、mask掩块也有介绍，可以简单看一看</p>\n<p><a href=\"https://blog.csdn.net/dawn1227/article/details/64125542\" target=\"_blank\" rel=\"noopener\">OpenCV检测斑马线</a></p>\n</blockquote>\n<p><strong>问题：白色像素点的占比：</strong></p>\n<p>首先二值区域的像素点以及找出来了</p>\n<p>nonzero的大小也是有的</p>\n<p><strong>那么下来就看一下斑马线处nonzero的值是不是过分偏大？</strong></p>\n<p>然后通过这个方法增加一个阈值</p>\n<p>但是似乎并不是真的偏大</p>\n<p>python 获取列表中的最大值：<code>max(list)</code>即可返回列表list中的最大值</p>\n<p>通过最大值判断右边界，仍然不完整，因为有可能右侧出现漏光等现象，那么这些白色像素点就是多余的，而不是所需要的了</p>\n<p>==通过直接检测白色像素点的最大值，需要保证没有任何干扰，需要保证滤波效果==</p>\n<p>对他们进行规避：</p>\n<ul>\n<li>非全局采样</li>\n<li>这些点是不是集中在某个角落，考虑进行分离<ul>\n<li>例如可以使用黑色遮盖</li>\n<li>或者使用<strong>霍夫变换</strong>进行<strong>识别后分割</strong></li>\n</ul>\n</li>\n</ul>\n<p><strong>突然想到一个问题，我确实可能没有办法识别弯道，但是我可以识别直线的车道线，然后把它盖住</strong></p>\n<p>新方法：使用霍夫变换检测直的车道线，并将其遮盖</p>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/15e3f9d8c121\" target=\"_blank\" rel=\"noopener\">简易车道线识别（图像与计算机视觉）</a></p>\n<p>本文思路：</p>\n<ol>\n<li>获取图像</li>\n<li>调整大小</li>\n<li>MySetting类：初始化<ol>\n<li>做了一些画图错做</li>\n<li>高斯滤波</li>\n<li>Canny边缘检测</li>\n<li>roi区域</li>\n<li>open和close</li>\n<li>huogh检测</li>\n</ol>\n</li>\n<li>找出左右车道线，霍夫变换确定直线的斜率，确定直线，画图</li>\n</ol>\n<p>比较感兴趣的是ROI区域的选择，很有意思</p>\n<p><code>ROI_Based_Edge_Filtering()</code></p>\n<p>膨胀和腐蚀基本上是一样的</p>\n</blockquote>\n<h3 id=\"霍夫变换\"><a href=\"#霍夫变换\" class=\"headerlink\" title=\"霍夫变换\"></a>霍夫变换</h3><p><strong>检测直线：</strong></p>\n<p>这个霍夫变换有点意思，就是过每个点的直线的斜率和截距构成一个二维区域，如果某些点的区域刚好重合在这个点，那么这些点就在该点的斜率和截距所代表的直线上</p>\n<p><strong>检测圆：</strong></p>\n<p>三点可以确定一个圆</p>\n<p>以这三点做所有半径的圆则必有一个公共交点，这个交点就是 以此三点为圆的圆心</p>\n<p>霍夫圆检测对噪声比较敏感，首先要对图像做中值滤波</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>（1）<strong>使用霍夫检测对整体进行了检测</strong></p>\n<p>输出了画有结果直线的图像，但问题是得出的所需要的线不足，尤其是边缘检测出来的线据称情况过于严重</p>\n<p><strong>（2）调整霍夫检测的参数，增加中值滤波</strong></p>\n<p>通过调试，首先找出斑马线上独特的点：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200912212448690.png\" alt=\"image-20200912212448690\"></p>\n<p>这里我专门取了斜率为负值的点，从而将他们画出来</p>\n<p>横向斑马线以 -1 为主要斜率</p>\n<p>纵向斑马线的斜率也都主要是 1，这没有办法使用</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200912215910447.png\" alt=\"image-20200912215910447\"></p>\n<p>但是还有一点问题：</p>\n<ol>\n<li>离群点或者直线的剔除</li>\n<li>横向线好判断，但是竖向的线不好判断</li>\n</ol>\n<p><strong>（3）然后找这些点的包络点</strong></p>\n<p>找四个点：</p>\n<p>x 最大的 - 右上角</p>\n<p>x 最小的 - 左下角</p>\n<p><del><strong>y 最大的 - 右下角 - 这个点可以不要，直接按上面的线向下覆盖到最低端</strong></del></p>\n<p>y 最小的 - 左上角</p>\n<p>注意离的太远的不能要！就是右下角那里</p>\n<p>然后把包络点区域内全部涂黑</p>\n<p>问题是：</p>\n<ul>\n<li>怎么样找到所需的点？</li>\n</ul>\n<p>np.array 类型的变量 - lines没有index方法， list有index方法</p>\n<p>np.array类型的变量应该使用where方法</p>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/nxf-rabbit75/p/10073916.html\" target=\"_blank\" rel=\"noopener\">找出numpy array数组的最值及其索引</a></p>\n<p><a href=\"https://blog.csdn.net/lcl497049972/article/details/89386293\" target=\"_blank\" rel=\"noopener\">查找列表中某个值的位置（python）</a></p>\n<p><a href=\"https://www.runoob.com/python/func-number-max.html\" target=\"_blank\" rel=\"noopener\">使用python中的max函数找到最大值</a></p>\n</blockquote>\n<ul>\n<li>离群点的去除</li>\n</ul>\n<p>可能需要加大阈值，但是说真的没有看到阈值的效果</p>\n<p><strong>最后使用的方法</strong></p>\n<ul>\n<li>将所有检测出的特征点的x和y坐标分别放入列表</li>\n<li>然后按照所需寻找想要的点</li>\n<li>最后根据找出的点进行画图</li>\n</ul>\n<p><strong>问题是感觉计算量一下子大了很多</strong></p>\n<p>比较明显的区域：</p>\n<p>直接可以把斑马线去除，但是这个地方其实不是很影响</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913154825876.png\" alt=\"image-20200913154825876\"></p>\n<p>真正比较有影响的是出斑马线的部分，遮盖有效果</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913160049787.png\" alt=\"image-20200913160049787\"></p>\n<p>原图 =》 binary_wraped =》 canny边缘检测 =》 霍夫直线检测 =》 黑色覆盖斑马线区域</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/斑马线覆盖.png\" alt=\"image-20200913162727339\"></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200913162918804.png\" alt=\"image-20200913162918804\"></p>\n<p><strong>接下来，调整霍夫变换，避免边缘点的检测</strong></p>\n<blockquote>\n<p>本质问题上，车道线的目标是提速，能够提升速度的情况下，仍然能够流畅地运行</p>\n</blockquote>\n<h2 id=\"难点二：IMU的使用\"><a href=\"#难点二：IMU的使用\" class=\"headerlink\" title=\"难点二：IMU的使用\"></a>难点二：IMU的使用</h2><p>IMU - 惯性测量单元</p>\n<p>测量物体三轴姿态角（或角速率）以及加速度的装置，一般来说，IMU安装在被测物体的重心上，用字啊需要进行运动控制的设备上，也用在需要用姿态进行精密位移推算的场合</p>\n<p>在串口节点中发布的有关超声波和IMU消息的主题：</p>\n<p>类型都是 int32 的类型，但是单位也各有不同</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>话题</th>\n<th>意义</th>\n<th>单位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/vcu/ActualMotorSpeed</td>\n<td>实际电机转速</td>\n<td>转/s</td>\n</tr>\n<tr>\n<td>/vcu/ActualVechileMode</td>\n<td>实际挡位信号</td>\n<td></td>\n</tr>\n<tr>\n<td>/vcu/ActualVechileDirection</td>\n<td>实际方向</td>\n<td></td>\n</tr>\n<tr>\n<td>/vcu/SupersonicDistance</td>\n<td>超声波距离</td>\n<td>mm</td>\n</tr>\n<tr>\n<td>/vcu/aX</td>\n<td>IMU加速度X</td>\n<td>g 重力加速度</td>\n</tr>\n<tr>\n<td>/vcu/aY</td>\n<td>IMU加速度Y</td>\n<td>重力加速度</td>\n</tr>\n<tr>\n<td>/vcu/aZ</td>\n<td>IMU加速度Z</td>\n<td>重力加速度</td>\n</tr>\n<tr>\n<td>/vcu/alphaX</td>\n<td>IMU角速度X</td>\n<td>度/秒</td>\n</tr>\n<tr>\n<td>/vcu/alphaY</td>\n<td>IMU角速度Y</td>\n<td>度/秒</td>\n</tr>\n<tr>\n<td>/vcu/alphaZ</td>\n<td>IMU角速度Z</td>\n<td>度/秒</td>\n</tr>\n<tr>\n<td>/vcu/BX</td>\n<td>IMU磁场X</td>\n<td>mGS（毫高斯）</td>\n</tr>\n<tr>\n<td>/vcu/BY</td>\n<td>IMU磁场Y</td>\n<td>mGS</td>\n</tr>\n<tr>\n<td>/vcu/BZ</td>\n<td>IMU磁场Z</td>\n<td>mGS</td>\n</tr>\n<tr>\n<td>/vcu/thetaX</td>\n<td>IMU角度X</td>\n<td>度</td>\n</tr>\n<tr>\n<td>/vcu/thetaY</td>\n<td>IMU角度Y</td>\n<td>度</td>\n</tr>\n<tr>\n<td>/vcu/thetaZ</td>\n<td>IMU角度Z</td>\n<td>度</td>\n</tr>\n<tr>\n<td>/vcu/batteryVoltage</td>\n<td>电池电压</td>\n<td>V</td>\n</tr>\n<tr>\n<td>/vcu/motorTemperature</td>\n<td>电机温度</td>\n<td>摄氏度</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/u013468614/article/details/106724804?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-16-106724804.nonecase&amp;utm_term=imu%E9%87%8C%E7%A8%8B%E8%AE%A1\" target=\"_blank\" rel=\"noopener\">移动机器人轮式里程计</a></p>\n<p><a href=\"https://blog.csdn.net/hzwwpgmwy/article/details/85086393?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-85086393.nonecase&amp;utm_term=imu%E9%87%8C%E7%A8%8B%E8%AE%A1\" target=\"_blank\" rel=\"noopener\">里程计航迹推演与IMU预积分</a></p>\n<p><a href=\"https://blog.csdn.net/baimei4833953/article/details/80768762\" target=\"_blank\" rel=\"noopener\">IMU与里程计融合</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/164778891\" target=\"_blank\" rel=\"noopener\">从零手写VIO——（三）基于优化的 IMU 与视觉信息融合（下篇）</a></p>\n<p>VIO相关知识</p>\n</blockquote>"},{"title":"华为云无人车参赛笔记二","date":"2020-09-29T01:24:30.000Z","_content":"\n上一篇主要内容是针对本赛事中的重难点进行描述，但是针对实际问题，需要更加细致的调整。\n\n本文记录实际调试过程中遇到的问题和改善方法。\n\n<!--more-->\n\n## 问题记录\n\n### 1. 首先需要调整透视变换视角\n\n主要是画面范围的调整。\n\n由于弯道比较多，真实小车的视线中很少能看到两条线；同时，大概是因为选择透视变换的范围比较小，无法覆盖到需要的图像区域。因此需要对画面进行调整。\n\n**直接用openCV添加直线**\n\n![image-20200903135454484](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200903135454484.png)\n\n> 可能出现的问题：\n>\n> `SystemError: new style getargs format but argument is not a tuple`\n>\n> 这个问题应该关键是数据的类型不太对\n\n效果如图所示，大概明白如下：前面的区域界定，只是计算转换矩阵，然后使用转换矩阵把整个图片进行转换。\n\n所以说，**转换矩阵要谨慎一点**，不是随便怎么转换都可以的。\n\n那么我们应该怎么样转换呢？让比例更加准确一点！\n\n![image-20200904094713780](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200904094713780.png)\n\n这张图应证了我的想法，确实需要**调整好直线道路上的透视变换效果图**。\n\n> 本赛道转弯比较多\n>\n> 按道理来说，按照透视的原理，只要将一个水平的梯形区域转换为一个正常的方形区域就可以了\n>\n> 但是现实是，本赛道弯道多，车身倾角大，导致车的姿态情况不是水平，最好有一点偏角\n>\n> 应该是左低右高的一个区域就比较好\n\n**原始区域：**\n\n变换前：`src_points = np.array([[3,570], [387,460], [906,452], [1041,485]], dtype=\"float32\")`\n\n变换后：`[266., 686.], [266., 19.], [931., 20.], [931., 701.]`\n\n该区域的问题是，没有线的区域会比较多，或者说覆盖的车道区域有点小\n\n从形状上来看倒是很符合左低右高的形状\n\n**区域1：**\n\n变换前：`src_points = np.array([[3,570], [387,460], [1106,472], [1241,520]], dtype=\"float32\")`\n\n![image-20200903151451012](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200903151451012.png)\n\n其实这个区域还不错\n\n对中间的纯黑地带过滤也比较到位\n\n就看实际中的表现如何\n\n> 不对，这个确实应该动态进行调整\n>\n> ==车身姿态影响到了拍摄角度==\n>\n> 左转的时候应该是坐地右高，右转的时候则是要右低左高了，目前这样肯定是不够的\n>\n> 如果按照IMU的数据去调整呢\n\n**区域2**：\n\n变换前：`src_points = np.array([[3,520], [387,470], [1106,472], [1241,520]], dtype=\"float32\")`\n\n我使用opencv将视频转换为图片，然后用matplotlib展示出图片，然后进行分析\n\n![image-20200904205233116](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200904205233116.png)\n\n目前看完了全部代码之后，就很明朗了\n\n就是要不断调整透视变换的比例，从而确保在直线道路上，能够调试出满意的透视变换图像\n\n---\n\n==观察结果：==\n\n按照最后的观察结果来看，右转问题有二：\n\n第一，其视角偏上，那么近一点的区域就会反应过于灵敏\n\n- 这个调整的是转换前的区域大小，以及转换后的区域的大小\n\n第二，如果角度变换的速度太慢，就会没有转到有线的位置，从而丢失车道线画面\n\n- 这里调节角度变换的速度，一个是调整==计算`cmdSteer`的系数k==，基准是 -19，**这个数字是什么意思呢？**\n- 这个数字应该是弯道的斜率，不同的弯这个系数确实是不太一样的\n\n**其实比较好奇，什么样的结果算是改动成功？**\n\n结果就是应该准确快速地转弯成功\n\n### 2. midPoint\n\nmidpoint理论上是视野的中点，但是程序中是 320，这个是有点奇怪的，偏左了一点点\n\n- 回答：程序中有两个midPoint，一个是midPoint_x，这个值是640，已经确定，没有问题\n- 还有一个是midPoint_y，似乎是用以分隔上下部分，这个值目前定的是320，实际上也可以进行调整，主要还是看车道在画面中所占的位置\n\n这个值感觉不是特别需要改动\n\n或者说修改的意义不大\n\n### 3. 视频录制\n\n使用opencv-python录制视频\n\n首先使用的代码参考：[Python-OpenCV视频录制](https://blog.csdn.net/hhaowang/article/details/88236612)\n\n但是这个一点都不好用，录制的视频播放速度极快，丢帧也比较严重了\n\n接下来希望参考：[Python -opencv 录制视频](https://blog.csdn.net/weixin_43635647/article/details/103774559)\n\n这个代码看起来要简洁一点\n\n### 4. 入弯出弯测试\n\n目前来说，右转入弯要么不够迅速，要么会提前（主要还是看视野内的车道线情况）\n\n左转入弯有问题，似乎是机械方面的故障，从信号上来说已经是左转了，但是实际转弯情况却是右转的\n\n目前的参数中：\n\n**转向参数设为 -21**\n\n效果不错，右转弯很合适，左转弯尚有不足\n\n速度调至10很完美，速度调至15稍有不足（主要是左转弯时会打方向比较急、猛）\n\n### 5. 斑马线识别\n\n怎么样将最边上的线识别出来呢？\n\n用了边缘检测，效果尚可，但是怎么样压制其他区域呢？\n\n首先查看了lanebase点的位置，可以看的出来，在这之前的一小段高曝光中，会对lanebase产生一点影响\n\n![image-20200908221446425](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908221446425.png)\n\n![image-20200908222634494](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908222634494.png)\n\n此时lanebase做了什么\n\n![image-20200908222912990](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908222912990.png)\n\n当前使用的解决方法涉及两个参数;\n\n- 白色像素占图像的比例：大于0.083\n- lane_base中心值只要小于900，就会自动加500，保证向左转弯过车道线\n\n> 我认为该问题中的关键是lane_base位置的错误，导致了车道曲线的识别问题\n>\n> 因此我的两种方法：\n>\n> - 根据lanebase的突变情况，使用黑色色块进行掩盖\n> - 根据lanebase的突变情况，对lanebase进行修正\n>   - 其实第二种修正情况，有一定的问题，那就是一刀切全部加了500，这个不是非常合理\n>   - 但是我发现nonzerox的值似乎和我设想的不太一样【nonzerox要配合nonzeroy来同时查看，nonzeroy是从0到720，nonzerox则也是要跟着nonzeroy的像素值进行变化】也不对，不需要直接进行索引，直接求最大值也是可以的\n\n#### 新方法\n\n使用霍夫变换检测斑马线的两侧横线，然后求凸包的顶点，将凸包内的斑马线直接去除，该方法在视觉效果上还是不错的\n\n**测试参数表：**\n\n各参数含义：\n\n- rho：\n- theta：\n- threshold：\n- min_line_length：\n- max_line_gap：\n\n| rho  | theta     | threshold | min_line_length | max_line_gap | 效果                                 |\n| ---- | --------- | --------- | --------------- | ------------ | ------------------------------------ |\n| 1    | np.pi/180 | 30        | 30              | 30           | 出现的线条会很少                     |\n| 1    | np.pi/180 | 50        | 30              | 1            | 出现线条多，很多小线条以点的形式出现 |\n|      |           |           |                 |              |                                      |\n\n\n\n### 6. 滑动平均问题\n\n关于servoNode中的滑动平均值，之前确实没有过多考虑，可能还是希望能就原状进行测试，但是忽略了代码间的相互协调能力\n\n![image-20200910135546937](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200910135546937.png)\n\n这个 n 值的设定主要是起到滑动平均的基数的关系\n\n如果调整n，发布的速度也会比较慢，但是也需要可以起到比较好的光滑的效果（不见得）\n\n需要尝试一下，目前设想的测试顺序如下所示：\n\n| n=   | 1                        | 5                                      | 3    | 10   |\n| ---- | ------------------------ | -------------------------------------- | ---- | ---- |\n|      | 抖动比较明显，但是可过弯 | 抖动降低，但是人行道不易通过，转角过大 |      |      |\n\n\n\n### 7. 整体规划首个思路\n\n**起步**\n\n由于是绿灯开始后才进行运动，因此可以在运动的开始添加一个延时，在此延时中将无人车的运动方向设置为50，可以稍微加快速度\n\n**左转弯**\n\n使用视觉进行检测，几乎不需要进行干扰\n\n**人行道**\n\n可以通过opencv或者是hilens进行识别\n\n- 在此位置需要停车\n\n可以通过激光雷达检测到右侧的距离，检测行人等障碍物\n\n- 此时应该判断是不是处在左转弯的过程中？【或者说怎样让它具有独特性，而不是全赛道通用的】\n- 需要判断障碍物是不是消失，障碍物的级别最高，高于人行道，高于车道\n- 检测到障碍物时：方向设置为50，挡位设置为空，避免来回的摆动\n\n**重新启动**\n\n- 应当保持停车前的运行方向不变\n- 检测重新启动后的小车运动方向\n- 重新可以设置方向和挡位（也就是说在斑马线期间视觉确实也是在启动的，只不过不能修改方向值）\n\n**交叉区域**\n\n激光雷达slam，可以在中间交叉区域通过判断两边距离是否一致从而实现\n\n**右转弯**\n\n视觉可以实现比较好的操作\n\n**限速操作**\n\n我们把限制后的速度调整为10，限速前应当能够按照15-20进行运动\n\n注意限速和转角之间的配合关系，需要进行测试\n\n这边转弯的过程中限速和转角是不是能很好地进行配合\n\n**停车**\n\n首先识别到黄灯，开始进入停车识别\n\n然后识别车的位姿，是不是和右侧挡板平行（使用激光雷达）\n\n满足和右侧挡板平行，或者能够保持一定的距离，进行驶入\n\n最后当看不到黄灯、或者红灯后，进行延时，从而确保停车完毕\n\n- 注意不能压线，不能碰挡板\n\n```mermaid\ngraph LR\ncamera --> l(laneDetection)\nl --> images\nl --> l2(lane_vel:topic)\nl2 -.- res1[有效信息只有angle_z]\nl2 --> s1((servoNode))\n\nh[hilens] --> t1(traffic_light)\nh --> t2(标识牌信息)\nt1 --> s1\nt2 --> s1\ns1 --> m1(manul)\ns1 --> d1(direction)\ns1 --> s2(speed)\ns1 --> g(gear)\n\nm1 -.- res2[自动手动]\nd1 -.- res3[方向]\ns2 -.- res4[速度]\ng -.- res5[挡位]\n```\n\n### 8. /scan话题无法读取的问题\n\n> 参考：[ROS多机通讯踩坑，（主机和从机之间可以订阅话题，但是看不到话题消息）](https://blog.csdn.net/qq_38441692/article/details/98205852)\n>\n> [**rostopic list works but rostopic echo does not**](https://answers.ros.org/question/48240/rostopic-list-works-but-rostopic-echo-does-not/)\n\n该问题已经解决，使用/rosout进行读取","source":"_posts/华为云无人车参赛笔记二.md","raw":"---\ntitle: 华为云无人车参赛笔记二\ndate: 2020-09-29 09:24:30\ncategories:\n\t- [机器视觉]\n\t- [ROS]\ntags:\n\t- 华为云无人车\n\t- OpenCV\n---\n\n上一篇主要内容是针对本赛事中的重难点进行描述，但是针对实际问题，需要更加细致的调整。\n\n本文记录实际调试过程中遇到的问题和改善方法。\n\n<!--more-->\n\n## 问题记录\n\n### 1. 首先需要调整透视变换视角\n\n主要是画面范围的调整。\n\n由于弯道比较多，真实小车的视线中很少能看到两条线；同时，大概是因为选择透视变换的范围比较小，无法覆盖到需要的图像区域。因此需要对画面进行调整。\n\n**直接用openCV添加直线**\n\n![image-20200903135454484](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200903135454484.png)\n\n> 可能出现的问题：\n>\n> `SystemError: new style getargs format but argument is not a tuple`\n>\n> 这个问题应该关键是数据的类型不太对\n\n效果如图所示，大概明白如下：前面的区域界定，只是计算转换矩阵，然后使用转换矩阵把整个图片进行转换。\n\n所以说，**转换矩阵要谨慎一点**，不是随便怎么转换都可以的。\n\n那么我们应该怎么样转换呢？让比例更加准确一点！\n\n![image-20200904094713780](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200904094713780.png)\n\n这张图应证了我的想法，确实需要**调整好直线道路上的透视变换效果图**。\n\n> 本赛道转弯比较多\n>\n> 按道理来说，按照透视的原理，只要将一个水平的梯形区域转换为一个正常的方形区域就可以了\n>\n> 但是现实是，本赛道弯道多，车身倾角大，导致车的姿态情况不是水平，最好有一点偏角\n>\n> 应该是左低右高的一个区域就比较好\n\n**原始区域：**\n\n变换前：`src_points = np.array([[3,570], [387,460], [906,452], [1041,485]], dtype=\"float32\")`\n\n变换后：`[266., 686.], [266., 19.], [931., 20.], [931., 701.]`\n\n该区域的问题是，没有线的区域会比较多，或者说覆盖的车道区域有点小\n\n从形状上来看倒是很符合左低右高的形状\n\n**区域1：**\n\n变换前：`src_points = np.array([[3,570], [387,460], [1106,472], [1241,520]], dtype=\"float32\")`\n\n![image-20200903151451012](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200903151451012.png)\n\n其实这个区域还不错\n\n对中间的纯黑地带过滤也比较到位\n\n就看实际中的表现如何\n\n> 不对，这个确实应该动态进行调整\n>\n> ==车身姿态影响到了拍摄角度==\n>\n> 左转的时候应该是坐地右高，右转的时候则是要右低左高了，目前这样肯定是不够的\n>\n> 如果按照IMU的数据去调整呢\n\n**区域2**：\n\n变换前：`src_points = np.array([[3,520], [387,470], [1106,472], [1241,520]], dtype=\"float32\")`\n\n我使用opencv将视频转换为图片，然后用matplotlib展示出图片，然后进行分析\n\n![image-20200904205233116](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200904205233116.png)\n\n目前看完了全部代码之后，就很明朗了\n\n就是要不断调整透视变换的比例，从而确保在直线道路上，能够调试出满意的透视变换图像\n\n---\n\n==观察结果：==\n\n按照最后的观察结果来看，右转问题有二：\n\n第一，其视角偏上，那么近一点的区域就会反应过于灵敏\n\n- 这个调整的是转换前的区域大小，以及转换后的区域的大小\n\n第二，如果角度变换的速度太慢，就会没有转到有线的位置，从而丢失车道线画面\n\n- 这里调节角度变换的速度，一个是调整==计算`cmdSteer`的系数k==，基准是 -19，**这个数字是什么意思呢？**\n- 这个数字应该是弯道的斜率，不同的弯这个系数确实是不太一样的\n\n**其实比较好奇，什么样的结果算是改动成功？**\n\n结果就是应该准确快速地转弯成功\n\n### 2. midPoint\n\nmidpoint理论上是视野的中点，但是程序中是 320，这个是有点奇怪的，偏左了一点点\n\n- 回答：程序中有两个midPoint，一个是midPoint_x，这个值是640，已经确定，没有问题\n- 还有一个是midPoint_y，似乎是用以分隔上下部分，这个值目前定的是320，实际上也可以进行调整，主要还是看车道在画面中所占的位置\n\n这个值感觉不是特别需要改动\n\n或者说修改的意义不大\n\n### 3. 视频录制\n\n使用opencv-python录制视频\n\n首先使用的代码参考：[Python-OpenCV视频录制](https://blog.csdn.net/hhaowang/article/details/88236612)\n\n但是这个一点都不好用，录制的视频播放速度极快，丢帧也比较严重了\n\n接下来希望参考：[Python -opencv 录制视频](https://blog.csdn.net/weixin_43635647/article/details/103774559)\n\n这个代码看起来要简洁一点\n\n### 4. 入弯出弯测试\n\n目前来说，右转入弯要么不够迅速，要么会提前（主要还是看视野内的车道线情况）\n\n左转入弯有问题，似乎是机械方面的故障，从信号上来说已经是左转了，但是实际转弯情况却是右转的\n\n目前的参数中：\n\n**转向参数设为 -21**\n\n效果不错，右转弯很合适，左转弯尚有不足\n\n速度调至10很完美，速度调至15稍有不足（主要是左转弯时会打方向比较急、猛）\n\n### 5. 斑马线识别\n\n怎么样将最边上的线识别出来呢？\n\n用了边缘检测，效果尚可，但是怎么样压制其他区域呢？\n\n首先查看了lanebase点的位置，可以看的出来，在这之前的一小段高曝光中，会对lanebase产生一点影响\n\n![image-20200908221446425](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908221446425.png)\n\n![image-20200908222634494](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908222634494.png)\n\n此时lanebase做了什么\n\n![image-20200908222912990](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908222912990.png)\n\n当前使用的解决方法涉及两个参数;\n\n- 白色像素占图像的比例：大于0.083\n- lane_base中心值只要小于900，就会自动加500，保证向左转弯过车道线\n\n> 我认为该问题中的关键是lane_base位置的错误，导致了车道曲线的识别问题\n>\n> 因此我的两种方法：\n>\n> - 根据lanebase的突变情况，使用黑色色块进行掩盖\n> - 根据lanebase的突变情况，对lanebase进行修正\n>   - 其实第二种修正情况，有一定的问题，那就是一刀切全部加了500，这个不是非常合理\n>   - 但是我发现nonzerox的值似乎和我设想的不太一样【nonzerox要配合nonzeroy来同时查看，nonzeroy是从0到720，nonzerox则也是要跟着nonzeroy的像素值进行变化】也不对，不需要直接进行索引，直接求最大值也是可以的\n\n#### 新方法\n\n使用霍夫变换检测斑马线的两侧横线，然后求凸包的顶点，将凸包内的斑马线直接去除，该方法在视觉效果上还是不错的\n\n**测试参数表：**\n\n各参数含义：\n\n- rho：\n- theta：\n- threshold：\n- min_line_length：\n- max_line_gap：\n\n| rho  | theta     | threshold | min_line_length | max_line_gap | 效果                                 |\n| ---- | --------- | --------- | --------------- | ------------ | ------------------------------------ |\n| 1    | np.pi/180 | 30        | 30              | 30           | 出现的线条会很少                     |\n| 1    | np.pi/180 | 50        | 30              | 1            | 出现线条多，很多小线条以点的形式出现 |\n|      |           |           |                 |              |                                      |\n\n\n\n### 6. 滑动平均问题\n\n关于servoNode中的滑动平均值，之前确实没有过多考虑，可能还是希望能就原状进行测试，但是忽略了代码间的相互协调能力\n\n![image-20200910135546937](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200910135546937.png)\n\n这个 n 值的设定主要是起到滑动平均的基数的关系\n\n如果调整n，发布的速度也会比较慢，但是也需要可以起到比较好的光滑的效果（不见得）\n\n需要尝试一下，目前设想的测试顺序如下所示：\n\n| n=   | 1                        | 5                                      | 3    | 10   |\n| ---- | ------------------------ | -------------------------------------- | ---- | ---- |\n|      | 抖动比较明显，但是可过弯 | 抖动降低，但是人行道不易通过，转角过大 |      |      |\n\n\n\n### 7. 整体规划首个思路\n\n**起步**\n\n由于是绿灯开始后才进行运动，因此可以在运动的开始添加一个延时，在此延时中将无人车的运动方向设置为50，可以稍微加快速度\n\n**左转弯**\n\n使用视觉进行检测，几乎不需要进行干扰\n\n**人行道**\n\n可以通过opencv或者是hilens进行识别\n\n- 在此位置需要停车\n\n可以通过激光雷达检测到右侧的距离，检测行人等障碍物\n\n- 此时应该判断是不是处在左转弯的过程中？【或者说怎样让它具有独特性，而不是全赛道通用的】\n- 需要判断障碍物是不是消失，障碍物的级别最高，高于人行道，高于车道\n- 检测到障碍物时：方向设置为50，挡位设置为空，避免来回的摆动\n\n**重新启动**\n\n- 应当保持停车前的运行方向不变\n- 检测重新启动后的小车运动方向\n- 重新可以设置方向和挡位（也就是说在斑马线期间视觉确实也是在启动的，只不过不能修改方向值）\n\n**交叉区域**\n\n激光雷达slam，可以在中间交叉区域通过判断两边距离是否一致从而实现\n\n**右转弯**\n\n视觉可以实现比较好的操作\n\n**限速操作**\n\n我们把限制后的速度调整为10，限速前应当能够按照15-20进行运动\n\n注意限速和转角之间的配合关系，需要进行测试\n\n这边转弯的过程中限速和转角是不是能很好地进行配合\n\n**停车**\n\n首先识别到黄灯，开始进入停车识别\n\n然后识别车的位姿，是不是和右侧挡板平行（使用激光雷达）\n\n满足和右侧挡板平行，或者能够保持一定的距离，进行驶入\n\n最后当看不到黄灯、或者红灯后，进行延时，从而确保停车完毕\n\n- 注意不能压线，不能碰挡板\n\n```mermaid\ngraph LR\ncamera --> l(laneDetection)\nl --> images\nl --> l2(lane_vel:topic)\nl2 -.- res1[有效信息只有angle_z]\nl2 --> s1((servoNode))\n\nh[hilens] --> t1(traffic_light)\nh --> t2(标识牌信息)\nt1 --> s1\nt2 --> s1\ns1 --> m1(manul)\ns1 --> d1(direction)\ns1 --> s2(speed)\ns1 --> g(gear)\n\nm1 -.- res2[自动手动]\nd1 -.- res3[方向]\ns2 -.- res4[速度]\ng -.- res5[挡位]\n```\n\n### 8. /scan话题无法读取的问题\n\n> 参考：[ROS多机通讯踩坑，（主机和从机之间可以订阅话题，但是看不到话题消息）](https://blog.csdn.net/qq_38441692/article/details/98205852)\n>\n> [**rostopic list works but rostopic echo does not**](https://answers.ros.org/question/48240/rostopic-list-works-but-rostopic-echo-does-not/)\n\n该问题已经解决，使用/rosout进行读取","slug":"华为云无人车参赛笔记二","published":1,"updated":"2021-01-26T06:22:28.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n894003ik8tl1mfce6xr","content":"<p>上一篇主要内容是针对本赛事中的重难点进行描述，但是针对实际问题，需要更加细致的调整。</p>\n<p>本文记录实际调试过程中遇到的问题和改善方法。</p>\n<a id=\"more\"></a>\n<h2 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h2><h3 id=\"1-首先需要调整透视变换视角\"><a href=\"#1-首先需要调整透视变换视角\" class=\"headerlink\" title=\"1. 首先需要调整透视变换视角\"></a>1. 首先需要调整透视变换视角</h3><p>主要是画面范围的调整。</p>\n<p>由于弯道比较多，真实小车的视线中很少能看到两条线；同时，大概是因为选择透视变换的范围比较小，无法覆盖到需要的图像区域。因此需要对画面进行调整。</p>\n<p><strong>直接用openCV添加直线</strong></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200903135454484.png\" alt=\"image-20200903135454484\"></p>\n<blockquote>\n<p>可能出现的问题：</p>\n<p><code>SystemError: new style getargs format but argument is not a tuple</code></p>\n<p>这个问题应该关键是数据的类型不太对</p>\n</blockquote>\n<p>效果如图所示，大概明白如下：前面的区域界定，只是计算转换矩阵，然后使用转换矩阵把整个图片进行转换。</p>\n<p>所以说，<strong>转换矩阵要谨慎一点</strong>，不是随便怎么转换都可以的。</p>\n<p>那么我们应该怎么样转换呢？让比例更加准确一点！</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200904094713780.png\" alt=\"image-20200904094713780\"></p>\n<p>这张图应证了我的想法，确实需要<strong>调整好直线道路上的透视变换效果图</strong>。</p>\n<blockquote>\n<p>本赛道转弯比较多</p>\n<p>按道理来说，按照透视的原理，只要将一个水平的梯形区域转换为一个正常的方形区域就可以了</p>\n<p>但是现实是，本赛道弯道多，车身倾角大，导致车的姿态情况不是水平，最好有一点偏角</p>\n<p>应该是左低右高的一个区域就比较好</p>\n</blockquote>\n<p><strong>原始区域：</strong></p>\n<p>变换前：<code>src_points = np.array([[3,570], [387,460], [906,452], [1041,485]], dtype=&quot;float32&quot;)</code></p>\n<p>变换后：<code>[266., 686.], [266., 19.], [931., 20.], [931., 701.]</code></p>\n<p>该区域的问题是，没有线的区域会比较多，或者说覆盖的车道区域有点小</p>\n<p>从形状上来看倒是很符合左低右高的形状</p>\n<p><strong>区域1：</strong></p>\n<p>变换前：<code>src_points = np.array([[3,570], [387,460], [1106,472], [1241,520]], dtype=&quot;float32&quot;)</code></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200903151451012.png\" alt=\"image-20200903151451012\"></p>\n<p>其实这个区域还不错</p>\n<p>对中间的纯黑地带过滤也比较到位</p>\n<p>就看实际中的表现如何</p>\n<blockquote>\n<p>不对，这个确实应该动态进行调整</p>\n<p>==车身姿态影响到了拍摄角度==</p>\n<p>左转的时候应该是坐地右高，右转的时候则是要右低左高了，目前这样肯定是不够的</p>\n<p>如果按照IMU的数据去调整呢</p>\n</blockquote>\n<p><strong>区域2</strong>：</p>\n<p>变换前：<code>src_points = np.array([[3,520], [387,470], [1106,472], [1241,520]], dtype=&quot;float32&quot;)</code></p>\n<p>我使用opencv将视频转换为图片，然后用matplotlib展示出图片，然后进行分析</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200904205233116.png\" alt=\"image-20200904205233116\"></p>\n<p>目前看完了全部代码之后，就很明朗了</p>\n<p>就是要不断调整透视变换的比例，从而确保在直线道路上，能够调试出满意的透视变换图像</p>\n<hr>\n<p>==观察结果：==</p>\n<p>按照最后的观察结果来看，右转问题有二：</p>\n<p>第一，其视角偏上，那么近一点的区域就会反应过于灵敏</p>\n<ul>\n<li>这个调整的是转换前的区域大小，以及转换后的区域的大小</li>\n</ul>\n<p>第二，如果角度变换的速度太慢，就会没有转到有线的位置，从而丢失车道线画面</p>\n<ul>\n<li>这里调节角度变换的速度，一个是调整==计算<code>cmdSteer</code>的系数k==，基准是 -19，<strong>这个数字是什么意思呢？</strong></li>\n<li>这个数字应该是弯道的斜率，不同的弯这个系数确实是不太一样的</li>\n</ul>\n<p><strong>其实比较好奇，什么样的结果算是改动成功？</strong></p>\n<p>结果就是应该准确快速地转弯成功</p>\n<h3 id=\"2-midPoint\"><a href=\"#2-midPoint\" class=\"headerlink\" title=\"2. midPoint\"></a>2. midPoint</h3><p>midpoint理论上是视野的中点，但是程序中是 320，这个是有点奇怪的，偏左了一点点</p>\n<ul>\n<li>回答：程序中有两个midPoint，一个是midPoint_x，这个值是640，已经确定，没有问题</li>\n<li>还有一个是midPoint_y，似乎是用以分隔上下部分，这个值目前定的是320，实际上也可以进行调整，主要还是看车道在画面中所占的位置</li>\n</ul>\n<p>这个值感觉不是特别需要改动</p>\n<p>或者说修改的意义不大</p>\n<h3 id=\"3-视频录制\"><a href=\"#3-视频录制\" class=\"headerlink\" title=\"3. 视频录制\"></a>3. 视频录制</h3><p>使用opencv-python录制视频</p>\n<p>首先使用的代码参考：<a href=\"https://blog.csdn.net/hhaowang/article/details/88236612\" target=\"_blank\" rel=\"noopener\">Python-OpenCV视频录制</a></p>\n<p>但是这个一点都不好用，录制的视频播放速度极快，丢帧也比较严重了</p>\n<p>接下来希望参考：<a href=\"https://blog.csdn.net/weixin_43635647/article/details/103774559\" target=\"_blank\" rel=\"noopener\">Python -opencv 录制视频</a></p>\n<p>这个代码看起来要简洁一点</p>\n<h3 id=\"4-入弯出弯测试\"><a href=\"#4-入弯出弯测试\" class=\"headerlink\" title=\"4. 入弯出弯测试\"></a>4. 入弯出弯测试</h3><p>目前来说，右转入弯要么不够迅速，要么会提前（主要还是看视野内的车道线情况）</p>\n<p>左转入弯有问题，似乎是机械方面的故障，从信号上来说已经是左转了，但是实际转弯情况却是右转的</p>\n<p>目前的参数中：</p>\n<p><strong>转向参数设为 -21</strong></p>\n<p>效果不错，右转弯很合适，左转弯尚有不足</p>\n<p>速度调至10很完美，速度调至15稍有不足（主要是左转弯时会打方向比较急、猛）</p>\n<h3 id=\"5-斑马线识别\"><a href=\"#5-斑马线识别\" class=\"headerlink\" title=\"5. 斑马线识别\"></a>5. 斑马线识别</h3><p>怎么样将最边上的线识别出来呢？</p>\n<p>用了边缘检测，效果尚可，但是怎么样压制其他区域呢？</p>\n<p>首先查看了lanebase点的位置，可以看的出来，在这之前的一小段高曝光中，会对lanebase产生一点影响</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908221446425.png\" alt=\"image-20200908221446425\"></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908222634494.png\" alt=\"image-20200908222634494\"></p>\n<p>此时lanebase做了什么</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908222912990.png\" alt=\"image-20200908222912990\"></p>\n<p>当前使用的解决方法涉及两个参数;</p>\n<ul>\n<li>白色像素占图像的比例：大于0.083</li>\n<li>lane_base中心值只要小于900，就会自动加500，保证向左转弯过车道线</li>\n</ul>\n<blockquote>\n<p>我认为该问题中的关键是lane_base位置的错误，导致了车道曲线的识别问题</p>\n<p>因此我的两种方法：</p>\n<ul>\n<li>根据lanebase的突变情况，使用黑色色块进行掩盖</li>\n<li>根据lanebase的突变情况，对lanebase进行修正<ul>\n<li>其实第二种修正情况，有一定的问题，那就是一刀切全部加了500，这个不是非常合理</li>\n<li>但是我发现nonzerox的值似乎和我设想的不太一样【nonzerox要配合nonzeroy来同时查看，nonzeroy是从0到720，nonzerox则也是要跟着nonzeroy的像素值进行变化】也不对，不需要直接进行索引，直接求最大值也是可以的</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"新方法\"><a href=\"#新方法\" class=\"headerlink\" title=\"新方法\"></a>新方法</h4><p>使用霍夫变换检测斑马线的两侧横线，然后求凸包的顶点，将凸包内的斑马线直接去除，该方法在视觉效果上还是不错的</p>\n<p><strong>测试参数表：</strong></p>\n<p>各参数含义：</p>\n<ul>\n<li>rho：</li>\n<li>theta：</li>\n<li>threshold：</li>\n<li>min_line_length：</li>\n<li>max_line_gap：</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>rho</th>\n<th>theta</th>\n<th>threshold</th>\n<th>min_line_length</th>\n<th>max_line_gap</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>np.pi/180</td>\n<td>30</td>\n<td>30</td>\n<td>30</td>\n<td>出现的线条会很少</td>\n</tr>\n<tr>\n<td>1</td>\n<td>np.pi/180</td>\n<td>50</td>\n<td>30</td>\n<td>1</td>\n<td>出现线条多，很多小线条以点的形式出现</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"6-滑动平均问题\"><a href=\"#6-滑动平均问题\" class=\"headerlink\" title=\"6. 滑动平均问题\"></a>6. 滑动平均问题</h3><p>关于servoNode中的滑动平均值，之前确实没有过多考虑，可能还是希望能就原状进行测试，但是忽略了代码间的相互协调能力</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200910135546937.png\" alt=\"image-20200910135546937\"></p>\n<p>这个 n 值的设定主要是起到滑动平均的基数的关系</p>\n<p>如果调整n，发布的速度也会比较慢，但是也需要可以起到比较好的光滑的效果（不见得）</p>\n<p>需要尝试一下，目前设想的测试顺序如下所示：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>n=</th>\n<th>1</th>\n<th>5</th>\n<th>3</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>抖动比较明显，但是可过弯</td>\n<td>抖动降低，但是人行道不易通过，转角过大</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"7-整体规划首个思路\"><a href=\"#7-整体规划首个思路\" class=\"headerlink\" title=\"7. 整体规划首个思路\"></a>7. 整体规划首个思路</h3><p><strong>起步</strong></p>\n<p>由于是绿灯开始后才进行运动，因此可以在运动的开始添加一个延时，在此延时中将无人车的运动方向设置为50，可以稍微加快速度</p>\n<p><strong>左转弯</strong></p>\n<p>使用视觉进行检测，几乎不需要进行干扰</p>\n<p><strong>人行道</strong></p>\n<p>可以通过opencv或者是hilens进行识别</p>\n<ul>\n<li>在此位置需要停车</li>\n</ul>\n<p>可以通过激光雷达检测到右侧的距离，检测行人等障碍物</p>\n<ul>\n<li>此时应该判断是不是处在左转弯的过程中？【或者说怎样让它具有独特性，而不是全赛道通用的】</li>\n<li>需要判断障碍物是不是消失，障碍物的级别最高，高于人行道，高于车道</li>\n<li>检测到障碍物时：方向设置为50，挡位设置为空，避免来回的摆动</li>\n</ul>\n<p><strong>重新启动</strong></p>\n<ul>\n<li>应当保持停车前的运行方向不变</li>\n<li>检测重新启动后的小车运动方向</li>\n<li>重新可以设置方向和挡位（也就是说在斑马线期间视觉确实也是在启动的，只不过不能修改方向值）</li>\n</ul>\n<p><strong>交叉区域</strong></p>\n<p>激光雷达slam，可以在中间交叉区域通过判断两边距离是否一致从而实现</p>\n<p><strong>右转弯</strong></p>\n<p>视觉可以实现比较好的操作</p>\n<p><strong>限速操作</strong></p>\n<p>我们把限制后的速度调整为10，限速前应当能够按照15-20进行运动</p>\n<p>注意限速和转角之间的配合关系，需要进行测试</p>\n<p>这边转弯的过程中限速和转角是不是能很好地进行配合</p>\n<p><strong>停车</strong></p>\n<p>首先识别到黄灯，开始进入停车识别</p>\n<p>然后识别车的位姿，是不是和右侧挡板平行（使用激光雷达）</p>\n<p>满足和右侧挡板平行，或者能够保持一定的距离，进行驶入</p>\n<p>最后当看不到黄灯、或者红灯后，进行延时，从而确保停车完毕</p>\n<ul>\n<li>注意不能压线，不能碰挡板</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">camera --&gt; l(laneDetection)</span><br><span class=\"line\">l --&gt; images</span><br><span class=\"line\">l --&gt; l2(lane_vel:topic)</span><br><span class=\"line\">l2 -.- res1[有效信息只有angle_z]</span><br><span class=\"line\">l2 --&gt; s1((servoNode))</span><br><span class=\"line\"></span><br><span class=\"line\">h[hilens] --&gt; t1(traffic_light)</span><br><span class=\"line\">h --&gt; t2(标识牌信息)</span><br><span class=\"line\">t1 --&gt; s1</span><br><span class=\"line\">t2 --&gt; s1</span><br><span class=\"line\">s1 --&gt; m1(manul)</span><br><span class=\"line\">s1 --&gt; d1(direction)</span><br><span class=\"line\">s1 --&gt; s2(speed)</span><br><span class=\"line\">s1 --&gt; g(gear)</span><br><span class=\"line\"></span><br><span class=\"line\">m1 -.- res2[自动手动]</span><br><span class=\"line\">d1 -.- res3[方向]</span><br><span class=\"line\">s2 -.- res4[速度]</span><br><span class=\"line\">g -.- res5[挡位]</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-scan话题无法读取的问题\"><a href=\"#8-scan话题无法读取的问题\" class=\"headerlink\" title=\"8. /scan话题无法读取的问题\"></a>8. /scan话题无法读取的问题</h3><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/qq_38441692/article/details/98205852\" target=\"_blank\" rel=\"noopener\">ROS多机通讯踩坑，（主机和从机之间可以订阅话题，但是看不到话题消息）</a></p>\n<p><a href=\"https://answers.ros.org/question/48240/rostopic-list-works-but-rostopic-echo-does-not/\" target=\"_blank\" rel=\"noopener\"><strong>rostopic list works but rostopic echo does not</strong></a></p>\n</blockquote>\n<p>该问题已经解决，使用/rosout进行读取</p>\n","site":{"data":{}},"excerpt":"<p>上一篇主要内容是针对本赛事中的重难点进行描述，但是针对实际问题，需要更加细致的调整。</p>\n<p>本文记录实际调试过程中遇到的问题和改善方法。</p>","more":"<h2 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h2><h3 id=\"1-首先需要调整透视变换视角\"><a href=\"#1-首先需要调整透视变换视角\" class=\"headerlink\" title=\"1. 首先需要调整透视变换视角\"></a>1. 首先需要调整透视变换视角</h3><p>主要是画面范围的调整。</p>\n<p>由于弯道比较多，真实小车的视线中很少能看到两条线；同时，大概是因为选择透视变换的范围比较小，无法覆盖到需要的图像区域。因此需要对画面进行调整。</p>\n<p><strong>直接用openCV添加直线</strong></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200903135454484.png\" alt=\"image-20200903135454484\"></p>\n<blockquote>\n<p>可能出现的问题：</p>\n<p><code>SystemError: new style getargs format but argument is not a tuple</code></p>\n<p>这个问题应该关键是数据的类型不太对</p>\n</blockquote>\n<p>效果如图所示，大概明白如下：前面的区域界定，只是计算转换矩阵，然后使用转换矩阵把整个图片进行转换。</p>\n<p>所以说，<strong>转换矩阵要谨慎一点</strong>，不是随便怎么转换都可以的。</p>\n<p>那么我们应该怎么样转换呢？让比例更加准确一点！</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200904094713780.png\" alt=\"image-20200904094713780\"></p>\n<p>这张图应证了我的想法，确实需要<strong>调整好直线道路上的透视变换效果图</strong>。</p>\n<blockquote>\n<p>本赛道转弯比较多</p>\n<p>按道理来说，按照透视的原理，只要将一个水平的梯形区域转换为一个正常的方形区域就可以了</p>\n<p>但是现实是，本赛道弯道多，车身倾角大，导致车的姿态情况不是水平，最好有一点偏角</p>\n<p>应该是左低右高的一个区域就比较好</p>\n</blockquote>\n<p><strong>原始区域：</strong></p>\n<p>变换前：<code>src_points = np.array([[3,570], [387,460], [906,452], [1041,485]], dtype=&quot;float32&quot;)</code></p>\n<p>变换后：<code>[266., 686.], [266., 19.], [931., 20.], [931., 701.]</code></p>\n<p>该区域的问题是，没有线的区域会比较多，或者说覆盖的车道区域有点小</p>\n<p>从形状上来看倒是很符合左低右高的形状</p>\n<p><strong>区域1：</strong></p>\n<p>变换前：<code>src_points = np.array([[3,570], [387,460], [1106,472], [1241,520]], dtype=&quot;float32&quot;)</code></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200903151451012.png\" alt=\"image-20200903151451012\"></p>\n<p>其实这个区域还不错</p>\n<p>对中间的纯黑地带过滤也比较到位</p>\n<p>就看实际中的表现如何</p>\n<blockquote>\n<p>不对，这个确实应该动态进行调整</p>\n<p>==车身姿态影响到了拍摄角度==</p>\n<p>左转的时候应该是坐地右高，右转的时候则是要右低左高了，目前这样肯定是不够的</p>\n<p>如果按照IMU的数据去调整呢</p>\n</blockquote>\n<p><strong>区域2</strong>：</p>\n<p>变换前：<code>src_points = np.array([[3,520], [387,470], [1106,472], [1241,520]], dtype=&quot;float32&quot;)</code></p>\n<p>我使用opencv将视频转换为图片，然后用matplotlib展示出图片，然后进行分析</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200904205233116.png\" alt=\"image-20200904205233116\"></p>\n<p>目前看完了全部代码之后，就很明朗了</p>\n<p>就是要不断调整透视变换的比例，从而确保在直线道路上，能够调试出满意的透视变换图像</p>\n<hr>\n<p>==观察结果：==</p>\n<p>按照最后的观察结果来看，右转问题有二：</p>\n<p>第一，其视角偏上，那么近一点的区域就会反应过于灵敏</p>\n<ul>\n<li>这个调整的是转换前的区域大小，以及转换后的区域的大小</li>\n</ul>\n<p>第二，如果角度变换的速度太慢，就会没有转到有线的位置，从而丢失车道线画面</p>\n<ul>\n<li>这里调节角度变换的速度，一个是调整==计算<code>cmdSteer</code>的系数k==，基准是 -19，<strong>这个数字是什么意思呢？</strong></li>\n<li>这个数字应该是弯道的斜率，不同的弯这个系数确实是不太一样的</li>\n</ul>\n<p><strong>其实比较好奇，什么样的结果算是改动成功？</strong></p>\n<p>结果就是应该准确快速地转弯成功</p>\n<h3 id=\"2-midPoint\"><a href=\"#2-midPoint\" class=\"headerlink\" title=\"2. midPoint\"></a>2. midPoint</h3><p>midpoint理论上是视野的中点，但是程序中是 320，这个是有点奇怪的，偏左了一点点</p>\n<ul>\n<li>回答：程序中有两个midPoint，一个是midPoint_x，这个值是640，已经确定，没有问题</li>\n<li>还有一个是midPoint_y，似乎是用以分隔上下部分，这个值目前定的是320，实际上也可以进行调整，主要还是看车道在画面中所占的位置</li>\n</ul>\n<p>这个值感觉不是特别需要改动</p>\n<p>或者说修改的意义不大</p>\n<h3 id=\"3-视频录制\"><a href=\"#3-视频录制\" class=\"headerlink\" title=\"3. 视频录制\"></a>3. 视频录制</h3><p>使用opencv-python录制视频</p>\n<p>首先使用的代码参考：<a href=\"https://blog.csdn.net/hhaowang/article/details/88236612\" target=\"_blank\" rel=\"noopener\">Python-OpenCV视频录制</a></p>\n<p>但是这个一点都不好用，录制的视频播放速度极快，丢帧也比较严重了</p>\n<p>接下来希望参考：<a href=\"https://blog.csdn.net/weixin_43635647/article/details/103774559\" target=\"_blank\" rel=\"noopener\">Python -opencv 录制视频</a></p>\n<p>这个代码看起来要简洁一点</p>\n<h3 id=\"4-入弯出弯测试\"><a href=\"#4-入弯出弯测试\" class=\"headerlink\" title=\"4. 入弯出弯测试\"></a>4. 入弯出弯测试</h3><p>目前来说，右转入弯要么不够迅速，要么会提前（主要还是看视野内的车道线情况）</p>\n<p>左转入弯有问题，似乎是机械方面的故障，从信号上来说已经是左转了，但是实际转弯情况却是右转的</p>\n<p>目前的参数中：</p>\n<p><strong>转向参数设为 -21</strong></p>\n<p>效果不错，右转弯很合适，左转弯尚有不足</p>\n<p>速度调至10很完美，速度调至15稍有不足（主要是左转弯时会打方向比较急、猛）</p>\n<h3 id=\"5-斑马线识别\"><a href=\"#5-斑马线识别\" class=\"headerlink\" title=\"5. 斑马线识别\"></a>5. 斑马线识别</h3><p>怎么样将最边上的线识别出来呢？</p>\n<p>用了边缘检测，效果尚可，但是怎么样压制其他区域呢？</p>\n<p>首先查看了lanebase点的位置，可以看的出来，在这之前的一小段高曝光中，会对lanebase产生一点影响</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908221446425.png\" alt=\"image-20200908221446425\"></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908222634494.png\" alt=\"image-20200908222634494\"></p>\n<p>此时lanebase做了什么</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200908222912990.png\" alt=\"image-20200908222912990\"></p>\n<p>当前使用的解决方法涉及两个参数;</p>\n<ul>\n<li>白色像素占图像的比例：大于0.083</li>\n<li>lane_base中心值只要小于900，就会自动加500，保证向左转弯过车道线</li>\n</ul>\n<blockquote>\n<p>我认为该问题中的关键是lane_base位置的错误，导致了车道曲线的识别问题</p>\n<p>因此我的两种方法：</p>\n<ul>\n<li>根据lanebase的突变情况，使用黑色色块进行掩盖</li>\n<li>根据lanebase的突变情况，对lanebase进行修正<ul>\n<li>其实第二种修正情况，有一定的问题，那就是一刀切全部加了500，这个不是非常合理</li>\n<li>但是我发现nonzerox的值似乎和我设想的不太一样【nonzerox要配合nonzeroy来同时查看，nonzeroy是从0到720，nonzerox则也是要跟着nonzeroy的像素值进行变化】也不对，不需要直接进行索引，直接求最大值也是可以的</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"新方法\"><a href=\"#新方法\" class=\"headerlink\" title=\"新方法\"></a>新方法</h4><p>使用霍夫变换检测斑马线的两侧横线，然后求凸包的顶点，将凸包内的斑马线直接去除，该方法在视觉效果上还是不错的</p>\n<p><strong>测试参数表：</strong></p>\n<p>各参数含义：</p>\n<ul>\n<li>rho：</li>\n<li>theta：</li>\n<li>threshold：</li>\n<li>min_line_length：</li>\n<li>max_line_gap：</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>rho</th>\n<th>theta</th>\n<th>threshold</th>\n<th>min_line_length</th>\n<th>max_line_gap</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>np.pi/180</td>\n<td>30</td>\n<td>30</td>\n<td>30</td>\n<td>出现的线条会很少</td>\n</tr>\n<tr>\n<td>1</td>\n<td>np.pi/180</td>\n<td>50</td>\n<td>30</td>\n<td>1</td>\n<td>出现线条多，很多小线条以点的形式出现</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"6-滑动平均问题\"><a href=\"#6-滑动平均问题\" class=\"headerlink\" title=\"6. 滑动平均问题\"></a>6. 滑动平均问题</h3><p>关于servoNode中的滑动平均值，之前确实没有过多考虑，可能还是希望能就原状进行测试，但是忽略了代码间的相互协调能力</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200910135546937.png\" alt=\"image-20200910135546937\"></p>\n<p>这个 n 值的设定主要是起到滑动平均的基数的关系</p>\n<p>如果调整n，发布的速度也会比较慢，但是也需要可以起到比较好的光滑的效果（不见得）</p>\n<p>需要尝试一下，目前设想的测试顺序如下所示：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>n=</th>\n<th>1</th>\n<th>5</th>\n<th>3</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>抖动比较明显，但是可过弯</td>\n<td>抖动降低，但是人行道不易通过，转角过大</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"7-整体规划首个思路\"><a href=\"#7-整体规划首个思路\" class=\"headerlink\" title=\"7. 整体规划首个思路\"></a>7. 整体规划首个思路</h3><p><strong>起步</strong></p>\n<p>由于是绿灯开始后才进行运动，因此可以在运动的开始添加一个延时，在此延时中将无人车的运动方向设置为50，可以稍微加快速度</p>\n<p><strong>左转弯</strong></p>\n<p>使用视觉进行检测，几乎不需要进行干扰</p>\n<p><strong>人行道</strong></p>\n<p>可以通过opencv或者是hilens进行识别</p>\n<ul>\n<li>在此位置需要停车</li>\n</ul>\n<p>可以通过激光雷达检测到右侧的距离，检测行人等障碍物</p>\n<ul>\n<li>此时应该判断是不是处在左转弯的过程中？【或者说怎样让它具有独特性，而不是全赛道通用的】</li>\n<li>需要判断障碍物是不是消失，障碍物的级别最高，高于人行道，高于车道</li>\n<li>检测到障碍物时：方向设置为50，挡位设置为空，避免来回的摆动</li>\n</ul>\n<p><strong>重新启动</strong></p>\n<ul>\n<li>应当保持停车前的运行方向不变</li>\n<li>检测重新启动后的小车运动方向</li>\n<li>重新可以设置方向和挡位（也就是说在斑马线期间视觉确实也是在启动的，只不过不能修改方向值）</li>\n</ul>\n<p><strong>交叉区域</strong></p>\n<p>激光雷达slam，可以在中间交叉区域通过判断两边距离是否一致从而实现</p>\n<p><strong>右转弯</strong></p>\n<p>视觉可以实现比较好的操作</p>\n<p><strong>限速操作</strong></p>\n<p>我们把限制后的速度调整为10，限速前应当能够按照15-20进行运动</p>\n<p>注意限速和转角之间的配合关系，需要进行测试</p>\n<p>这边转弯的过程中限速和转角是不是能很好地进行配合</p>\n<p><strong>停车</strong></p>\n<p>首先识别到黄灯，开始进入停车识别</p>\n<p>然后识别车的位姿，是不是和右侧挡板平行（使用激光雷达）</p>\n<p>满足和右侧挡板平行，或者能够保持一定的距离，进行驶入</p>\n<p>最后当看不到黄灯、或者红灯后，进行延时，从而确保停车完毕</p>\n<ul>\n<li>注意不能压线，不能碰挡板</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">camera --&gt; l(laneDetection)</span><br><span class=\"line\">l --&gt; images</span><br><span class=\"line\">l --&gt; l2(lane_vel:topic)</span><br><span class=\"line\">l2 -.- res1[有效信息只有angle_z]</span><br><span class=\"line\">l2 --&gt; s1((servoNode))</span><br><span class=\"line\"></span><br><span class=\"line\">h[hilens] --&gt; t1(traffic_light)</span><br><span class=\"line\">h --&gt; t2(标识牌信息)</span><br><span class=\"line\">t1 --&gt; s1</span><br><span class=\"line\">t2 --&gt; s1</span><br><span class=\"line\">s1 --&gt; m1(manul)</span><br><span class=\"line\">s1 --&gt; d1(direction)</span><br><span class=\"line\">s1 --&gt; s2(speed)</span><br><span class=\"line\">s1 --&gt; g(gear)</span><br><span class=\"line\"></span><br><span class=\"line\">m1 -.- res2[自动手动]</span><br><span class=\"line\">d1 -.- res3[方向]</span><br><span class=\"line\">s2 -.- res4[速度]</span><br><span class=\"line\">g -.- res5[挡位]</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-scan话题无法读取的问题\"><a href=\"#8-scan话题无法读取的问题\" class=\"headerlink\" title=\"8. /scan话题无法读取的问题\"></a>8. /scan话题无法读取的问题</h3><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/qq_38441692/article/details/98205852\" target=\"_blank\" rel=\"noopener\">ROS多机通讯踩坑，（主机和从机之间可以订阅话题，但是看不到话题消息）</a></p>\n<p><a href=\"https://answers.ros.org/question/48240/rostopic-list-works-but-rostopic-echo-does-not/\" target=\"_blank\" rel=\"noopener\"><strong>rostopic list works but rostopic echo does not</strong></a></p>\n</blockquote>\n<p>该问题已经解决，使用/rosout进行读取</p>"},{"title":"数据库-SQL语言","date":"2021-03-03T08:33:27.000Z","_content":"\n怎么样建立起一个数据仓库的\n\n- 肯定不是说把 csv 数据导入 mysql 这么简单，确实就像 布迩 说的，我这个算是别人建好的数据仓库\n- 那么究竟怎样才是自己建立数据仓库呢？\n\ncsv 文件导入 MySQL：\n\n```mysql\nload data infile 'F:/MySqlData/test1.csv' -- CSV文件存放路径\ninto table student -- 要将数据导入的表名\nfields terminated by '列的分隔符' optionally enclosed by '\"' escaped by '\"'\nlines terminated by '\\r\\n' -- 回车换行符;\n```\n\n如果是linux下生成的文件，就是 `\\n` 结尾\n\n注意：这个东西很有可能会出现各种的报错，需要修改配置文件等内容\n\n<!--more-->\n\n> 参考：[将csv的数据导入mysql](https://www.cnblogs.com/yoyotl/p/9858587.html)\n\n语句\n\n```mysql\nselect * from student;\n```\n\n> 怎么样构建一个数据仓库\n>\n> 数据库索引的原则\n>\n> 数据库面试常见的问题\n>\n> 数据库面经找一找\n\n# SQL\n\nStructured Query Language 结构化查询语言\n\nRDBMS 关系数据库管理系统\n\n`use database;` 选择数据库\n\n`set names utf8;` 设置使用的字符集\n\n> SQL 对大小写不敏感\n>\n> 分号是分隔SQL语句的标准方法\n\n`CREATE DATABASE` 创建新的数据库\n\n`ALTER DATABASE` 修改数据库\n\n`UPDATE` 更新数据库中的数据\n\n`DELETE` 删除数据库中的数据\n\n`INSERT INTO` 向数据库中插入新数据\n\n---\n\n`CREATE TABLE` 创建新表\n\n`ALTER TABLE` 变更（改变）数据库表\n\n`DROP TABLE` 删除表\n\n---\n\n`CREATE INDEX` 创建索引（搜索键）\n\n`DROP INDEX` 删除索引\n\n> 数据库 database 和 表 table 的区别\n>\n> SQL 和 MySQL 的关系\n>\n> SQL 有很多种，包括 SQL Sever/MS Access, MySQL, Oracle，SQL是语言，MySQL 是一种数据库软件\n\n## 语句\n\n### 创建\n\n创建数据库\n\n`CREATE DATABASE db_name`\n\n创建数据表\n\n```sql\nCREATE TABLE table_name\n(\nID int,\nName varchar(255),\nAddress varchar(255),\nCity varchar(255)\n);\n```\n\n然后可以使用 `INSERT INTO` 向表中插入数据\n\n可以对数据表内容进行约束，保证合规：\n\n创建表时可以针对列进行内容的约束：\n\n```sql\nCREATE TABLE table_name\n(\nID int constraint_name AUTO INCREMENT,\nName varchar(255) constraint_name,\nAddress varchar(255) constraint_name,\nCity varchar(255) DEFAULT ‘Sandnes’,\nUNIQUE (ID),\nPRIMARY KEY (Name),\nCHECK (ID>0)\n);\n```\n\n这里写的 `constraint_name` 可以是：\n\n- NOT NULL  -  不能存储 NULL 值；再修改 为 “NULL”就可以存储 NULL 值了\n- UNIQUE - 为列或者多个列提供唯一性的保证，一个表可以有多个，mysql需要单独在最后声明 `UNIQUE (P_Id)`\n- PRIMARY KEY - 为列或者多个列提供唯一性的保证，但是每个表只能有一个\n- FOREIGN KEY - 保护表直接的连接，可能有某个列是两个表之间的连接外键\n- CHECK - 限制列中值的范围\n- DEFAULT - 向列中插入默认值\n\n如果表已经建立好了，可以使用\n\n `ALTER TABLE table_name MODIFY column_name type constrain_name;`\n\n这些约束也可以删除，要使用 `ALTER TABLE table_name xxx constrain_name` 语句\n\n其中xxx 位置：\n\n- NOT NULL 用 MODIFY\n- UNIQUE 用 DROP\n- PRIMARY 用 DROP\n- FOREIGN 用 DROP\n- CHECK 用 DROP\n- DEFAULT 用 DROP\n\n`AUTO INCREMENT` 字段，每次插入新记录时，会自动地创建主键字段的值 \n\n比如上面的例子中，ID就是这样的字段，默认开始值是1（也可以自己设置起始值），每条新纪录递增1\n\n这样的话，向表中添加数据时，不需要为 ID 字段规定值（会自动生成）\n\n### 索引\n\n为了更快地查找数据，可以创建索引\n\n> 但是索引是看不到的！\n\n更新一个包含索引的表更花时间\n\n一般只在最常搜索的列创建索引\n\n`CREATE INDEX index_name ON table_name (column_name)` 创建简单索引，可以使用重复的值\n\n`CREATE UNIQUE INDEX index_name ON table_name (column_name)` 创建唯一索引，不能使用重复的值（两个行不能索引值相同）\n\n### 读取\n\n`SELECT * FROM database;` 读取数据表的信息\n\n- `*` 表示全部\n- `*` 的位置可以被替换为一个或者多个列的 列名，多个列名之间用 `,` 进行区分\n- 结果会存储在一个**结果表**中 —— **结果集**\n\n上面的搜索中一个列可能会包含多个重复值，可以用\n\n`SELECT DISTINCT * FROM table_name;` 就会只取出要选的那一列中不重复的值\n\n要选取前多少个数据，使用到  `TOP` 语句，但是这个语句在不同的sql 语言种是不一样的，以 MySQL 为例，使用 `LIMIT` 进行限定：\n\n```sql\nSELECT column_name(s)\nFROM table_name\nLIMIT number;\n```\n\n可以选择满足条件的前 number 条记录\n\n\n\n---\n\n```sql\nSELECT *\nFROM table_name\nWHERE column_name = value1\nAND column_name > value2\n```\n\n如果 value 是数值，不用引号\n\n如果 value 是文本值，要用引号\n\nWHERE 子句中的运算符\n\n- = 等于\n- <> 不等于\n- BETWEEN 在某个范围内 `BETWEEN value1 AND value2`\n  - 介于 value1 和 value2 之间\n  - 也可以添加 `NOT` 表示不在某个区间，比如 `NOT BETWEEN xxx`\n  - value1 和 value2 可以都是数字，**也可以是字母**，还可以是日期date（`2016-05-10` 之类的）\n  - MySQL中，BETWEEN 区间 是**包括两个边界的值**的！ NOT BETWEEN 就不包括两个边界的值了\n- LIKE 搜索某种模式 `LIKE pattern` \n  - 这个指定模式是用通配符来进行设定的\n  - 比如 `G%`  表示以 G 开头的字符值\n  - 还可以使用  `NOT LIKE pattern` 排除某个模式\n- IN 指定针对某个列的多个可能值\n  - 使用在指向比较明确的场合\n  - 比如 `WHERE column_name IN (value1, value2, ...)`\n  - 那么该 column 的值一定要在指定的 value 中\n  - IN 和 = 的区别是，IN 可以规定多个值，= 只能规定一个值，可以互相转换，使用 `OR`\n\n> 通配符\n>\n> - `%` 替代0-n个字符\n> - `-` 替代 1 个字符\n>\n> 正则表达式\n>\n> `REGEXP 'pattern'`和 `NOT REGEXP`\n>\n> （或者`RLIKE`和 `NOTRLIKE`）\n>\n> 例如\n>\n> ```sql\n> SELECT * FROM table_name\n> WHERE column_name REGEXP '^[A-H]'\n> ```\n>\n> 表示的是以A到H 开头的字符\n>\n> `REGEXP '^[^A-H]'` 表示的是，不以A到H开头的字符\n\n子句\n\n`AND`  两个条件都成立，才会显示一条记录\n\n`OR` 两个条件有一个成立，就会显示一条记录\n\n这两个符号可以结合起来，还可以加括号，这样构成复杂语句\n\n```SQL\nSELECT column_name\nFROM table_name\nORDER BY column_name ASC|DESC;\n```\n\n`ORDER BY` 对结果集按照某个列（或者某几个列）进行排序\n\n`DESC` 是按照降序排序\n\n> 如果按照多个列进行排序\n>\n> 先按照第一列，然后按照第二个列，两个列都会考虑\n>\n> 比如\n>\n> ![image-20210302223234109](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210302223234109.png)\n\n### 增删改\n\n```sql\nINSERT INTO table_name (column1, column2, column3)\nVALUES (value1, value2, value3,...);\n```\n\n`INSERT INTO`\n\n可以用来插入一个新行的数据\n\n也可以指定某几个列插入数值，没有说到的列就是0\n\n> 列表的第一列是“id”\n>\n> “id”会自动更新\n\n【MySQL不支持】`SELECT INSERT INTO`用来从一个表中复制数据（行），然后把数据插入到另一个新表【这个表原本不存在】中\n\n【MySQL 支持】`INSERT INTO ... SELECT` 也是用来从一个表中复制数据（行），然后插入到一个已存在的表中【这个被插入的表中已经存在的行不会受影响】\n\n```sql\nINSERT INTO table2\n(column_names)\nSELECT column_names\nFROM table1;\n```\n\n`ALTER TABLE` 添加、删除、修改列\n\n`ALTER TABLE table_name ADD column_name datatype`  添加列\n\n删除，alter … drop\n\n修改表中数据的类型  alter … modify \n\n```sql\nUPDATE table_name\nSET column1=value1, column2=value2, ...\nWHERE some_column=some_value;\n```\n\n`UPDATE` 语句可以用来更新表中的记录\n\n注意一定要使用 `WHERE` 语句来限定需要更新的记录，要不然，所有记录都会被更新\n\n```SQL\nDELETE FROM table_name\nWHERE some_column=some_value;\n```\n\n`DELETE` 语句用来删除表中的记录（行）\n\n注意要使用 `WHERE` 语句限定需要删除的记录，否则所有记录会被删除\n\n> 删库跑路\n>\n> `DELETE * FROM table_name;`\n>\n> 或者 `DELETE FROM table_name;` 会删除全部行\n\n`DROP` 可以用来删除 索引、表和数据库\n\n`ALTER TABLE table_name DROP INDEX index_name`  删除表中的索引\n\n`DROP TABLE table_name` 删除表\n\n`DROP DATABASE db_name` 删除数据库\n\n`TRUNCATE TABLE table_name` 删除表内数据，但不删除表本身\n\n### 起别名 AS\n\n```sql\nSELECT column_name AS alias_name FROM table_name;  -- 给列起别名\nSELECT column_name FROM table_name AS alias_name;  -- 给表起别名\n```\n\n多个列需要分别 AS\n\n`CONCAT (column1, column2) AS column3` 可以将多个列结合在一起，创建一个 column3 的别名\n\n```sql\nSELECT name, CONCAT(url, ',', alexa, ',', conntry) AS site_info FROM table_name;\n```\n\n起别名对于在多个表中进行混合查询比较有利，比如\n\n```sql\nSELECT w.name, w.url, a.count, a.data\nFROM Websites AS w, access_log AS a\nWHERE a.site_id=w.id and w.name=\"菜鸟教程\"\n```\n\n总结来说，别名的好处就是：\n\n- 查询多个表\n- 查询中使用了函数\n- 列名称很长\n- 多列结合\n\n比较方便\n\n> 如果在多个表中进行查询，不同表中的列名需要添加各自的前缀\n\n### 多表合并\n\nSQL join 用于把来自两个或者多个表的行结合起来\n\n主要分四类\n\n- LEFT JOIN - 即使右表没有匹配，也会从左表返回行\n- RIGHT JOIN - 即使左表没有匹配，也会从右表返回行\n- INNER JOIN - 在表中存在至少一个匹配时返回行【比如表A的行，在表B中没有匹配，那么这些行就不会列出】\n- FULL JOIN - 只要一个表存在匹配，就返回行 ==但是MySQL中不支持 FULL OUTER JOIN==\n\n但是具体还有方法，总共有7种相关的用法\n\n最常见：`INNER JOIN` 从多个表中返回满足JOIN条件的所有行\n\n```sql\nSELECT w.id, w.name, a.count, a.date\nFROM Websites as w\nINNER JOIN access_log as a\nON w.id=a.site_id;\n```\n\nON  后面会跟随连接的条件【也就是说，两个表是通过这个参数列连起来的】\n\n最后返回的结果集中，将只包含所搜寻的四个参数：w.id, w.name, a.count, a.date\n\n```sql\nSELECT w.name, a.count, a.date\nFROM Websites as w\nLEFT JOIN access_log as a\nON w.id=a.site_id\nORDERED BY a.count DESC;\n```\n\n即使 表 a（access） 中没有与 w.id 相同的 site_id， 那么 w.id 所在的数据还是会存在于结果中\n\n这个时候，这一行里面没有的元素就会用 `NULL` 来填充\n\n`RIGHT JOIN` 是相似的\n\n`UNION` 操作符：合并多个 SELECT 语句的结果集\n\n有两种用法：\n\n第一种是 `UNION`，那么不会保留重复值\n\n```sql\nSELECT country FROM Websites\nUNION\nSELECT country FROM apps\nORDER BY country;\n```\n\n另一种是 `UNION ALL`，会保留重复值\n\n还可以在加上 `WHERE` 等语句 再进行筛选\n\n> `WHERE` 语句一般加在 `ORDER BY` 前面\n\n### 视图（VIEWS）\n\n视图 - 可视化的表\n\n感觉很像是从表中选择了部分数据，不是特别具体\n\n似乎 Northwind 样本数据库使用的比较多\n\n### MySQL 中的时间 Dates\n\n有一些内建时间函数，可以参考：https://runoob.com/sql/sql-dates.html\n\n比如 NOW() 返回当前的时间和日期 - 分为两个部分 CURDATE() 是当前的日期，CURTIME() 是当前的时间\n\n可以使用 `DATA_FORMATE(date, format)` 函数来指定 想要的显示 日期/时间数据的格式，format 部分就是正则式\n\n## 数据类型\n\nNULL - 遗漏的未知数值，不是0，不能和0比较\n\n要选用 为 NULL 的数值，应该用 `WHERE column_name IS NULL`\n\n不选用，则是 `IS NOT NULL`\n\nMySQL 中还有 `IFNULL(column_name, 0)`函数，用来处理，如果这个值是 NULL，那么就会转化为0\n\n或者 `COALESCE(column_name, 0)` 函数，如果是NULL，转为0\n\nSQL中常用的数据类型，以Mysql为例子：\n\n- int\n- float\n- Char - 也就是 string，最多255，固定长度\n- Varchar - 也就是string（variable）一类的， 可变长度，最多255\n- blob或者 text - 也就是 binary object\n\n每种具体的数据库里面可能是不太一样的\n\nMysql中主要三类\n\n- Text 类型，也分 tiny、medium、long的\n- number 类型，分 tiny、small、medium、big、float、double等\n- date 类型，分日期的、日期时间的、时间戳（timestamp）、年的\n\n### 注释\n\n\n注释方法：\n\n- `–` 单行注释，两个 - ，加一个空格\n- `#` 单行注释\n- `/* */` 多行注释\n\n> 自检查：[SQL数据库面试题以及答案（50例题）](https://blog.csdn.net/hundan_520520/article/details/54881208?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=1328593.8838.16147378952884227&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control)\n\n## 常用原则\n\n> 参考：[数据库常见面试题（附答案）](https://blog.csdn.net/qq_22222499/article/details/79060495)\n\n基本表的性质【事务四大特征】\n\n- 原子性：要么执行，要么不执行\n- 隔离性：所有操作全部执行完以前，其他会话不能看到过程\n- 一致性：事务前后，数据总额一致\n- 持久性：一旦事务提交，对数据的改变是永久的\n\n索引分类（5种），索引失效条件\n\n- 普通索引：最基本的索引，没有任何限制\n- 唯一索引：索引列的值必须唯一，可以空值\n- 主键索引：唯一索引，不允许空值\n- 全文索引：耗时耗空间\n- 组合索引：提高效率，遵循“最左前缀”原则\n\n关于数据库有几种索引\n\n- 按索引列的唯一性，可以分为唯一索引和非唯一索引\n- 按索引列的个数：单列索引和符合索引\n- 按索引列的物理组织方式：B树索引、位图索引、反向键索引、函数索引、删除索引、重建索引\n","source":"_posts/数据库-SQL语言.md","raw":"---\ntitle: 数据库-SQL语言\ndate: 2021-03-03 16:33:27\ncategories:\n\t- Data Analysis\ntags:\n\t- MySQL\n\t- DataBases\n---\n\n怎么样建立起一个数据仓库的\n\n- 肯定不是说把 csv 数据导入 mysql 这么简单，确实就像 布迩 说的，我这个算是别人建好的数据仓库\n- 那么究竟怎样才是自己建立数据仓库呢？\n\ncsv 文件导入 MySQL：\n\n```mysql\nload data infile 'F:/MySqlData/test1.csv' -- CSV文件存放路径\ninto table student -- 要将数据导入的表名\nfields terminated by '列的分隔符' optionally enclosed by '\"' escaped by '\"'\nlines terminated by '\\r\\n' -- 回车换行符;\n```\n\n如果是linux下生成的文件，就是 `\\n` 结尾\n\n注意：这个东西很有可能会出现各种的报错，需要修改配置文件等内容\n\n<!--more-->\n\n> 参考：[将csv的数据导入mysql](https://www.cnblogs.com/yoyotl/p/9858587.html)\n\n语句\n\n```mysql\nselect * from student;\n```\n\n> 怎么样构建一个数据仓库\n>\n> 数据库索引的原则\n>\n> 数据库面试常见的问题\n>\n> 数据库面经找一找\n\n# SQL\n\nStructured Query Language 结构化查询语言\n\nRDBMS 关系数据库管理系统\n\n`use database;` 选择数据库\n\n`set names utf8;` 设置使用的字符集\n\n> SQL 对大小写不敏感\n>\n> 分号是分隔SQL语句的标准方法\n\n`CREATE DATABASE` 创建新的数据库\n\n`ALTER DATABASE` 修改数据库\n\n`UPDATE` 更新数据库中的数据\n\n`DELETE` 删除数据库中的数据\n\n`INSERT INTO` 向数据库中插入新数据\n\n---\n\n`CREATE TABLE` 创建新表\n\n`ALTER TABLE` 变更（改变）数据库表\n\n`DROP TABLE` 删除表\n\n---\n\n`CREATE INDEX` 创建索引（搜索键）\n\n`DROP INDEX` 删除索引\n\n> 数据库 database 和 表 table 的区别\n>\n> SQL 和 MySQL 的关系\n>\n> SQL 有很多种，包括 SQL Sever/MS Access, MySQL, Oracle，SQL是语言，MySQL 是一种数据库软件\n\n## 语句\n\n### 创建\n\n创建数据库\n\n`CREATE DATABASE db_name`\n\n创建数据表\n\n```sql\nCREATE TABLE table_name\n(\nID int,\nName varchar(255),\nAddress varchar(255),\nCity varchar(255)\n);\n```\n\n然后可以使用 `INSERT INTO` 向表中插入数据\n\n可以对数据表内容进行约束，保证合规：\n\n创建表时可以针对列进行内容的约束：\n\n```sql\nCREATE TABLE table_name\n(\nID int constraint_name AUTO INCREMENT,\nName varchar(255) constraint_name,\nAddress varchar(255) constraint_name,\nCity varchar(255) DEFAULT ‘Sandnes’,\nUNIQUE (ID),\nPRIMARY KEY (Name),\nCHECK (ID>0)\n);\n```\n\n这里写的 `constraint_name` 可以是：\n\n- NOT NULL  -  不能存储 NULL 值；再修改 为 “NULL”就可以存储 NULL 值了\n- UNIQUE - 为列或者多个列提供唯一性的保证，一个表可以有多个，mysql需要单独在最后声明 `UNIQUE (P_Id)`\n- PRIMARY KEY - 为列或者多个列提供唯一性的保证，但是每个表只能有一个\n- FOREIGN KEY - 保护表直接的连接，可能有某个列是两个表之间的连接外键\n- CHECK - 限制列中值的范围\n- DEFAULT - 向列中插入默认值\n\n如果表已经建立好了，可以使用\n\n `ALTER TABLE table_name MODIFY column_name type constrain_name;`\n\n这些约束也可以删除，要使用 `ALTER TABLE table_name xxx constrain_name` 语句\n\n其中xxx 位置：\n\n- NOT NULL 用 MODIFY\n- UNIQUE 用 DROP\n- PRIMARY 用 DROP\n- FOREIGN 用 DROP\n- CHECK 用 DROP\n- DEFAULT 用 DROP\n\n`AUTO INCREMENT` 字段，每次插入新记录时，会自动地创建主键字段的值 \n\n比如上面的例子中，ID就是这样的字段，默认开始值是1（也可以自己设置起始值），每条新纪录递增1\n\n这样的话，向表中添加数据时，不需要为 ID 字段规定值（会自动生成）\n\n### 索引\n\n为了更快地查找数据，可以创建索引\n\n> 但是索引是看不到的！\n\n更新一个包含索引的表更花时间\n\n一般只在最常搜索的列创建索引\n\n`CREATE INDEX index_name ON table_name (column_name)` 创建简单索引，可以使用重复的值\n\n`CREATE UNIQUE INDEX index_name ON table_name (column_name)` 创建唯一索引，不能使用重复的值（两个行不能索引值相同）\n\n### 读取\n\n`SELECT * FROM database;` 读取数据表的信息\n\n- `*` 表示全部\n- `*` 的位置可以被替换为一个或者多个列的 列名，多个列名之间用 `,` 进行区分\n- 结果会存储在一个**结果表**中 —— **结果集**\n\n上面的搜索中一个列可能会包含多个重复值，可以用\n\n`SELECT DISTINCT * FROM table_name;` 就会只取出要选的那一列中不重复的值\n\n要选取前多少个数据，使用到  `TOP` 语句，但是这个语句在不同的sql 语言种是不一样的，以 MySQL 为例，使用 `LIMIT` 进行限定：\n\n```sql\nSELECT column_name(s)\nFROM table_name\nLIMIT number;\n```\n\n可以选择满足条件的前 number 条记录\n\n\n\n---\n\n```sql\nSELECT *\nFROM table_name\nWHERE column_name = value1\nAND column_name > value2\n```\n\n如果 value 是数值，不用引号\n\n如果 value 是文本值，要用引号\n\nWHERE 子句中的运算符\n\n- = 等于\n- <> 不等于\n- BETWEEN 在某个范围内 `BETWEEN value1 AND value2`\n  - 介于 value1 和 value2 之间\n  - 也可以添加 `NOT` 表示不在某个区间，比如 `NOT BETWEEN xxx`\n  - value1 和 value2 可以都是数字，**也可以是字母**，还可以是日期date（`2016-05-10` 之类的）\n  - MySQL中，BETWEEN 区间 是**包括两个边界的值**的！ NOT BETWEEN 就不包括两个边界的值了\n- LIKE 搜索某种模式 `LIKE pattern` \n  - 这个指定模式是用通配符来进行设定的\n  - 比如 `G%`  表示以 G 开头的字符值\n  - 还可以使用  `NOT LIKE pattern` 排除某个模式\n- IN 指定针对某个列的多个可能值\n  - 使用在指向比较明确的场合\n  - 比如 `WHERE column_name IN (value1, value2, ...)`\n  - 那么该 column 的值一定要在指定的 value 中\n  - IN 和 = 的区别是，IN 可以规定多个值，= 只能规定一个值，可以互相转换，使用 `OR`\n\n> 通配符\n>\n> - `%` 替代0-n个字符\n> - `-` 替代 1 个字符\n>\n> 正则表达式\n>\n> `REGEXP 'pattern'`和 `NOT REGEXP`\n>\n> （或者`RLIKE`和 `NOTRLIKE`）\n>\n> 例如\n>\n> ```sql\n> SELECT * FROM table_name\n> WHERE column_name REGEXP '^[A-H]'\n> ```\n>\n> 表示的是以A到H 开头的字符\n>\n> `REGEXP '^[^A-H]'` 表示的是，不以A到H开头的字符\n\n子句\n\n`AND`  两个条件都成立，才会显示一条记录\n\n`OR` 两个条件有一个成立，就会显示一条记录\n\n这两个符号可以结合起来，还可以加括号，这样构成复杂语句\n\n```SQL\nSELECT column_name\nFROM table_name\nORDER BY column_name ASC|DESC;\n```\n\n`ORDER BY` 对结果集按照某个列（或者某几个列）进行排序\n\n`DESC` 是按照降序排序\n\n> 如果按照多个列进行排序\n>\n> 先按照第一列，然后按照第二个列，两个列都会考虑\n>\n> 比如\n>\n> ![image-20210302223234109](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210302223234109.png)\n\n### 增删改\n\n```sql\nINSERT INTO table_name (column1, column2, column3)\nVALUES (value1, value2, value3,...);\n```\n\n`INSERT INTO`\n\n可以用来插入一个新行的数据\n\n也可以指定某几个列插入数值，没有说到的列就是0\n\n> 列表的第一列是“id”\n>\n> “id”会自动更新\n\n【MySQL不支持】`SELECT INSERT INTO`用来从一个表中复制数据（行），然后把数据插入到另一个新表【这个表原本不存在】中\n\n【MySQL 支持】`INSERT INTO ... SELECT` 也是用来从一个表中复制数据（行），然后插入到一个已存在的表中【这个被插入的表中已经存在的行不会受影响】\n\n```sql\nINSERT INTO table2\n(column_names)\nSELECT column_names\nFROM table1;\n```\n\n`ALTER TABLE` 添加、删除、修改列\n\n`ALTER TABLE table_name ADD column_name datatype`  添加列\n\n删除，alter … drop\n\n修改表中数据的类型  alter … modify \n\n```sql\nUPDATE table_name\nSET column1=value1, column2=value2, ...\nWHERE some_column=some_value;\n```\n\n`UPDATE` 语句可以用来更新表中的记录\n\n注意一定要使用 `WHERE` 语句来限定需要更新的记录，要不然，所有记录都会被更新\n\n```SQL\nDELETE FROM table_name\nWHERE some_column=some_value;\n```\n\n`DELETE` 语句用来删除表中的记录（行）\n\n注意要使用 `WHERE` 语句限定需要删除的记录，否则所有记录会被删除\n\n> 删库跑路\n>\n> `DELETE * FROM table_name;`\n>\n> 或者 `DELETE FROM table_name;` 会删除全部行\n\n`DROP` 可以用来删除 索引、表和数据库\n\n`ALTER TABLE table_name DROP INDEX index_name`  删除表中的索引\n\n`DROP TABLE table_name` 删除表\n\n`DROP DATABASE db_name` 删除数据库\n\n`TRUNCATE TABLE table_name` 删除表内数据，但不删除表本身\n\n### 起别名 AS\n\n```sql\nSELECT column_name AS alias_name FROM table_name;  -- 给列起别名\nSELECT column_name FROM table_name AS alias_name;  -- 给表起别名\n```\n\n多个列需要分别 AS\n\n`CONCAT (column1, column2) AS column3` 可以将多个列结合在一起，创建一个 column3 的别名\n\n```sql\nSELECT name, CONCAT(url, ',', alexa, ',', conntry) AS site_info FROM table_name;\n```\n\n起别名对于在多个表中进行混合查询比较有利，比如\n\n```sql\nSELECT w.name, w.url, a.count, a.data\nFROM Websites AS w, access_log AS a\nWHERE a.site_id=w.id and w.name=\"菜鸟教程\"\n```\n\n总结来说，别名的好处就是：\n\n- 查询多个表\n- 查询中使用了函数\n- 列名称很长\n- 多列结合\n\n比较方便\n\n> 如果在多个表中进行查询，不同表中的列名需要添加各自的前缀\n\n### 多表合并\n\nSQL join 用于把来自两个或者多个表的行结合起来\n\n主要分四类\n\n- LEFT JOIN - 即使右表没有匹配，也会从左表返回行\n- RIGHT JOIN - 即使左表没有匹配，也会从右表返回行\n- INNER JOIN - 在表中存在至少一个匹配时返回行【比如表A的行，在表B中没有匹配，那么这些行就不会列出】\n- FULL JOIN - 只要一个表存在匹配，就返回行 ==但是MySQL中不支持 FULL OUTER JOIN==\n\n但是具体还有方法，总共有7种相关的用法\n\n最常见：`INNER JOIN` 从多个表中返回满足JOIN条件的所有行\n\n```sql\nSELECT w.id, w.name, a.count, a.date\nFROM Websites as w\nINNER JOIN access_log as a\nON w.id=a.site_id;\n```\n\nON  后面会跟随连接的条件【也就是说，两个表是通过这个参数列连起来的】\n\n最后返回的结果集中，将只包含所搜寻的四个参数：w.id, w.name, a.count, a.date\n\n```sql\nSELECT w.name, a.count, a.date\nFROM Websites as w\nLEFT JOIN access_log as a\nON w.id=a.site_id\nORDERED BY a.count DESC;\n```\n\n即使 表 a（access） 中没有与 w.id 相同的 site_id， 那么 w.id 所在的数据还是会存在于结果中\n\n这个时候，这一行里面没有的元素就会用 `NULL` 来填充\n\n`RIGHT JOIN` 是相似的\n\n`UNION` 操作符：合并多个 SELECT 语句的结果集\n\n有两种用法：\n\n第一种是 `UNION`，那么不会保留重复值\n\n```sql\nSELECT country FROM Websites\nUNION\nSELECT country FROM apps\nORDER BY country;\n```\n\n另一种是 `UNION ALL`，会保留重复值\n\n还可以在加上 `WHERE` 等语句 再进行筛选\n\n> `WHERE` 语句一般加在 `ORDER BY` 前面\n\n### 视图（VIEWS）\n\n视图 - 可视化的表\n\n感觉很像是从表中选择了部分数据，不是特别具体\n\n似乎 Northwind 样本数据库使用的比较多\n\n### MySQL 中的时间 Dates\n\n有一些内建时间函数，可以参考：https://runoob.com/sql/sql-dates.html\n\n比如 NOW() 返回当前的时间和日期 - 分为两个部分 CURDATE() 是当前的日期，CURTIME() 是当前的时间\n\n可以使用 `DATA_FORMATE(date, format)` 函数来指定 想要的显示 日期/时间数据的格式，format 部分就是正则式\n\n## 数据类型\n\nNULL - 遗漏的未知数值，不是0，不能和0比较\n\n要选用 为 NULL 的数值，应该用 `WHERE column_name IS NULL`\n\n不选用，则是 `IS NOT NULL`\n\nMySQL 中还有 `IFNULL(column_name, 0)`函数，用来处理，如果这个值是 NULL，那么就会转化为0\n\n或者 `COALESCE(column_name, 0)` 函数，如果是NULL，转为0\n\nSQL中常用的数据类型，以Mysql为例子：\n\n- int\n- float\n- Char - 也就是 string，最多255，固定长度\n- Varchar - 也就是string（variable）一类的， 可变长度，最多255\n- blob或者 text - 也就是 binary object\n\n每种具体的数据库里面可能是不太一样的\n\nMysql中主要三类\n\n- Text 类型，也分 tiny、medium、long的\n- number 类型，分 tiny、small、medium、big、float、double等\n- date 类型，分日期的、日期时间的、时间戳（timestamp）、年的\n\n### 注释\n\n\n注释方法：\n\n- `–` 单行注释，两个 - ，加一个空格\n- `#` 单行注释\n- `/* */` 多行注释\n\n> 自检查：[SQL数据库面试题以及答案（50例题）](https://blog.csdn.net/hundan_520520/article/details/54881208?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=1328593.8838.16147378952884227&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control)\n\n## 常用原则\n\n> 参考：[数据库常见面试题（附答案）](https://blog.csdn.net/qq_22222499/article/details/79060495)\n\n基本表的性质【事务四大特征】\n\n- 原子性：要么执行，要么不执行\n- 隔离性：所有操作全部执行完以前，其他会话不能看到过程\n- 一致性：事务前后，数据总额一致\n- 持久性：一旦事务提交，对数据的改变是永久的\n\n索引分类（5种），索引失效条件\n\n- 普通索引：最基本的索引，没有任何限制\n- 唯一索引：索引列的值必须唯一，可以空值\n- 主键索引：唯一索引，不允许空值\n- 全文索引：耗时耗空间\n- 组合索引：提高效率，遵循“最左前缀”原则\n\n关于数据库有几种索引\n\n- 按索引列的唯一性，可以分为唯一索引和非唯一索引\n- 按索引列的个数：单列索引和符合索引\n- 按索引列的物理组织方式：B树索引、位图索引、反向键索引、函数索引、删除索引、重建索引\n","slug":"数据库-SQL语言","published":1,"updated":"2021-03-03T08:43:15.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n895003lk8tlbvvyhohe","content":"<p>怎么样建立起一个数据仓库的</p>\n<ul>\n<li>肯定不是说把 csv 数据导入 mysql 这么简单，确实就像 布迩 说的，我这个算是别人建好的数据仓库</li>\n<li>那么究竟怎样才是自己建立数据仓库呢？</li>\n</ul>\n<p>csv 文件导入 MySQL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load data infile &#39;F:&#x2F;MySqlData&#x2F;test1.csv&#39; -- CSV文件存放路径</span><br><span class=\"line\">into table student -- 要将数据导入的表名</span><br><span class=\"line\">fields terminated by &#39;列的分隔符&#39; optionally enclosed by &#39;&quot;&#39; escaped by &#39;&quot;&#39;</span><br><span class=\"line\">lines terminated by &#39;\\r\\n&#39; -- 回车换行符;</span><br></pre></td></tr></table></figure>\n<p>如果是linux下生成的文件，就是 <code>\\n</code> 结尾</p>\n<p>注意：这个东西很有可能会出现各种的报错，需要修改配置文件等内容</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/yoyotl/p/9858587.html\" target=\"_blank\" rel=\"noopener\">将csv的数据导入mysql</a></p>\n</blockquote>\n<p>语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from student;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>怎么样构建一个数据仓库</p>\n<p>数据库索引的原则</p>\n<p>数据库面试常见的问题</p>\n<p>数据库面经找一找</p>\n</blockquote>\n<h1 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h1><p>Structured Query Language 结构化查询语言</p>\n<p>RDBMS 关系数据库管理系统</p>\n<p><code>use database;</code> 选择数据库</p>\n<p><code>set names utf8;</code> 设置使用的字符集</p>\n<blockquote>\n<p>SQL 对大小写不敏感</p>\n<p>分号是分隔SQL语句的标准方法</p>\n</blockquote>\n<p><code>CREATE DATABASE</code> 创建新的数据库</p>\n<p><code>ALTER DATABASE</code> 修改数据库</p>\n<p><code>UPDATE</code> 更新数据库中的数据</p>\n<p><code>DELETE</code> 删除数据库中的数据</p>\n<p><code>INSERT INTO</code> 向数据库中插入新数据</p>\n<hr>\n<p><code>CREATE TABLE</code> 创建新表</p>\n<p><code>ALTER TABLE</code> 变更（改变）数据库表</p>\n<p><code>DROP TABLE</code> 删除表</p>\n<hr>\n<p><code>CREATE INDEX</code> 创建索引（搜索键）</p>\n<p><code>DROP INDEX</code> 删除索引</p>\n<blockquote>\n<p>数据库 database 和 表 table 的区别</p>\n<p>SQL 和 MySQL 的关系</p>\n<p>SQL 有很多种，包括 SQL Sever/MS Access, MySQL, Oracle，SQL是语言，MySQL 是一种数据库软件</p>\n</blockquote>\n<h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>创建数据库</p>\n<p><code>CREATE DATABASE db_name</code></p>\n<p>创建数据表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\">(</span><br><span class=\"line\"><span class=\"keyword\">ID</span> <span class=\"built_in\">int</span>,</span><br><span class=\"line\"><span class=\"keyword\">Name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">Address <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">City <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>然后可以使用 <code>INSERT INTO</code> 向表中插入数据</p>\n<p>可以对数据表内容进行约束，保证合规：</p>\n<p>创建表时可以针对列进行内容的约束：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\">(</span><br><span class=\"line\"><span class=\"keyword\">ID</span> <span class=\"built_in\">int</span> constraint_name <span class=\"keyword\">AUTO</span> <span class=\"keyword\">INCREMENT</span>,</span><br><span class=\"line\"><span class=\"keyword\">Name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) constraint_name,</span><br><span class=\"line\">Address <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) constraint_name,</span><br><span class=\"line\">City <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> ‘Sandnes’,</span><br><span class=\"line\"><span class=\"keyword\">UNIQUE</span> (<span class=\"keyword\">ID</span>),</span><br><span class=\"line\">PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"keyword\">Name</span>),</span><br><span class=\"line\"><span class=\"keyword\">CHECK</span> (<span class=\"keyword\">ID</span>&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>这里写的 <code>constraint_name</code> 可以是：</p>\n<ul>\n<li>NOT NULL  -  不能存储 NULL 值；再修改 为 “NULL”就可以存储 NULL 值了</li>\n<li>UNIQUE - 为列或者多个列提供唯一性的保证，一个表可以有多个，mysql需要单独在最后声明 <code>UNIQUE (P_Id)</code></li>\n<li>PRIMARY KEY - 为列或者多个列提供唯一性的保证，但是每个表只能有一个</li>\n<li>FOREIGN KEY - 保护表直接的连接，可能有某个列是两个表之间的连接外键</li>\n<li>CHECK - 限制列中值的范围</li>\n<li>DEFAULT - 向列中插入默认值</li>\n</ul>\n<p>如果表已经建立好了，可以使用</p>\n<p> <code>ALTER TABLE table_name MODIFY column_name type constrain_name;</code></p>\n<p>这些约束也可以删除，要使用 <code>ALTER TABLE table_name xxx constrain_name</code> 语句</p>\n<p>其中xxx 位置：</p>\n<ul>\n<li>NOT NULL 用 MODIFY</li>\n<li>UNIQUE 用 DROP</li>\n<li>PRIMARY 用 DROP</li>\n<li>FOREIGN 用 DROP</li>\n<li>CHECK 用 DROP</li>\n<li>DEFAULT 用 DROP</li>\n</ul>\n<p><code>AUTO INCREMENT</code> 字段，每次插入新记录时，会自动地创建主键字段的值 </p>\n<p>比如上面的例子中，ID就是这样的字段，默认开始值是1（也可以自己设置起始值），每条新纪录递增1</p>\n<p>这样的话，向表中添加数据时，不需要为 ID 字段规定值（会自动生成）</p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>为了更快地查找数据，可以创建索引</p>\n<blockquote>\n<p>但是索引是看不到的！</p>\n</blockquote>\n<p>更新一个包含索引的表更花时间</p>\n<p>一般只在最常搜索的列创建索引</p>\n<p><code>CREATE INDEX index_name ON table_name (column_name)</code> 创建简单索引，可以使用重复的值</p>\n<p><code>CREATE UNIQUE INDEX index_name ON table_name (column_name)</code> 创建唯一索引，不能使用重复的值（两个行不能索引值相同）</p>\n<h3 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h3><p><code>SELECT * FROM database;</code> 读取数据表的信息</p>\n<ul>\n<li><code>*</code> 表示全部</li>\n<li><code>*</code> 的位置可以被替换为一个或者多个列的 列名，多个列名之间用 <code>,</code> 进行区分</li>\n<li>结果会存储在一个<strong>结果表</strong>中 —— <strong>结果集</strong></li>\n</ul>\n<p>上面的搜索中一个列可能会包含多个重复值，可以用</p>\n<p><code>SELECT DISTINCT * FROM table_name;</code> 就会只取出要选的那一列中不重复的值</p>\n<p>要选取前多少个数据，使用到  <code>TOP</code> 语句，但是这个语句在不同的sql 语言种是不一样的，以 MySQL 为例，使用 <code>LIMIT</code> 进行限定：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">LIMIT</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n<p>可以选择满足条件的前 number 条记录</p>\n<hr>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> column_name = value1</span><br><span class=\"line\"><span class=\"keyword\">AND</span> column_name &gt; value2</span><br></pre></td></tr></table></figure>\n<p>如果 value 是数值，不用引号</p>\n<p>如果 value 是文本值，要用引号</p>\n<p>WHERE 子句中的运算符</p>\n<ul>\n<li>= 等于</li>\n<li>&lt;&gt; 不等于</li>\n<li>BETWEEN 在某个范围内 <code>BETWEEN value1 AND value2</code><ul>\n<li>介于 value1 和 value2 之间</li>\n<li>也可以添加 <code>NOT</code> 表示不在某个区间，比如 <code>NOT BETWEEN xxx</code></li>\n<li>value1 和 value2 可以都是数字，<strong>也可以是字母</strong>，还可以是日期date（<code>2016-05-10</code> 之类的）</li>\n<li>MySQL中，BETWEEN 区间 是<strong>包括两个边界的值</strong>的！ NOT BETWEEN 就不包括两个边界的值了</li>\n</ul>\n</li>\n<li>LIKE 搜索某种模式 <code>LIKE pattern</code> <ul>\n<li>这个指定模式是用通配符来进行设定的</li>\n<li>比如 <code>G%</code>  表示以 G 开头的字符值</li>\n<li>还可以使用  <code>NOT LIKE pattern</code> 排除某个模式</li>\n</ul>\n</li>\n<li>IN 指定针对某个列的多个可能值<ul>\n<li>使用在指向比较明确的场合</li>\n<li>比如 <code>WHERE column_name IN (value1, value2, ...)</code></li>\n<li>那么该 column 的值一定要在指定的 value 中</li>\n<li>IN 和 = 的区别是，IN 可以规定多个值，= 只能规定一个值，可以互相转换，使用 <code>OR</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>通配符</p>\n<ul>\n<li><code>%</code> 替代0-n个字符</li>\n<li><code>-</code> 替代 1 个字符</li>\n</ul>\n<p>正则表达式</p>\n<p><code>REGEXP &#39;pattern&#39;</code>和 <code>NOT REGEXP</code></p>\n<p>（或者<code>RLIKE</code>和 <code>NOTRLIKE</code>）</p>\n<p>例如</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> column_name REGEXP <span class=\"string\">'^[A-H]'</span></span><br></pre></td></tr></table></figure>\n<p>表示的是以A到H 开头的字符</p>\n<p><code>REGEXP &#39;^[^A-H]&#39;</code> 表示的是，不以A到H开头的字符</p>\n</blockquote>\n<p>子句</p>\n<p><code>AND</code>  两个条件都成立，才会显示一条记录</p>\n<p><code>OR</code> 两个条件有一个成立，就会显示一条记录</p>\n<p>这两个符号可以结合起来，还可以加括号，这样构成复杂语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> column_name <span class=\"keyword\">ASC</span>|<span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<p><code>ORDER BY</code> 对结果集按照某个列（或者某几个列）进行排序</p>\n<p><code>DESC</code> 是按照降序排序</p>\n<blockquote>\n<p>如果按照多个列进行排序</p>\n<p>先按照第一列，然后按照第二个列，两个列都会考虑</p>\n<p>比如</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210302223234109.png\" alt=\"image-20210302223234109\"></p>\n</blockquote>\n<h3 id=\"增删改\"><a href=\"#增删改\" class=\"headerlink\" title=\"增删改\"></a>增删改</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table_name (column1, column2, column3)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (value1, value2, value3,...);</span><br></pre></td></tr></table></figure>\n<p><code>INSERT INTO</code></p>\n<p>可以用来插入一个新行的数据</p>\n<p>也可以指定某几个列插入数值，没有说到的列就是0</p>\n<blockquote>\n<p>列表的第一列是“id”</p>\n<p>“id”会自动更新</p>\n</blockquote>\n<p>【MySQL不支持】<code>SELECT INSERT INTO</code>用来从一个表中复制数据（行），然后把数据插入到另一个新表【这个表原本不存在】中</p>\n<p>【MySQL 支持】<code>INSERT INTO ... SELECT</code> 也是用来从一个表中复制数据（行），然后插入到一个已存在的表中【这个被插入的表中已经存在的行不会受影响】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table2</span><br><span class=\"line\">(column_names)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column_names</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1;</span><br></pre></td></tr></table></figure>\n<p><code>ALTER TABLE</code> 添加、删除、修改列</p>\n<p><code>ALTER TABLE table_name ADD column_name datatype</code>  添加列</p>\n<p>删除，alter … drop</p>\n<p>修改表中数据的类型  alter … modify </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">SET</span> column1=value1, column2=value2, ...</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure>\n<p><code>UPDATE</code> 语句可以用来更新表中的记录</p>\n<p>注意一定要使用 <code>WHERE</code> 语句来限定需要更新的记录，要不然，所有记录都会被更新</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure>\n<p><code>DELETE</code> 语句用来删除表中的记录（行）</p>\n<p>注意要使用 <code>WHERE</code> 语句限定需要删除的记录，否则所有记录会被删除</p>\n<blockquote>\n<p>删库跑路</p>\n<p><code>DELETE * FROM table_name;</code></p>\n<p>或者 <code>DELETE FROM table_name;</code> 会删除全部行</p>\n</blockquote>\n<p><code>DROP</code> 可以用来删除 索引、表和数据库</p>\n<p><code>ALTER TABLE table_name DROP INDEX index_name</code>  删除表中的索引</p>\n<p><code>DROP TABLE table_name</code> 删除表</p>\n<p><code>DROP DATABASE db_name</code> 删除数据库</p>\n<p><code>TRUNCATE TABLE table_name</code> 删除表内数据，但不删除表本身</p>\n<h3 id=\"起别名-AS\"><a href=\"#起别名-AS\" class=\"headerlink\" title=\"起别名 AS\"></a>起别名 AS</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name <span class=\"keyword\">AS</span> alias_name <span class=\"keyword\">FROM</span> table_name;  <span class=\"comment\">-- 给列起别名</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name <span class=\"keyword\">FROM</span> table_name <span class=\"keyword\">AS</span> alias_name;  <span class=\"comment\">-- 给表起别名</span></span><br></pre></td></tr></table></figure>\n<p>多个列需要分别 AS</p>\n<p><code>CONCAT (column1, column2) AS column3</code> 可以将多个列结合在一起，创建一个 column3 的别名</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, <span class=\"keyword\">CONCAT</span>(<span class=\"keyword\">url</span>, <span class=\"string\">','</span>, alexa, <span class=\"string\">','</span>, conntry) <span class=\"keyword\">AS</span> site_info <span class=\"keyword\">FROM</span> table_name;</span><br></pre></td></tr></table></figure>\n<p>起别名对于在多个表中进行混合查询比较有利，比如</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> w.name, w.url, a.count, a.data</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Websites <span class=\"keyword\">AS</span> w, access_log <span class=\"keyword\">AS</span> a</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> a.site_id=w.id <span class=\"keyword\">and</span> w.name=<span class=\"string\">\"菜鸟教程\"</span></span><br></pre></td></tr></table></figure>\n<p>总结来说，别名的好处就是：</p>\n<ul>\n<li>查询多个表</li>\n<li>查询中使用了函数</li>\n<li>列名称很长</li>\n<li>多列结合</li>\n</ul>\n<p>比较方便</p>\n<blockquote>\n<p>如果在多个表中进行查询，不同表中的列名需要添加各自的前缀</p>\n</blockquote>\n<h3 id=\"多表合并\"><a href=\"#多表合并\" class=\"headerlink\" title=\"多表合并\"></a>多表合并</h3><p>SQL join 用于把来自两个或者多个表的行结合起来</p>\n<p>主要分四类</p>\n<ul>\n<li>LEFT JOIN - 即使右表没有匹配，也会从左表返回行</li>\n<li>RIGHT JOIN - 即使左表没有匹配，也会从右表返回行</li>\n<li>INNER JOIN - 在表中存在至少一个匹配时返回行【比如表A的行，在表B中没有匹配，那么这些行就不会列出】</li>\n<li>FULL JOIN - 只要一个表存在匹配，就返回行 ==但是MySQL中不支持 FULL OUTER JOIN==</li>\n</ul>\n<p>但是具体还有方法，总共有7种相关的用法</p>\n<p>最常见：<code>INNER JOIN</code> 从多个表中返回满足JOIN条件的所有行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> w.id, w.name, a.count, a.date</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Websites <span class=\"keyword\">as</span> w</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> access_log <span class=\"keyword\">as</span> a</span><br><span class=\"line\"><span class=\"keyword\">ON</span> w.id=a.site_id;</span><br></pre></td></tr></table></figure>\n<p>ON  后面会跟随连接的条件【也就是说，两个表是通过这个参数列连起来的】</p>\n<p>最后返回的结果集中，将只包含所搜寻的四个参数：w.id, w.name, a.count, a.date</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> w.name, a.count, a.date</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Websites <span class=\"keyword\">as</span> w</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> access_log <span class=\"keyword\">as</span> a</span><br><span class=\"line\"><span class=\"keyword\">ON</span> w.id=a.site_id</span><br><span class=\"line\">ORDERED <span class=\"keyword\">BY</span> a.count <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<p>即使 表 a（access） 中没有与 w.id 相同的 site_id， 那么 w.id 所在的数据还是会存在于结果中</p>\n<p>这个时候，这一行里面没有的元素就会用 <code>NULL</code> 来填充</p>\n<p><code>RIGHT JOIN</code> 是相似的</p>\n<p><code>UNION</code> 操作符：合并多个 SELECT 语句的结果集</p>\n<p>有两种用法：</p>\n<p>第一种是 <code>UNION</code>，那么不会保留重复值</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> country <span class=\"keyword\">FROM</span> Websites</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> country <span class=\"keyword\">FROM</span> apps</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> country;</span><br></pre></td></tr></table></figure>\n<p>另一种是 <code>UNION ALL</code>，会保留重复值</p>\n<p>还可以在加上 <code>WHERE</code> 等语句 再进行筛选</p>\n<blockquote>\n<p><code>WHERE</code> 语句一般加在 <code>ORDER BY</code> 前面</p>\n</blockquote>\n<h3 id=\"视图（VIEWS）\"><a href=\"#视图（VIEWS）\" class=\"headerlink\" title=\"视图（VIEWS）\"></a>视图（VIEWS）</h3><p>视图 - 可视化的表</p>\n<p>感觉很像是从表中选择了部分数据，不是特别具体</p>\n<p>似乎 Northwind 样本数据库使用的比较多</p>\n<h3 id=\"MySQL-中的时间-Dates\"><a href=\"#MySQL-中的时间-Dates\" class=\"headerlink\" title=\"MySQL 中的时间 Dates\"></a>MySQL 中的时间 Dates</h3><p>有一些内建时间函数，可以参考：<a href=\"https://runoob.com/sql/sql-dates.html\" target=\"_blank\" rel=\"noopener\">https://runoob.com/sql/sql-dates.html</a></p>\n<p>比如 NOW() 返回当前的时间和日期 - 分为两个部分 CURDATE() 是当前的日期，CURTIME() 是当前的时间</p>\n<p>可以使用 <code>DATA_FORMATE(date, format)</code> 函数来指定 想要的显示 日期/时间数据的格式，format 部分就是正则式</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>NULL - 遗漏的未知数值，不是0，不能和0比较</p>\n<p>要选用 为 NULL 的数值，应该用 <code>WHERE column_name IS NULL</code></p>\n<p>不选用，则是 <code>IS NOT NULL</code></p>\n<p>MySQL 中还有 <code>IFNULL(column_name, 0)</code>函数，用来处理，如果这个值是 NULL，那么就会转化为0</p>\n<p>或者 <code>COALESCE(column_name, 0)</code> 函数，如果是NULL，转为0</p>\n<p>SQL中常用的数据类型，以Mysql为例子：</p>\n<ul>\n<li>int</li>\n<li>float</li>\n<li>Char - 也就是 string，最多255，固定长度</li>\n<li>Varchar - 也就是string（variable）一类的， 可变长度，最多255</li>\n<li>blob或者 text - 也就是 binary object</li>\n</ul>\n<p>每种具体的数据库里面可能是不太一样的</p>\n<p>Mysql中主要三类</p>\n<ul>\n<li>Text 类型，也分 tiny、medium、long的</li>\n<li>number 类型，分 tiny、small、medium、big、float、double等</li>\n<li>date 类型，分日期的、日期时间的、时间戳（timestamp）、年的</li>\n</ul>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>注释方法：</p>\n<ul>\n<li><code>–</code> 单行注释，两个 - ，加一个空格</li>\n<li><code>#</code> 单行注释</li>\n<li><code>/* */</code> 多行注释</li>\n</ul>\n<blockquote>\n<p>自检查：<a href=\"https://blog.csdn.net/hundan_520520/article/details/54881208?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=1328593.8838.16147378952884227&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control\" target=\"_blank\" rel=\"noopener\">SQL数据库面试题以及答案（50例题）</a></p>\n</blockquote>\n<h2 id=\"常用原则\"><a href=\"#常用原则\" class=\"headerlink\" title=\"常用原则\"></a>常用原则</h2><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/qq_22222499/article/details/79060495\" target=\"_blank\" rel=\"noopener\">数据库常见面试题（附答案）</a></p>\n</blockquote>\n<p>基本表的性质【事务四大特征】</p>\n<ul>\n<li>原子性：要么执行，要么不执行</li>\n<li>隔离性：所有操作全部执行完以前，其他会话不能看到过程</li>\n<li>一致性：事务前后，数据总额一致</li>\n<li>持久性：一旦事务提交，对数据的改变是永久的</li>\n</ul>\n<p>索引分类（5种），索引失效条件</p>\n<ul>\n<li>普通索引：最基本的索引，没有任何限制</li>\n<li>唯一索引：索引列的值必须唯一，可以空值</li>\n<li>主键索引：唯一索引，不允许空值</li>\n<li>全文索引：耗时耗空间</li>\n<li>组合索引：提高效率，遵循“最左前缀”原则</li>\n</ul>\n<p>关于数据库有几种索引</p>\n<ul>\n<li>按索引列的唯一性，可以分为唯一索引和非唯一索引</li>\n<li>按索引列的个数：单列索引和符合索引</li>\n<li>按索引列的物理组织方式：B树索引、位图索引、反向键索引、函数索引、删除索引、重建索引</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>怎么样建立起一个数据仓库的</p>\n<ul>\n<li>肯定不是说把 csv 数据导入 mysql 这么简单，确实就像 布迩 说的，我这个算是别人建好的数据仓库</li>\n<li>那么究竟怎样才是自己建立数据仓库呢？</li>\n</ul>\n<p>csv 文件导入 MySQL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load data infile &#39;F:&#x2F;MySqlData&#x2F;test1.csv&#39; -- CSV文件存放路径</span><br><span class=\"line\">into table student -- 要将数据导入的表名</span><br><span class=\"line\">fields terminated by &#39;列的分隔符&#39; optionally enclosed by &#39;&quot;&#39; escaped by &#39;&quot;&#39;</span><br><span class=\"line\">lines terminated by &#39;\\r\\n&#39; -- 回车换行符;</span><br></pre></td></tr></table></figure>\n<p>如果是linux下生成的文件，就是 <code>\\n</code> 结尾</p>\n<p>注意：这个东西很有可能会出现各种的报错，需要修改配置文件等内容</p>","more":"<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/yoyotl/p/9858587.html\" target=\"_blank\" rel=\"noopener\">将csv的数据导入mysql</a></p>\n</blockquote>\n<p>语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from student;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>怎么样构建一个数据仓库</p>\n<p>数据库索引的原则</p>\n<p>数据库面试常见的问题</p>\n<p>数据库面经找一找</p>\n</blockquote>\n<h1 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h1><p>Structured Query Language 结构化查询语言</p>\n<p>RDBMS 关系数据库管理系统</p>\n<p><code>use database;</code> 选择数据库</p>\n<p><code>set names utf8;</code> 设置使用的字符集</p>\n<blockquote>\n<p>SQL 对大小写不敏感</p>\n<p>分号是分隔SQL语句的标准方法</p>\n</blockquote>\n<p><code>CREATE DATABASE</code> 创建新的数据库</p>\n<p><code>ALTER DATABASE</code> 修改数据库</p>\n<p><code>UPDATE</code> 更新数据库中的数据</p>\n<p><code>DELETE</code> 删除数据库中的数据</p>\n<p><code>INSERT INTO</code> 向数据库中插入新数据</p>\n<hr>\n<p><code>CREATE TABLE</code> 创建新表</p>\n<p><code>ALTER TABLE</code> 变更（改变）数据库表</p>\n<p><code>DROP TABLE</code> 删除表</p>\n<hr>\n<p><code>CREATE INDEX</code> 创建索引（搜索键）</p>\n<p><code>DROP INDEX</code> 删除索引</p>\n<blockquote>\n<p>数据库 database 和 表 table 的区别</p>\n<p>SQL 和 MySQL 的关系</p>\n<p>SQL 有很多种，包括 SQL Sever/MS Access, MySQL, Oracle，SQL是语言，MySQL 是一种数据库软件</p>\n</blockquote>\n<h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>创建数据库</p>\n<p><code>CREATE DATABASE db_name</code></p>\n<p>创建数据表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\">(</span><br><span class=\"line\"><span class=\"keyword\">ID</span> <span class=\"built_in\">int</span>,</span><br><span class=\"line\"><span class=\"keyword\">Name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">Address <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">City <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>然后可以使用 <code>INSERT INTO</code> 向表中插入数据</p>\n<p>可以对数据表内容进行约束，保证合规：</p>\n<p>创建表时可以针对列进行内容的约束：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\">(</span><br><span class=\"line\"><span class=\"keyword\">ID</span> <span class=\"built_in\">int</span> constraint_name <span class=\"keyword\">AUTO</span> <span class=\"keyword\">INCREMENT</span>,</span><br><span class=\"line\"><span class=\"keyword\">Name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) constraint_name,</span><br><span class=\"line\">Address <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) constraint_name,</span><br><span class=\"line\">City <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> ‘Sandnes’,</span><br><span class=\"line\"><span class=\"keyword\">UNIQUE</span> (<span class=\"keyword\">ID</span>),</span><br><span class=\"line\">PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"keyword\">Name</span>),</span><br><span class=\"line\"><span class=\"keyword\">CHECK</span> (<span class=\"keyword\">ID</span>&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>这里写的 <code>constraint_name</code> 可以是：</p>\n<ul>\n<li>NOT NULL  -  不能存储 NULL 值；再修改 为 “NULL”就可以存储 NULL 值了</li>\n<li>UNIQUE - 为列或者多个列提供唯一性的保证，一个表可以有多个，mysql需要单独在最后声明 <code>UNIQUE (P_Id)</code></li>\n<li>PRIMARY KEY - 为列或者多个列提供唯一性的保证，但是每个表只能有一个</li>\n<li>FOREIGN KEY - 保护表直接的连接，可能有某个列是两个表之间的连接外键</li>\n<li>CHECK - 限制列中值的范围</li>\n<li>DEFAULT - 向列中插入默认值</li>\n</ul>\n<p>如果表已经建立好了，可以使用</p>\n<p> <code>ALTER TABLE table_name MODIFY column_name type constrain_name;</code></p>\n<p>这些约束也可以删除，要使用 <code>ALTER TABLE table_name xxx constrain_name</code> 语句</p>\n<p>其中xxx 位置：</p>\n<ul>\n<li>NOT NULL 用 MODIFY</li>\n<li>UNIQUE 用 DROP</li>\n<li>PRIMARY 用 DROP</li>\n<li>FOREIGN 用 DROP</li>\n<li>CHECK 用 DROP</li>\n<li>DEFAULT 用 DROP</li>\n</ul>\n<p><code>AUTO INCREMENT</code> 字段，每次插入新记录时，会自动地创建主键字段的值 </p>\n<p>比如上面的例子中，ID就是这样的字段，默认开始值是1（也可以自己设置起始值），每条新纪录递增1</p>\n<p>这样的话，向表中添加数据时，不需要为 ID 字段规定值（会自动生成）</p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>为了更快地查找数据，可以创建索引</p>\n<blockquote>\n<p>但是索引是看不到的！</p>\n</blockquote>\n<p>更新一个包含索引的表更花时间</p>\n<p>一般只在最常搜索的列创建索引</p>\n<p><code>CREATE INDEX index_name ON table_name (column_name)</code> 创建简单索引，可以使用重复的值</p>\n<p><code>CREATE UNIQUE INDEX index_name ON table_name (column_name)</code> 创建唯一索引，不能使用重复的值（两个行不能索引值相同）</p>\n<h3 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h3><p><code>SELECT * FROM database;</code> 读取数据表的信息</p>\n<ul>\n<li><code>*</code> 表示全部</li>\n<li><code>*</code> 的位置可以被替换为一个或者多个列的 列名，多个列名之间用 <code>,</code> 进行区分</li>\n<li>结果会存储在一个<strong>结果表</strong>中 —— <strong>结果集</strong></li>\n</ul>\n<p>上面的搜索中一个列可能会包含多个重复值，可以用</p>\n<p><code>SELECT DISTINCT * FROM table_name;</code> 就会只取出要选的那一列中不重复的值</p>\n<p>要选取前多少个数据，使用到  <code>TOP</code> 语句，但是这个语句在不同的sql 语言种是不一样的，以 MySQL 为例，使用 <code>LIMIT</code> 进行限定：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">LIMIT</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n<p>可以选择满足条件的前 number 条记录</p>\n<hr>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> column_name = value1</span><br><span class=\"line\"><span class=\"keyword\">AND</span> column_name &gt; value2</span><br></pre></td></tr></table></figure>\n<p>如果 value 是数值，不用引号</p>\n<p>如果 value 是文本值，要用引号</p>\n<p>WHERE 子句中的运算符</p>\n<ul>\n<li>= 等于</li>\n<li>&lt;&gt; 不等于</li>\n<li>BETWEEN 在某个范围内 <code>BETWEEN value1 AND value2</code><ul>\n<li>介于 value1 和 value2 之间</li>\n<li>也可以添加 <code>NOT</code> 表示不在某个区间，比如 <code>NOT BETWEEN xxx</code></li>\n<li>value1 和 value2 可以都是数字，<strong>也可以是字母</strong>，还可以是日期date（<code>2016-05-10</code> 之类的）</li>\n<li>MySQL中，BETWEEN 区间 是<strong>包括两个边界的值</strong>的！ NOT BETWEEN 就不包括两个边界的值了</li>\n</ul>\n</li>\n<li>LIKE 搜索某种模式 <code>LIKE pattern</code> <ul>\n<li>这个指定模式是用通配符来进行设定的</li>\n<li>比如 <code>G%</code>  表示以 G 开头的字符值</li>\n<li>还可以使用  <code>NOT LIKE pattern</code> 排除某个模式</li>\n</ul>\n</li>\n<li>IN 指定针对某个列的多个可能值<ul>\n<li>使用在指向比较明确的场合</li>\n<li>比如 <code>WHERE column_name IN (value1, value2, ...)</code></li>\n<li>那么该 column 的值一定要在指定的 value 中</li>\n<li>IN 和 = 的区别是，IN 可以规定多个值，= 只能规定一个值，可以互相转换，使用 <code>OR</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>通配符</p>\n<ul>\n<li><code>%</code> 替代0-n个字符</li>\n<li><code>-</code> 替代 1 个字符</li>\n</ul>\n<p>正则表达式</p>\n<p><code>REGEXP &#39;pattern&#39;</code>和 <code>NOT REGEXP</code></p>\n<p>（或者<code>RLIKE</code>和 <code>NOTRLIKE</code>）</p>\n<p>例如</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> column_name REGEXP <span class=\"string\">'^[A-H]'</span></span><br></pre></td></tr></table></figure>\n<p>表示的是以A到H 开头的字符</p>\n<p><code>REGEXP &#39;^[^A-H]&#39;</code> 表示的是，不以A到H开头的字符</p>\n</blockquote>\n<p>子句</p>\n<p><code>AND</code>  两个条件都成立，才会显示一条记录</p>\n<p><code>OR</code> 两个条件有一个成立，就会显示一条记录</p>\n<p>这两个符号可以结合起来，还可以加括号，这样构成复杂语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> column_name <span class=\"keyword\">ASC</span>|<span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<p><code>ORDER BY</code> 对结果集按照某个列（或者某几个列）进行排序</p>\n<p><code>DESC</code> 是按照降序排序</p>\n<blockquote>\n<p>如果按照多个列进行排序</p>\n<p>先按照第一列，然后按照第二个列，两个列都会考虑</p>\n<p>比如</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210302223234109.png\" alt=\"image-20210302223234109\"></p>\n</blockquote>\n<h3 id=\"增删改\"><a href=\"#增删改\" class=\"headerlink\" title=\"增删改\"></a>增删改</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table_name (column1, column2, column3)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (value1, value2, value3,...);</span><br></pre></td></tr></table></figure>\n<p><code>INSERT INTO</code></p>\n<p>可以用来插入一个新行的数据</p>\n<p>也可以指定某几个列插入数值，没有说到的列就是0</p>\n<blockquote>\n<p>列表的第一列是“id”</p>\n<p>“id”会自动更新</p>\n</blockquote>\n<p>【MySQL不支持】<code>SELECT INSERT INTO</code>用来从一个表中复制数据（行），然后把数据插入到另一个新表【这个表原本不存在】中</p>\n<p>【MySQL 支持】<code>INSERT INTO ... SELECT</code> 也是用来从一个表中复制数据（行），然后插入到一个已存在的表中【这个被插入的表中已经存在的行不会受影响】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table2</span><br><span class=\"line\">(column_names)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column_names</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1;</span><br></pre></td></tr></table></figure>\n<p><code>ALTER TABLE</code> 添加、删除、修改列</p>\n<p><code>ALTER TABLE table_name ADD column_name datatype</code>  添加列</p>\n<p>删除，alter … drop</p>\n<p>修改表中数据的类型  alter … modify </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">SET</span> column1=value1, column2=value2, ...</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure>\n<p><code>UPDATE</code> 语句可以用来更新表中的记录</p>\n<p>注意一定要使用 <code>WHERE</code> 语句来限定需要更新的记录，要不然，所有记录都会被更新</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure>\n<p><code>DELETE</code> 语句用来删除表中的记录（行）</p>\n<p>注意要使用 <code>WHERE</code> 语句限定需要删除的记录，否则所有记录会被删除</p>\n<blockquote>\n<p>删库跑路</p>\n<p><code>DELETE * FROM table_name;</code></p>\n<p>或者 <code>DELETE FROM table_name;</code> 会删除全部行</p>\n</blockquote>\n<p><code>DROP</code> 可以用来删除 索引、表和数据库</p>\n<p><code>ALTER TABLE table_name DROP INDEX index_name</code>  删除表中的索引</p>\n<p><code>DROP TABLE table_name</code> 删除表</p>\n<p><code>DROP DATABASE db_name</code> 删除数据库</p>\n<p><code>TRUNCATE TABLE table_name</code> 删除表内数据，但不删除表本身</p>\n<h3 id=\"起别名-AS\"><a href=\"#起别名-AS\" class=\"headerlink\" title=\"起别名 AS\"></a>起别名 AS</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name <span class=\"keyword\">AS</span> alias_name <span class=\"keyword\">FROM</span> table_name;  <span class=\"comment\">-- 给列起别名</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name <span class=\"keyword\">FROM</span> table_name <span class=\"keyword\">AS</span> alias_name;  <span class=\"comment\">-- 给表起别名</span></span><br></pre></td></tr></table></figure>\n<p>多个列需要分别 AS</p>\n<p><code>CONCAT (column1, column2) AS column3</code> 可以将多个列结合在一起，创建一个 column3 的别名</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, <span class=\"keyword\">CONCAT</span>(<span class=\"keyword\">url</span>, <span class=\"string\">','</span>, alexa, <span class=\"string\">','</span>, conntry) <span class=\"keyword\">AS</span> site_info <span class=\"keyword\">FROM</span> table_name;</span><br></pre></td></tr></table></figure>\n<p>起别名对于在多个表中进行混合查询比较有利，比如</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> w.name, w.url, a.count, a.data</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Websites <span class=\"keyword\">AS</span> w, access_log <span class=\"keyword\">AS</span> a</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> a.site_id=w.id <span class=\"keyword\">and</span> w.name=<span class=\"string\">\"菜鸟教程\"</span></span><br></pre></td></tr></table></figure>\n<p>总结来说，别名的好处就是：</p>\n<ul>\n<li>查询多个表</li>\n<li>查询中使用了函数</li>\n<li>列名称很长</li>\n<li>多列结合</li>\n</ul>\n<p>比较方便</p>\n<blockquote>\n<p>如果在多个表中进行查询，不同表中的列名需要添加各自的前缀</p>\n</blockquote>\n<h3 id=\"多表合并\"><a href=\"#多表合并\" class=\"headerlink\" title=\"多表合并\"></a>多表合并</h3><p>SQL join 用于把来自两个或者多个表的行结合起来</p>\n<p>主要分四类</p>\n<ul>\n<li>LEFT JOIN - 即使右表没有匹配，也会从左表返回行</li>\n<li>RIGHT JOIN - 即使左表没有匹配，也会从右表返回行</li>\n<li>INNER JOIN - 在表中存在至少一个匹配时返回行【比如表A的行，在表B中没有匹配，那么这些行就不会列出】</li>\n<li>FULL JOIN - 只要一个表存在匹配，就返回行 ==但是MySQL中不支持 FULL OUTER JOIN==</li>\n</ul>\n<p>但是具体还有方法，总共有7种相关的用法</p>\n<p>最常见：<code>INNER JOIN</code> 从多个表中返回满足JOIN条件的所有行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> w.id, w.name, a.count, a.date</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Websites <span class=\"keyword\">as</span> w</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> access_log <span class=\"keyword\">as</span> a</span><br><span class=\"line\"><span class=\"keyword\">ON</span> w.id=a.site_id;</span><br></pre></td></tr></table></figure>\n<p>ON  后面会跟随连接的条件【也就是说，两个表是通过这个参数列连起来的】</p>\n<p>最后返回的结果集中，将只包含所搜寻的四个参数：w.id, w.name, a.count, a.date</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> w.name, a.count, a.date</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Websites <span class=\"keyword\">as</span> w</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> access_log <span class=\"keyword\">as</span> a</span><br><span class=\"line\"><span class=\"keyword\">ON</span> w.id=a.site_id</span><br><span class=\"line\">ORDERED <span class=\"keyword\">BY</span> a.count <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n<p>即使 表 a（access） 中没有与 w.id 相同的 site_id， 那么 w.id 所在的数据还是会存在于结果中</p>\n<p>这个时候，这一行里面没有的元素就会用 <code>NULL</code> 来填充</p>\n<p><code>RIGHT JOIN</code> 是相似的</p>\n<p><code>UNION</code> 操作符：合并多个 SELECT 语句的结果集</p>\n<p>有两种用法：</p>\n<p>第一种是 <code>UNION</code>，那么不会保留重复值</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> country <span class=\"keyword\">FROM</span> Websites</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> country <span class=\"keyword\">FROM</span> apps</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> country;</span><br></pre></td></tr></table></figure>\n<p>另一种是 <code>UNION ALL</code>，会保留重复值</p>\n<p>还可以在加上 <code>WHERE</code> 等语句 再进行筛选</p>\n<blockquote>\n<p><code>WHERE</code> 语句一般加在 <code>ORDER BY</code> 前面</p>\n</blockquote>\n<h3 id=\"视图（VIEWS）\"><a href=\"#视图（VIEWS）\" class=\"headerlink\" title=\"视图（VIEWS）\"></a>视图（VIEWS）</h3><p>视图 - 可视化的表</p>\n<p>感觉很像是从表中选择了部分数据，不是特别具体</p>\n<p>似乎 Northwind 样本数据库使用的比较多</p>\n<h3 id=\"MySQL-中的时间-Dates\"><a href=\"#MySQL-中的时间-Dates\" class=\"headerlink\" title=\"MySQL 中的时间 Dates\"></a>MySQL 中的时间 Dates</h3><p>有一些内建时间函数，可以参考：<a href=\"https://runoob.com/sql/sql-dates.html\" target=\"_blank\" rel=\"noopener\">https://runoob.com/sql/sql-dates.html</a></p>\n<p>比如 NOW() 返回当前的时间和日期 - 分为两个部分 CURDATE() 是当前的日期，CURTIME() 是当前的时间</p>\n<p>可以使用 <code>DATA_FORMATE(date, format)</code> 函数来指定 想要的显示 日期/时间数据的格式，format 部分就是正则式</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>NULL - 遗漏的未知数值，不是0，不能和0比较</p>\n<p>要选用 为 NULL 的数值，应该用 <code>WHERE column_name IS NULL</code></p>\n<p>不选用，则是 <code>IS NOT NULL</code></p>\n<p>MySQL 中还有 <code>IFNULL(column_name, 0)</code>函数，用来处理，如果这个值是 NULL，那么就会转化为0</p>\n<p>或者 <code>COALESCE(column_name, 0)</code> 函数，如果是NULL，转为0</p>\n<p>SQL中常用的数据类型，以Mysql为例子：</p>\n<ul>\n<li>int</li>\n<li>float</li>\n<li>Char - 也就是 string，最多255，固定长度</li>\n<li>Varchar - 也就是string（variable）一类的， 可变长度，最多255</li>\n<li>blob或者 text - 也就是 binary object</li>\n</ul>\n<p>每种具体的数据库里面可能是不太一样的</p>\n<p>Mysql中主要三类</p>\n<ul>\n<li>Text 类型，也分 tiny、medium、long的</li>\n<li>number 类型，分 tiny、small、medium、big、float、double等</li>\n<li>date 类型，分日期的、日期时间的、时间戳（timestamp）、年的</li>\n</ul>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>注释方法：</p>\n<ul>\n<li><code>–</code> 单行注释，两个 - ，加一个空格</li>\n<li><code>#</code> 单行注释</li>\n<li><code>/* */</code> 多行注释</li>\n</ul>\n<blockquote>\n<p>自检查：<a href=\"https://blog.csdn.net/hundan_520520/article/details/54881208?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=1328593.8838.16147378952884227&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control\" target=\"_blank\" rel=\"noopener\">SQL数据库面试题以及答案（50例题）</a></p>\n</blockquote>\n<h2 id=\"常用原则\"><a href=\"#常用原则\" class=\"headerlink\" title=\"常用原则\"></a>常用原则</h2><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/qq_22222499/article/details/79060495\" target=\"_blank\" rel=\"noopener\">数据库常见面试题（附答案）</a></p>\n</blockquote>\n<p>基本表的性质【事务四大特征】</p>\n<ul>\n<li>原子性：要么执行，要么不执行</li>\n<li>隔离性：所有操作全部执行完以前，其他会话不能看到过程</li>\n<li>一致性：事务前后，数据总额一致</li>\n<li>持久性：一旦事务提交，对数据的改变是永久的</li>\n</ul>\n<p>索引分类（5种），索引失效条件</p>\n<ul>\n<li>普通索引：最基本的索引，没有任何限制</li>\n<li>唯一索引：索引列的值必须唯一，可以空值</li>\n<li>主键索引：唯一索引，不允许空值</li>\n<li>全文索引：耗时耗空间</li>\n<li>组合索引：提高效率，遵循“最左前缀”原则</li>\n</ul>\n<p>关于数据库有几种索引</p>\n<ul>\n<li>按索引列的唯一性，可以分为唯一索引和非唯一索引</li>\n<li>按索引列的个数：单列索引和符合索引</li>\n<li>按索引列的物理组织方式：B树索引、位图索引、反向键索引、函数索引、删除索引、重建索引</li>\n</ul>"},{"title":"【统计学习方法】5-决策树","date":"2021-01-28T06:45:45.000Z","_content":"\n一句话解释：主要针对分类问题，对已有数据，根据各个特征的表现情况进行二分类（或多分类），从而形成一个像树一样的分类结构。\n\n------\n\n这一部分公式比较多，配合例题进行理解。\n\n<!-- more -->\n\n# 5.1 定义\n\n一个决策树，大概就是像下图一样的一个结构：\n\n<img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树模型.jpg\" alt=\"决策树模型\" style=\"zoom: 25%;\" />\n\n如果学习过数据结构，你可能很快反映出，这不就是“树”结构吗？我感觉差不多就是这样，一个二分类或者多分类的树结构，遇到分叉点就是做选择题。\n\n一般分三个步骤：**特征选择，树的生成，树的剪枝**，常用于分类问题。\n\n# 5.2 特征选择\n\n## 为什么要选择特征？\n\n因为特征很多，从不同特征开始分类，得到的树的效果可能不一样。\n\n## 选择特征\n\n我们怎么知道哪个特征更适合分类呢？或者说怎样来判断一个特征是不是适合分类呢？\n\n用**信息增益**来判断。\n\n## 信息增益\n\n### 熵\n\n$H(X)=-\\Sigma^n_{i=1}p_ilogp_i$ 也可以记作 **H(p)**\n\n其中，X是取有限值的离散随机变量，概率分布为$P(x=x_i)=p_i,i=1,2,...,n$，**当 $p_i$ 为 0 时，log 0 = 0.**\n\n意义：**熵越大，随机变量的不确定性越大。也就是说，熵是用来衡量随机变量的不确定性的！**\n\n### 条件熵    \n\n$H(Y|X)=\\Sigma^n_{i=1}p_iH(Y|X=x_i)$  \n\n**表示的是，在已知X的条件下，Y的不确定性。**\n\n### 经验熵与经验条件熵  \n\n如果概率 Pi 是由数据估计（特别是极大似然估计）得到的，所对应的熵和条件熵就是经验熵和经验条件熵。\n\n### 互信息（也就是信息增益）\n\n熵与条件熵的差值。\n\n该差值表示了**不确定性减少的程度**，减少越多就说明这个“条件”适合进行分类。\n\n**因此，信息增益大的特征具有更强的分类能力。**\n\n## 计算方法\n\n**输入：**训练数据集D和特征A\n\n**对数据集的处理：**\n\n1. $|D|$表示样本容量\n2. 有 $K $个类别，分别为$C_k$，每个类别中的样本个数为 $|C_k|$\n3. 根据特征 A 可以将 D 划分为 n 个子集，分别为 $D_i$，$D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$\n\n**输出：**特征A对训练数据集D的信息增益 $g(D,A)$\n\n**步骤：**\n\n1. 计算数据集 D 的经验熵 H(D)\n\n   $H(D)=-\\Sigma^K_{k=1}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}$ \n\n2. 计算特征A对数据机D的经验条件熵 H(D|A)\n\n    $H(D|A)=\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}H(D_i)=-\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}\\Sigma^K_{i=1}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{D_i}$\n\n3. 计算信息增益\n\n   $g(D,A)=H(D)-H(D|A)$\n\n简单实用，但是**缺点**是：偏向于选择**取值较多的特征。**\n\n## 改进方法\n\n使用**信息增益比**\n\n**信息增益比**是信息增益与熵的比值。\n\n信息增益比$g_R(D,A)=\\frac{g(D,A)}{H_A(D)}$\n\n其中$H_A(D)=-\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}log_2{|D_i|}{|D|}$，**和前面的经验条件熵 H(D|A) 还是有点不一样的！**\n\n#  5.3 决策树的生成\n\n## ID3算法\n\n上面的内容只是选择了一个最优的特征值，大概相当于找到了一个比较好的根节点，但是还没有生成决策树。\n\n使用下面的算法生成决策树：\n\n![ID3算法](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/ID3算法.png)\n\n**缺点：容易过拟合**\n\nC4.5算法\n\n不同之处：选择**信息增益比**来选择特征。并不比ID3算法强多少。\n\n# 5.4 决策树的剪枝\n\n剪枝就是让决策树的枝干少一点——这样鲁棒性更好。\n\n是减小过拟合的一种方法。\n\n一般方法是引入**损失函数**，衡量剪枝前后的效果（也就是比较剪枝前后的损失函数），选择损失函数最小的方式生成决策树。\n\n决策树的损失函数：\n\n$C_\\alpha(T)=\\Sigma^{|T|}_{t=1}N_tH_t(T)+\\alpha|T|$\n\n代入经验熵$H_t(T)=-\\Sigma_k\\frac{N_{tk}}{N_t}log\\frac{N_{tk}}{N_t}$即可。\n\n其中$\\alpha$的作用是：\n\n- $\\alpha$越大，促使选择简单模型\n- $\\alpha$越小，促使选择复杂模型\n- $\\alpha$为0，不考虑模型复杂度\n\n$|T|$表示模型复杂度。\n\n# 5.5 CART算法\n\n分类与回归树（classsification and regression tree）\n\n本方法不细讲了，主要思想其实很相近，只是完整地提出了从特征选择、决策树生成到剪枝的全过程，并且**只使用二叉树（不管有几个选择）**，所以泛化程度可能更好！\n\n生成：递归地构建**二叉决策树**\n\n如何对输入空间进行划分\n\n特征选择：使用**基尼指数**最小化原则\n\n\n\n最小二乘回归树生成算法\n\n**其实本方法和前面的算法在逻辑上有相似之处，但是最大的不同是，这里的每一个子树都是二叉树。**\n\n------\n\n# 举个栗子！\n\n**下面是一个贷款申请的训练数据，我们先关注最后一栏，类别——就是是否同意贷款。**\n\n| ID   | 年龄 | 有工作 | 有自己的房子 | 信贷情况 | 类别 |\n| :--- | :--- | :----- | :----------- | :------- | :--- |\n| 1    | 青年 | 否     | 否           | 一般     | 否   |\n| 2    | 青年 | 否     | 否           | 好       | 否   |\n| 3    | 青年 | 是     | 否           | 好       | 是   |\n| 4    | 青年 | 是     | 是           | 一般     | 是   |\n| 5    | 青年 | 否     | 否           | 一般     | 否   |\n| 6    | 中年 | 否     | 否           | 一般     | 否   |\n| 7    | 中年 | 否     | 否           | 好       | 否   |\n| 8    | 中年 | 是     | 是           | 好       | 是   |\n| 9    | 中年 | 否     | 是           | 非常好   | 是   |\n| 10   | 中年 | 否     | 是           | 非常好   | 是   |\n| 11   | 老年 | 否     | 是           | 非常好   | 是   |\n| 12   | 老年 | 否     | 是           | 好       | 是   |\n| 13   | 老年 | 是     | 否           | 好       | 是   |\n| 14   | 老年 | 是     | 否           | 非常好   | 是   |\n| 15   | 老年 | 否     | 否           | 一般     | 否   |\n\n**OK，根据上面这个表格，如果给你一个新的数据，你怎样判断是不是要贷款给ta呢？**\n\n一步步来进行：\n\n\n\n首先可以看到特征比较多，从不同特征开始可以形成不同的决策树。\n\n![图-不同特征决定的不同决策数](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/图-不同特征决定的不同决策数.png)\n\n\n\n经验熵$H(D)=-\\frac{9}{15}log_2\\frac{9}{15}-\\frac{6}{15}log_2\\frac{6}{15}=0.971$计算**信息增益：**\n\n（1）条件经验熵：$D_1,D_2,D_3$分别是$D$中$A_1$(年龄)取值为青年、中年和老年的样本子集。\n\n$H(D_1)=-\\frac{2}{5}log_2\\frac{2}{5}-\\frac{3}{5}log_2\\frac{3}{5} \\\\ H(D_2)=-\\frac{3}{5}log_2\\frac{3}{5}-\\frac{2}{5}log_2\\frac{2}{5} \\\\ H(D_3)=-\\frac{4}{5}log_2\\frac{4}{5}-\\frac{1}{5}log_2\\frac{1}{5}$\n\n（2）分别以$A_1,A_2,A_3,A_4$ 表示年龄、有工作、有自己的房子和信贷情况**四个特征**，计算信息增益：\n\n$g(D,A_1)=H(D)-[\\frac{5}{15}H(D_1)+\\frac{5}{15}H(D_2)+\\frac{5}{15}H(D_3)]=0.971-0.888=0.083$\n\n**还没有完，这只是一个分类的信息增益！！** \n\n**如果想要计算其他四个分类，还得重新计算条件经验熵，然后计算信息增益：**\n\n关于**A2**的信息增益：\n\n首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_2)=H(D)-[\\frac{5}{15}H(D_1)+\\frac{5}{15}H(D_2)]=0.324$\n\n关于**A3**的信息增益：\n\n首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_1)=H(D)-[\\frac{6}{15}H(D_1)+\\frac{9}{15}H(D_2)]=0.420$\n\n关于**A4**的信息增益：\n\n首先有三个子集，计算$H(D_1),H(D_2),H(D_3)$，然后计算信息增益：$g(D,A_1)=0.363$\n\n**根据信息增益的比较，特征$A_3$（有自己的房子）的信息增益最大，所以选择特征$A_3$作为最优特征**。\n\n\n\n首先选取特征$A_3$作为根结点；然后$A_3$把数据集划分为两个子集$D_1$（表示有房子）和$D_2$（表示没有房子）。\n\n分别观察：\n\n（1）$D_1$只有同一类的样本点，所以是一个叶节点，标记为“是”。\n\n（2）$D_2$需要对其它三个特征$A_1,A_2,A_4$中选择新的特征：计算信息增益：$g(D_2,A_1)=H(D_2)-H(D_2|A_1)=0.918-0.667=0.251\\\\ g(D_2,A_2)=H(D_2)-H(D_2|A_2)=0.918\\\\ g(D_2,A_4)=H(D_2)-H(D_2|A_4)=0.474$\n\n信息增益最大的是$A_2$，所以$A_2$（有工作）成为一个子结点，然后再分支……计算，直到全部分类完毕。\n\n**本题比较巧，由$A_2$分类后，全部元素已经分类完毕了。**例如，通过以上计算以后，我们得到的决策树就是：\n\n![决策树的生成](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树的生成.png)\n\n","source":"_posts/统计学习方法五.md","raw":"---\ntitle: 【统计学习方法】5-决策树\ndate: 2021-01-28 14:45:45\ncategories:\n\t- 机器学习\ntags:\n\t- 统计学习方法\n---\n\n一句话解释：主要针对分类问题，对已有数据，根据各个特征的表现情况进行二分类（或多分类），从而形成一个像树一样的分类结构。\n\n------\n\n这一部分公式比较多，配合例题进行理解。\n\n<!-- more -->\n\n# 5.1 定义\n\n一个决策树，大概就是像下图一样的一个结构：\n\n<img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树模型.jpg\" alt=\"决策树模型\" style=\"zoom: 25%;\" />\n\n如果学习过数据结构，你可能很快反映出，这不就是“树”结构吗？我感觉差不多就是这样，一个二分类或者多分类的树结构，遇到分叉点就是做选择题。\n\n一般分三个步骤：**特征选择，树的生成，树的剪枝**，常用于分类问题。\n\n# 5.2 特征选择\n\n## 为什么要选择特征？\n\n因为特征很多，从不同特征开始分类，得到的树的效果可能不一样。\n\n## 选择特征\n\n我们怎么知道哪个特征更适合分类呢？或者说怎样来判断一个特征是不是适合分类呢？\n\n用**信息增益**来判断。\n\n## 信息增益\n\n### 熵\n\n$H(X)=-\\Sigma^n_{i=1}p_ilogp_i$ 也可以记作 **H(p)**\n\n其中，X是取有限值的离散随机变量，概率分布为$P(x=x_i)=p_i,i=1,2,...,n$，**当 $p_i$ 为 0 时，log 0 = 0.**\n\n意义：**熵越大，随机变量的不确定性越大。也就是说，熵是用来衡量随机变量的不确定性的！**\n\n### 条件熵    \n\n$H(Y|X)=\\Sigma^n_{i=1}p_iH(Y|X=x_i)$  \n\n**表示的是，在已知X的条件下，Y的不确定性。**\n\n### 经验熵与经验条件熵  \n\n如果概率 Pi 是由数据估计（特别是极大似然估计）得到的，所对应的熵和条件熵就是经验熵和经验条件熵。\n\n### 互信息（也就是信息增益）\n\n熵与条件熵的差值。\n\n该差值表示了**不确定性减少的程度**，减少越多就说明这个“条件”适合进行分类。\n\n**因此，信息增益大的特征具有更强的分类能力。**\n\n## 计算方法\n\n**输入：**训练数据集D和特征A\n\n**对数据集的处理：**\n\n1. $|D|$表示样本容量\n2. 有 $K $个类别，分别为$C_k$，每个类别中的样本个数为 $|C_k|$\n3. 根据特征 A 可以将 D 划分为 n 个子集，分别为 $D_i$，$D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$\n\n**输出：**特征A对训练数据集D的信息增益 $g(D,A)$\n\n**步骤：**\n\n1. 计算数据集 D 的经验熵 H(D)\n\n   $H(D)=-\\Sigma^K_{k=1}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}$ \n\n2. 计算特征A对数据机D的经验条件熵 H(D|A)\n\n    $H(D|A)=\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}H(D_i)=-\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}\\Sigma^K_{i=1}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{D_i}$\n\n3. 计算信息增益\n\n   $g(D,A)=H(D)-H(D|A)$\n\n简单实用，但是**缺点**是：偏向于选择**取值较多的特征。**\n\n## 改进方法\n\n使用**信息增益比**\n\n**信息增益比**是信息增益与熵的比值。\n\n信息增益比$g_R(D,A)=\\frac{g(D,A)}{H_A(D)}$\n\n其中$H_A(D)=-\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}log_2{|D_i|}{|D|}$，**和前面的经验条件熵 H(D|A) 还是有点不一样的！**\n\n#  5.3 决策树的生成\n\n## ID3算法\n\n上面的内容只是选择了一个最优的特征值，大概相当于找到了一个比较好的根节点，但是还没有生成决策树。\n\n使用下面的算法生成决策树：\n\n![ID3算法](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/ID3算法.png)\n\n**缺点：容易过拟合**\n\nC4.5算法\n\n不同之处：选择**信息增益比**来选择特征。并不比ID3算法强多少。\n\n# 5.4 决策树的剪枝\n\n剪枝就是让决策树的枝干少一点——这样鲁棒性更好。\n\n是减小过拟合的一种方法。\n\n一般方法是引入**损失函数**，衡量剪枝前后的效果（也就是比较剪枝前后的损失函数），选择损失函数最小的方式生成决策树。\n\n决策树的损失函数：\n\n$C_\\alpha(T)=\\Sigma^{|T|}_{t=1}N_tH_t(T)+\\alpha|T|$\n\n代入经验熵$H_t(T)=-\\Sigma_k\\frac{N_{tk}}{N_t}log\\frac{N_{tk}}{N_t}$即可。\n\n其中$\\alpha$的作用是：\n\n- $\\alpha$越大，促使选择简单模型\n- $\\alpha$越小，促使选择复杂模型\n- $\\alpha$为0，不考虑模型复杂度\n\n$|T|$表示模型复杂度。\n\n# 5.5 CART算法\n\n分类与回归树（classsification and regression tree）\n\n本方法不细讲了，主要思想其实很相近，只是完整地提出了从特征选择、决策树生成到剪枝的全过程，并且**只使用二叉树（不管有几个选择）**，所以泛化程度可能更好！\n\n生成：递归地构建**二叉决策树**\n\n如何对输入空间进行划分\n\n特征选择：使用**基尼指数**最小化原则\n\n\n\n最小二乘回归树生成算法\n\n**其实本方法和前面的算法在逻辑上有相似之处，但是最大的不同是，这里的每一个子树都是二叉树。**\n\n------\n\n# 举个栗子！\n\n**下面是一个贷款申请的训练数据，我们先关注最后一栏，类别——就是是否同意贷款。**\n\n| ID   | 年龄 | 有工作 | 有自己的房子 | 信贷情况 | 类别 |\n| :--- | :--- | :----- | :----------- | :------- | :--- |\n| 1    | 青年 | 否     | 否           | 一般     | 否   |\n| 2    | 青年 | 否     | 否           | 好       | 否   |\n| 3    | 青年 | 是     | 否           | 好       | 是   |\n| 4    | 青年 | 是     | 是           | 一般     | 是   |\n| 5    | 青年 | 否     | 否           | 一般     | 否   |\n| 6    | 中年 | 否     | 否           | 一般     | 否   |\n| 7    | 中年 | 否     | 否           | 好       | 否   |\n| 8    | 中年 | 是     | 是           | 好       | 是   |\n| 9    | 中年 | 否     | 是           | 非常好   | 是   |\n| 10   | 中年 | 否     | 是           | 非常好   | 是   |\n| 11   | 老年 | 否     | 是           | 非常好   | 是   |\n| 12   | 老年 | 否     | 是           | 好       | 是   |\n| 13   | 老年 | 是     | 否           | 好       | 是   |\n| 14   | 老年 | 是     | 否           | 非常好   | 是   |\n| 15   | 老年 | 否     | 否           | 一般     | 否   |\n\n**OK，根据上面这个表格，如果给你一个新的数据，你怎样判断是不是要贷款给ta呢？**\n\n一步步来进行：\n\n\n\n首先可以看到特征比较多，从不同特征开始可以形成不同的决策树。\n\n![图-不同特征决定的不同决策数](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/图-不同特征决定的不同决策数.png)\n\n\n\n经验熵$H(D)=-\\frac{9}{15}log_2\\frac{9}{15}-\\frac{6}{15}log_2\\frac{6}{15}=0.971$计算**信息增益：**\n\n（1）条件经验熵：$D_1,D_2,D_3$分别是$D$中$A_1$(年龄)取值为青年、中年和老年的样本子集。\n\n$H(D_1)=-\\frac{2}{5}log_2\\frac{2}{5}-\\frac{3}{5}log_2\\frac{3}{5} \\\\ H(D_2)=-\\frac{3}{5}log_2\\frac{3}{5}-\\frac{2}{5}log_2\\frac{2}{5} \\\\ H(D_3)=-\\frac{4}{5}log_2\\frac{4}{5}-\\frac{1}{5}log_2\\frac{1}{5}$\n\n（2）分别以$A_1,A_2,A_3,A_4$ 表示年龄、有工作、有自己的房子和信贷情况**四个特征**，计算信息增益：\n\n$g(D,A_1)=H(D)-[\\frac{5}{15}H(D_1)+\\frac{5}{15}H(D_2)+\\frac{5}{15}H(D_3)]=0.971-0.888=0.083$\n\n**还没有完，这只是一个分类的信息增益！！** \n\n**如果想要计算其他四个分类，还得重新计算条件经验熵，然后计算信息增益：**\n\n关于**A2**的信息增益：\n\n首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_2)=H(D)-[\\frac{5}{15}H(D_1)+\\frac{5}{15}H(D_2)]=0.324$\n\n关于**A3**的信息增益：\n\n首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_1)=H(D)-[\\frac{6}{15}H(D_1)+\\frac{9}{15}H(D_2)]=0.420$\n\n关于**A4**的信息增益：\n\n首先有三个子集，计算$H(D_1),H(D_2),H(D_3)$，然后计算信息增益：$g(D,A_1)=0.363$\n\n**根据信息增益的比较，特征$A_3$（有自己的房子）的信息增益最大，所以选择特征$A_3$作为最优特征**。\n\n\n\n首先选取特征$A_3$作为根结点；然后$A_3$把数据集划分为两个子集$D_1$（表示有房子）和$D_2$（表示没有房子）。\n\n分别观察：\n\n（1）$D_1$只有同一类的样本点，所以是一个叶节点，标记为“是”。\n\n（2）$D_2$需要对其它三个特征$A_1,A_2,A_4$中选择新的特征：计算信息增益：$g(D_2,A_1)=H(D_2)-H(D_2|A_1)=0.918-0.667=0.251\\\\ g(D_2,A_2)=H(D_2)-H(D_2|A_2)=0.918\\\\ g(D_2,A_4)=H(D_2)-H(D_2|A_4)=0.474$\n\n信息增益最大的是$A_2$，所以$A_2$（有工作）成为一个子结点，然后再分支……计算，直到全部分类完毕。\n\n**本题比较巧，由$A_2$分类后，全部元素已经分类完毕了。**例如，通过以上计算以后，我们得到的决策树就是：\n\n![决策树的生成](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树的生成.png)\n\n","slug":"统计学习方法五","published":1,"updated":"2021-01-28T07:24:25.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n896003nk8tl07sbff6d","content":"<p>一句话解释：主要针对分类问题，对已有数据，根据各个特征的表现情况进行二分类（或多分类），从而形成一个像树一样的分类结构。</p>\n<hr>\n<p>这一部分公式比较多，配合例题进行理解。</p>\n<a id=\"more\"></a>\n<h1 id=\"5-1-定义\"><a href=\"#5-1-定义\" class=\"headerlink\" title=\"5.1 定义\"></a>5.1 定义</h1><p>一个决策树，大概就是像下图一样的一个结构：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树模型.jpg\" alt=\"决策树模型\" style=\"zoom: 25%;\" /></p>\n<p>如果学习过数据结构，你可能很快反映出，这不就是“树”结构吗？我感觉差不多就是这样，一个二分类或者多分类的树结构，遇到分叉点就是做选择题。</p>\n<p>一般分三个步骤：<strong>特征选择，树的生成，树的剪枝</strong>，常用于分类问题。</p>\n<h1 id=\"5-2-特征选择\"><a href=\"#5-2-特征选择\" class=\"headerlink\" title=\"5.2 特征选择\"></a>5.2 特征选择</h1><h2 id=\"为什么要选择特征？\"><a href=\"#为什么要选择特征？\" class=\"headerlink\" title=\"为什么要选择特征？\"></a>为什么要选择特征？</h2><p>因为特征很多，从不同特征开始分类，得到的树的效果可能不一样。</p>\n<h2 id=\"选择特征\"><a href=\"#选择特征\" class=\"headerlink\" title=\"选择特征\"></a>选择特征</h2><p>我们怎么知道哪个特征更适合分类呢？或者说怎样来判断一个特征是不是适合分类呢？</p>\n<p>用<strong>信息增益</strong>来判断。</p>\n<h2 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h2><h3 id=\"熵\"><a href=\"#熵\" class=\"headerlink\" title=\"熵\"></a>熵</h3><p>$H(X)=-\\Sigma^n_{i=1}p_ilogp_i$ 也可以记作 <strong>H(p)</strong></p>\n<p>其中，X是取有限值的离散随机变量，概率分布为$P(x=x_i)=p_i,i=1,2,…,n$，<strong>当 $p_i$ 为 0 时，log 0 = 0.</strong></p>\n<p>意义：<strong>熵越大，随机变量的不确定性越大。也就是说，熵是用来衡量随机变量的不确定性的！</strong></p>\n<h3 id=\"条件熵\"><a href=\"#条件熵\" class=\"headerlink\" title=\"条件熵\"></a>条件熵</h3><p>$H(Y|X)=\\Sigma^n_{i=1}p_iH(Y|X=x_i)$  </p>\n<p><strong>表示的是，在已知X的条件下，Y的不确定性。</strong></p>\n<h3 id=\"经验熵与经验条件熵\"><a href=\"#经验熵与经验条件熵\" class=\"headerlink\" title=\"经验熵与经验条件熵\"></a>经验熵与经验条件熵</h3><p>如果概率 Pi 是由数据估计（特别是极大似然估计）得到的，所对应的熵和条件熵就是经验熵和经验条件熵。</p>\n<h3 id=\"互信息（也就是信息增益）\"><a href=\"#互信息（也就是信息增益）\" class=\"headerlink\" title=\"互信息（也就是信息增益）\"></a>互信息（也就是信息增益）</h3><p>熵与条件熵的差值。</p>\n<p>该差值表示了<strong>不确定性减少的程度</strong>，减少越多就说明这个“条件”适合进行分类。</p>\n<p><strong>因此，信息增益大的特征具有更强的分类能力。</strong></p>\n<h2 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h2><p><strong>输入：</strong>训练数据集D和特征A</p>\n<p><strong>对数据集的处理：</strong></p>\n<ol>\n<li>$|D|$表示样本容量</li>\n<li>有 $K $个类别，分别为$C_k$，每个类别中的样本个数为 $|C_k|$</li>\n<li>根据特征 A 可以将 D 划分为 n 个子集，分别为 $D_i$，$D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$</li>\n</ol>\n<p><strong>输出：</strong>特征A对训练数据集D的信息增益 $g(D,A)$</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p>计算数据集 D 的经验熵 H(D)</p>\n<p>$H(D)=-\\Sigma^K_{k=1}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}$ </p>\n</li>\n<li><p>计算特征A对数据机D的经验条件熵 H(D|A)</p>\n<p> $H(D|A)=\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}H(D_i)=-\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}\\Sigma^K_{i=1}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{D_i}$</p>\n</li>\n<li><p>计算信息增益</p>\n<p>$g(D,A)=H(D)-H(D|A)$</p>\n</li>\n</ol>\n<p>简单实用，但是<strong>缺点</strong>是：偏向于选择<strong>取值较多的特征。</strong></p>\n<h2 id=\"改进方法\"><a href=\"#改进方法\" class=\"headerlink\" title=\"改进方法\"></a>改进方法</h2><p>使用<strong>信息增益比</strong></p>\n<p><strong>信息增益比</strong>是信息增益与熵的比值。</p>\n<p>信息增益比$g_R(D,A)=\\frac{g(D,A)}{H_A(D)}$</p>\n<p>其中$H_A(D)=-\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}log_2{|D_i|}{|D|}$，<strong>和前面的经验条件熵 H(D|A) 还是有点不一样的！</strong></p>\n<h1 id=\"5-3-决策树的生成\"><a href=\"#5-3-决策树的生成\" class=\"headerlink\" title=\"5.3 决策树的生成\"></a>5.3 决策树的生成</h1><h2 id=\"ID3算法\"><a href=\"#ID3算法\" class=\"headerlink\" title=\"ID3算法\"></a>ID3算法</h2><p>上面的内容只是选择了一个最优的特征值，大概相当于找到了一个比较好的根节点，但是还没有生成决策树。</p>\n<p>使用下面的算法生成决策树：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/ID3算法.png\" alt=\"ID3算法\"></p>\n<p><strong>缺点：容易过拟合</strong></p>\n<p>C4.5算法</p>\n<p>不同之处：选择<strong>信息增益比</strong>来选择特征。并不比ID3算法强多少。</p>\n<h1 id=\"5-4-决策树的剪枝\"><a href=\"#5-4-决策树的剪枝\" class=\"headerlink\" title=\"5.4 决策树的剪枝\"></a>5.4 决策树的剪枝</h1><p>剪枝就是让决策树的枝干少一点——这样鲁棒性更好。</p>\n<p>是减小过拟合的一种方法。</p>\n<p>一般方法是引入<strong>损失函数</strong>，衡量剪枝前后的效果（也就是比较剪枝前后的损失函数），选择损失函数最小的方式生成决策树。</p>\n<p>决策树的损失函数：</p>\n<p>$C_\\alpha(T)=\\Sigma^{|T|}_{t=1}N_tH_t(T)+\\alpha|T|$</p>\n<p>代入经验熵$H_t(T)=-\\Sigma_k\\frac{N_{tk}}{N_t}log\\frac{N_{tk}}{N_t}$即可。</p>\n<p>其中$\\alpha$的作用是：</p>\n<ul>\n<li>$\\alpha$越大，促使选择简单模型</li>\n<li>$\\alpha$越小，促使选择复杂模型</li>\n<li>$\\alpha$为0，不考虑模型复杂度</li>\n</ul>\n<p>$|T|$表示模型复杂度。</p>\n<h1 id=\"5-5-CART算法\"><a href=\"#5-5-CART算法\" class=\"headerlink\" title=\"5.5 CART算法\"></a>5.5 CART算法</h1><p>分类与回归树（classsification and regression tree）</p>\n<p>本方法不细讲了，主要思想其实很相近，只是完整地提出了从特征选择、决策树生成到剪枝的全过程，并且<strong>只使用二叉树（不管有几个选择）</strong>，所以泛化程度可能更好！</p>\n<p>生成：递归地构建<strong>二叉决策树</strong></p>\n<p>如何对输入空间进行划分</p>\n<p>特征选择：使用<strong>基尼指数</strong>最小化原则</p>\n<p>最小二乘回归树生成算法</p>\n<p><strong>其实本方法和前面的算法在逻辑上有相似之处，但是最大的不同是，这里的每一个子树都是二叉树。</strong></p>\n<hr>\n<h1 id=\"举个栗子！\"><a href=\"#举个栗子！\" class=\"headerlink\" title=\"举个栗子！\"></a>举个栗子！</h1><p><strong>下面是一个贷款申请的训练数据，我们先关注最后一栏，类别——就是是否同意贷款。</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ID</th>\n<th style=\"text-align:left\">年龄</th>\n<th style=\"text-align:left\">有工作</th>\n<th style=\"text-align:left\">有自己的房子</th>\n<th style=\"text-align:left\">信贷情况</th>\n<th style=\"text-align:left\">类别</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">非常好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">非常好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">非常好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">非常好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>OK，根据上面这个表格，如果给你一个新的数据，你怎样判断是不是要贷款给ta呢？</strong></p>\n<p>一步步来进行：</p>\n<p>首先可以看到特征比较多，从不同特征开始可以形成不同的决策树。</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/图-不同特征决定的不同决策数.png\" alt=\"图-不同特征决定的不同决策数\"></p>\n<p>经验熵$H(D)=-\\frac{9}{15}log_2\\frac{9}{15}-\\frac{6}{15}log_2\\frac{6}{15}=0.971$计算<strong>信息增益：</strong></p>\n<p>（1）条件经验熵：$D_1,D_2,D_3$分别是$D$中$A_1$(年龄)取值为青年、中年和老年的样本子集。</p>\n<p>$H(D_1)=-\\frac{2}{5}log_2\\frac{2}{5}-\\frac{3}{5}log_2\\frac{3}{5} \\\\ H(D_2)=-\\frac{3}{5}log_2\\frac{3}{5}-\\frac{2}{5}log_2\\frac{2}{5} \\\\ H(D_3)=-\\frac{4}{5}log_2\\frac{4}{5}-\\frac{1}{5}log_2\\frac{1}{5}$</p>\n<p>（2）分别以$A_1,A_2,A_3,A_4$ 表示年龄、有工作、有自己的房子和信贷情况<strong>四个特征</strong>，计算信息增益：</p>\n<p>$g(D,A_1)=H(D)-[\\frac{5}{15}H(D_1)+\\frac{5}{15}H(D_2)+\\frac{5}{15}H(D_3)]=0.971-0.888=0.083$</p>\n<p><strong>还没有完，这只是一个分类的信息增益！！</strong> </p>\n<p><strong>如果想要计算其他四个分类，还得重新计算条件经验熵，然后计算信息增益：</strong></p>\n<p>关于<strong>A2</strong>的信息增益：</p>\n<p>首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_2)=H(D)-[\\frac{5}{15}H(D_1)+\\frac{5}{15}H(D_2)]=0.324$</p>\n<p>关于<strong>A3</strong>的信息增益：</p>\n<p>首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_1)=H(D)-[\\frac{6}{15}H(D_1)+\\frac{9}{15}H(D_2)]=0.420$</p>\n<p>关于<strong>A4</strong>的信息增益：</p>\n<p>首先有三个子集，计算$H(D_1),H(D_2),H(D_3)$，然后计算信息增益：$g(D,A_1)=0.363$</p>\n<p><strong>根据信息增益的比较，特征$A_3$（有自己的房子）的信息增益最大，所以选择特征$A_3$作为最优特征</strong>。</p>\n<p>首先选取特征$A_3$作为根结点；然后$A_3$把数据集划分为两个子集$D_1$（表示有房子）和$D_2$（表示没有房子）。</p>\n<p>分别观察：</p>\n<p>（1）$D_1$只有同一类的样本点，所以是一个叶节点，标记为“是”。</p>\n<p>（2）$D_2$需要对其它三个特征$A_1,A_2,A_4$中选择新的特征：计算信息增益：$g(D_2,A_1)=H(D_2)-H(D_2|A_1)=0.918-0.667=0.251\\\\ g(D_2,A_2)=H(D_2)-H(D_2|A_2)=0.918\\\\ g(D_2,A_4)=H(D_2)-H(D_2|A_4)=0.474$</p>\n<p>信息增益最大的是$A_2$，所以$A_2$（有工作）成为一个子结点，然后再分支……计算，直到全部分类完毕。</p>\n<p><strong>本题比较巧，由$A_2$分类后，全部元素已经分类完毕了。</strong>例如，通过以上计算以后，我们得到的决策树就是：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树的生成.png\" alt=\"决策树的生成\"></p>\n","site":{"data":{}},"excerpt":"<p>一句话解释：主要针对分类问题，对已有数据，根据各个特征的表现情况进行二分类（或多分类），从而形成一个像树一样的分类结构。</p>\n<hr>\n<p>这一部分公式比较多，配合例题进行理解。</p>","more":"<h1 id=\"5-1-定义\"><a href=\"#5-1-定义\" class=\"headerlink\" title=\"5.1 定义\"></a>5.1 定义</h1><p>一个决策树，大概就是像下图一样的一个结构：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树模型.jpg\" alt=\"决策树模型\" style=\"zoom: 25%;\" /></p>\n<p>如果学习过数据结构，你可能很快反映出，这不就是“树”结构吗？我感觉差不多就是这样，一个二分类或者多分类的树结构，遇到分叉点就是做选择题。</p>\n<p>一般分三个步骤：<strong>特征选择，树的生成，树的剪枝</strong>，常用于分类问题。</p>\n<h1 id=\"5-2-特征选择\"><a href=\"#5-2-特征选择\" class=\"headerlink\" title=\"5.2 特征选择\"></a>5.2 特征选择</h1><h2 id=\"为什么要选择特征？\"><a href=\"#为什么要选择特征？\" class=\"headerlink\" title=\"为什么要选择特征？\"></a>为什么要选择特征？</h2><p>因为特征很多，从不同特征开始分类，得到的树的效果可能不一样。</p>\n<h2 id=\"选择特征\"><a href=\"#选择特征\" class=\"headerlink\" title=\"选择特征\"></a>选择特征</h2><p>我们怎么知道哪个特征更适合分类呢？或者说怎样来判断一个特征是不是适合分类呢？</p>\n<p>用<strong>信息增益</strong>来判断。</p>\n<h2 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h2><h3 id=\"熵\"><a href=\"#熵\" class=\"headerlink\" title=\"熵\"></a>熵</h3><p>$H(X)=-\\Sigma^n_{i=1}p_ilogp_i$ 也可以记作 <strong>H(p)</strong></p>\n<p>其中，X是取有限值的离散随机变量，概率分布为$P(x=x_i)=p_i,i=1,2,…,n$，<strong>当 $p_i$ 为 0 时，log 0 = 0.</strong></p>\n<p>意义：<strong>熵越大，随机变量的不确定性越大。也就是说，熵是用来衡量随机变量的不确定性的！</strong></p>\n<h3 id=\"条件熵\"><a href=\"#条件熵\" class=\"headerlink\" title=\"条件熵\"></a>条件熵</h3><p>$H(Y|X)=\\Sigma^n_{i=1}p_iH(Y|X=x_i)$  </p>\n<p><strong>表示的是，在已知X的条件下，Y的不确定性。</strong></p>\n<h3 id=\"经验熵与经验条件熵\"><a href=\"#经验熵与经验条件熵\" class=\"headerlink\" title=\"经验熵与经验条件熵\"></a>经验熵与经验条件熵</h3><p>如果概率 Pi 是由数据估计（特别是极大似然估计）得到的，所对应的熵和条件熵就是经验熵和经验条件熵。</p>\n<h3 id=\"互信息（也就是信息增益）\"><a href=\"#互信息（也就是信息增益）\" class=\"headerlink\" title=\"互信息（也就是信息增益）\"></a>互信息（也就是信息增益）</h3><p>熵与条件熵的差值。</p>\n<p>该差值表示了<strong>不确定性减少的程度</strong>，减少越多就说明这个“条件”适合进行分类。</p>\n<p><strong>因此，信息增益大的特征具有更强的分类能力。</strong></p>\n<h2 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h2><p><strong>输入：</strong>训练数据集D和特征A</p>\n<p><strong>对数据集的处理：</strong></p>\n<ol>\n<li>$|D|$表示样本容量</li>\n<li>有 $K $个类别，分别为$C_k$，每个类别中的样本个数为 $|C_k|$</li>\n<li>根据特征 A 可以将 D 划分为 n 个子集，分别为 $D_i$，$D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$</li>\n</ol>\n<p><strong>输出：</strong>特征A对训练数据集D的信息增益 $g(D,A)$</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p>计算数据集 D 的经验熵 H(D)</p>\n<p>$H(D)=-\\Sigma^K_{k=1}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}$ </p>\n</li>\n<li><p>计算特征A对数据机D的经验条件熵 H(D|A)</p>\n<p> $H(D|A)=\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}H(D_i)=-\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}\\Sigma^K_{i=1}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{D_i}$</p>\n</li>\n<li><p>计算信息增益</p>\n<p>$g(D,A)=H(D)-H(D|A)$</p>\n</li>\n</ol>\n<p>简单实用，但是<strong>缺点</strong>是：偏向于选择<strong>取值较多的特征。</strong></p>\n<h2 id=\"改进方法\"><a href=\"#改进方法\" class=\"headerlink\" title=\"改进方法\"></a>改进方法</h2><p>使用<strong>信息增益比</strong></p>\n<p><strong>信息增益比</strong>是信息增益与熵的比值。</p>\n<p>信息增益比$g_R(D,A)=\\frac{g(D,A)}{H_A(D)}$</p>\n<p>其中$H_A(D)=-\\Sigma^n_{i=1}\\frac{|D_i|}{|D|}log_2{|D_i|}{|D|}$，<strong>和前面的经验条件熵 H(D|A) 还是有点不一样的！</strong></p>\n<h1 id=\"5-3-决策树的生成\"><a href=\"#5-3-决策树的生成\" class=\"headerlink\" title=\"5.3 决策树的生成\"></a>5.3 决策树的生成</h1><h2 id=\"ID3算法\"><a href=\"#ID3算法\" class=\"headerlink\" title=\"ID3算法\"></a>ID3算法</h2><p>上面的内容只是选择了一个最优的特征值，大概相当于找到了一个比较好的根节点，但是还没有生成决策树。</p>\n<p>使用下面的算法生成决策树：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/ID3算法.png\" alt=\"ID3算法\"></p>\n<p><strong>缺点：容易过拟合</strong></p>\n<p>C4.5算法</p>\n<p>不同之处：选择<strong>信息增益比</strong>来选择特征。并不比ID3算法强多少。</p>\n<h1 id=\"5-4-决策树的剪枝\"><a href=\"#5-4-决策树的剪枝\" class=\"headerlink\" title=\"5.4 决策树的剪枝\"></a>5.4 决策树的剪枝</h1><p>剪枝就是让决策树的枝干少一点——这样鲁棒性更好。</p>\n<p>是减小过拟合的一种方法。</p>\n<p>一般方法是引入<strong>损失函数</strong>，衡量剪枝前后的效果（也就是比较剪枝前后的损失函数），选择损失函数最小的方式生成决策树。</p>\n<p>决策树的损失函数：</p>\n<p>$C_\\alpha(T)=\\Sigma^{|T|}_{t=1}N_tH_t(T)+\\alpha|T|$</p>\n<p>代入经验熵$H_t(T)=-\\Sigma_k\\frac{N_{tk}}{N_t}log\\frac{N_{tk}}{N_t}$即可。</p>\n<p>其中$\\alpha$的作用是：</p>\n<ul>\n<li>$\\alpha$越大，促使选择简单模型</li>\n<li>$\\alpha$越小，促使选择复杂模型</li>\n<li>$\\alpha$为0，不考虑模型复杂度</li>\n</ul>\n<p>$|T|$表示模型复杂度。</p>\n<h1 id=\"5-5-CART算法\"><a href=\"#5-5-CART算法\" class=\"headerlink\" title=\"5.5 CART算法\"></a>5.5 CART算法</h1><p>分类与回归树（classsification and regression tree）</p>\n<p>本方法不细讲了，主要思想其实很相近，只是完整地提出了从特征选择、决策树生成到剪枝的全过程，并且<strong>只使用二叉树（不管有几个选择）</strong>，所以泛化程度可能更好！</p>\n<p>生成：递归地构建<strong>二叉决策树</strong></p>\n<p>如何对输入空间进行划分</p>\n<p>特征选择：使用<strong>基尼指数</strong>最小化原则</p>\n<p>最小二乘回归树生成算法</p>\n<p><strong>其实本方法和前面的算法在逻辑上有相似之处，但是最大的不同是，这里的每一个子树都是二叉树。</strong></p>\n<hr>\n<h1 id=\"举个栗子！\"><a href=\"#举个栗子！\" class=\"headerlink\" title=\"举个栗子！\"></a>举个栗子！</h1><p><strong>下面是一个贷款申请的训练数据，我们先关注最后一栏，类别——就是是否同意贷款。</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ID</th>\n<th style=\"text-align:left\">年龄</th>\n<th style=\"text-align:left\">有工作</th>\n<th style=\"text-align:left\">有自己的房子</th>\n<th style=\"text-align:left\">信贷情况</th>\n<th style=\"text-align:left\">类别</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">青年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">非常好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">中年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">非常好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">非常好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">非常好</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">老年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">一般</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>OK，根据上面这个表格，如果给你一个新的数据，你怎样判断是不是要贷款给ta呢？</strong></p>\n<p>一步步来进行：</p>\n<p>首先可以看到特征比较多，从不同特征开始可以形成不同的决策树。</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/图-不同特征决定的不同决策数.png\" alt=\"图-不同特征决定的不同决策数\"></p>\n<p>经验熵$H(D)=-\\frac{9}{15}log_2\\frac{9}{15}-\\frac{6}{15}log_2\\frac{6}{15}=0.971$计算<strong>信息增益：</strong></p>\n<p>（1）条件经验熵：$D_1,D_2,D_3$分别是$D$中$A_1$(年龄)取值为青年、中年和老年的样本子集。</p>\n<p>$H(D_1)=-\\frac{2}{5}log_2\\frac{2}{5}-\\frac{3}{5}log_2\\frac{3}{5} \\\\ H(D_2)=-\\frac{3}{5}log_2\\frac{3}{5}-\\frac{2}{5}log_2\\frac{2}{5} \\\\ H(D_3)=-\\frac{4}{5}log_2\\frac{4}{5}-\\frac{1}{5}log_2\\frac{1}{5}$</p>\n<p>（2）分别以$A_1,A_2,A_3,A_4$ 表示年龄、有工作、有自己的房子和信贷情况<strong>四个特征</strong>，计算信息增益：</p>\n<p>$g(D,A_1)=H(D)-[\\frac{5}{15}H(D_1)+\\frac{5}{15}H(D_2)+\\frac{5}{15}H(D_3)]=0.971-0.888=0.083$</p>\n<p><strong>还没有完，这只是一个分类的信息增益！！</strong> </p>\n<p><strong>如果想要计算其他四个分类，还得重新计算条件经验熵，然后计算信息增益：</strong></p>\n<p>关于<strong>A2</strong>的信息增益：</p>\n<p>首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_2)=H(D)-[\\frac{5}{15}H(D_1)+\\frac{5}{15}H(D_2)]=0.324$</p>\n<p>关于<strong>A3</strong>的信息增益：</p>\n<p>首先有两个子集，计算$H(D_1),H(D_2)$，然后计算信息增益：$g(D,A_1)=H(D)-[\\frac{6}{15}H(D_1)+\\frac{9}{15}H(D_2)]=0.420$</p>\n<p>关于<strong>A4</strong>的信息增益：</p>\n<p>首先有三个子集，计算$H(D_1),H(D_2),H(D_3)$，然后计算信息增益：$g(D,A_1)=0.363$</p>\n<p><strong>根据信息增益的比较，特征$A_3$（有自己的房子）的信息增益最大，所以选择特征$A_3$作为最优特征</strong>。</p>\n<p>首先选取特征$A_3$作为根结点；然后$A_3$把数据集划分为两个子集$D_1$（表示有房子）和$D_2$（表示没有房子）。</p>\n<p>分别观察：</p>\n<p>（1）$D_1$只有同一类的样本点，所以是一个叶节点，标记为“是”。</p>\n<p>（2）$D_2$需要对其它三个特征$A_1,A_2,A_4$中选择新的特征：计算信息增益：$g(D_2,A_1)=H(D_2)-H(D_2|A_1)=0.918-0.667=0.251\\\\ g(D_2,A_2)=H(D_2)-H(D_2|A_2)=0.918\\\\ g(D_2,A_4)=H(D_2)-H(D_2|A_4)=0.474$</p>\n<p>信息增益最大的是$A_2$，所以$A_2$（有工作）成为一个子结点，然后再分支……计算，直到全部分类完毕。</p>\n<p><strong>本题比较巧，由$A_2$分类后，全部元素已经分类完毕了。</strong>例如，通过以上计算以后，我们得到的决策树就是：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/决策树的生成.png\" alt=\"决策树的生成\"></p>"},{"title":"LeetCode刷题笔记（一）","date":"2020-09-03T02:09:27.000Z","_content":"\n本文按题目排序，每期10题。\n\n本期内容多以排序为主，出现了滑动窗口等算法，学习到了python对于数组的一些操作。\n\n<!--more-->\n\n# 数组\n\n## 2. 两数相加\n\n`next`函数：返回迭代器的下一个项目\n\n`.next`函数：\n\npython3 中的 `->`，出现在函数定义中尤其的多：\n\n- 用于标记返回函数注释\n\n- 指示函数返回的类型\n\n- 常常出现在python函数定义的函数名后面，为函数添加元数据，描述函数的返回类型，从而方便开发人员使用：\n\n  ```python\n  def add(x,y) -> int:\n      return x+y\n  ```\n\n  这里面，元数据表明了函数的返回值为int类型\n\n本题提供了`ListNode`的类，应当学会使用\n\n- val一般是value的意思吧\n\n- 怎样实例化一个类？\n\n  ```python\n  class add:\n      type = 'add'\n      def __init__(self, name, sex, leg):\n          self.name = name\n          self.sex = sex\n          self.leg = leg\n          \n  cat = animal('cat', 'male', 4)\n  ```\n\n- 这里的`ListNode`类很巧妙，用的时候要注意\n\n  解题思路：[leecode第二题python解法](https://leetcode-cn.com/problems/add-two-numbers/solution/zui-zhi-bai-de-xie-fa-by-meng-zhi-hen-n-2/)\n\n## 3. 无重复字符的最长子串\n\n问题1：str变量有索引吗？似乎没有\n\n- subscriptable 可下标的，也就是可索引的\n\n问题2：如何把字符串转化为列表（有序）\n\n```python\n# 字符串用 split() 转化为列表\na = 'ab,cd,ef'\nprint(a.split(','))\n\n# 列表转化为字符串\nl = ['a', 'b']\nprint(''.join(l))\n```\n\n可是如果没有`,' '`逗号、空格之类的呢？\n\n额，醉了\n\n```python\ns = 'abc'\nlist(s)\n>>> ['a', 'b', 'c']\n```\n\n这道题还是有点难度的，并不是说都是从第一位开始来算的\n\n有可能从中间开始计算，那么这个时候该怎么办呢？\n\n首先移动到第 i 位，比较 该位之前所有位，是否与它相同\n\n记录位置，选最近的哪个\n\n\n\n几种特殊情况：\n\n**只有一个重复的，1**\n\n**空字符串，0**\n\n**字符串是空格：**\n\n- 怎样区分空格和空，是一个问题\n\n> ```python\n> len(str) == 0 # 这是字符串为空\n> str.isspace() == True # 这是字符串为空格\n> ```\n\n随之而来另一个问题：\n\n- 将字符串转为列表，空格是怎么处理的？\n\n> 这个我自己做了一个实验：\n>\n> 空格还是空格，还是放在那里的\n>\n> 而且它的布尔值也是True\n>\n> 与此同时，空字符串的bool值是False\n\n\n\n**只有两个字符：au，**怎么进行判断，那就是没有重复项，因此的话，需要直接把整个字符串的长度计算进来，也就是说到目前这个量都是对的\n\n\n\n现在的问题是`pwwkew`为什么结果是`5`而不是`3`\n\n开始流动，到了w，开始那个是1，最后这个，j=1或2，都会给list_lit增加一项\n\n比如说到k了，lit是空的，这个时候头已经变了，不再是从头开始了！\n\n设计一个num记录当前无重复的最大数值\n\n那么循环就应该从num开始\n\n\n\n这个题涉及的语言方法还是比较多的，我用的str方法\n\n题解中有用enumerate方法的，还有用C++中的指针方法的\n\n提到最多的还是“滑动窗口”\n\n其实倒也没有错，我的方法其实也是为了实现一个**滑动窗口**，并且记录窗口的长度，但是问题是空格该怎么算\n\n## 4. 寻找两个正序数组的中位数\n\n读题：本题的要求是：\n\n给的两个数列（list）顺序是好的\n\n但是最后要找的，是两个数组合并到一块，然后取中位数\n\n那么合并后的数组，要进行排序（或者不用排序了，使用一些算法来寻找中位数），这就是问题所在了\n\n**数组怎么排序呢？**\n\n`list.sort()`方法可以进行排序，默认是升序\n\n如果列表中有字符串，字符串是按照首字母顺序来的\n\n没有返回值\n\n本题中是正序数组\n\n**本题还对复杂度进行了要求：**\n\n![网页上的一张排序的时间复杂度详情](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/1226993-20191224220129568-1860331149.png)\n\n**本题核心：找第k小的数**\n\n用到了递归的方法\n\n我们比较了 第 k/2 个数的大小情况，然后cut掉一部分\n\n最后把一边消耗完，返回另一边最小的哪个数字\n\n**还有一种很巧妙的计算奇偶两个数列中位数的一个方法**\n\n```matlab\nk1 = (len(nums1) + len(nums2) + 1) // 2\nk2 = (len(nums1) + len(nums2) + 2) // 2\n```\n\n如果两个数列一奇一偶：\n\nk1 = k2\n\n如果两个数列都是奇数，或者都是偶数\n\nk1 是中间左边，k2是中间右边\n\n## 17. 电话号码的字母组合\n\n九键输入法中，2-9每个数字对应着一些字母\n\n给定一个仅包含数字2-9的**字符串**，返回所有它能表示的字母组合（顺序可以任意）\n\n![例图](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/17_telephone_keypad.png)\n\n本来来说，应该要给一个字典存放以下，以便记录每个数字都对应哪些字母\n\n但是实际上也有一定的规律，大多三个，有两个是四个，而且是连续的\n\n**分析：**\n\n输入是字符串，可以进行索引，然后找对应的字母\n\n- 每个数字 =》 对应几个字母\n- 下一个数字 =》 对应几个字母\n- 还需要做排列组合\n\n不过，这样的话，岂不是要做3-4层循环？而且还要逐个遍历\n\n感觉容易超时\n\n不对呀，我不是很好控制循环的层数，加之，组合出来的字符串实在有点多\n\n可以这样思考：\n\n如果你已经有了各数字对应的字母\n\n你会如何得到最后的字符串呢？\n\n直接两两组合\n\n这个两两组合还是会使用循环\n\n组合出的是字符串，组合的结果会放在列表里面\n\n```python\n# 移动到某一位\n# 当前位与之前的字符串进行各种组合\n# 把组合出的字符串重新加入字符列表\n```\n\n【9月3日】现在的方法是，判断列表是不是空的\n\n如果是空的，说明是第一个数字，那么此时，就需要填入单个的字符，但是这个字符又不能直接加到最后的内容中\n\n如果不是空的，这时已经不是第一个数字了\n\n所以我引入了一个新的列表，是上一个列表的copy\n\n## 122. 买卖股票的最佳时机 II\n\n给一个数组，第i个元素表示第i天的价格\n\n可以多次交易，但是购买前需要出售掉之前的股票，设计算法让利润最大\n\n（1）利润也就是价差，主要是卖的时候的价差\n\n（2）最多买i/2次，卖也是\n\n（3）应该是低价买进，高价卖出，找差价最大的两天？\n\n \t\t所以应该先找最低点，买进，然后找其后的最高点（跌之前卖出）\n\n跳出股票的场景，其实是在求**数组中数的差值**，上升过程中，找最大差值卖出，跌到最低，应当买入\n\n1. 滑动窗口，移动到当前值，判断大小：\n\n   小于上一个值，小于下一个值，此时应该买进\n\n   小于上一个值，大于下一个值，观望，下一个值（或之后）应该买进\n\n   大于上一个值，小于下一个值，观望，上一个值（或之前）应该买进\n\n   大于上一个值，大于下一个值，卖出\n\n2. 所以需要有一个股票计数君，记录当前手里有没有股票\n\n   没有才能买\n\n   有才能卖\n\n3. 还有一个利润君，计算利润\n\n手里有股票：\n\n- 价格\n\n```python\n# 未完\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        profit = 0\n        stock = 0\n        i = 1\n        while i < len(prices):\n            if stock:   # 手里有股票，应当卖出\n                # 观察价格，应当是最高点卖出\n                while prices[i] < prices[i+1] and i+1 < len(prices):\n                    i += 1\n                # 股票卖出\n                stock -= 1\n                i += 1\n            else：      # 手里没有股票，应该买进\n                # 观察价格，最低点买入\n                while prices[i] < prices[i-1] and i < len(prices):\n                    i += 1\n                # 股票买入\n                stock += 1\n        return profit\n```\n\n我怎么觉得是一个滑动窗口的问题\n\n试看一个窗口：\n\n如果手里还没有股票：\n\n- 此时如果是 ab，a<b，则在a买入\n- 如果ba，则观望\n\n如果手里已经有了股票：\n\n- 此时如果是ba，则在b卖出\n- 如果ab，则观望\n- 如果已经到结尾了，直接卖出\n\n也就是说总是第一个点交易，除非已到结尾\n\n这种方法是可以的，效果也还不错\n\n> 看别人的题解，有一种很秀的方法，是我这种方法的进化：\n>\n> 直接求**下一个数-本数**的差值（也就是利润）\n>\n> 如果是正的，就加上，如果是0或者负的，就跳过\n>\n> **至于连续上涨交易日，等价于每天都在买卖**\n\n\n\n## 136. 只出现一次的数字\n\n哈希表问题\n\n一个非空整数数组中：\n\n- 只有一个元素只出现了一次\n- 其余每个元素都出现了两次\n\n找出这个只出现了一次的元素\n\n额外要求：线性时间复杂度，不使用额外空间\n\n```python\n# 在有限能力范围内，我的想法是\nclass solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        # 首先给数组去重排序\n        # 然后遍历循环，找出数组中数字的索引位置\n        # 如果索引位置只有1个，那么就是只出现了一次\n```\n\n问题是：我要怎么分析它的时间复杂度是不是线性的，数组去重排序本身所用的时间就比较多，python中仅一句代码\n\n**列表的去重**\n\n（1）set方法，起始时转化成了元组，所以之后需要再转化成list，优点是索引值不变\n\n（2）itertools.groupby\n\n（3）fromkeys\n\n（4）添加到新的列表\n\n（5）列表的sort方法可以做到排序\n\n```python\n# 再思考，去重排序其实是多此一举的\nclass solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        # 遍历循环\n        # 找数组中有没有和它一样的\n        # 因为是从前往后的，已经遍历过的不算，已经配好对的也不能再遍历了\n```\n\n还是要排一下序，不然不好找\n\ncontinue和break\n\ncontinue仅停止本次循环\n\nbreak跳出本层循环体\n\n> NB的解法：\n>\n> （1）一个小神的解法是：由于全是数字，直接去重，然后double，减去原来的，得到的差就是唯一一个单个的数字；\n>\n> （2）**另一种解法是python中的异或：**\n>\n> **符号是`^`**\n>\n> **相同的数异或为0**\n>\n> **0和任何数异或，结果都是这个数本身**\n>\n> 所以，依次异或就可以，剩下来的一定是只出现一次的数\n>\n> （3）还有一种解法是：Collections.Counter() 函数，这是一个计数器\n\n\n\n## 202.快乐数\n\n一个正整数，每一次将该数替换为它每个位置上的数字的平方和，不断重复这个过程\n\n如果最终能够变成1，那么就是快乐数\n\n如果不能变成1，那么就不是快乐数\n\n> 其实变成1，就必须是一个1，和多个0\n\n```python\n# 另写一个函数，用来计算平方和\n# 其中，首先需要把上一个数字拆成单个数字的组合，把数字变成列表\n# 然后计算平方和并相加\n```\n\n**把数字，拆成一个个单个数字的列表**，可以先转换成字符串，然后再转换为列表\n\n关键问题是，如何判断它不是快乐数？\n\n一次循环，不行，两次循环不行，要多少次循环呢？\n\n无限循环始终变不到1，但是我不可能真的无限循环，要有判断吧！\n\n> 尝试251，发现，会有重复！如果出现重复，那么肯定是不可以了\n>\n> 也是，全部是100以内的加减法，所以第一次运算之后也不会大于3位\n>\n> 三位数的组合，能够实现快乐数的\n>\n> > 所以这里有一个问题，三位数，计算平方数，用循环显然不是很经济，取位才是更经济的方法\n\n递归似乎是有上限的，先后遇到两个问题：\n\n（1）`maximum recursion depth exceeded while getting the str of the object` 超出了最大递归深度，估计大概递归不到1000次就超出了\n\n**python中if 条件的非是：`if not`**\n\n没错，看了题解，我基本发现真相了\n\n就是判断有没有重复，然后再判断是不是1就可以了\n\n所以，需要一个之来存放已经出现过的值：\n\nset() 元组，特点是无序不重复，可以进行关系测试，计算交集、差集、并集等等\n\n## 724. 寻找数组的中心索引\n\n如果一个数组（python中是list）中，某个数的左侧数字之和 = 右侧数字之和，那么这个数就是中心数，返回索引值\n\n我的方法就是，先求出总和\n\n然后看左边的数字之和，是不是等于（总和-当前数字）/ 2\n\n```python\nclass Solution:\n    def pivotIndex(self, nums: List[int]) -> int:\n        i = 0\n        list_sum = sum(nums)\n        while i < len(nums):\n            left_sum = sum(nums[0:i])\n            if (list_sum - nums[i])/2 == left_sum:\n                return i\n            i += 1\n        return -1\n```\n\n一把过。\n\n# 筛法\n\n## 204. 计数质数\n\n这个题居然难度是简单？\n\n给一个n，统计小于n的质数的数量\n\n问题1：是不是得计算一下一个数是不是质数？\n\n- 质数，除了1和它本身，不能被其他数整除，但是这个其他数也要进行遍历吗？余数为0的检验\n\n问题2：计算资源的使用\n\n- 从1到n循环\n- 从1到n做除数，观察余数\n- 所以复杂度在$O(n^2)$级别\n\n最后要的只是数量，而没有要具体是哪些\n\n其实按照双循环的思路，做出来并不难，难的是速度，一下子就写出了代码，但是总是有**超时问题**，这个问题也很严重了！\n\n```python\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        count = 0\n        i = 1\n        # 判断每个数是不是质数\n        while i < n:\n            if self.is_primes(i):\n                # 如果是质数，则计数君加1\n                count += 1\n            i += 1\n        return count\n\n    # 判断一个数是不是质数\n    def is_primes(self, num: int) -> bool:\n        if num == 1:\n            return False\n        elif num == 2:\n            return True\n        else:\n            k = 2\n            while (k * k) <= num:\n                if num % k == 0:\n                    return False\n                else:\n                    k += 1\n            return True\n```\n\n理论上，已经除过的数的倍数也不能再作为除数了\n\n但是这个筛选听起来就很麻烦\n\n从解答来看\n\n1. **i不需要遍历到n，而只需要到sqrt(n)即可**\n\n   因为，如果不是素数，在sqrt(n)之后的乘数其实就是前面的反过来\n\n   ![image-20200818094425006](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200818094425006.png)\n\n   这样的话，复杂度降到了$O(\\sqrt n)$\n\n2. **其实也不是非要有一个判断质数的函数**\n\n   的确，比如3，没有必要从2开始除，这就是在白费力气\n\n   所以应该使用排除法\n\n   2是素数，2的倍数都不可能是素数\n\n   3也是素数，3的倍数\n\n   4因为是2的倍数，所以已经不是素数了\n\n   5仍然是素数，倍数\n\n   6是2的倍数，也是3的倍数\n\n   7仍然素数\n\n   8，2的倍数\n\n   9，3的倍数\n\n   **这个方法确实很妙！！**\n\n[**昂拉多塞筛法**：](https://leetcode-cn.com/problems/count-primes/comments/38186)\n\n由于给出的数是n，不妨给出一个有n个1的列表：方法是：`list =[1] * n`\n\n如果我们找出合数，然后把它的倍数所在位置的值标记为0:\n\n- 这个也是极妙\n- 如果2是素数，其倍数从2*2=4开始，到n结束，间隔都是2\n- 如果3是素数，其倍数从3*3=9开始（因为3x2已经是2的倍数了，就可以略过），到n结束，间隔都是3\n- 如果5是素数，其倍数从5*5=25开始······\n- 实在是很妙，所以就是 从 i*i 开始，到 n 结束，间隔为 i\n\n这要到最后，这个列表中为1的地方就是所有素数的索引位置了！\n\n纯粹筛法，不用仔细计算！\n\n# 其他\n\n## 面试题16.08 整数的英文表示\n\n有点意思\n\n这个题中：\n\n**首先看数字长度：**\n\n3位：hundred\n\n4位：thousand\n\n5位：xxty xx thousand（这个地方可能会比较难）\n\n6位： million\n\n9位：billion\n\n高于9位，还是billion\n\n\n\n每过一个点看3位数字\n\n用函数嵌套会比较好一点\n\n**另外两位数：**\n\n10-19有特殊的表示\n\n如果是0x一类的\n\n**三位数：**\n\nxxx hundred xxty xx\n\n**顺序：正向还是反向？**\n\n正向可能会好一点\n\n如果是反向的话，那么两位数的情况可能不是很通用\n\n\n\n问题一：python中，int没有长度，所以要先转化成list\n\n方法是，先从int转为str，然后从str转为list，或者str也是有长度的可以直接用\n\n> 参考：[python中str,int,list,list(str),list(int)的相互转换](https://blog.csdn.net/jingyoushui/article/details/100133496)\n\n这道题说实在的，道理就是这么多，每三位读取一次\n\n看位数，不停进行查找就可以了\n\n但是从一个题解来看，还是有可学习之处的，那就是怎么样把数字的写法写的更简洁\n\n其实除了 thousand、million、billion之外，其他部分的写法还是很通用的\n\n---\n\nOK！本期10题就先到这里了，期待下一个10题快点到来！","source":"_posts/LeetCode刷题笔记一.md","raw":"---\ntitle: LeetCode刷题笔记（一）\ndate: 2020-09-03 10:09:27\ncategories:\n\t- 算法\ntags:\n\t- LeetCode\n\t- 排序问题\n\t- 滑动窗口\n---\n\n本文按题目排序，每期10题。\n\n本期内容多以排序为主，出现了滑动窗口等算法，学习到了python对于数组的一些操作。\n\n<!--more-->\n\n# 数组\n\n## 2. 两数相加\n\n`next`函数：返回迭代器的下一个项目\n\n`.next`函数：\n\npython3 中的 `->`，出现在函数定义中尤其的多：\n\n- 用于标记返回函数注释\n\n- 指示函数返回的类型\n\n- 常常出现在python函数定义的函数名后面，为函数添加元数据，描述函数的返回类型，从而方便开发人员使用：\n\n  ```python\n  def add(x,y) -> int:\n      return x+y\n  ```\n\n  这里面，元数据表明了函数的返回值为int类型\n\n本题提供了`ListNode`的类，应当学会使用\n\n- val一般是value的意思吧\n\n- 怎样实例化一个类？\n\n  ```python\n  class add:\n      type = 'add'\n      def __init__(self, name, sex, leg):\n          self.name = name\n          self.sex = sex\n          self.leg = leg\n          \n  cat = animal('cat', 'male', 4)\n  ```\n\n- 这里的`ListNode`类很巧妙，用的时候要注意\n\n  解题思路：[leecode第二题python解法](https://leetcode-cn.com/problems/add-two-numbers/solution/zui-zhi-bai-de-xie-fa-by-meng-zhi-hen-n-2/)\n\n## 3. 无重复字符的最长子串\n\n问题1：str变量有索引吗？似乎没有\n\n- subscriptable 可下标的，也就是可索引的\n\n问题2：如何把字符串转化为列表（有序）\n\n```python\n# 字符串用 split() 转化为列表\na = 'ab,cd,ef'\nprint(a.split(','))\n\n# 列表转化为字符串\nl = ['a', 'b']\nprint(''.join(l))\n```\n\n可是如果没有`,' '`逗号、空格之类的呢？\n\n额，醉了\n\n```python\ns = 'abc'\nlist(s)\n>>> ['a', 'b', 'c']\n```\n\n这道题还是有点难度的，并不是说都是从第一位开始来算的\n\n有可能从中间开始计算，那么这个时候该怎么办呢？\n\n首先移动到第 i 位，比较 该位之前所有位，是否与它相同\n\n记录位置，选最近的哪个\n\n\n\n几种特殊情况：\n\n**只有一个重复的，1**\n\n**空字符串，0**\n\n**字符串是空格：**\n\n- 怎样区分空格和空，是一个问题\n\n> ```python\n> len(str) == 0 # 这是字符串为空\n> str.isspace() == True # 这是字符串为空格\n> ```\n\n随之而来另一个问题：\n\n- 将字符串转为列表，空格是怎么处理的？\n\n> 这个我自己做了一个实验：\n>\n> 空格还是空格，还是放在那里的\n>\n> 而且它的布尔值也是True\n>\n> 与此同时，空字符串的bool值是False\n\n\n\n**只有两个字符：au，**怎么进行判断，那就是没有重复项，因此的话，需要直接把整个字符串的长度计算进来，也就是说到目前这个量都是对的\n\n\n\n现在的问题是`pwwkew`为什么结果是`5`而不是`3`\n\n开始流动，到了w，开始那个是1，最后这个，j=1或2，都会给list_lit增加一项\n\n比如说到k了，lit是空的，这个时候头已经变了，不再是从头开始了！\n\n设计一个num记录当前无重复的最大数值\n\n那么循环就应该从num开始\n\n\n\n这个题涉及的语言方法还是比较多的，我用的str方法\n\n题解中有用enumerate方法的，还有用C++中的指针方法的\n\n提到最多的还是“滑动窗口”\n\n其实倒也没有错，我的方法其实也是为了实现一个**滑动窗口**，并且记录窗口的长度，但是问题是空格该怎么算\n\n## 4. 寻找两个正序数组的中位数\n\n读题：本题的要求是：\n\n给的两个数列（list）顺序是好的\n\n但是最后要找的，是两个数组合并到一块，然后取中位数\n\n那么合并后的数组，要进行排序（或者不用排序了，使用一些算法来寻找中位数），这就是问题所在了\n\n**数组怎么排序呢？**\n\n`list.sort()`方法可以进行排序，默认是升序\n\n如果列表中有字符串，字符串是按照首字母顺序来的\n\n没有返回值\n\n本题中是正序数组\n\n**本题还对复杂度进行了要求：**\n\n![网页上的一张排序的时间复杂度详情](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/1226993-20191224220129568-1860331149.png)\n\n**本题核心：找第k小的数**\n\n用到了递归的方法\n\n我们比较了 第 k/2 个数的大小情况，然后cut掉一部分\n\n最后把一边消耗完，返回另一边最小的哪个数字\n\n**还有一种很巧妙的计算奇偶两个数列中位数的一个方法**\n\n```matlab\nk1 = (len(nums1) + len(nums2) + 1) // 2\nk2 = (len(nums1) + len(nums2) + 2) // 2\n```\n\n如果两个数列一奇一偶：\n\nk1 = k2\n\n如果两个数列都是奇数，或者都是偶数\n\nk1 是中间左边，k2是中间右边\n\n## 17. 电话号码的字母组合\n\n九键输入法中，2-9每个数字对应着一些字母\n\n给定一个仅包含数字2-9的**字符串**，返回所有它能表示的字母组合（顺序可以任意）\n\n![例图](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/17_telephone_keypad.png)\n\n本来来说，应该要给一个字典存放以下，以便记录每个数字都对应哪些字母\n\n但是实际上也有一定的规律，大多三个，有两个是四个，而且是连续的\n\n**分析：**\n\n输入是字符串，可以进行索引，然后找对应的字母\n\n- 每个数字 =》 对应几个字母\n- 下一个数字 =》 对应几个字母\n- 还需要做排列组合\n\n不过，这样的话，岂不是要做3-4层循环？而且还要逐个遍历\n\n感觉容易超时\n\n不对呀，我不是很好控制循环的层数，加之，组合出来的字符串实在有点多\n\n可以这样思考：\n\n如果你已经有了各数字对应的字母\n\n你会如何得到最后的字符串呢？\n\n直接两两组合\n\n这个两两组合还是会使用循环\n\n组合出的是字符串，组合的结果会放在列表里面\n\n```python\n# 移动到某一位\n# 当前位与之前的字符串进行各种组合\n# 把组合出的字符串重新加入字符列表\n```\n\n【9月3日】现在的方法是，判断列表是不是空的\n\n如果是空的，说明是第一个数字，那么此时，就需要填入单个的字符，但是这个字符又不能直接加到最后的内容中\n\n如果不是空的，这时已经不是第一个数字了\n\n所以我引入了一个新的列表，是上一个列表的copy\n\n## 122. 买卖股票的最佳时机 II\n\n给一个数组，第i个元素表示第i天的价格\n\n可以多次交易，但是购买前需要出售掉之前的股票，设计算法让利润最大\n\n（1）利润也就是价差，主要是卖的时候的价差\n\n（2）最多买i/2次，卖也是\n\n（3）应该是低价买进，高价卖出，找差价最大的两天？\n\n \t\t所以应该先找最低点，买进，然后找其后的最高点（跌之前卖出）\n\n跳出股票的场景，其实是在求**数组中数的差值**，上升过程中，找最大差值卖出，跌到最低，应当买入\n\n1. 滑动窗口，移动到当前值，判断大小：\n\n   小于上一个值，小于下一个值，此时应该买进\n\n   小于上一个值，大于下一个值，观望，下一个值（或之后）应该买进\n\n   大于上一个值，小于下一个值，观望，上一个值（或之前）应该买进\n\n   大于上一个值，大于下一个值，卖出\n\n2. 所以需要有一个股票计数君，记录当前手里有没有股票\n\n   没有才能买\n\n   有才能卖\n\n3. 还有一个利润君，计算利润\n\n手里有股票：\n\n- 价格\n\n```python\n# 未完\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        profit = 0\n        stock = 0\n        i = 1\n        while i < len(prices):\n            if stock:   # 手里有股票，应当卖出\n                # 观察价格，应当是最高点卖出\n                while prices[i] < prices[i+1] and i+1 < len(prices):\n                    i += 1\n                # 股票卖出\n                stock -= 1\n                i += 1\n            else：      # 手里没有股票，应该买进\n                # 观察价格，最低点买入\n                while prices[i] < prices[i-1] and i < len(prices):\n                    i += 1\n                # 股票买入\n                stock += 1\n        return profit\n```\n\n我怎么觉得是一个滑动窗口的问题\n\n试看一个窗口：\n\n如果手里还没有股票：\n\n- 此时如果是 ab，a<b，则在a买入\n- 如果ba，则观望\n\n如果手里已经有了股票：\n\n- 此时如果是ba，则在b卖出\n- 如果ab，则观望\n- 如果已经到结尾了，直接卖出\n\n也就是说总是第一个点交易，除非已到结尾\n\n这种方法是可以的，效果也还不错\n\n> 看别人的题解，有一种很秀的方法，是我这种方法的进化：\n>\n> 直接求**下一个数-本数**的差值（也就是利润）\n>\n> 如果是正的，就加上，如果是0或者负的，就跳过\n>\n> **至于连续上涨交易日，等价于每天都在买卖**\n\n\n\n## 136. 只出现一次的数字\n\n哈希表问题\n\n一个非空整数数组中：\n\n- 只有一个元素只出现了一次\n- 其余每个元素都出现了两次\n\n找出这个只出现了一次的元素\n\n额外要求：线性时间复杂度，不使用额外空间\n\n```python\n# 在有限能力范围内，我的想法是\nclass solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        # 首先给数组去重排序\n        # 然后遍历循环，找出数组中数字的索引位置\n        # 如果索引位置只有1个，那么就是只出现了一次\n```\n\n问题是：我要怎么分析它的时间复杂度是不是线性的，数组去重排序本身所用的时间就比较多，python中仅一句代码\n\n**列表的去重**\n\n（1）set方法，起始时转化成了元组，所以之后需要再转化成list，优点是索引值不变\n\n（2）itertools.groupby\n\n（3）fromkeys\n\n（4）添加到新的列表\n\n（5）列表的sort方法可以做到排序\n\n```python\n# 再思考，去重排序其实是多此一举的\nclass solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        # 遍历循环\n        # 找数组中有没有和它一样的\n        # 因为是从前往后的，已经遍历过的不算，已经配好对的也不能再遍历了\n```\n\n还是要排一下序，不然不好找\n\ncontinue和break\n\ncontinue仅停止本次循环\n\nbreak跳出本层循环体\n\n> NB的解法：\n>\n> （1）一个小神的解法是：由于全是数字，直接去重，然后double，减去原来的，得到的差就是唯一一个单个的数字；\n>\n> （2）**另一种解法是python中的异或：**\n>\n> **符号是`^`**\n>\n> **相同的数异或为0**\n>\n> **0和任何数异或，结果都是这个数本身**\n>\n> 所以，依次异或就可以，剩下来的一定是只出现一次的数\n>\n> （3）还有一种解法是：Collections.Counter() 函数，这是一个计数器\n\n\n\n## 202.快乐数\n\n一个正整数，每一次将该数替换为它每个位置上的数字的平方和，不断重复这个过程\n\n如果最终能够变成1，那么就是快乐数\n\n如果不能变成1，那么就不是快乐数\n\n> 其实变成1，就必须是一个1，和多个0\n\n```python\n# 另写一个函数，用来计算平方和\n# 其中，首先需要把上一个数字拆成单个数字的组合，把数字变成列表\n# 然后计算平方和并相加\n```\n\n**把数字，拆成一个个单个数字的列表**，可以先转换成字符串，然后再转换为列表\n\n关键问题是，如何判断它不是快乐数？\n\n一次循环，不行，两次循环不行，要多少次循环呢？\n\n无限循环始终变不到1，但是我不可能真的无限循环，要有判断吧！\n\n> 尝试251，发现，会有重复！如果出现重复，那么肯定是不可以了\n>\n> 也是，全部是100以内的加减法，所以第一次运算之后也不会大于3位\n>\n> 三位数的组合，能够实现快乐数的\n>\n> > 所以这里有一个问题，三位数，计算平方数，用循环显然不是很经济，取位才是更经济的方法\n\n递归似乎是有上限的，先后遇到两个问题：\n\n（1）`maximum recursion depth exceeded while getting the str of the object` 超出了最大递归深度，估计大概递归不到1000次就超出了\n\n**python中if 条件的非是：`if not`**\n\n没错，看了题解，我基本发现真相了\n\n就是判断有没有重复，然后再判断是不是1就可以了\n\n所以，需要一个之来存放已经出现过的值：\n\nset() 元组，特点是无序不重复，可以进行关系测试，计算交集、差集、并集等等\n\n## 724. 寻找数组的中心索引\n\n如果一个数组（python中是list）中，某个数的左侧数字之和 = 右侧数字之和，那么这个数就是中心数，返回索引值\n\n我的方法就是，先求出总和\n\n然后看左边的数字之和，是不是等于（总和-当前数字）/ 2\n\n```python\nclass Solution:\n    def pivotIndex(self, nums: List[int]) -> int:\n        i = 0\n        list_sum = sum(nums)\n        while i < len(nums):\n            left_sum = sum(nums[0:i])\n            if (list_sum - nums[i])/2 == left_sum:\n                return i\n            i += 1\n        return -1\n```\n\n一把过。\n\n# 筛法\n\n## 204. 计数质数\n\n这个题居然难度是简单？\n\n给一个n，统计小于n的质数的数量\n\n问题1：是不是得计算一下一个数是不是质数？\n\n- 质数，除了1和它本身，不能被其他数整除，但是这个其他数也要进行遍历吗？余数为0的检验\n\n问题2：计算资源的使用\n\n- 从1到n循环\n- 从1到n做除数，观察余数\n- 所以复杂度在$O(n^2)$级别\n\n最后要的只是数量，而没有要具体是哪些\n\n其实按照双循环的思路，做出来并不难，难的是速度，一下子就写出了代码，但是总是有**超时问题**，这个问题也很严重了！\n\n```python\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        count = 0\n        i = 1\n        # 判断每个数是不是质数\n        while i < n:\n            if self.is_primes(i):\n                # 如果是质数，则计数君加1\n                count += 1\n            i += 1\n        return count\n\n    # 判断一个数是不是质数\n    def is_primes(self, num: int) -> bool:\n        if num == 1:\n            return False\n        elif num == 2:\n            return True\n        else:\n            k = 2\n            while (k * k) <= num:\n                if num % k == 0:\n                    return False\n                else:\n                    k += 1\n            return True\n```\n\n理论上，已经除过的数的倍数也不能再作为除数了\n\n但是这个筛选听起来就很麻烦\n\n从解答来看\n\n1. **i不需要遍历到n，而只需要到sqrt(n)即可**\n\n   因为，如果不是素数，在sqrt(n)之后的乘数其实就是前面的反过来\n\n   ![image-20200818094425006](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200818094425006.png)\n\n   这样的话，复杂度降到了$O(\\sqrt n)$\n\n2. **其实也不是非要有一个判断质数的函数**\n\n   的确，比如3，没有必要从2开始除，这就是在白费力气\n\n   所以应该使用排除法\n\n   2是素数，2的倍数都不可能是素数\n\n   3也是素数，3的倍数\n\n   4因为是2的倍数，所以已经不是素数了\n\n   5仍然是素数，倍数\n\n   6是2的倍数，也是3的倍数\n\n   7仍然素数\n\n   8，2的倍数\n\n   9，3的倍数\n\n   **这个方法确实很妙！！**\n\n[**昂拉多塞筛法**：](https://leetcode-cn.com/problems/count-primes/comments/38186)\n\n由于给出的数是n，不妨给出一个有n个1的列表：方法是：`list =[1] * n`\n\n如果我们找出合数，然后把它的倍数所在位置的值标记为0:\n\n- 这个也是极妙\n- 如果2是素数，其倍数从2*2=4开始，到n结束，间隔都是2\n- 如果3是素数，其倍数从3*3=9开始（因为3x2已经是2的倍数了，就可以略过），到n结束，间隔都是3\n- 如果5是素数，其倍数从5*5=25开始······\n- 实在是很妙，所以就是 从 i*i 开始，到 n 结束，间隔为 i\n\n这要到最后，这个列表中为1的地方就是所有素数的索引位置了！\n\n纯粹筛法，不用仔细计算！\n\n# 其他\n\n## 面试题16.08 整数的英文表示\n\n有点意思\n\n这个题中：\n\n**首先看数字长度：**\n\n3位：hundred\n\n4位：thousand\n\n5位：xxty xx thousand（这个地方可能会比较难）\n\n6位： million\n\n9位：billion\n\n高于9位，还是billion\n\n\n\n每过一个点看3位数字\n\n用函数嵌套会比较好一点\n\n**另外两位数：**\n\n10-19有特殊的表示\n\n如果是0x一类的\n\n**三位数：**\n\nxxx hundred xxty xx\n\n**顺序：正向还是反向？**\n\n正向可能会好一点\n\n如果是反向的话，那么两位数的情况可能不是很通用\n\n\n\n问题一：python中，int没有长度，所以要先转化成list\n\n方法是，先从int转为str，然后从str转为list，或者str也是有长度的可以直接用\n\n> 参考：[python中str,int,list,list(str),list(int)的相互转换](https://blog.csdn.net/jingyoushui/article/details/100133496)\n\n这道题说实在的，道理就是这么多，每三位读取一次\n\n看位数，不停进行查找就可以了\n\n但是从一个题解来看，还是有可学习之处的，那就是怎么样把数字的写法写的更简洁\n\n其实除了 thousand、million、billion之外，其他部分的写法还是很通用的\n\n---\n\nOK！本期10题就先到这里了，期待下一个10题快点到来！","slug":"LeetCode刷题笔记一","published":1,"updated":"2021-01-26T06:20:53.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n89g0041k8tl10fhfsx2","content":"<p>本文按题目排序，每期10题。</p>\n<p>本期内容多以排序为主，出现了滑动窗口等算法，学习到了python对于数组的一些操作。</p>\n<a id=\"more\"></a>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2. 两数相加\"></a>2. 两数相加</h2><p><code>next</code>函数：返回迭代器的下一个项目</p>\n<p><code>.next</code>函数：</p>\n<p>python3 中的 <code>-&gt;</code>，出现在函数定义中尤其的多：</p>\n<ul>\n<li><p>用于标记返回函数注释</p>\n</li>\n<li><p>指示函数返回的类型</p>\n</li>\n<li><p>常常出现在python函数定义的函数名后面，为函数添加元数据，描述函数的返回类型，从而方便开发人员使用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x,y)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y</span><br></pre></td></tr></table></figure>\n<p>这里面，元数据表明了函数的返回值为int类型</p>\n</li>\n</ul>\n<p>本题提供了<code>ListNode</code>的类，应当学会使用</p>\n<ul>\n<li><p>val一般是value的意思吧</p>\n</li>\n<li><p>怎样实例化一个类？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">add</span>:</span></span><br><span class=\"line\">    type = <span class=\"string\">'add'</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, sex, leg)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.sex = sex</span><br><span class=\"line\">        self.leg = leg</span><br><span class=\"line\">        </span><br><span class=\"line\">cat = animal(<span class=\"string\">'cat'</span>, <span class=\"string\">'male'</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这里的<code>ListNode</code>类很巧妙，用的时候要注意</p>\n<p>解题思路：<a href=\"https://leetcode-cn.com/problems/add-two-numbers/solution/zui-zhi-bai-de-xie-fa-by-meng-zhi-hen-n-2/\" target=\"_blank\" rel=\"noopener\">leecode第二题python解法</a></p>\n</li>\n</ul>\n<h2 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3. 无重复字符的最长子串\"></a>3. 无重复字符的最长子串</h2><p>问题1：str变量有索引吗？似乎没有</p>\n<ul>\n<li>subscriptable 可下标的，也就是可索引的</li>\n</ul>\n<p>问题2：如何把字符串转化为列表（有序）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 字符串用 split() 转化为列表</span></span><br><span class=\"line\">a = <span class=\"string\">'ab,cd,ef'</span></span><br><span class=\"line\">print(a.split(<span class=\"string\">','</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列表转化为字符串</span></span><br><span class=\"line\">l = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]</span><br><span class=\"line\">print(<span class=\"string\">''</span>.join(l))</span><br></pre></td></tr></table></figure>\n<p>可是如果没有<code>,&#39; &#39;</code>逗号、空格之类的呢？</p>\n<p>额，醉了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'abc'</span></span><br><span class=\"line\">list(s)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</span><br></pre></td></tr></table></figure>\n<p>这道题还是有点难度的，并不是说都是从第一位开始来算的</p>\n<p>有可能从中间开始计算，那么这个时候该怎么办呢？</p>\n<p>首先移动到第 i 位，比较 该位之前所有位，是否与它相同</p>\n<p>记录位置，选最近的哪个</p>\n<p>几种特殊情况：</p>\n<p><strong>只有一个重复的，1</strong></p>\n<p><strong>空字符串，0</strong></p>\n<p><strong>字符串是空格：</strong></p>\n<ul>\n<li>怎样区分空格和空，是一个问题</li>\n</ul>\n<blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len(str) == <span class=\"number\">0</span> <span class=\"comment\"># 这是字符串为空</span></span><br><span class=\"line\">str.isspace() == <span class=\"literal\">True</span> <span class=\"comment\"># 这是字符串为空格</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>随之而来另一个问题：</p>\n<ul>\n<li>将字符串转为列表，空格是怎么处理的？</li>\n</ul>\n<blockquote>\n<p>这个我自己做了一个实验：</p>\n<p>空格还是空格，还是放在那里的</p>\n<p>而且它的布尔值也是True</p>\n<p>与此同时，空字符串的bool值是False</p>\n</blockquote>\n<p><strong>只有两个字符：au，</strong>怎么进行判断，那就是没有重复项，因此的话，需要直接把整个字符串的长度计算进来，也就是说到目前这个量都是对的</p>\n<p>现在的问题是<code>pwwkew</code>为什么结果是<code>5</code>而不是<code>3</code></p>\n<p>开始流动，到了w，开始那个是1，最后这个，j=1或2，都会给list_lit增加一项</p>\n<p>比如说到k了，lit是空的，这个时候头已经变了，不再是从头开始了！</p>\n<p>设计一个num记录当前无重复的最大数值</p>\n<p>那么循环就应该从num开始</p>\n<p>这个题涉及的语言方法还是比较多的，我用的str方法</p>\n<p>题解中有用enumerate方法的，还有用C++中的指针方法的</p>\n<p>提到最多的还是“滑动窗口”</p>\n<p>其实倒也没有错，我的方法其实也是为了实现一个<strong>滑动窗口</strong>，并且记录窗口的长度，但是问题是空格该怎么算</p>\n<h2 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4. 寻找两个正序数组的中位数\"></a>4. 寻找两个正序数组的中位数</h2><p>读题：本题的要求是：</p>\n<p>给的两个数列（list）顺序是好的</p>\n<p>但是最后要找的，是两个数组合并到一块，然后取中位数</p>\n<p>那么合并后的数组，要进行排序（或者不用排序了，使用一些算法来寻找中位数），这就是问题所在了</p>\n<p><strong>数组怎么排序呢？</strong></p>\n<p><code>list.sort()</code>方法可以进行排序，默认是升序</p>\n<p>如果列表中有字符串，字符串是按照首字母顺序来的</p>\n<p>没有返回值</p>\n<p>本题中是正序数组</p>\n<p><strong>本题还对复杂度进行了要求：</strong></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/1226993-20191224220129568-1860331149.png\" alt=\"网页上的一张排序的时间复杂度详情\"></p>\n<p><strong>本题核心：找第k小的数</strong></p>\n<p>用到了递归的方法</p>\n<p>我们比较了 第 k/2 个数的大小情况，然后cut掉一部分</p>\n<p>最后把一边消耗完，返回另一边最小的哪个数字</p>\n<p><strong>还有一种很巧妙的计算奇偶两个数列中位数的一个方法</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k1 = (len(nums1) + len(nums2) + 1) // 2</span><br><span class=\"line\">k2 = (len(nums1) + len(nums2) + 2) // 2</span><br></pre></td></tr></table></figure>\n<p>如果两个数列一奇一偶：</p>\n<p>k1 = k2</p>\n<p>如果两个数列都是奇数，或者都是偶数</p>\n<p>k1 是中间左边，k2是中间右边</p>\n<h2 id=\"17-电话号码的字母组合\"><a href=\"#17-电话号码的字母组合\" class=\"headerlink\" title=\"17. 电话号码的字母组合\"></a>17. 电话号码的字母组合</h2><p>九键输入法中，2-9每个数字对应着一些字母</p>\n<p>给定一个仅包含数字2-9的<strong>字符串</strong>，返回所有它能表示的字母组合（顺序可以任意）</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/17_telephone_keypad.png\" alt=\"例图\"></p>\n<p>本来来说，应该要给一个字典存放以下，以便记录每个数字都对应哪些字母</p>\n<p>但是实际上也有一定的规律，大多三个，有两个是四个，而且是连续的</p>\n<p><strong>分析：</strong></p>\n<p>输入是字符串，可以进行索引，然后找对应的字母</p>\n<ul>\n<li>每个数字 =》 对应几个字母</li>\n<li>下一个数字 =》 对应几个字母</li>\n<li>还需要做排列组合</li>\n</ul>\n<p>不过，这样的话，岂不是要做3-4层循环？而且还要逐个遍历</p>\n<p>感觉容易超时</p>\n<p>不对呀，我不是很好控制循环的层数，加之，组合出来的字符串实在有点多</p>\n<p>可以这样思考：</p>\n<p>如果你已经有了各数字对应的字母</p>\n<p>你会如何得到最后的字符串呢？</p>\n<p>直接两两组合</p>\n<p>这个两两组合还是会使用循环</p>\n<p>组合出的是字符串，组合的结果会放在列表里面</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 移动到某一位</span></span><br><span class=\"line\"><span class=\"comment\"># 当前位与之前的字符串进行各种组合</span></span><br><span class=\"line\"><span class=\"comment\"># 把组合出的字符串重新加入字符列表</span></span><br></pre></td></tr></table></figure>\n<p>【9月3日】现在的方法是，判断列表是不是空的</p>\n<p>如果是空的，说明是第一个数字，那么此时，就需要填入单个的字符，但是这个字符又不能直接加到最后的内容中</p>\n<p>如果不是空的，这时已经不是第一个数字了</p>\n<p>所以我引入了一个新的列表，是上一个列表的copy</p>\n<h2 id=\"122-买卖股票的最佳时机-II\"><a href=\"#122-买卖股票的最佳时机-II\" class=\"headerlink\" title=\"122. 买卖股票的最佳时机 II\"></a>122. 买卖股票的最佳时机 II</h2><p>给一个数组，第i个元素表示第i天的价格</p>\n<p>可以多次交易，但是购买前需要出售掉之前的股票，设计算法让利润最大</p>\n<p>（1）利润也就是价差，主要是卖的时候的价差</p>\n<p>（2）最多买i/2次，卖也是</p>\n<p>（3）应该是低价买进，高价卖出，找差价最大的两天？</p>\n<pre><code>     所以应该先找最低点，买进，然后找其后的最高点（跌之前卖出）\n</code></pre><p>跳出股票的场景，其实是在求<strong>数组中数的差值</strong>，上升过程中，找最大差值卖出，跌到最低，应当买入</p>\n<ol>\n<li><p>滑动窗口，移动到当前值，判断大小：</p>\n<p>小于上一个值，小于下一个值，此时应该买进</p>\n<p>小于上一个值，大于下一个值，观望，下一个值（或之后）应该买进</p>\n<p>大于上一个值，小于下一个值，观望，上一个值（或之前）应该买进</p>\n<p>大于上一个值，大于下一个值，卖出</p>\n</li>\n<li><p>所以需要有一个股票计数君，记录当前手里有没有股票</p>\n<p>没有才能买</p>\n<p>有才能卖</p>\n</li>\n<li><p>还有一个利润君，计算利润</p>\n</li>\n</ol>\n<p>手里有股票：</p>\n<ul>\n<li>价格</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 未完</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        profit = <span class=\"number\">0</span></span><br><span class=\"line\">        stock = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(prices):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stock:   <span class=\"comment\"># 手里有股票，应当卖出</span></span><br><span class=\"line\">                <span class=\"comment\"># 观察价格，应当是最高点卖出</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> prices[i] &lt; prices[i+<span class=\"number\">1</span>] <span class=\"keyword\">and</span> i+<span class=\"number\">1</span> &lt; len(prices):</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"comment\"># 股票卖出</span></span><br><span class=\"line\">                stock -= <span class=\"number\">1</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>：      <span class=\"comment\"># 手里没有股票，应该买进</span></span><br><span class=\"line\">                <span class=\"comment\"># 观察价格，最低点买入</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> prices[i] &lt; prices[i<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> i &lt; len(prices):</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"comment\"># 股票买入</span></span><br><span class=\"line\">                stock += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n<p>我怎么觉得是一个滑动窗口的问题</p>\n<p>试看一个窗口：</p>\n<p>如果手里还没有股票：</p>\n<ul>\n<li>此时如果是 ab，a&lt;b，则在a买入</li>\n<li>如果ba，则观望</li>\n</ul>\n<p>如果手里已经有了股票：</p>\n<ul>\n<li>此时如果是ba，则在b卖出</li>\n<li>如果ab，则观望</li>\n<li>如果已经到结尾了，直接卖出</li>\n</ul>\n<p>也就是说总是第一个点交易，除非已到结尾</p>\n<p>这种方法是可以的，效果也还不错</p>\n<blockquote>\n<p>看别人的题解，有一种很秀的方法，是我这种方法的进化：</p>\n<p>直接求<strong>下一个数-本数</strong>的差值（也就是利润）</p>\n<p>如果是正的，就加上，如果是0或者负的，就跳过</p>\n<p><strong>至于连续上涨交易日，等价于每天都在买卖</strong></p>\n</blockquote>\n<h2 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a>136. 只出现一次的数字</h2><p>哈希表问题</p>\n<p>一个非空整数数组中：</p>\n<ul>\n<li>只有一个元素只出现了一次</li>\n<li>其余每个元素都出现了两次</li>\n</ul>\n<p>找出这个只出现了一次的元素</p>\n<p>额外要求：线性时间复杂度，不使用额外空间</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在有限能力范围内，我的想法是</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 首先给数组去重排序</span></span><br><span class=\"line\">        <span class=\"comment\"># 然后遍历循环，找出数组中数字的索引位置</span></span><br><span class=\"line\">        <span class=\"comment\"># 如果索引位置只有1个，那么就是只出现了一次</span></span><br></pre></td></tr></table></figure>\n<p>问题是：我要怎么分析它的时间复杂度是不是线性的，数组去重排序本身所用的时间就比较多，python中仅一句代码</p>\n<p><strong>列表的去重</strong></p>\n<p>（1）set方法，起始时转化成了元组，所以之后需要再转化成list，优点是索引值不变</p>\n<p>（2）itertools.groupby</p>\n<p>（3）fromkeys</p>\n<p>（4）添加到新的列表</p>\n<p>（5）列表的sort方法可以做到排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 再思考，去重排序其实是多此一举的</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 遍历循环</span></span><br><span class=\"line\">        <span class=\"comment\"># 找数组中有没有和它一样的</span></span><br><span class=\"line\">        <span class=\"comment\"># 因为是从前往后的，已经遍历过的不算，已经配好对的也不能再遍历了</span></span><br></pre></td></tr></table></figure>\n<p>还是要排一下序，不然不好找</p>\n<p>continue和break</p>\n<p>continue仅停止本次循环</p>\n<p>break跳出本层循环体</p>\n<blockquote>\n<p>NB的解法：</p>\n<p>（1）一个小神的解法是：由于全是数字，直接去重，然后double，减去原来的，得到的差就是唯一一个单个的数字；</p>\n<p>（2）<strong>另一种解法是python中的异或：</strong></p>\n<p><strong>符号是<code>^</code></strong></p>\n<p><strong>相同的数异或为0</strong></p>\n<p><strong>0和任何数异或，结果都是这个数本身</strong></p>\n<p>所以，依次异或就可以，剩下来的一定是只出现一次的数</p>\n<p>（3）还有一种解法是：Collections.Counter() 函数，这是一个计数器</p>\n</blockquote>\n<h2 id=\"202-快乐数\"><a href=\"#202-快乐数\" class=\"headerlink\" title=\"202.快乐数\"></a>202.快乐数</h2><p>一个正整数，每一次将该数替换为它每个位置上的数字的平方和，不断重复这个过程</p>\n<p>如果最终能够变成1，那么就是快乐数</p>\n<p>如果不能变成1，那么就不是快乐数</p>\n<blockquote>\n<p>其实变成1，就必须是一个1，和多个0</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 另写一个函数，用来计算平方和</span></span><br><span class=\"line\"><span class=\"comment\"># 其中，首先需要把上一个数字拆成单个数字的组合，把数字变成列表</span></span><br><span class=\"line\"><span class=\"comment\"># 然后计算平方和并相加</span></span><br></pre></td></tr></table></figure>\n<p><strong>把数字，拆成一个个单个数字的列表</strong>，可以先转换成字符串，然后再转换为列表</p>\n<p>关键问题是，如何判断它不是快乐数？</p>\n<p>一次循环，不行，两次循环不行，要多少次循环呢？</p>\n<p>无限循环始终变不到1，但是我不可能真的无限循环，要有判断吧！</p>\n<blockquote>\n<p>尝试251，发现，会有重复！如果出现重复，那么肯定是不可以了</p>\n<p>也是，全部是100以内的加减法，所以第一次运算之后也不会大于3位</p>\n<p>三位数的组合，能够实现快乐数的</p>\n<blockquote>\n<p>所以这里有一个问题，三位数，计算平方数，用循环显然不是很经济，取位才是更经济的方法</p>\n</blockquote>\n</blockquote>\n<p>递归似乎是有上限的，先后遇到两个问题：</p>\n<p>（1）<code>maximum recursion depth exceeded while getting the str of the object</code> 超出了最大递归深度，估计大概递归不到1000次就超出了</p>\n<p><strong>python中if 条件的非是：<code>if not</code></strong></p>\n<p>没错，看了题解，我基本发现真相了</p>\n<p>就是判断有没有重复，然后再判断是不是1就可以了</p>\n<p>所以，需要一个之来存放已经出现过的值：</p>\n<p>set() 元组，特点是无序不重复，可以进行关系测试，计算交集、差集、并集等等</p>\n<h2 id=\"724-寻找数组的中心索引\"><a href=\"#724-寻找数组的中心索引\" class=\"headerlink\" title=\"724. 寻找数组的中心索引\"></a>724. 寻找数组的中心索引</h2><p>如果一个数组（python中是list）中，某个数的左侧数字之和 = 右侧数字之和，那么这个数就是中心数，返回索引值</p>\n<p>我的方法就是，先求出总和</p>\n<p>然后看左边的数字之和，是不是等于（总和-当前数字）/ 2</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pivotIndex</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        list_sum = sum(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(nums):</span><br><span class=\"line\">            left_sum = sum(nums[<span class=\"number\">0</span>:i])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list_sum - nums[i])/<span class=\"number\">2</span> == left_sum:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>一把过。</p>\n<h1 id=\"筛法\"><a href=\"#筛法\" class=\"headerlink\" title=\"筛法\"></a>筛法</h1><h2 id=\"204-计数质数\"><a href=\"#204-计数质数\" class=\"headerlink\" title=\"204. 计数质数\"></a>204. 计数质数</h2><p>这个题居然难度是简单？</p>\n<p>给一个n，统计小于n的质数的数量</p>\n<p>问题1：是不是得计算一下一个数是不是质数？</p>\n<ul>\n<li>质数，除了1和它本身，不能被其他数整除，但是这个其他数也要进行遍历吗？余数为0的检验</li>\n</ul>\n<p>问题2：计算资源的使用</p>\n<ul>\n<li>从1到n循环</li>\n<li>从1到n做除数，观察余数</li>\n<li>所以复杂度在$O(n^2)$级别</li>\n</ul>\n<p>最后要的只是数量，而没有要具体是哪些</p>\n<p>其实按照双循环的思路，做出来并不难，难的是速度，一下子就写出了代码，但是总是有<strong>超时问题</strong>，这个问题也很严重了！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPrimes</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 判断每个数是不是质数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.is_primes(i):</span><br><span class=\"line\">                <span class=\"comment\"># 如果是质数，则计数君加1</span></span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 判断一个数是不是质数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_primes</span><span class=\"params\">(self, num: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            k = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (k * k) &lt;= num:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> num % k == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    k += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>理论上，已经除过的数的倍数也不能再作为除数了</p>\n<p>但是这个筛选听起来就很麻烦</p>\n<p>从解答来看</p>\n<ol>\n<li><p><strong>i不需要遍历到n，而只需要到sqrt(n)即可</strong></p>\n<p>因为，如果不是素数，在sqrt(n)之后的乘数其实就是前面的反过来</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200818094425006.png\" alt=\"image-20200818094425006\"></p>\n<p>这样的话，复杂度降到了$O(\\sqrt n)$</p>\n</li>\n<li><p><strong>其实也不是非要有一个判断质数的函数</strong></p>\n<p>的确，比如3，没有必要从2开始除，这就是在白费力气</p>\n<p>所以应该使用排除法</p>\n<p>2是素数，2的倍数都不可能是素数</p>\n<p>3也是素数，3的倍数</p>\n<p>4因为是2的倍数，所以已经不是素数了</p>\n<p>5仍然是素数，倍数</p>\n<p>6是2的倍数，也是3的倍数</p>\n<p>7仍然素数</p>\n<p>8，2的倍数</p>\n<p>9，3的倍数</p>\n<p><strong>这个方法确实很妙！！</strong></p>\n</li>\n</ol>\n<p><a href=\"https://leetcode-cn.com/problems/count-primes/comments/38186\" target=\"_blank\" rel=\"noopener\"><strong>昂拉多塞筛法</strong>：</a></p>\n<p>由于给出的数是n，不妨给出一个有n个1的列表：方法是：<code>list =[1] * n</code></p>\n<p>如果我们找出合数，然后把它的倍数所在位置的值标记为0:</p>\n<ul>\n<li>这个也是极妙</li>\n<li>如果2是素数，其倍数从2*2=4开始，到n结束，间隔都是2</li>\n<li>如果3是素数，其倍数从3*3=9开始（因为3x2已经是2的倍数了，就可以略过），到n结束，间隔都是3</li>\n<li>如果5是素数，其倍数从5*5=25开始······</li>\n<li>实在是很妙，所以就是 从 i*i 开始，到 n 结束，间隔为 i</li>\n</ul>\n<p>这要到最后，这个列表中为1的地方就是所有素数的索引位置了！</p>\n<p>纯粹筛法，不用仔细计算！</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"面试题16-08-整数的英文表示\"><a href=\"#面试题16-08-整数的英文表示\" class=\"headerlink\" title=\"面试题16.08 整数的英文表示\"></a>面试题16.08 整数的英文表示</h2><p>有点意思</p>\n<p>这个题中：</p>\n<p><strong>首先看数字长度：</strong></p>\n<p>3位：hundred</p>\n<p>4位：thousand</p>\n<p>5位：xxty xx thousand（这个地方可能会比较难）</p>\n<p>6位： million</p>\n<p>9位：billion</p>\n<p>高于9位，还是billion</p>\n<p>每过一个点看3位数字</p>\n<p>用函数嵌套会比较好一点</p>\n<p><strong>另外两位数：</strong></p>\n<p>10-19有特殊的表示</p>\n<p>如果是0x一类的</p>\n<p><strong>三位数：</strong></p>\n<p>xxx hundred xxty xx</p>\n<p><strong>顺序：正向还是反向？</strong></p>\n<p>正向可能会好一点</p>\n<p>如果是反向的话，那么两位数的情况可能不是很通用</p>\n<p>问题一：python中，int没有长度，所以要先转化成list</p>\n<p>方法是，先从int转为str，然后从str转为list，或者str也是有长度的可以直接用</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/jingyoushui/article/details/100133496\" target=\"_blank\" rel=\"noopener\">python中str,int,list,list(str),list(int)的相互转换</a></p>\n</blockquote>\n<p>这道题说实在的，道理就是这么多，每三位读取一次</p>\n<p>看位数，不停进行查找就可以了</p>\n<p>但是从一个题解来看，还是有可学习之处的，那就是怎么样把数字的写法写的更简洁</p>\n<p>其实除了 thousand、million、billion之外，其他部分的写法还是很通用的</p>\n<hr>\n<p>OK！本期10题就先到这里了，期待下一个10题快点到来！</p>\n","site":{"data":{}},"excerpt":"<p>本文按题目排序，每期10题。</p>\n<p>本期内容多以排序为主，出现了滑动窗口等算法，学习到了python对于数组的一些操作。</p>","more":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2. 两数相加\"></a>2. 两数相加</h2><p><code>next</code>函数：返回迭代器的下一个项目</p>\n<p><code>.next</code>函数：</p>\n<p>python3 中的 <code>-&gt;</code>，出现在函数定义中尤其的多：</p>\n<ul>\n<li><p>用于标记返回函数注释</p>\n</li>\n<li><p>指示函数返回的类型</p>\n</li>\n<li><p>常常出现在python函数定义的函数名后面，为函数添加元数据，描述函数的返回类型，从而方便开发人员使用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x,y)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y</span><br></pre></td></tr></table></figure>\n<p>这里面，元数据表明了函数的返回值为int类型</p>\n</li>\n</ul>\n<p>本题提供了<code>ListNode</code>的类，应当学会使用</p>\n<ul>\n<li><p>val一般是value的意思吧</p>\n</li>\n<li><p>怎样实例化一个类？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">add</span>:</span></span><br><span class=\"line\">    type = <span class=\"string\">'add'</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, sex, leg)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.sex = sex</span><br><span class=\"line\">        self.leg = leg</span><br><span class=\"line\">        </span><br><span class=\"line\">cat = animal(<span class=\"string\">'cat'</span>, <span class=\"string\">'male'</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这里的<code>ListNode</code>类很巧妙，用的时候要注意</p>\n<p>解题思路：<a href=\"https://leetcode-cn.com/problems/add-two-numbers/solution/zui-zhi-bai-de-xie-fa-by-meng-zhi-hen-n-2/\" target=\"_blank\" rel=\"noopener\">leecode第二题python解法</a></p>\n</li>\n</ul>\n<h2 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3. 无重复字符的最长子串\"></a>3. 无重复字符的最长子串</h2><p>问题1：str变量有索引吗？似乎没有</p>\n<ul>\n<li>subscriptable 可下标的，也就是可索引的</li>\n</ul>\n<p>问题2：如何把字符串转化为列表（有序）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 字符串用 split() 转化为列表</span></span><br><span class=\"line\">a = <span class=\"string\">'ab,cd,ef'</span></span><br><span class=\"line\">print(a.split(<span class=\"string\">','</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列表转化为字符串</span></span><br><span class=\"line\">l = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]</span><br><span class=\"line\">print(<span class=\"string\">''</span>.join(l))</span><br></pre></td></tr></table></figure>\n<p>可是如果没有<code>,&#39; &#39;</code>逗号、空格之类的呢？</p>\n<p>额，醉了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'abc'</span></span><br><span class=\"line\">list(s)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</span><br></pre></td></tr></table></figure>\n<p>这道题还是有点难度的，并不是说都是从第一位开始来算的</p>\n<p>有可能从中间开始计算，那么这个时候该怎么办呢？</p>\n<p>首先移动到第 i 位，比较 该位之前所有位，是否与它相同</p>\n<p>记录位置，选最近的哪个</p>\n<p>几种特殊情况：</p>\n<p><strong>只有一个重复的，1</strong></p>\n<p><strong>空字符串，0</strong></p>\n<p><strong>字符串是空格：</strong></p>\n<ul>\n<li>怎样区分空格和空，是一个问题</li>\n</ul>\n<blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len(str) == <span class=\"number\">0</span> <span class=\"comment\"># 这是字符串为空</span></span><br><span class=\"line\">str.isspace() == <span class=\"literal\">True</span> <span class=\"comment\"># 这是字符串为空格</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>随之而来另一个问题：</p>\n<ul>\n<li>将字符串转为列表，空格是怎么处理的？</li>\n</ul>\n<blockquote>\n<p>这个我自己做了一个实验：</p>\n<p>空格还是空格，还是放在那里的</p>\n<p>而且它的布尔值也是True</p>\n<p>与此同时，空字符串的bool值是False</p>\n</blockquote>\n<p><strong>只有两个字符：au，</strong>怎么进行判断，那就是没有重复项，因此的话，需要直接把整个字符串的长度计算进来，也就是说到目前这个量都是对的</p>\n<p>现在的问题是<code>pwwkew</code>为什么结果是<code>5</code>而不是<code>3</code></p>\n<p>开始流动，到了w，开始那个是1，最后这个，j=1或2，都会给list_lit增加一项</p>\n<p>比如说到k了，lit是空的，这个时候头已经变了，不再是从头开始了！</p>\n<p>设计一个num记录当前无重复的最大数值</p>\n<p>那么循环就应该从num开始</p>\n<p>这个题涉及的语言方法还是比较多的，我用的str方法</p>\n<p>题解中有用enumerate方法的，还有用C++中的指针方法的</p>\n<p>提到最多的还是“滑动窗口”</p>\n<p>其实倒也没有错，我的方法其实也是为了实现一个<strong>滑动窗口</strong>，并且记录窗口的长度，但是问题是空格该怎么算</p>\n<h2 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4. 寻找两个正序数组的中位数\"></a>4. 寻找两个正序数组的中位数</h2><p>读题：本题的要求是：</p>\n<p>给的两个数列（list）顺序是好的</p>\n<p>但是最后要找的，是两个数组合并到一块，然后取中位数</p>\n<p>那么合并后的数组，要进行排序（或者不用排序了，使用一些算法来寻找中位数），这就是问题所在了</p>\n<p><strong>数组怎么排序呢？</strong></p>\n<p><code>list.sort()</code>方法可以进行排序，默认是升序</p>\n<p>如果列表中有字符串，字符串是按照首字母顺序来的</p>\n<p>没有返回值</p>\n<p>本题中是正序数组</p>\n<p><strong>本题还对复杂度进行了要求：</strong></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/1226993-20191224220129568-1860331149.png\" alt=\"网页上的一张排序的时间复杂度详情\"></p>\n<p><strong>本题核心：找第k小的数</strong></p>\n<p>用到了递归的方法</p>\n<p>我们比较了 第 k/2 个数的大小情况，然后cut掉一部分</p>\n<p>最后把一边消耗完，返回另一边最小的哪个数字</p>\n<p><strong>还有一种很巧妙的计算奇偶两个数列中位数的一个方法</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k1 = (len(nums1) + len(nums2) + 1) // 2</span><br><span class=\"line\">k2 = (len(nums1) + len(nums2) + 2) // 2</span><br></pre></td></tr></table></figure>\n<p>如果两个数列一奇一偶：</p>\n<p>k1 = k2</p>\n<p>如果两个数列都是奇数，或者都是偶数</p>\n<p>k1 是中间左边，k2是中间右边</p>\n<h2 id=\"17-电话号码的字母组合\"><a href=\"#17-电话号码的字母组合\" class=\"headerlink\" title=\"17. 电话号码的字母组合\"></a>17. 电话号码的字母组合</h2><p>九键输入法中，2-9每个数字对应着一些字母</p>\n<p>给定一个仅包含数字2-9的<strong>字符串</strong>，返回所有它能表示的字母组合（顺序可以任意）</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/17_telephone_keypad.png\" alt=\"例图\"></p>\n<p>本来来说，应该要给一个字典存放以下，以便记录每个数字都对应哪些字母</p>\n<p>但是实际上也有一定的规律，大多三个，有两个是四个，而且是连续的</p>\n<p><strong>分析：</strong></p>\n<p>输入是字符串，可以进行索引，然后找对应的字母</p>\n<ul>\n<li>每个数字 =》 对应几个字母</li>\n<li>下一个数字 =》 对应几个字母</li>\n<li>还需要做排列组合</li>\n</ul>\n<p>不过，这样的话，岂不是要做3-4层循环？而且还要逐个遍历</p>\n<p>感觉容易超时</p>\n<p>不对呀，我不是很好控制循环的层数，加之，组合出来的字符串实在有点多</p>\n<p>可以这样思考：</p>\n<p>如果你已经有了各数字对应的字母</p>\n<p>你会如何得到最后的字符串呢？</p>\n<p>直接两两组合</p>\n<p>这个两两组合还是会使用循环</p>\n<p>组合出的是字符串，组合的结果会放在列表里面</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 移动到某一位</span></span><br><span class=\"line\"><span class=\"comment\"># 当前位与之前的字符串进行各种组合</span></span><br><span class=\"line\"><span class=\"comment\"># 把组合出的字符串重新加入字符列表</span></span><br></pre></td></tr></table></figure>\n<p>【9月3日】现在的方法是，判断列表是不是空的</p>\n<p>如果是空的，说明是第一个数字，那么此时，就需要填入单个的字符，但是这个字符又不能直接加到最后的内容中</p>\n<p>如果不是空的，这时已经不是第一个数字了</p>\n<p>所以我引入了一个新的列表，是上一个列表的copy</p>\n<h2 id=\"122-买卖股票的最佳时机-II\"><a href=\"#122-买卖股票的最佳时机-II\" class=\"headerlink\" title=\"122. 买卖股票的最佳时机 II\"></a>122. 买卖股票的最佳时机 II</h2><p>给一个数组，第i个元素表示第i天的价格</p>\n<p>可以多次交易，但是购买前需要出售掉之前的股票，设计算法让利润最大</p>\n<p>（1）利润也就是价差，主要是卖的时候的价差</p>\n<p>（2）最多买i/2次，卖也是</p>\n<p>（3）应该是低价买进，高价卖出，找差价最大的两天？</p>\n<pre><code>     所以应该先找最低点，买进，然后找其后的最高点（跌之前卖出）\n</code></pre><p>跳出股票的场景，其实是在求<strong>数组中数的差值</strong>，上升过程中，找最大差值卖出，跌到最低，应当买入</p>\n<ol>\n<li><p>滑动窗口，移动到当前值，判断大小：</p>\n<p>小于上一个值，小于下一个值，此时应该买进</p>\n<p>小于上一个值，大于下一个值，观望，下一个值（或之后）应该买进</p>\n<p>大于上一个值，小于下一个值，观望，上一个值（或之前）应该买进</p>\n<p>大于上一个值，大于下一个值，卖出</p>\n</li>\n<li><p>所以需要有一个股票计数君，记录当前手里有没有股票</p>\n<p>没有才能买</p>\n<p>有才能卖</p>\n</li>\n<li><p>还有一个利润君，计算利润</p>\n</li>\n</ol>\n<p>手里有股票：</p>\n<ul>\n<li>价格</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 未完</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        profit = <span class=\"number\">0</span></span><br><span class=\"line\">        stock = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(prices):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> stock:   <span class=\"comment\"># 手里有股票，应当卖出</span></span><br><span class=\"line\">                <span class=\"comment\"># 观察价格，应当是最高点卖出</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> prices[i] &lt; prices[i+<span class=\"number\">1</span>] <span class=\"keyword\">and</span> i+<span class=\"number\">1</span> &lt; len(prices):</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"comment\"># 股票卖出</span></span><br><span class=\"line\">                stock -= <span class=\"number\">1</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>：      <span class=\"comment\"># 手里没有股票，应该买进</span></span><br><span class=\"line\">                <span class=\"comment\"># 观察价格，最低点买入</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> prices[i] &lt; prices[i<span class=\"number\">-1</span>] <span class=\"keyword\">and</span> i &lt; len(prices):</span><br><span class=\"line\">                    i += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"comment\"># 股票买入</span></span><br><span class=\"line\">                stock += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> profit</span><br></pre></td></tr></table></figure>\n<p>我怎么觉得是一个滑动窗口的问题</p>\n<p>试看一个窗口：</p>\n<p>如果手里还没有股票：</p>\n<ul>\n<li>此时如果是 ab，a&lt;b，则在a买入</li>\n<li>如果ba，则观望</li>\n</ul>\n<p>如果手里已经有了股票：</p>\n<ul>\n<li>此时如果是ba，则在b卖出</li>\n<li>如果ab，则观望</li>\n<li>如果已经到结尾了，直接卖出</li>\n</ul>\n<p>也就是说总是第一个点交易，除非已到结尾</p>\n<p>这种方法是可以的，效果也还不错</p>\n<blockquote>\n<p>看别人的题解，有一种很秀的方法，是我这种方法的进化：</p>\n<p>直接求<strong>下一个数-本数</strong>的差值（也就是利润）</p>\n<p>如果是正的，就加上，如果是0或者负的，就跳过</p>\n<p><strong>至于连续上涨交易日，等价于每天都在买卖</strong></p>\n</blockquote>\n<h2 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a>136. 只出现一次的数字</h2><p>哈希表问题</p>\n<p>一个非空整数数组中：</p>\n<ul>\n<li>只有一个元素只出现了一次</li>\n<li>其余每个元素都出现了两次</li>\n</ul>\n<p>找出这个只出现了一次的元素</p>\n<p>额外要求：线性时间复杂度，不使用额外空间</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在有限能力范围内，我的想法是</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 首先给数组去重排序</span></span><br><span class=\"line\">        <span class=\"comment\"># 然后遍历循环，找出数组中数字的索引位置</span></span><br><span class=\"line\">        <span class=\"comment\"># 如果索引位置只有1个，那么就是只出现了一次</span></span><br></pre></td></tr></table></figure>\n<p>问题是：我要怎么分析它的时间复杂度是不是线性的，数组去重排序本身所用的时间就比较多，python中仅一句代码</p>\n<p><strong>列表的去重</strong></p>\n<p>（1）set方法，起始时转化成了元组，所以之后需要再转化成list，优点是索引值不变</p>\n<p>（2）itertools.groupby</p>\n<p>（3）fromkeys</p>\n<p>（4）添加到新的列表</p>\n<p>（5）列表的sort方法可以做到排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 再思考，去重排序其实是多此一举的</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 遍历循环</span></span><br><span class=\"line\">        <span class=\"comment\"># 找数组中有没有和它一样的</span></span><br><span class=\"line\">        <span class=\"comment\"># 因为是从前往后的，已经遍历过的不算，已经配好对的也不能再遍历了</span></span><br></pre></td></tr></table></figure>\n<p>还是要排一下序，不然不好找</p>\n<p>continue和break</p>\n<p>continue仅停止本次循环</p>\n<p>break跳出本层循环体</p>\n<blockquote>\n<p>NB的解法：</p>\n<p>（1）一个小神的解法是：由于全是数字，直接去重，然后double，减去原来的，得到的差就是唯一一个单个的数字；</p>\n<p>（2）<strong>另一种解法是python中的异或：</strong></p>\n<p><strong>符号是<code>^</code></strong></p>\n<p><strong>相同的数异或为0</strong></p>\n<p><strong>0和任何数异或，结果都是这个数本身</strong></p>\n<p>所以，依次异或就可以，剩下来的一定是只出现一次的数</p>\n<p>（3）还有一种解法是：Collections.Counter() 函数，这是一个计数器</p>\n</blockquote>\n<h2 id=\"202-快乐数\"><a href=\"#202-快乐数\" class=\"headerlink\" title=\"202.快乐数\"></a>202.快乐数</h2><p>一个正整数，每一次将该数替换为它每个位置上的数字的平方和，不断重复这个过程</p>\n<p>如果最终能够变成1，那么就是快乐数</p>\n<p>如果不能变成1，那么就不是快乐数</p>\n<blockquote>\n<p>其实变成1，就必须是一个1，和多个0</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 另写一个函数，用来计算平方和</span></span><br><span class=\"line\"><span class=\"comment\"># 其中，首先需要把上一个数字拆成单个数字的组合，把数字变成列表</span></span><br><span class=\"line\"><span class=\"comment\"># 然后计算平方和并相加</span></span><br></pre></td></tr></table></figure>\n<p><strong>把数字，拆成一个个单个数字的列表</strong>，可以先转换成字符串，然后再转换为列表</p>\n<p>关键问题是，如何判断它不是快乐数？</p>\n<p>一次循环，不行，两次循环不行，要多少次循环呢？</p>\n<p>无限循环始终变不到1，但是我不可能真的无限循环，要有判断吧！</p>\n<blockquote>\n<p>尝试251，发现，会有重复！如果出现重复，那么肯定是不可以了</p>\n<p>也是，全部是100以内的加减法，所以第一次运算之后也不会大于3位</p>\n<p>三位数的组合，能够实现快乐数的</p>\n<blockquote>\n<p>所以这里有一个问题，三位数，计算平方数，用循环显然不是很经济，取位才是更经济的方法</p>\n</blockquote>\n</blockquote>\n<p>递归似乎是有上限的，先后遇到两个问题：</p>\n<p>（1）<code>maximum recursion depth exceeded while getting the str of the object</code> 超出了最大递归深度，估计大概递归不到1000次就超出了</p>\n<p><strong>python中if 条件的非是：<code>if not</code></strong></p>\n<p>没错，看了题解，我基本发现真相了</p>\n<p>就是判断有没有重复，然后再判断是不是1就可以了</p>\n<p>所以，需要一个之来存放已经出现过的值：</p>\n<p>set() 元组，特点是无序不重复，可以进行关系测试，计算交集、差集、并集等等</p>\n<h2 id=\"724-寻找数组的中心索引\"><a href=\"#724-寻找数组的中心索引\" class=\"headerlink\" title=\"724. 寻找数组的中心索引\"></a>724. 寻找数组的中心索引</h2><p>如果一个数组（python中是list）中，某个数的左侧数字之和 = 右侧数字之和，那么这个数就是中心数，返回索引值</p>\n<p>我的方法就是，先求出总和</p>\n<p>然后看左边的数字之和，是不是等于（总和-当前数字）/ 2</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pivotIndex</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        list_sum = sum(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(nums):</span><br><span class=\"line\">            left_sum = sum(nums[<span class=\"number\">0</span>:i])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list_sum - nums[i])/<span class=\"number\">2</span> == left_sum:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<p>一把过。</p>\n<h1 id=\"筛法\"><a href=\"#筛法\" class=\"headerlink\" title=\"筛法\"></a>筛法</h1><h2 id=\"204-计数质数\"><a href=\"#204-计数质数\" class=\"headerlink\" title=\"204. 计数质数\"></a>204. 计数质数</h2><p>这个题居然难度是简单？</p>\n<p>给一个n，统计小于n的质数的数量</p>\n<p>问题1：是不是得计算一下一个数是不是质数？</p>\n<ul>\n<li>质数，除了1和它本身，不能被其他数整除，但是这个其他数也要进行遍历吗？余数为0的检验</li>\n</ul>\n<p>问题2：计算资源的使用</p>\n<ul>\n<li>从1到n循环</li>\n<li>从1到n做除数，观察余数</li>\n<li>所以复杂度在$O(n^2)$级别</li>\n</ul>\n<p>最后要的只是数量，而没有要具体是哪些</p>\n<p>其实按照双循环的思路，做出来并不难，难的是速度，一下子就写出了代码，但是总是有<strong>超时问题</strong>，这个问题也很严重了！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPrimes</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 判断每个数是不是质数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.is_primes(i):</span><br><span class=\"line\">                <span class=\"comment\"># 如果是质数，则计数君加1</span></span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 判断一个数是不是质数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_primes</span><span class=\"params\">(self, num: int)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> num == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            k = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (k * k) &lt;= num:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> num % k == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    k += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>理论上，已经除过的数的倍数也不能再作为除数了</p>\n<p>但是这个筛选听起来就很麻烦</p>\n<p>从解答来看</p>\n<ol>\n<li><p><strong>i不需要遍历到n，而只需要到sqrt(n)即可</strong></p>\n<p>因为，如果不是素数，在sqrt(n)之后的乘数其实就是前面的反过来</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20200818094425006.png\" alt=\"image-20200818094425006\"></p>\n<p>这样的话，复杂度降到了$O(\\sqrt n)$</p>\n</li>\n<li><p><strong>其实也不是非要有一个判断质数的函数</strong></p>\n<p>的确，比如3，没有必要从2开始除，这就是在白费力气</p>\n<p>所以应该使用排除法</p>\n<p>2是素数，2的倍数都不可能是素数</p>\n<p>3也是素数，3的倍数</p>\n<p>4因为是2的倍数，所以已经不是素数了</p>\n<p>5仍然是素数，倍数</p>\n<p>6是2的倍数，也是3的倍数</p>\n<p>7仍然素数</p>\n<p>8，2的倍数</p>\n<p>9，3的倍数</p>\n<p><strong>这个方法确实很妙！！</strong></p>\n</li>\n</ol>\n<p><a href=\"https://leetcode-cn.com/problems/count-primes/comments/38186\" target=\"_blank\" rel=\"noopener\"><strong>昂拉多塞筛法</strong>：</a></p>\n<p>由于给出的数是n，不妨给出一个有n个1的列表：方法是：<code>list =[1] * n</code></p>\n<p>如果我们找出合数，然后把它的倍数所在位置的值标记为0:</p>\n<ul>\n<li>这个也是极妙</li>\n<li>如果2是素数，其倍数从2*2=4开始，到n结束，间隔都是2</li>\n<li>如果3是素数，其倍数从3*3=9开始（因为3x2已经是2的倍数了，就可以略过），到n结束，间隔都是3</li>\n<li>如果5是素数，其倍数从5*5=25开始······</li>\n<li>实在是很妙，所以就是 从 i*i 开始，到 n 结束，间隔为 i</li>\n</ul>\n<p>这要到最后，这个列表中为1的地方就是所有素数的索引位置了！</p>\n<p>纯粹筛法，不用仔细计算！</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"面试题16-08-整数的英文表示\"><a href=\"#面试题16-08-整数的英文表示\" class=\"headerlink\" title=\"面试题16.08 整数的英文表示\"></a>面试题16.08 整数的英文表示</h2><p>有点意思</p>\n<p>这个题中：</p>\n<p><strong>首先看数字长度：</strong></p>\n<p>3位：hundred</p>\n<p>4位：thousand</p>\n<p>5位：xxty xx thousand（这个地方可能会比较难）</p>\n<p>6位： million</p>\n<p>9位：billion</p>\n<p>高于9位，还是billion</p>\n<p>每过一个点看3位数字</p>\n<p>用函数嵌套会比较好一点</p>\n<p><strong>另外两位数：</strong></p>\n<p>10-19有特殊的表示</p>\n<p>如果是0x一类的</p>\n<p><strong>三位数：</strong></p>\n<p>xxx hundred xxty xx</p>\n<p><strong>顺序：正向还是反向？</strong></p>\n<p>正向可能会好一点</p>\n<p>如果是反向的话，那么两位数的情况可能不是很通用</p>\n<p>问题一：python中，int没有长度，所以要先转化成list</p>\n<p>方法是，先从int转为str，然后从str转为list，或者str也是有长度的可以直接用</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/jingyoushui/article/details/100133496\" target=\"_blank\" rel=\"noopener\">python中str,int,list,list(str),list(int)的相互转换</a></p>\n</blockquote>\n<p>这道题说实在的，道理就是这么多，每三位读取一次</p>\n<p>看位数，不停进行查找就可以了</p>\n<p>但是从一个题解来看，还是有可学习之处的，那就是怎么样把数字的写法写的更简洁</p>\n<p>其实除了 thousand、million、billion之外，其他部分的写法还是很通用的</p>\n<hr>\n<p>OK！本期10题就先到这里了，期待下一个10题快点到来！</p>"},{"title":"LeetCode刷题笔记（七）","date":"2021-03-29T08:46:05.000Z","_content":"\n# <!-- 链表 -->\n\n## 206. 反转链表\n\n这个题其实已经做过多次了，这次总结一下：\n\n题目要求：给出一个链表的头节点，请反转整个链表，并且返回反转后的链表的头节点。\n\n这个题用递归的方法简直是非常之妙，而且十分经典。\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverse(self, head: ListNode) -> ListNone:\n        if not head or not head.next: return head\n        last = self.reverse(head.next)\n        head.next.next = head\n        head.next = None\n        return last\n```\n\n这个做法简直非常精妙，充分体现了递归方法中的关键：\n\n1）找一个最简问题，解决它\n\n2）充分理解并相信函数能解决你的问题\n\n<!-- more -->\n\n## 92. 反转链表 II\n\n这道题要求的是 反转链表中的某一部分\n\n比如给出 head，left，right，请反转从 left 到 right 的部分\n\n![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)\n\n根据前面做过的反转链表，这里的思路大概有两种：\n\n1. 先反转 left 到 末尾，再反转 right 到末尾；但是这种方法仔细一想就是不可能的，因为第一次反转之后，末尾的元素到前面来了，要想再把它们翻转回去是不可能的。\n2. 只翻转 left 到 right 的部分，然后再拼接起来。\n\n第2种方法是可行的，但是需要考虑的问题有：\n\n1. 要记录 left 的前一个节点 pre\n2. 要记录 right 的后一个节点 succ（successor）\n3. pre 的 next 指向反转后的头节点\n4. 反转后的尾节点的 next 指向 succ\n\n可见是一个比较复杂的问题，应该怎么处理呢\n\n---\n\n### 官方题解\n\n分为7个步骤：\n\n1）在头节点前添加哑节点防止头节点变化，哑节点不能动\n\n2）创建一个移动节点寻找左节点的上一个节点，其实也就找到了左节点\n\n3）再创建一个移动节点到右节点，其实也就找到了右节点的下一个节点\n\n4）截断中间部分\n\n5）反转中间部分（用一个无返回值的函数进行操作）\n\n6）重接中间部分\n\n7）返回哑节点的下一个节点\n\n> 我的题解：[官方解法-python复现](https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/guan-fang-jie-fa-pythonfu-xian-by-yue-wo-kebj/)\n\n# <!-- 单调栈、哨兵 -->\n\n## 84. 柱状图中的最大的矩形\n\n问题描述：\n\n给出一个柱形图（数组），数组中的元素表示柱的高度，现在需要在柱形图中找出一个能画出的最大的矩形，比如：\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)\n\n---\n\n先从暴力解法——枚举开始。\n\n（1）枚举宽度【左右边界】\n\n1. 左边界从0开始遍历\n2. 右边界从左边界开始遍历\n3. 高度取从左边界到右边界区间最矮高度\n4. 计算面积，记录最大面积\n\n这样一看，这个题的暴力方法其实也是很规矩的。\n\n缺点是：时间复杂度在 O(N^2)，因为有循环套循环，而且占用内存也不小。\n\n（2）枚举高度\n\n这种方法的思想是先找定一个高度点，然后左右扩展确定边界【边界的特征是两边的高度将小于边界的高度】，最后计算出面积。\n\n也就是扩展左右的柱子，高度均不能小于 h。\n\n这个方法其实就是在找能够覆盖第 i 个柱子的最大矩形，可以参考：[84. 柱状图中最大的矩形/C++](https://blog.csdn.net/Zolewit/article/details/88863970)\n\n---\n\n题目有一些特点：\n\n1. 借鉴枚举高度的方法，我们应该找到左右两侧 最近的 高度小于 h 的柱子。\n\n2. 一个结论和思想：\n   1. 如果两根柱子：`j0 < j1`，`height[j0]>height[j1]`\n   2. 那么对于 `j1` 之后的柱子，`j0`一定不是 最近的 小于 柱子高度的柱子。【至于高度大于它的，其实不重要】\n\n第一个特点说明，我们要找的就是比当前柱子小的最近的柱子，包括左边和右边；\n\n第二个特点说明，当我们找到这个最近的之后，远处的其实不重要了，比这个高的也不重要了【就可以删除了】\n\n所以使用了 单调栈这样一个思路去求解这个问题\n\n---\n\n使用单调栈：\n\n我个人觉得这篇题解讲的很好：[暴力解法、栈（单调栈、哨兵技巧）](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/)\n\n它讲明白了一件事情，就是栈顶元素删除之前做了什么：\n\n- 其实直到我们找到一个比较短的柱子时，我们才知道以上一个值为高度的矩形到这里结束了，一个面积就求出来了\n- 然后后面的高度就会以现在这个短的为基准了\n\n总结一下，我们是怎么确定一个柱形的面积的：\n\n- 我们记录了下标，下标对应的高度\n- 当我们发现这个下标比上一个下标矮的时候，好了，说明上一个下标对应的高度的矩形到头了，可以计算了\n- 而上一个下标对应的高度的矩形，其实还要找一下左边界，什么时候左边界也比它小了，这个区间找到了，这个高度的矩形面积可以算了，这个高度就完全结束了\n\n上面说的这个过程可能需要 进行多次，直到左边没有高度 小于 当前的高度了\n\n这个过程中，缓存数据是从左往右的，计算结果是从右往左的，所以就是后进的先出，这样的数据结构就是栈\n\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # 先求一下总长度\n        n = len(heights)\n        # 这是结果，记录面积\n        area = 0\n        # 这个栈用来做单调栈，栈是用来记位置的，而不是记高度的\n        stack = []\n        \n        # 对数组一次遍历\n        for i in range(n):\n            # 遇到了下降的情况，开始出栈和计算了\n            while len(stack) > 0 and heights[i] < heights[stack[-1]]:\n                # 出栈，要计算面积了\n                cur_height = heights[stack.pop()]\n                \n                # 这个是？保证绝对单调吗？\n                while len(stack) > 0 and cur_height == heights[stack[-1]]:\n                    stack.pop()\n            \n                if len(stack) > 0:\n                    # 栈没有空，那么左右边界求一下\n                    cur_width = i - stack[-1] - 1\n                else:\n                    # 栈空了，那就是全长\n                    cur_width = i\n                # 计算面积\n                area = max(area, cur_height * cur_width)\n            # 这是新的高度（可能是更高的，也可能是栈操作了一遍之后新加的高度）\n            stack.append(i)\n            \n        # 数组遍历结束了，但是栈可能还没有清空\n        while len(stack) > 0 is not None:\n            cur_height = heights[stack.pop()]\n            while len(stack) > 0 and cur_height == heights[stack[-1]]:\n                stack.pop()\n            \n            if len(stack) > 0:\n                # 因为数组已经遍历结束了，这里留下来的高度就是从记录位置到尾部的了\n                cur_width = n - stack[-1] - 1\n            else:\n                cur_width = n\n            area = max(area, cur_height * cur_width)\n            \n       \treturn area \n```\n\n上面这种方法做了分类讨论：\n\n- 弹栈的时候，栈有可能是空的\n- 遍历完成后，栈里还有元素\n\n解决方法：【**哨兵方法**】Sentinel\n\n- 数组两端加上两个 0：只要比 1 严格小就可以了\n  - 左边的哨兵一定比数组中所有元素都小，绝对不会出栈\n  - 右边的哨兵一定比数组中所有元素都小，会让所有元素都出栈（除了左边的哨兵）\n- 这样就可以不用分类讨论了\n\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        area = 0\n        heights = [0] + heights + [0]\n        # 先向栈中放入哨兵\n        stack = [0]\n        n += 2\n        \n        for i in range(1, n):\n            while heights[i] < heights[stack[-1]]:\n                cur_height = heights[stack.pop()]\n                cur_width = i - stack[-1] -1\n                area = max(area, cur_height * cur_width)\n            # 下面这一句为什么是在 while循环外的？\n            # 这个地方不要担心 i 不满足要求，因为如果不满足要求，过不了上面的while循环\n            stack.append(i)\n        return area\n```\n\n居然一下子简洁了这么多，哨兵的作用真的很厉害\n\n> python 实现栈的方法其实就是 list，栈顶就是 list 尾部\n\n> 我想起有一个**收集雨水**的问题，其实有一定的联系，都是单调栈的问题\n>\n> 单调栈问题：739、469、42\n\n# <!-- 哈希表 -->\n\n## 1603. 设计停车系统\n\n题目描述：\n\n1. 告诉了三种车位的数量：大、中、小车位各有几个\n2. 然后告诉车的类型：大、中、小车辆\n\n最后，问每辆车是不是有位置停，返回布尔值\n\n而且这个问题就是先到先得，车位满了后面的就是 false\n\n最简单的想法，直接3个 if 进行判断\n\n稍微好一点的方法，可以使用一个哈希表进行3种车位的存储，这样搜索起来也比较快：内存消耗少了一点点，用时居然还是很高\n\n## 20. 有效的括号\n\n描述：\n\n数学中，括号是成对出现的，而且括号应该是 由内向外完整嵌套的，比如：\n\n`{[()]}` 就是有效的\n\n`{[}])` 方括号位置不对，圆括号少了一半就是无效的\n\n现在就是给一个全是括号的字符串，检测是不是有效的\n\n---\n\n这个题曾经看过了题解，记下了一个重要的方法：哈希表\n\n用 左括号 做 key，右括号 做value\n\n我自己想出以下步骤：\n\n1. 遍历字符串\n   1. 如果是左括号\n      1. 新建一个 need 列表存储 需要的右括号\n   2. 如果是右括号，看是不是 need 中最后一个（最新需要的）右括号\n      1. 如果是，need 中最新的右括号扔掉【其实就是栈啊】\n      2. 如果不是，直接 False\n2. 最后看 need 是不是空的\n   1. 如果是，返回 True\n   2. 如果不是，返回 False\n\n其中几个细节点：\n\n1. 怎么样检查是不是左括号？\n   1. 方法一，需要一个左括号的列表\n   2. 方法二，检查 括号是不是字典的一个 key：`if xxx in dict.keys():`\n\n# <!-- Hot 100 问题 -->\n\n## 5. 最长回文子串问题\n\n问题描述：\n\n给一个字符串，请返回该字符串中最长的回文子串（串，应该是连续的）\n\n---\n\n首先想到暴力解法：\n\n枚举所有可能的字符串（的左右两边）\n\n然后判断这个子串是不是回文的，并记录最长的回文子串\n\n我的写法超时了，最大问题在于怎么判断是不是回文的，如果对于每一个可疑的子串都采用`双指针`的方法进行判断，那么肯定会超时，所以才需要用算法\n\n---\n\n方法一：动态规划\n\n从大的角度讲，枚举所有可能的子串是必要的，这个复杂度可能少不了\n\n但是\n\n1. 判断回文串的方法可以采用动态规划方法，如果 `[i+1, j-1]` 的子串是回文串，那么`[i, j] 且 s[i]==s[j]`的子串就是一个回文串，这样的判断方法比每一次都用双指针要好得多；\n2. 怎么样知道 `[i+1, j-1]` 的子串是不是回文串呢，这里就需要记录一定的信息了，怎么样既能记录开头，也能记录结尾，还能记录是不是回文串呢？`二维数组`\n\n注意两种情况：\n\n1. `[i, i]` 一定是回文的\n2. `[i, i+1]` 是不是回文的，要看 `s[i]` 和 `s[i+1]` 是不是相等\n\n官方解答中使用的遍历方法是按照 子串长度 和 起始位置 进行枚举，这种方法确实可以实现枚举，而且优点是对同一个长度的子串，可以使用一个简单的判断条件进行排除\n\n---\n\n方法二：中心扩展\n\n这个方法很有意思\n\n回文串有两种：奇数形和偶数形\n\n奇数形的中心应该是 `s[i] == s[i]`\n\n偶数形的中心应该是 `s[i] == s[i+1]`\n\n然后所有的回文串都是有这样的中心的，并且应该根据这个中心向两边进行扩展，所以我们的步骤就是：\n\n1. 枚举中心，并检查奇数形和偶数形两种可能\n2. 向两边进行扩展，直到出现不对称的情况\n3. 返回最长长度\n\n这个方法其实时间复杂度还是 `O(n^2)`，因为少不了要向两边进行扩展\n\n但是这个思路可能比较清晰\n\n---\n\n细节一：原字符串长度为1\n\n按照第二个思路进行尝试，部分错误，案例为：`a` ，结果输出为空\n\n问题还是没有对一个字母，或者一个数字的情况做很好的处理\n\n我的错误方法是：\n\n```python\nn = len(s)\nfor i in range(n):\n    ...\n    ans = s[elft, right]\nreturn ans\n```\n\n这样导致一个问题就是，如果 n = 1，那么会直接跳过循环遍历，直接把空的 ans 导出了\n\n官方的方法是：\n\n```python\nstart, end = 0, 0\nfor i in range(len(s)):\n    修改 start, end 的值\nreturn s[start: end+1]\n```\n\n其实主要还是最后一句的功劳，就是把0，0的情况也考虑在内了\n\n可以对我的方法进行一点点修改，保证不是空的就可以了\n\n`return s[0] if not ans else ans`\n\n细节二：索引相减 和 字符串长度不一定相等\n\n `right - left` 和 `len()` 不是相等的，差了1\n\n所以应该要 `right-left == len(ans)-1`\n\n但是如果要更新 `ans` 结果子串的时候，又应该是 `ans = s[left:right+1]`以免 right 字符没有加入到子串当中\n\n## 10. 正则表达式匹配\n\n输入：\n\n两个字符串，s - 要匹配的字符串，p-正则表达式\n\n正则表达式中会有三种值：\n\n- 字母，直接匹配，必须相等\n- `.` 匹配任意一个单个字符\n- `*` 匹配任意个前面的一个元素\n\n需要返回的是，是否能够进行匹配\n\n---\n\n这个题的关键难点在 `.*` 表示可以匹配任意多个任意字符\n\n如果正则表达式中这两个后面还有字符呢，那就会非常棘手\n\n这类问题之前其实也有，就是有多种可能性的问题 —— 动态规划\n\n---\n\n这道题做动态规划，最难的一点是怎么样把问题思考全面，还有就是初始化非常容易出错\n\n动态规划思路：\n\n1. `p[j] == s[i]` ，最方便，`dp[i][j] = dp[i-1][j-1]`\n2. `p[j] == '.'`，也还可以，`dp[i][j] = dp[i-1][j-1]`\n3. `p[j] == '*'`，比较麻烦，需要分两种情况\n   1. `p[j-1] != s[i]`，那么就是说 `*` 前面的字母也不匹配，那么直接`dp[i][j] = dp[i][j-2]`\n   2. `p[j-1] == '.'`或`p[j-1] == s[i]`，那么就要考虑匹配多少的问题呢，有两种情况，匹配了很多，或者一个都没有匹配==【这里给出了一个很好的例子，比如 “###b”和“###b*”】==\n      1. 匹配了很多 `dp[i][j] = dp[i-1][j]`\n      2. 一个都没有匹配 `dp[i][j] = dp[i][j-2]`\n      3. 以上两种情况，只要出现一种就可以了，所以是 or 的关系\n\n初始化问题：\n\n1. 如果全部初始化为 False，那么不管怎么变，最后都是 False，所以一定要有Ture，但是又不能直接判断出某一个是True，所以方法有在 s 和 p 前面都加一个空格，然后定义第一个 `dp[0][0]=True`\n2. `dp`矩阵是个二维矩阵，到底需要多大？而且它的索引又会和`s`和`p`的索引相关\n3. 如果 `p` 字符串并不能覆盖 `s`字符串呢？\n\n```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m = len(s)\n        n = len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] =='*': dp[0][j] = dp[0][j-2]\n\n        # i 指针，在 s 上滑动\n        for i in range(1, m+1):\n            r = i - 1\n            for j in range(1, n+1):\n                c = j - 1\n                if p[c] == s[r] or p[c] == '.':\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[c] == '*':\n                    if p[c-1] == s[r] or p[c-1] == '.':\n                        dp[i][j] = dp[i-1][j] or dp[i][j-2]\n                    else:\n                        dp[i][j] = dp[i][j-2]\n        return dp[m][n]\n```\n\n> 最后参考内容：\n>\n> https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/\n\n## 11. 盛水最多的容器\n\n是接雨水问题、柱状图中最大矩形问题的前序问题\n\n这个相对比较简单一点\n\n两个柱子之间有阻挡也没有关系\n\n用双指针-左右指针进行收缩\n\n如果左边高度比较低，就移动左边指针\n\n如果右边高度比较低，就移动右边指针\n\n但是这道题的耗时有点离谱，大家都是怎么刷时间的\n\n## 34. 在排序数组中查找元素的第一个和最后一个位置 - 二分法\n\n数组是有序的，给定一个target\n\n查找 target 在数组中的位置\n\n---\n\n这个题其实是看过算法的，但是二分法就是 细节魔鬼！\n\n有一个非常好的题解：[34.【朴实无华的二分查找】咱们一步一步来！](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/34po-shi-wu-hua-de-er-fen-cha-zhao-zan-men-yi-bu-y/)\n\n这篇文章中的思路非常好，在不会跑的时候，就先用走的。\n\n二分法在本问题中的应用是：\n\n1. 找到target的左边界\n2. 找到target的右边界\n\n整个流程是：\n\n1. 找到target在区间中的左右边界：用二分法\n2. 对左右边界进行判断，决定最后输出情况\n\n----\n\n核心：怎样找到 target 的左右边界，注意细节\n\n找左边界：\n\n1. left 取开头，right 取结尾，先把左边界的原始值设置为-2，如果根本就不需要进行下面的判断，左边界将为-2\n2. 循环，条件是 left <= right\n   1. 二分法，找中间位置 mid\n   2. 如果 mid 位置数值 小于 target【说明左边界在 mid 的右边】，那就\n      1. left 换到 mid+1 的位置\n   3. 如果 mid 位置数值 大于等于 target【说明左边界在 mid 的左边，但是具体在哪还不确定】\n      1. right 换到 mid-1 的位置\n      2. 把 左边界 也移到 right 的位置\n\n找右边界：【虽说左边和右边可以类比，但是细节真的还是不太一样】\n\n1. left 取开头，right 取结尾，先把右边界的原始值设置为-2，如果根本就不需要进行下面的判断，右边界将为-2【这一步基本相同】\n2. 循环，条件是 left <= right\n   1. 二分法，找中间位置 mid\n   2. 如果 mid 位置数值 大于 target【说明右边界在 mid 的左边】\n      1. right = mid - 1\n   3. 如果 mid 位置数值 小于等于 target【说明左边界在 mid 的右边，但是具体在哪还不确定】\n      1. 先把left移过去，缩小区间，left = mid + 1\n      2. 把右边界也移过去，rightBorder = left\n\n上面两个过程就把寻找左右边界的工作走完了，这样也比较清晰，但是里面到底是什么时候修改 left 或者 right，什么时候记录左右边界值，其实还是需要一点讲究的，需要注意一下！\n\n接下来是判断，会有几种情况：\n\n1. 最简单的肯定是有target，那么左右边界之间应该是不太一样的，返回 [leftBorder+1, rightBorder-1]\n2. 如果全部比 target 大，或者全部比 target 小呢？这个时候肯定会有一侧的边界为-2，就是没有变化过，所以也可以进行得出了【-1， -1】\n3. 其他情况，【-1， -1】\n\n可能最不容易判断的情况是 [1], target=1的情况，其实这个时候，leftBorder为-1，rightBorder为2，所以是可以得出结论的【0，0】\n\n# <!-- ASCII -->\n\n## 804. 唯一摩尔斯密码词\n\n这个问题是说，给了一个写有多个词的 list\n\n根据摩尔斯密码分别进行转化，然后判断这些词的摩尔斯密码中有没有相同的\n\n返回的是不相同的摩尔斯密码的数量\n\n---\n\n补充知识：\n\n### python 与 ASCII码\n\n这道题给的是小写字母\n\n密码本也是一个list，怎么样进行检索\n\n小写字母的 ASCII 码是 97-122\n\n大写字母的 ASCII 码是 65-90\n\n数字的 ASCII 码是 48-57\n\n可以使用 `ord(str)` 函数将字符转换为相应的 ASCII 码\n\n还可以使用 `chr(int)` 将 ASCII 码转换为相应的字符\n\n还可以直接使用 `ord(x) - ord('a')` ，这样即使不知道 a 的ASCII 码是多少也可以进行使用\n\n---\n\n第一步，获得所有单词的摩尔斯密码串：\n\n本题使用就这样使用\n\n`ord(str)-97` 就是这个小写字母在密码本中的索引值了\n\n获得摩尔斯密码串是比较容易的\n\n第二步，分析这些密码穿是不是又重复的：\n\n- 我用了 set() 集合，主要是存储和查询\n- 官方用了哈希表进行存储，其实差不多\n\n---\n\n再补充知识：\n\n### python中的集合\n\n创建一个集合，可以用\n\n`B = {a, b, 'c'}` 这样的形式\n\n但是如果创建 空集合，必须是 `A = set()`， 如果是 `{}` 就成了创建空的字典了\n\n增加元素：`add`\n\n将元素拆分成一个一个字符再添加进集合：`update`\n\n删除某个元素：\n\n- `remove`，不存在会报错\n- `discard`， 不存在也不报错\n- `pop`，删除并返回【注意是任意元素】\n- `clear`，清空集合\n\n集合与集合之间可以进行数学运算：交并包含等关系\n\n---\n\n本期十题就到这里，接下来将会主攻 LeetCode Hot 100 问题！","source":"_posts/LeetCode刷题笔记七.md","raw":"---\ntitle: LeetCode刷题笔记（七）\ndate: 2021-03-29 16:46:05\ncategories:\n\t- 算法\ntags:\n\t- 链表\n\t- 单调栈\n\t- 哈希表\n\t- hot100\n\t- ascii\n---\n\n# <!-- 链表 -->\n\n## 206. 反转链表\n\n这个题其实已经做过多次了，这次总结一下：\n\n题目要求：给出一个链表的头节点，请反转整个链表，并且返回反转后的链表的头节点。\n\n这个题用递归的方法简直是非常之妙，而且十分经典。\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverse(self, head: ListNode) -> ListNone:\n        if not head or not head.next: return head\n        last = self.reverse(head.next)\n        head.next.next = head\n        head.next = None\n        return last\n```\n\n这个做法简直非常精妙，充分体现了递归方法中的关键：\n\n1）找一个最简问题，解决它\n\n2）充分理解并相信函数能解决你的问题\n\n<!-- more -->\n\n## 92. 反转链表 II\n\n这道题要求的是 反转链表中的某一部分\n\n比如给出 head，left，right，请反转从 left 到 right 的部分\n\n![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)\n\n根据前面做过的反转链表，这里的思路大概有两种：\n\n1. 先反转 left 到 末尾，再反转 right 到末尾；但是这种方法仔细一想就是不可能的，因为第一次反转之后，末尾的元素到前面来了，要想再把它们翻转回去是不可能的。\n2. 只翻转 left 到 right 的部分，然后再拼接起来。\n\n第2种方法是可行的，但是需要考虑的问题有：\n\n1. 要记录 left 的前一个节点 pre\n2. 要记录 right 的后一个节点 succ（successor）\n3. pre 的 next 指向反转后的头节点\n4. 反转后的尾节点的 next 指向 succ\n\n可见是一个比较复杂的问题，应该怎么处理呢\n\n---\n\n### 官方题解\n\n分为7个步骤：\n\n1）在头节点前添加哑节点防止头节点变化，哑节点不能动\n\n2）创建一个移动节点寻找左节点的上一个节点，其实也就找到了左节点\n\n3）再创建一个移动节点到右节点，其实也就找到了右节点的下一个节点\n\n4）截断中间部分\n\n5）反转中间部分（用一个无返回值的函数进行操作）\n\n6）重接中间部分\n\n7）返回哑节点的下一个节点\n\n> 我的题解：[官方解法-python复现](https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/guan-fang-jie-fa-pythonfu-xian-by-yue-wo-kebj/)\n\n# <!-- 单调栈、哨兵 -->\n\n## 84. 柱状图中的最大的矩形\n\n问题描述：\n\n给出一个柱形图（数组），数组中的元素表示柱的高度，现在需要在柱形图中找出一个能画出的最大的矩形，比如：\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)\n\n---\n\n先从暴力解法——枚举开始。\n\n（1）枚举宽度【左右边界】\n\n1. 左边界从0开始遍历\n2. 右边界从左边界开始遍历\n3. 高度取从左边界到右边界区间最矮高度\n4. 计算面积，记录最大面积\n\n这样一看，这个题的暴力方法其实也是很规矩的。\n\n缺点是：时间复杂度在 O(N^2)，因为有循环套循环，而且占用内存也不小。\n\n（2）枚举高度\n\n这种方法的思想是先找定一个高度点，然后左右扩展确定边界【边界的特征是两边的高度将小于边界的高度】，最后计算出面积。\n\n也就是扩展左右的柱子，高度均不能小于 h。\n\n这个方法其实就是在找能够覆盖第 i 个柱子的最大矩形，可以参考：[84. 柱状图中最大的矩形/C++](https://blog.csdn.net/Zolewit/article/details/88863970)\n\n---\n\n题目有一些特点：\n\n1. 借鉴枚举高度的方法，我们应该找到左右两侧 最近的 高度小于 h 的柱子。\n\n2. 一个结论和思想：\n   1. 如果两根柱子：`j0 < j1`，`height[j0]>height[j1]`\n   2. 那么对于 `j1` 之后的柱子，`j0`一定不是 最近的 小于 柱子高度的柱子。【至于高度大于它的，其实不重要】\n\n第一个特点说明，我们要找的就是比当前柱子小的最近的柱子，包括左边和右边；\n\n第二个特点说明，当我们找到这个最近的之后，远处的其实不重要了，比这个高的也不重要了【就可以删除了】\n\n所以使用了 单调栈这样一个思路去求解这个问题\n\n---\n\n使用单调栈：\n\n我个人觉得这篇题解讲的很好：[暴力解法、栈（单调栈、哨兵技巧）](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/)\n\n它讲明白了一件事情，就是栈顶元素删除之前做了什么：\n\n- 其实直到我们找到一个比较短的柱子时，我们才知道以上一个值为高度的矩形到这里结束了，一个面积就求出来了\n- 然后后面的高度就会以现在这个短的为基准了\n\n总结一下，我们是怎么确定一个柱形的面积的：\n\n- 我们记录了下标，下标对应的高度\n- 当我们发现这个下标比上一个下标矮的时候，好了，说明上一个下标对应的高度的矩形到头了，可以计算了\n- 而上一个下标对应的高度的矩形，其实还要找一下左边界，什么时候左边界也比它小了，这个区间找到了，这个高度的矩形面积可以算了，这个高度就完全结束了\n\n上面说的这个过程可能需要 进行多次，直到左边没有高度 小于 当前的高度了\n\n这个过程中，缓存数据是从左往右的，计算结果是从右往左的，所以就是后进的先出，这样的数据结构就是栈\n\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # 先求一下总长度\n        n = len(heights)\n        # 这是结果，记录面积\n        area = 0\n        # 这个栈用来做单调栈，栈是用来记位置的，而不是记高度的\n        stack = []\n        \n        # 对数组一次遍历\n        for i in range(n):\n            # 遇到了下降的情况，开始出栈和计算了\n            while len(stack) > 0 and heights[i] < heights[stack[-1]]:\n                # 出栈，要计算面积了\n                cur_height = heights[stack.pop()]\n                \n                # 这个是？保证绝对单调吗？\n                while len(stack) > 0 and cur_height == heights[stack[-1]]:\n                    stack.pop()\n            \n                if len(stack) > 0:\n                    # 栈没有空，那么左右边界求一下\n                    cur_width = i - stack[-1] - 1\n                else:\n                    # 栈空了，那就是全长\n                    cur_width = i\n                # 计算面积\n                area = max(area, cur_height * cur_width)\n            # 这是新的高度（可能是更高的，也可能是栈操作了一遍之后新加的高度）\n            stack.append(i)\n            \n        # 数组遍历结束了，但是栈可能还没有清空\n        while len(stack) > 0 is not None:\n            cur_height = heights[stack.pop()]\n            while len(stack) > 0 and cur_height == heights[stack[-1]]:\n                stack.pop()\n            \n            if len(stack) > 0:\n                # 因为数组已经遍历结束了，这里留下来的高度就是从记录位置到尾部的了\n                cur_width = n - stack[-1] - 1\n            else:\n                cur_width = n\n            area = max(area, cur_height * cur_width)\n            \n       \treturn area \n```\n\n上面这种方法做了分类讨论：\n\n- 弹栈的时候，栈有可能是空的\n- 遍历完成后，栈里还有元素\n\n解决方法：【**哨兵方法**】Sentinel\n\n- 数组两端加上两个 0：只要比 1 严格小就可以了\n  - 左边的哨兵一定比数组中所有元素都小，绝对不会出栈\n  - 右边的哨兵一定比数组中所有元素都小，会让所有元素都出栈（除了左边的哨兵）\n- 这样就可以不用分类讨论了\n\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        area = 0\n        heights = [0] + heights + [0]\n        # 先向栈中放入哨兵\n        stack = [0]\n        n += 2\n        \n        for i in range(1, n):\n            while heights[i] < heights[stack[-1]]:\n                cur_height = heights[stack.pop()]\n                cur_width = i - stack[-1] -1\n                area = max(area, cur_height * cur_width)\n            # 下面这一句为什么是在 while循环外的？\n            # 这个地方不要担心 i 不满足要求，因为如果不满足要求，过不了上面的while循环\n            stack.append(i)\n        return area\n```\n\n居然一下子简洁了这么多，哨兵的作用真的很厉害\n\n> python 实现栈的方法其实就是 list，栈顶就是 list 尾部\n\n> 我想起有一个**收集雨水**的问题，其实有一定的联系，都是单调栈的问题\n>\n> 单调栈问题：739、469、42\n\n# <!-- 哈希表 -->\n\n## 1603. 设计停车系统\n\n题目描述：\n\n1. 告诉了三种车位的数量：大、中、小车位各有几个\n2. 然后告诉车的类型：大、中、小车辆\n\n最后，问每辆车是不是有位置停，返回布尔值\n\n而且这个问题就是先到先得，车位满了后面的就是 false\n\n最简单的想法，直接3个 if 进行判断\n\n稍微好一点的方法，可以使用一个哈希表进行3种车位的存储，这样搜索起来也比较快：内存消耗少了一点点，用时居然还是很高\n\n## 20. 有效的括号\n\n描述：\n\n数学中，括号是成对出现的，而且括号应该是 由内向外完整嵌套的，比如：\n\n`{[()]}` 就是有效的\n\n`{[}])` 方括号位置不对，圆括号少了一半就是无效的\n\n现在就是给一个全是括号的字符串，检测是不是有效的\n\n---\n\n这个题曾经看过了题解，记下了一个重要的方法：哈希表\n\n用 左括号 做 key，右括号 做value\n\n我自己想出以下步骤：\n\n1. 遍历字符串\n   1. 如果是左括号\n      1. 新建一个 need 列表存储 需要的右括号\n   2. 如果是右括号，看是不是 need 中最后一个（最新需要的）右括号\n      1. 如果是，need 中最新的右括号扔掉【其实就是栈啊】\n      2. 如果不是，直接 False\n2. 最后看 need 是不是空的\n   1. 如果是，返回 True\n   2. 如果不是，返回 False\n\n其中几个细节点：\n\n1. 怎么样检查是不是左括号？\n   1. 方法一，需要一个左括号的列表\n   2. 方法二，检查 括号是不是字典的一个 key：`if xxx in dict.keys():`\n\n# <!-- Hot 100 问题 -->\n\n## 5. 最长回文子串问题\n\n问题描述：\n\n给一个字符串，请返回该字符串中最长的回文子串（串，应该是连续的）\n\n---\n\n首先想到暴力解法：\n\n枚举所有可能的字符串（的左右两边）\n\n然后判断这个子串是不是回文的，并记录最长的回文子串\n\n我的写法超时了，最大问题在于怎么判断是不是回文的，如果对于每一个可疑的子串都采用`双指针`的方法进行判断，那么肯定会超时，所以才需要用算法\n\n---\n\n方法一：动态规划\n\n从大的角度讲，枚举所有可能的子串是必要的，这个复杂度可能少不了\n\n但是\n\n1. 判断回文串的方法可以采用动态规划方法，如果 `[i+1, j-1]` 的子串是回文串，那么`[i, j] 且 s[i]==s[j]`的子串就是一个回文串，这样的判断方法比每一次都用双指针要好得多；\n2. 怎么样知道 `[i+1, j-1]` 的子串是不是回文串呢，这里就需要记录一定的信息了，怎么样既能记录开头，也能记录结尾，还能记录是不是回文串呢？`二维数组`\n\n注意两种情况：\n\n1. `[i, i]` 一定是回文的\n2. `[i, i+1]` 是不是回文的，要看 `s[i]` 和 `s[i+1]` 是不是相等\n\n官方解答中使用的遍历方法是按照 子串长度 和 起始位置 进行枚举，这种方法确实可以实现枚举，而且优点是对同一个长度的子串，可以使用一个简单的判断条件进行排除\n\n---\n\n方法二：中心扩展\n\n这个方法很有意思\n\n回文串有两种：奇数形和偶数形\n\n奇数形的中心应该是 `s[i] == s[i]`\n\n偶数形的中心应该是 `s[i] == s[i+1]`\n\n然后所有的回文串都是有这样的中心的，并且应该根据这个中心向两边进行扩展，所以我们的步骤就是：\n\n1. 枚举中心，并检查奇数形和偶数形两种可能\n2. 向两边进行扩展，直到出现不对称的情况\n3. 返回最长长度\n\n这个方法其实时间复杂度还是 `O(n^2)`，因为少不了要向两边进行扩展\n\n但是这个思路可能比较清晰\n\n---\n\n细节一：原字符串长度为1\n\n按照第二个思路进行尝试，部分错误，案例为：`a` ，结果输出为空\n\n问题还是没有对一个字母，或者一个数字的情况做很好的处理\n\n我的错误方法是：\n\n```python\nn = len(s)\nfor i in range(n):\n    ...\n    ans = s[elft, right]\nreturn ans\n```\n\n这样导致一个问题就是，如果 n = 1，那么会直接跳过循环遍历，直接把空的 ans 导出了\n\n官方的方法是：\n\n```python\nstart, end = 0, 0\nfor i in range(len(s)):\n    修改 start, end 的值\nreturn s[start: end+1]\n```\n\n其实主要还是最后一句的功劳，就是把0，0的情况也考虑在内了\n\n可以对我的方法进行一点点修改，保证不是空的就可以了\n\n`return s[0] if not ans else ans`\n\n细节二：索引相减 和 字符串长度不一定相等\n\n `right - left` 和 `len()` 不是相等的，差了1\n\n所以应该要 `right-left == len(ans)-1`\n\n但是如果要更新 `ans` 结果子串的时候，又应该是 `ans = s[left:right+1]`以免 right 字符没有加入到子串当中\n\n## 10. 正则表达式匹配\n\n输入：\n\n两个字符串，s - 要匹配的字符串，p-正则表达式\n\n正则表达式中会有三种值：\n\n- 字母，直接匹配，必须相等\n- `.` 匹配任意一个单个字符\n- `*` 匹配任意个前面的一个元素\n\n需要返回的是，是否能够进行匹配\n\n---\n\n这个题的关键难点在 `.*` 表示可以匹配任意多个任意字符\n\n如果正则表达式中这两个后面还有字符呢，那就会非常棘手\n\n这类问题之前其实也有，就是有多种可能性的问题 —— 动态规划\n\n---\n\n这道题做动态规划，最难的一点是怎么样把问题思考全面，还有就是初始化非常容易出错\n\n动态规划思路：\n\n1. `p[j] == s[i]` ，最方便，`dp[i][j] = dp[i-1][j-1]`\n2. `p[j] == '.'`，也还可以，`dp[i][j] = dp[i-1][j-1]`\n3. `p[j] == '*'`，比较麻烦，需要分两种情况\n   1. `p[j-1] != s[i]`，那么就是说 `*` 前面的字母也不匹配，那么直接`dp[i][j] = dp[i][j-2]`\n   2. `p[j-1] == '.'`或`p[j-1] == s[i]`，那么就要考虑匹配多少的问题呢，有两种情况，匹配了很多，或者一个都没有匹配==【这里给出了一个很好的例子，比如 “###b”和“###b*”】==\n      1. 匹配了很多 `dp[i][j] = dp[i-1][j]`\n      2. 一个都没有匹配 `dp[i][j] = dp[i][j-2]`\n      3. 以上两种情况，只要出现一种就可以了，所以是 or 的关系\n\n初始化问题：\n\n1. 如果全部初始化为 False，那么不管怎么变，最后都是 False，所以一定要有Ture，但是又不能直接判断出某一个是True，所以方法有在 s 和 p 前面都加一个空格，然后定义第一个 `dp[0][0]=True`\n2. `dp`矩阵是个二维矩阵，到底需要多大？而且它的索引又会和`s`和`p`的索引相关\n3. 如果 `p` 字符串并不能覆盖 `s`字符串呢？\n\n```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m = len(s)\n        n = len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] =='*': dp[0][j] = dp[0][j-2]\n\n        # i 指针，在 s 上滑动\n        for i in range(1, m+1):\n            r = i - 1\n            for j in range(1, n+1):\n                c = j - 1\n                if p[c] == s[r] or p[c] == '.':\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[c] == '*':\n                    if p[c-1] == s[r] or p[c-1] == '.':\n                        dp[i][j] = dp[i-1][j] or dp[i][j-2]\n                    else:\n                        dp[i][j] = dp[i][j-2]\n        return dp[m][n]\n```\n\n> 最后参考内容：\n>\n> https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/\n\n## 11. 盛水最多的容器\n\n是接雨水问题、柱状图中最大矩形问题的前序问题\n\n这个相对比较简单一点\n\n两个柱子之间有阻挡也没有关系\n\n用双指针-左右指针进行收缩\n\n如果左边高度比较低，就移动左边指针\n\n如果右边高度比较低，就移动右边指针\n\n但是这道题的耗时有点离谱，大家都是怎么刷时间的\n\n## 34. 在排序数组中查找元素的第一个和最后一个位置 - 二分法\n\n数组是有序的，给定一个target\n\n查找 target 在数组中的位置\n\n---\n\n这个题其实是看过算法的，但是二分法就是 细节魔鬼！\n\n有一个非常好的题解：[34.【朴实无华的二分查找】咱们一步一步来！](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/34po-shi-wu-hua-de-er-fen-cha-zhao-zan-men-yi-bu-y/)\n\n这篇文章中的思路非常好，在不会跑的时候，就先用走的。\n\n二分法在本问题中的应用是：\n\n1. 找到target的左边界\n2. 找到target的右边界\n\n整个流程是：\n\n1. 找到target在区间中的左右边界：用二分法\n2. 对左右边界进行判断，决定最后输出情况\n\n----\n\n核心：怎样找到 target 的左右边界，注意细节\n\n找左边界：\n\n1. left 取开头，right 取结尾，先把左边界的原始值设置为-2，如果根本就不需要进行下面的判断，左边界将为-2\n2. 循环，条件是 left <= right\n   1. 二分法，找中间位置 mid\n   2. 如果 mid 位置数值 小于 target【说明左边界在 mid 的右边】，那就\n      1. left 换到 mid+1 的位置\n   3. 如果 mid 位置数值 大于等于 target【说明左边界在 mid 的左边，但是具体在哪还不确定】\n      1. right 换到 mid-1 的位置\n      2. 把 左边界 也移到 right 的位置\n\n找右边界：【虽说左边和右边可以类比，但是细节真的还是不太一样】\n\n1. left 取开头，right 取结尾，先把右边界的原始值设置为-2，如果根本就不需要进行下面的判断，右边界将为-2【这一步基本相同】\n2. 循环，条件是 left <= right\n   1. 二分法，找中间位置 mid\n   2. 如果 mid 位置数值 大于 target【说明右边界在 mid 的左边】\n      1. right = mid - 1\n   3. 如果 mid 位置数值 小于等于 target【说明左边界在 mid 的右边，但是具体在哪还不确定】\n      1. 先把left移过去，缩小区间，left = mid + 1\n      2. 把右边界也移过去，rightBorder = left\n\n上面两个过程就把寻找左右边界的工作走完了，这样也比较清晰，但是里面到底是什么时候修改 left 或者 right，什么时候记录左右边界值，其实还是需要一点讲究的，需要注意一下！\n\n接下来是判断，会有几种情况：\n\n1. 最简单的肯定是有target，那么左右边界之间应该是不太一样的，返回 [leftBorder+1, rightBorder-1]\n2. 如果全部比 target 大，或者全部比 target 小呢？这个时候肯定会有一侧的边界为-2，就是没有变化过，所以也可以进行得出了【-1， -1】\n3. 其他情况，【-1， -1】\n\n可能最不容易判断的情况是 [1], target=1的情况，其实这个时候，leftBorder为-1，rightBorder为2，所以是可以得出结论的【0，0】\n\n# <!-- ASCII -->\n\n## 804. 唯一摩尔斯密码词\n\n这个问题是说，给了一个写有多个词的 list\n\n根据摩尔斯密码分别进行转化，然后判断这些词的摩尔斯密码中有没有相同的\n\n返回的是不相同的摩尔斯密码的数量\n\n---\n\n补充知识：\n\n### python 与 ASCII码\n\n这道题给的是小写字母\n\n密码本也是一个list，怎么样进行检索\n\n小写字母的 ASCII 码是 97-122\n\n大写字母的 ASCII 码是 65-90\n\n数字的 ASCII 码是 48-57\n\n可以使用 `ord(str)` 函数将字符转换为相应的 ASCII 码\n\n还可以使用 `chr(int)` 将 ASCII 码转换为相应的字符\n\n还可以直接使用 `ord(x) - ord('a')` ，这样即使不知道 a 的ASCII 码是多少也可以进行使用\n\n---\n\n第一步，获得所有单词的摩尔斯密码串：\n\n本题使用就这样使用\n\n`ord(str)-97` 就是这个小写字母在密码本中的索引值了\n\n获得摩尔斯密码串是比较容易的\n\n第二步，分析这些密码穿是不是又重复的：\n\n- 我用了 set() 集合，主要是存储和查询\n- 官方用了哈希表进行存储，其实差不多\n\n---\n\n再补充知识：\n\n### python中的集合\n\n创建一个集合，可以用\n\n`B = {a, b, 'c'}` 这样的形式\n\n但是如果创建 空集合，必须是 `A = set()`， 如果是 `{}` 就成了创建空的字典了\n\n增加元素：`add`\n\n将元素拆分成一个一个字符再添加进集合：`update`\n\n删除某个元素：\n\n- `remove`，不存在会报错\n- `discard`， 不存在也不报错\n- `pop`，删除并返回【注意是任意元素】\n- `clear`，清空集合\n\n集合与集合之间可以进行数学运算：交并包含等关系\n\n---\n\n本期十题就到这里，接下来将会主攻 LeetCode Hot 100 问题！","slug":"LeetCode刷题笔记七","published":1,"updated":"2021-04-24T02:11:13.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n89h0042k8tlfixydtc2","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><!-- 链表 --></h1><h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a>206. 反转链表</h2><p>这个题其实已经做过多次了，这次总结一下：</p>\n<p>题目要求：给出一个链表的头节点，请反转整个链表，并且返回反转后的链表的头节点。</p>\n<p>这个题用递归的方法简直是非常之妙，而且十分经典。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, val=<span class=\"number\">0</span>, next=None)</span>:</span></span><br><span class=\"line\">        self.val = val</span><br><span class=\"line\">        self.next = next</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNone:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> head.next: <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        last = self.reverse(head.next)</span><br><span class=\"line\">        head.next.next = head</span><br><span class=\"line\">        head.next = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> last</span><br></pre></td></tr></table></figure>\n<p>这个做法简直非常精妙，充分体现了递归方法中的关键：</p>\n<p>1）找一个最简问题，解决它</p>\n<p>2）充分理解并相信函数能解决你的问题</p>\n<a id=\"more\"></a>\n<h2 id=\"92-反转链表-II\"><a href=\"#92-反转链表-II\" class=\"headerlink\" title=\"92. 反转链表 II\"></a>92. 反转链表 II</h2><p>这道题要求的是 反转链表中的某一部分</p>\n<p>比如给出 head，left，right，请反转从 left 到 right 的部分</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg\" alt=\"img\"></p>\n<p>根据前面做过的反转链表，这里的思路大概有两种：</p>\n<ol>\n<li>先反转 left 到 末尾，再反转 right 到末尾；但是这种方法仔细一想就是不可能的，因为第一次反转之后，末尾的元素到前面来了，要想再把它们翻转回去是不可能的。</li>\n<li>只翻转 left 到 right 的部分，然后再拼接起来。</li>\n</ol>\n<p>第2种方法是可行的，但是需要考虑的问题有：</p>\n<ol>\n<li>要记录 left 的前一个节点 pre</li>\n<li>要记录 right 的后一个节点 succ（successor）</li>\n<li>pre 的 next 指向反转后的头节点</li>\n<li>反转后的尾节点的 next 指向 succ</li>\n</ol>\n<p>可见是一个比较复杂的问题，应该怎么处理呢</p>\n<hr>\n<h3 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>分为7个步骤：</p>\n<p>1）在头节点前添加哑节点防止头节点变化，哑节点不能动</p>\n<p>2）创建一个移动节点寻找左节点的上一个节点，其实也就找到了左节点</p>\n<p>3）再创建一个移动节点到右节点，其实也就找到了右节点的下一个节点</p>\n<p>4）截断中间部分</p>\n<p>5）反转中间部分（用一个无返回值的函数进行操作）</p>\n<p>6）重接中间部分</p>\n<p>7）返回哑节点的下一个节点</p>\n<blockquote>\n<p>我的题解：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/guan-fang-jie-fa-pythonfu-xian-by-yue-wo-kebj/\" target=\"_blank\" rel=\"noopener\">官方解法-python复现</a></p>\n</blockquote>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><!-- 单调栈、哨兵 --></h1><h2 id=\"84-柱状图中的最大的矩形\"><a href=\"#84-柱状图中的最大的矩形\" class=\"headerlink\" title=\"84. 柱状图中的最大的矩形\"></a>84. 柱状图中的最大的矩形</h2><p>问题描述：</p>\n<p>给出一个柱形图（数组），数组中的元素表示柱的高度，现在需要在柱形图中找出一个能画出的最大的矩形，比如：</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png\" alt=\"img\"></p>\n<hr>\n<p>先从暴力解法——枚举开始。</p>\n<p>（1）枚举宽度【左右边界】</p>\n<ol>\n<li>左边界从0开始遍历</li>\n<li>右边界从左边界开始遍历</li>\n<li>高度取从左边界到右边界区间最矮高度</li>\n<li>计算面积，记录最大面积</li>\n</ol>\n<p>这样一看，这个题的暴力方法其实也是很规矩的。</p>\n<p>缺点是：时间复杂度在 O(N^2)，因为有循环套循环，而且占用内存也不小。</p>\n<p>（2）枚举高度</p>\n<p>这种方法的思想是先找定一个高度点，然后左右扩展确定边界【边界的特征是两边的高度将小于边界的高度】，最后计算出面积。</p>\n<p>也就是扩展左右的柱子，高度均不能小于 h。</p>\n<p>这个方法其实就是在找能够覆盖第 i 个柱子的最大矩形，可以参考：<a href=\"https://blog.csdn.net/Zolewit/article/details/88863970\" target=\"_blank\" rel=\"noopener\">84. 柱状图中最大的矩形/C++</a></p>\n<hr>\n<p>题目有一些特点：</p>\n<ol>\n<li><p>借鉴枚举高度的方法，我们应该找到左右两侧 最近的 高度小于 h 的柱子。</p>\n</li>\n<li><p>一个结论和思想：</p>\n<ol>\n<li>如果两根柱子：<code>j0 &lt; j1</code>，<code>height[j0]&gt;height[j1]</code></li>\n<li>那么对于 <code>j1</code> 之后的柱子，<code>j0</code>一定不是 最近的 小于 柱子高度的柱子。【至于高度大于它的，其实不重要】</li>\n</ol>\n</li>\n</ol>\n<p>第一个特点说明，我们要找的就是比当前柱子小的最近的柱子，包括左边和右边；</p>\n<p>第二个特点说明，当我们找到这个最近的之后，远处的其实不重要了，比这个高的也不重要了【就可以删除了】</p>\n<p>所以使用了 单调栈这样一个思路去求解这个问题</p>\n<hr>\n<p>使用单调栈：</p>\n<p>我个人觉得这篇题解讲的很好：<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/\" target=\"_blank\" rel=\"noopener\">暴力解法、栈（单调栈、哨兵技巧）</a></p>\n<p>它讲明白了一件事情，就是栈顶元素删除之前做了什么：</p>\n<ul>\n<li>其实直到我们找到一个比较短的柱子时，我们才知道以上一个值为高度的矩形到这里结束了，一个面积就求出来了</li>\n<li>然后后面的高度就会以现在这个短的为基准了</li>\n</ul>\n<p>总结一下，我们是怎么确定一个柱形的面积的：</p>\n<ul>\n<li>我们记录了下标，下标对应的高度</li>\n<li>当我们发现这个下标比上一个下标矮的时候，好了，说明上一个下标对应的高度的矩形到头了，可以计算了</li>\n<li>而上一个下标对应的高度的矩形，其实还要找一下左边界，什么时候左边界也比它小了，这个区间找到了，这个高度的矩形面积可以算了，这个高度就完全结束了</li>\n</ul>\n<p>上面说的这个过程可能需要 进行多次，直到左边没有高度 小于 当前的高度了</p>\n<p>这个过程中，缓存数据是从左往右的，计算结果是从右往左的，所以就是后进的先出，这样的数据结构就是栈</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 先求一下总长度</span></span><br><span class=\"line\">        n = len(heights)</span><br><span class=\"line\">        <span class=\"comment\"># 这是结果，记录面积</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># 这个栈用来做单调栈，栈是用来记位置的，而不是记高度的</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 对数组一次遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"comment\"># 遇到了下降的情况，开始出栈和计算了</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> heights[i] &lt; heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                <span class=\"comment\"># 出栈，要计算面积了</span></span><br><span class=\"line\">                cur_height = heights[stack.pop()]</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># 这个是？保证绝对单调吗？</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> cur_height == heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                    stack.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"comment\"># 栈没有空，那么左右边界求一下</span></span><br><span class=\"line\">                    cur_width = i - stack[<span class=\"number\">-1</span>] - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"comment\"># 栈空了，那就是全长</span></span><br><span class=\"line\">                    cur_width = i</span><br><span class=\"line\">                <span class=\"comment\"># 计算面积</span></span><br><span class=\"line\">                area = max(area, cur_height * cur_width)</span><br><span class=\"line\">            <span class=\"comment\"># 这是新的高度（可能是更高的，也可能是栈操作了一遍之后新加的高度）</span></span><br><span class=\"line\">            stack.append(i)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># 数组遍历结束了，但是栈可能还没有清空</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            cur_height = heights[stack.pop()]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> cur_height == heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(stack) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 因为数组已经遍历结束了，这里留下来的高度就是从记录位置到尾部的了</span></span><br><span class=\"line\">                cur_width = n - stack[<span class=\"number\">-1</span>] - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                cur_width = n</span><br><span class=\"line\">            area = max(area, cur_height * cur_width)</span><br><span class=\"line\">            </span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>\n<p>上面这种方法做了分类讨论：</p>\n<ul>\n<li>弹栈的时候，栈有可能是空的</li>\n<li>遍历完成后，栈里还有元素</li>\n</ul>\n<p>解决方法：【<strong>哨兵方法</strong>】Sentinel</p>\n<ul>\n<li>数组两端加上两个 0：只要比 1 严格小就可以了<ul>\n<li>左边的哨兵一定比数组中所有元素都小，绝对不会出栈</li>\n<li>右边的哨兵一定比数组中所有元素都小，会让所有元素都出栈（除了左边的哨兵）</li>\n</ul>\n</li>\n<li>这样就可以不用分类讨论了</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        n = len(heights)</span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        heights = [<span class=\"number\">0</span>] + heights + [<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"comment\"># 先向栈中放入哨兵</span></span><br><span class=\"line\">        stack = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        n += <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">while</span> heights[i] &lt; heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                cur_height = heights[stack.pop()]</span><br><span class=\"line\">                cur_width = i - stack[<span class=\"number\">-1</span>] <span class=\"number\">-1</span></span><br><span class=\"line\">                area = max(area, cur_height * cur_width)</span><br><span class=\"line\">            <span class=\"comment\"># 下面这一句为什么是在 while循环外的？</span></span><br><span class=\"line\">            <span class=\"comment\"># 这个地方不要担心 i 不满足要求，因为如果不满足要求，过不了上面的while循环</span></span><br><span class=\"line\">            stack.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>\n<p>居然一下子简洁了这么多，哨兵的作用真的很厉害</p>\n<blockquote>\n<p>python 实现栈的方法其实就是 list，栈顶就是 list 尾部</p>\n<p>我想起有一个<strong>收集雨水</strong>的问题，其实有一定的联系，都是单调栈的问题</p>\n<p>单调栈问题：739、469、42</p>\n</blockquote>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><!-- 哈希表 --></h1><h2 id=\"1603-设计停车系统\"><a href=\"#1603-设计停车系统\" class=\"headerlink\" title=\"1603. 设计停车系统\"></a>1603. 设计停车系统</h2><p>题目描述：</p>\n<ol>\n<li>告诉了三种车位的数量：大、中、小车位各有几个</li>\n<li>然后告诉车的类型：大、中、小车辆</li>\n</ol>\n<p>最后，问每辆车是不是有位置停，返回布尔值</p>\n<p>而且这个问题就是先到先得，车位满了后面的就是 false</p>\n<p>最简单的想法，直接3个 if 进行判断</p>\n<p>稍微好一点的方法，可以使用一个哈希表进行3种车位的存储，这样搜索起来也比较快：内存消耗少了一点点，用时居然还是很高</p>\n<h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a>20. 有效的括号</h2><p>描述：</p>\n<p>数学中，括号是成对出现的，而且括号应该是 由内向外完整嵌套的，比如：</p>\n<p><code>{[()]}</code> 就是有效的</p>\n<p><code>{[}])</code> 方括号位置不对，圆括号少了一半就是无效的</p>\n<p>现在就是给一个全是括号的字符串，检测是不是有效的</p>\n<hr>\n<p>这个题曾经看过了题解，记下了一个重要的方法：哈希表</p>\n<p>用 左括号 做 key，右括号 做value</p>\n<p>我自己想出以下步骤：</p>\n<ol>\n<li>遍历字符串<ol>\n<li>如果是左括号<ol>\n<li>新建一个 need 列表存储 需要的右括号</li>\n</ol>\n</li>\n<li>如果是右括号，看是不是 need 中最后一个（最新需要的）右括号<ol>\n<li>如果是，need 中最新的右括号扔掉【其实就是栈啊】</li>\n<li>如果不是，直接 False</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>最后看 need 是不是空的<ol>\n<li>如果是，返回 True</li>\n<li>如果不是，返回 False</li>\n</ol>\n</li>\n</ol>\n<p>其中几个细节点：</p>\n<ol>\n<li>怎么样检查是不是左括号？<ol>\n<li>方法一，需要一个左括号的列表</li>\n<li>方法二，检查 括号是不是字典的一个 key：<code>if xxx in dict.keys():</code></li>\n</ol>\n</li>\n</ol>\n<h1 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><!-- Hot 100 问题 --></h1><h2 id=\"5-最长回文子串问题\"><a href=\"#5-最长回文子串问题\" class=\"headerlink\" title=\"5. 最长回文子串问题\"></a>5. 最长回文子串问题</h2><p>问题描述：</p>\n<p>给一个字符串，请返回该字符串中最长的回文子串（串，应该是连续的）</p>\n<hr>\n<p>首先想到暴力解法：</p>\n<p>枚举所有可能的字符串（的左右两边）</p>\n<p>然后判断这个子串是不是回文的，并记录最长的回文子串</p>\n<p>我的写法超时了，最大问题在于怎么判断是不是回文的，如果对于每一个可疑的子串都采用<code>双指针</code>的方法进行判断，那么肯定会超时，所以才需要用算法</p>\n<hr>\n<p>方法一：动态规划</p>\n<p>从大的角度讲，枚举所有可能的子串是必要的，这个复杂度可能少不了</p>\n<p>但是</p>\n<ol>\n<li>判断回文串的方法可以采用动态规划方法，如果 <code>[i+1, j-1]</code> 的子串是回文串，那么<code>[i, j] 且 s[i]==s[j]</code>的子串就是一个回文串，这样的判断方法比每一次都用双指针要好得多；</li>\n<li>怎么样知道 <code>[i+1, j-1]</code> 的子串是不是回文串呢，这里就需要记录一定的信息了，怎么样既能记录开头，也能记录结尾，还能记录是不是回文串呢？<code>二维数组</code></li>\n</ol>\n<p>注意两种情况：</p>\n<ol>\n<li><code>[i, i]</code> 一定是回文的</li>\n<li><code>[i, i+1]</code> 是不是回文的，要看 <code>s[i]</code> 和 <code>s[i+1]</code> 是不是相等</li>\n</ol>\n<p>官方解答中使用的遍历方法是按照 子串长度 和 起始位置 进行枚举，这种方法确实可以实现枚举，而且优点是对同一个长度的子串，可以使用一个简单的判断条件进行排除</p>\n<hr>\n<p>方法二：中心扩展</p>\n<p>这个方法很有意思</p>\n<p>回文串有两种：奇数形和偶数形</p>\n<p>奇数形的中心应该是 <code>s[i] == s[i]</code></p>\n<p>偶数形的中心应该是 <code>s[i] == s[i+1]</code></p>\n<p>然后所有的回文串都是有这样的中心的，并且应该根据这个中心向两边进行扩展，所以我们的步骤就是：</p>\n<ol>\n<li>枚举中心，并检查奇数形和偶数形两种可能</li>\n<li>向两边进行扩展，直到出现不对称的情况</li>\n<li>返回最长长度</li>\n</ol>\n<p>这个方法其实时间复杂度还是 <code>O(n^2)</code>，因为少不了要向两边进行扩展</p>\n<p>但是这个思路可能比较清晰</p>\n<hr>\n<p>细节一：原字符串长度为1</p>\n<p>按照第二个思路进行尝试，部分错误，案例为：<code>a</code> ，结果输出为空</p>\n<p>问题还是没有对一个字母，或者一个数字的情况做很好的处理</p>\n<p>我的错误方法是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = len(s)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ans = s[elft, right]</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>这样导致一个问题就是，如果 n = 1，那么会直接跳过循环遍历，直接把空的 ans 导出了</p>\n<p>官方的方法是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start, end = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">    修改 start, end 的值</span><br><span class=\"line\"><span class=\"keyword\">return</span> s[start: end+<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>其实主要还是最后一句的功劳，就是把0，0的情况也考虑在内了</p>\n<p>可以对我的方法进行一点点修改，保证不是空的就可以了</p>\n<p><code>return s[0] if not ans else ans</code></p>\n<p>细节二：索引相减 和 字符串长度不一定相等</p>\n<p> <code>right - left</code> 和 <code>len()</code> 不是相等的，差了1</p>\n<p>所以应该要 <code>right-left == len(ans)-1</code></p>\n<p>但是如果要更新 <code>ans</code> 结果子串的时候，又应该是 <code>ans = s[left:right+1]</code>以免 right 字符没有加入到子串当中</p>\n<h2 id=\"10-正则表达式匹配\"><a href=\"#10-正则表达式匹配\" class=\"headerlink\" title=\"10. 正则表达式匹配\"></a>10. 正则表达式匹配</h2><p>输入：</p>\n<p>两个字符串，s - 要匹配的字符串，p-正则表达式</p>\n<p>正则表达式中会有三种值：</p>\n<ul>\n<li>字母，直接匹配，必须相等</li>\n<li><code>.</code> 匹配任意一个单个字符</li>\n<li><code>*</code> 匹配任意个前面的一个元素</li>\n</ul>\n<p>需要返回的是，是否能够进行匹配</p>\n<hr>\n<p>这个题的关键难点在 <code>.*</code> 表示可以匹配任意多个任意字符</p>\n<p>如果正则表达式中这两个后面还有字符呢，那就会非常棘手</p>\n<p>这类问题之前其实也有，就是有多种可能性的问题 —— 动态规划</p>\n<hr>\n<p>这道题做动态规划，最难的一点是怎么样把问题思考全面，还有就是初始化非常容易出错</p>\n<p>动态规划思路：</p>\n<ol>\n<li><code>p[j] == s[i]</code> ，最方便，<code>dp[i][j] = dp[i-1][j-1]</code></li>\n<li><code>p[j] == &#39;.&#39;</code>，也还可以，<code>dp[i][j] = dp[i-1][j-1]</code></li>\n<li><code>p[j] == &#39;*&#39;</code>，比较麻烦，需要分两种情况<ol>\n<li><code>p[j-1] != s[i]</code>，那么就是说 <code>*</code> 前面的字母也不匹配，那么直接<code>dp[i][j] = dp[i][j-2]</code></li>\n<li><code>p[j-1] == &#39;.&#39;</code>或<code>p[j-1] == s[i]</code>，那么就要考虑匹配多少的问题呢，有两种情况，匹配了很多，或者一个都没有匹配==【这里给出了一个很好的例子，比如 “###b”和“###b*”】==<ol>\n<li>匹配了很多 <code>dp[i][j] = dp[i-1][j]</code></li>\n<li>一个都没有匹配 <code>dp[i][j] = dp[i][j-2]</code></li>\n<li>以上两种情况，只要出现一种就可以了，所以是 or 的关系</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>初始化问题：</p>\n<ol>\n<li>如果全部初始化为 False，那么不管怎么变，最后都是 False，所以一定要有Ture，但是又不能直接判断出某一个是True，所以方法有在 s 和 p 前面都加一个空格，然后定义第一个 <code>dp[0][0]=True</code></li>\n<li><code>dp</code>矩阵是个二维矩阵，到底需要多大？而且它的索引又会和<code>s</code>和<code>p</code>的索引相关</li>\n<li>如果 <code>p</code> 字符串并不能覆盖 <code>s</code>字符串呢？</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        m = len(s)</span><br><span class=\"line\">        n = len(p)</span><br><span class=\"line\">        dp = [[<span class=\"literal\">False</span>] * (n+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p[j<span class=\"number\">-1</span>] ==<span class=\"string\">'*'</span>: dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j<span class=\"number\">-2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># i 指针，在 s 上滑动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m+<span class=\"number\">1</span>):</span><br><span class=\"line\">            r = i - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">                c = j - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[c] == s[r] <span class=\"keyword\">or</span> p[c] == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> p[c] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> p[c<span class=\"number\">-1</span>] == s[r] <span class=\"keyword\">or</span> p[c<span class=\"number\">-1</span>] == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                        dp[i][j] = dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">or</span> dp[i][j<span class=\"number\">-2</span>]</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        dp[i][j] = dp[i][j<span class=\"number\">-2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>最后参考内容：</p>\n<p><a href=\"https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/</a></p>\n</blockquote>\n<h2 id=\"11-盛水最多的容器\"><a href=\"#11-盛水最多的容器\" class=\"headerlink\" title=\"11. 盛水最多的容器\"></a>11. 盛水最多的容器</h2><p>是接雨水问题、柱状图中最大矩形问题的前序问题</p>\n<p>这个相对比较简单一点</p>\n<p>两个柱子之间有阻挡也没有关系</p>\n<p>用双指针-左右指针进行收缩</p>\n<p>如果左边高度比较低，就移动左边指针</p>\n<p>如果右边高度比较低，就移动右边指针</p>\n<p>但是这道题的耗时有点离谱，大家都是怎么刷时间的</p>\n<h2 id=\"34-在排序数组中查找元素的第一个和最后一个位置-二分法\"><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置-二分法\" class=\"headerlink\" title=\"34. 在排序数组中查找元素的第一个和最后一个位置 - 二分法\"></a>34. 在排序数组中查找元素的第一个和最后一个位置 - 二分法</h2><p>数组是有序的，给定一个target</p>\n<p>查找 target 在数组中的位置</p>\n<hr>\n<p>这个题其实是看过算法的，但是二分法就是 细节魔鬼！</p>\n<p>有一个非常好的题解：<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/34po-shi-wu-hua-de-er-fen-cha-zhao-zan-men-yi-bu-y/\" target=\"_blank\" rel=\"noopener\">34.【朴实无华的二分查找】咱们一步一步来！</a></p>\n<p>这篇文章中的思路非常好，在不会跑的时候，就先用走的。</p>\n<p>二分法在本问题中的应用是：</p>\n<ol>\n<li>找到target的左边界</li>\n<li>找到target的右边界</li>\n</ol>\n<p>整个流程是：</p>\n<ol>\n<li>找到target在区间中的左右边界：用二分法</li>\n<li>对左右边界进行判断，决定最后输出情况</li>\n</ol>\n<hr>\n<p>核心：怎样找到 target 的左右边界，注意细节</p>\n<p>找左边界：</p>\n<ol>\n<li>left 取开头，right 取结尾，先把左边界的原始值设置为-2，如果根本就不需要进行下面的判断，左边界将为-2</li>\n<li>循环，条件是 left &lt;= right<ol>\n<li>二分法，找中间位置 mid</li>\n<li>如果 mid 位置数值 小于 target【说明左边界在 mid 的右边】，那就<ol>\n<li>left 换到 mid+1 的位置</li>\n</ol>\n</li>\n<li>如果 mid 位置数值 大于等于 target【说明左边界在 mid 的左边，但是具体在哪还不确定】<ol>\n<li>right 换到 mid-1 的位置</li>\n<li>把 左边界 也移到 right 的位置</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>找右边界：【虽说左边和右边可以类比，但是细节真的还是不太一样】</p>\n<ol>\n<li>left 取开头，right 取结尾，先把右边界的原始值设置为-2，如果根本就不需要进行下面的判断，右边界将为-2【这一步基本相同】</li>\n<li>循环，条件是 left &lt;= right<ol>\n<li>二分法，找中间位置 mid</li>\n<li>如果 mid 位置数值 大于 target【说明右边界在 mid 的左边】<ol>\n<li>right = mid - 1</li>\n</ol>\n</li>\n<li>如果 mid 位置数值 小于等于 target【说明左边界在 mid 的右边，但是具体在哪还不确定】<ol>\n<li>先把left移过去，缩小区间，left = mid + 1</li>\n<li>把右边界也移过去，rightBorder = left</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>上面两个过程就把寻找左右边界的工作走完了，这样也比较清晰，但是里面到底是什么时候修改 left 或者 right，什么时候记录左右边界值，其实还是需要一点讲究的，需要注意一下！</p>\n<p>接下来是判断，会有几种情况：</p>\n<ol>\n<li>最简单的肯定是有target，那么左右边界之间应该是不太一样的，返回 [leftBorder+1, rightBorder-1]</li>\n<li>如果全部比 target 大，或者全部比 target 小呢？这个时候肯定会有一侧的边界为-2，就是没有变化过，所以也可以进行得出了【-1， -1】</li>\n<li>其他情况，【-1， -1】</li>\n</ol>\n<p>可能最不容易判断的情况是 [1], target=1的情况，其实这个时候，leftBorder为-1，rightBorder为2，所以是可以得出结论的【0，0】</p>\n<h1 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><!-- ASCII --></h1><h2 id=\"804-唯一摩尔斯密码词\"><a href=\"#804-唯一摩尔斯密码词\" class=\"headerlink\" title=\"804. 唯一摩尔斯密码词\"></a>804. 唯一摩尔斯密码词</h2><p>这个问题是说，给了一个写有多个词的 list</p>\n<p>根据摩尔斯密码分别进行转化，然后判断这些词的摩尔斯密码中有没有相同的</p>\n<p>返回的是不相同的摩尔斯密码的数量</p>\n<hr>\n<p>补充知识：</p>\n<h3 id=\"python-与-ASCII码\"><a href=\"#python-与-ASCII码\" class=\"headerlink\" title=\"python 与 ASCII码\"></a>python 与 ASCII码</h3><p>这道题给的是小写字母</p>\n<p>密码本也是一个list，怎么样进行检索</p>\n<p>小写字母的 ASCII 码是 97-122</p>\n<p>大写字母的 ASCII 码是 65-90</p>\n<p>数字的 ASCII 码是 48-57</p>\n<p>可以使用 <code>ord(str)</code> 函数将字符转换为相应的 ASCII 码</p>\n<p>还可以使用 <code>chr(int)</code> 将 ASCII 码转换为相应的字符</p>\n<p>还可以直接使用 <code>ord(x) - ord(&#39;a&#39;)</code> ，这样即使不知道 a 的ASCII 码是多少也可以进行使用</p>\n<hr>\n<p>第一步，获得所有单词的摩尔斯密码串：</p>\n<p>本题使用就这样使用</p>\n<p><code>ord(str)-97</code> 就是这个小写字母在密码本中的索引值了</p>\n<p>获得摩尔斯密码串是比较容易的</p>\n<p>第二步，分析这些密码穿是不是又重复的：</p>\n<ul>\n<li>我用了 set() 集合，主要是存储和查询</li>\n<li>官方用了哈希表进行存储，其实差不多</li>\n</ul>\n<hr>\n<p>再补充知识：</p>\n<h3 id=\"python中的集合\"><a href=\"#python中的集合\" class=\"headerlink\" title=\"python中的集合\"></a>python中的集合</h3><p>创建一个集合，可以用</p>\n<p><code>B = {a, b, &#39;c&#39;}</code> 这样的形式</p>\n<p>但是如果创建 空集合，必须是 <code>A = set()</code>， 如果是 <code>{}</code> 就成了创建空的字典了</p>\n<p>增加元素：<code>add</code></p>\n<p>将元素拆分成一个一个字符再添加进集合：<code>update</code></p>\n<p>删除某个元素：</p>\n<ul>\n<li><code>remove</code>，不存在会报错</li>\n<li><code>discard</code>， 不存在也不报错</li>\n<li><code>pop</code>，删除并返回【注意是任意元素】</li>\n<li><code>clear</code>，清空集合</li>\n</ul>\n<p>集合与集合之间可以进行数学运算：交并包含等关系</p>\n<hr>\n<p>本期十题就到这里，接下来将会主攻 LeetCode Hot 100 问题！</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><!-- 链表 --></h1><h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a>206. 反转链表</h2><p>这个题其实已经做过多次了，这次总结一下：</p>\n<p>题目要求：给出一个链表的头节点，请反转整个链表，并且返回反转后的链表的头节点。</p>\n<p>这个题用递归的方法简直是非常之妙，而且十分经典。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, val=<span class=\"number\">0</span>, next=None)</span>:</span></span><br><span class=\"line\">        self.val = val</span><br><span class=\"line\">        self.next = next</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNone:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> head.next: <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        last = self.reverse(head.next)</span><br><span class=\"line\">        head.next.next = head</span><br><span class=\"line\">        head.next = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> last</span><br></pre></td></tr></table></figure>\n<p>这个做法简直非常精妙，充分体现了递归方法中的关键：</p>\n<p>1）找一个最简问题，解决它</p>\n<p>2）充分理解并相信函数能解决你的问题</p>","more":"<h2 id=\"92-反转链表-II\"><a href=\"#92-反转链表-II\" class=\"headerlink\" title=\"92. 反转链表 II\"></a>92. 反转链表 II</h2><p>这道题要求的是 反转链表中的某一部分</p>\n<p>比如给出 head，left，right，请反转从 left 到 right 的部分</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg\" alt=\"img\"></p>\n<p>根据前面做过的反转链表，这里的思路大概有两种：</p>\n<ol>\n<li>先反转 left 到 末尾，再反转 right 到末尾；但是这种方法仔细一想就是不可能的，因为第一次反转之后，末尾的元素到前面来了，要想再把它们翻转回去是不可能的。</li>\n<li>只翻转 left 到 right 的部分，然后再拼接起来。</li>\n</ol>\n<p>第2种方法是可行的，但是需要考虑的问题有：</p>\n<ol>\n<li>要记录 left 的前一个节点 pre</li>\n<li>要记录 right 的后一个节点 succ（successor）</li>\n<li>pre 的 next 指向反转后的头节点</li>\n<li>反转后的尾节点的 next 指向 succ</li>\n</ol>\n<p>可见是一个比较复杂的问题，应该怎么处理呢</p>\n<hr>\n<h3 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>分为7个步骤：</p>\n<p>1）在头节点前添加哑节点防止头节点变化，哑节点不能动</p>\n<p>2）创建一个移动节点寻找左节点的上一个节点，其实也就找到了左节点</p>\n<p>3）再创建一个移动节点到右节点，其实也就找到了右节点的下一个节点</p>\n<p>4）截断中间部分</p>\n<p>5）反转中间部分（用一个无返回值的函数进行操作）</p>\n<p>6）重接中间部分</p>\n<p>7）返回哑节点的下一个节点</p>\n<blockquote>\n<p>我的题解：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/guan-fang-jie-fa-pythonfu-xian-by-yue-wo-kebj/\" target=\"_blank\" rel=\"noopener\">官方解法-python复现</a></p>\n</blockquote>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><!-- 单调栈、哨兵 --></h1><h2 id=\"84-柱状图中的最大的矩形\"><a href=\"#84-柱状图中的最大的矩形\" class=\"headerlink\" title=\"84. 柱状图中的最大的矩形\"></a>84. 柱状图中的最大的矩形</h2><p>问题描述：</p>\n<p>给出一个柱形图（数组），数组中的元素表示柱的高度，现在需要在柱形图中找出一个能画出的最大的矩形，比如：</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png\" alt=\"img\"></p>\n<hr>\n<p>先从暴力解法——枚举开始。</p>\n<p>（1）枚举宽度【左右边界】</p>\n<ol>\n<li>左边界从0开始遍历</li>\n<li>右边界从左边界开始遍历</li>\n<li>高度取从左边界到右边界区间最矮高度</li>\n<li>计算面积，记录最大面积</li>\n</ol>\n<p>这样一看，这个题的暴力方法其实也是很规矩的。</p>\n<p>缺点是：时间复杂度在 O(N^2)，因为有循环套循环，而且占用内存也不小。</p>\n<p>（2）枚举高度</p>\n<p>这种方法的思想是先找定一个高度点，然后左右扩展确定边界【边界的特征是两边的高度将小于边界的高度】，最后计算出面积。</p>\n<p>也就是扩展左右的柱子，高度均不能小于 h。</p>\n<p>这个方法其实就是在找能够覆盖第 i 个柱子的最大矩形，可以参考：<a href=\"https://blog.csdn.net/Zolewit/article/details/88863970\" target=\"_blank\" rel=\"noopener\">84. 柱状图中最大的矩形/C++</a></p>\n<hr>\n<p>题目有一些特点：</p>\n<ol>\n<li><p>借鉴枚举高度的方法，我们应该找到左右两侧 最近的 高度小于 h 的柱子。</p>\n</li>\n<li><p>一个结论和思想：</p>\n<ol>\n<li>如果两根柱子：<code>j0 &lt; j1</code>，<code>height[j0]&gt;height[j1]</code></li>\n<li>那么对于 <code>j1</code> 之后的柱子，<code>j0</code>一定不是 最近的 小于 柱子高度的柱子。【至于高度大于它的，其实不重要】</li>\n</ol>\n</li>\n</ol>\n<p>第一个特点说明，我们要找的就是比当前柱子小的最近的柱子，包括左边和右边；</p>\n<p>第二个特点说明，当我们找到这个最近的之后，远处的其实不重要了，比这个高的也不重要了【就可以删除了】</p>\n<p>所以使用了 单调栈这样一个思路去求解这个问题</p>\n<hr>\n<p>使用单调栈：</p>\n<p>我个人觉得这篇题解讲的很好：<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/\" target=\"_blank\" rel=\"noopener\">暴力解法、栈（单调栈、哨兵技巧）</a></p>\n<p>它讲明白了一件事情，就是栈顶元素删除之前做了什么：</p>\n<ul>\n<li>其实直到我们找到一个比较短的柱子时，我们才知道以上一个值为高度的矩形到这里结束了，一个面积就求出来了</li>\n<li>然后后面的高度就会以现在这个短的为基准了</li>\n</ul>\n<p>总结一下，我们是怎么确定一个柱形的面积的：</p>\n<ul>\n<li>我们记录了下标，下标对应的高度</li>\n<li>当我们发现这个下标比上一个下标矮的时候，好了，说明上一个下标对应的高度的矩形到头了，可以计算了</li>\n<li>而上一个下标对应的高度的矩形，其实还要找一下左边界，什么时候左边界也比它小了，这个区间找到了，这个高度的矩形面积可以算了，这个高度就完全结束了</li>\n</ul>\n<p>上面说的这个过程可能需要 进行多次，直到左边没有高度 小于 当前的高度了</p>\n<p>这个过程中，缓存数据是从左往右的，计算结果是从右往左的，所以就是后进的先出，这样的数据结构就是栈</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 先求一下总长度</span></span><br><span class=\"line\">        n = len(heights)</span><br><span class=\"line\">        <span class=\"comment\"># 这是结果，记录面积</span></span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># 这个栈用来做单调栈，栈是用来记位置的，而不是记高度的</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 对数组一次遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"comment\"># 遇到了下降的情况，开始出栈和计算了</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> heights[i] &lt; heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                <span class=\"comment\"># 出栈，要计算面积了</span></span><br><span class=\"line\">                cur_height = heights[stack.pop()]</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># 这个是？保证绝对单调吗？</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> cur_height == heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                    stack.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"comment\"># 栈没有空，那么左右边界求一下</span></span><br><span class=\"line\">                    cur_width = i - stack[<span class=\"number\">-1</span>] - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"comment\"># 栈空了，那就是全长</span></span><br><span class=\"line\">                    cur_width = i</span><br><span class=\"line\">                <span class=\"comment\"># 计算面积</span></span><br><span class=\"line\">                area = max(area, cur_height * cur_width)</span><br><span class=\"line\">            <span class=\"comment\"># 这是新的高度（可能是更高的，也可能是栈操作了一遍之后新加的高度）</span></span><br><span class=\"line\">            stack.append(i)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># 数组遍历结束了，但是栈可能还没有清空</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            cur_height = heights[stack.pop()]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(stack) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> cur_height == heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(stack) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 因为数组已经遍历结束了，这里留下来的高度就是从记录位置到尾部的了</span></span><br><span class=\"line\">                cur_width = n - stack[<span class=\"number\">-1</span>] - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                cur_width = n</span><br><span class=\"line\">            area = max(area, cur_height * cur_width)</span><br><span class=\"line\">            </span><br><span class=\"line\">       \t<span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>\n<p>上面这种方法做了分类讨论：</p>\n<ul>\n<li>弹栈的时候，栈有可能是空的</li>\n<li>遍历完成后，栈里还有元素</li>\n</ul>\n<p>解决方法：【<strong>哨兵方法</strong>】Sentinel</p>\n<ul>\n<li>数组两端加上两个 0：只要比 1 严格小就可以了<ul>\n<li>左边的哨兵一定比数组中所有元素都小，绝对不会出栈</li>\n<li>右边的哨兵一定比数组中所有元素都小，会让所有元素都出栈（除了左边的哨兵）</li>\n</ul>\n</li>\n<li>这样就可以不用分类讨论了</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        n = len(heights)</span><br><span class=\"line\">        area = <span class=\"number\">0</span></span><br><span class=\"line\">        heights = [<span class=\"number\">0</span>] + heights + [<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"comment\"># 先向栈中放入哨兵</span></span><br><span class=\"line\">        stack = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        n += <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">while</span> heights[i] &lt; heights[stack[<span class=\"number\">-1</span>]]:</span><br><span class=\"line\">                cur_height = heights[stack.pop()]</span><br><span class=\"line\">                cur_width = i - stack[<span class=\"number\">-1</span>] <span class=\"number\">-1</span></span><br><span class=\"line\">                area = max(area, cur_height * cur_width)</span><br><span class=\"line\">            <span class=\"comment\"># 下面这一句为什么是在 while循环外的？</span></span><br><span class=\"line\">            <span class=\"comment\"># 这个地方不要担心 i 不满足要求，因为如果不满足要求，过不了上面的while循环</span></span><br><span class=\"line\">            stack.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> area</span><br></pre></td></tr></table></figure>\n<p>居然一下子简洁了这么多，哨兵的作用真的很厉害</p>\n<blockquote>\n<p>python 实现栈的方法其实就是 list，栈顶就是 list 尾部</p>\n<p>我想起有一个<strong>收集雨水</strong>的问题，其实有一定的联系，都是单调栈的问题</p>\n<p>单调栈问题：739、469、42</p>\n</blockquote>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><!-- 哈希表 --></h1><h2 id=\"1603-设计停车系统\"><a href=\"#1603-设计停车系统\" class=\"headerlink\" title=\"1603. 设计停车系统\"></a>1603. 设计停车系统</h2><p>题目描述：</p>\n<ol>\n<li>告诉了三种车位的数量：大、中、小车位各有几个</li>\n<li>然后告诉车的类型：大、中、小车辆</li>\n</ol>\n<p>最后，问每辆车是不是有位置停，返回布尔值</p>\n<p>而且这个问题就是先到先得，车位满了后面的就是 false</p>\n<p>最简单的想法，直接3个 if 进行判断</p>\n<p>稍微好一点的方法，可以使用一个哈希表进行3种车位的存储，这样搜索起来也比较快：内存消耗少了一点点，用时居然还是很高</p>\n<h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a>20. 有效的括号</h2><p>描述：</p>\n<p>数学中，括号是成对出现的，而且括号应该是 由内向外完整嵌套的，比如：</p>\n<p><code>{[()]}</code> 就是有效的</p>\n<p><code>{[}])</code> 方括号位置不对，圆括号少了一半就是无效的</p>\n<p>现在就是给一个全是括号的字符串，检测是不是有效的</p>\n<hr>\n<p>这个题曾经看过了题解，记下了一个重要的方法：哈希表</p>\n<p>用 左括号 做 key，右括号 做value</p>\n<p>我自己想出以下步骤：</p>\n<ol>\n<li>遍历字符串<ol>\n<li>如果是左括号<ol>\n<li>新建一个 need 列表存储 需要的右括号</li>\n</ol>\n</li>\n<li>如果是右括号，看是不是 need 中最后一个（最新需要的）右括号<ol>\n<li>如果是，need 中最新的右括号扔掉【其实就是栈啊】</li>\n<li>如果不是，直接 False</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>最后看 need 是不是空的<ol>\n<li>如果是，返回 True</li>\n<li>如果不是，返回 False</li>\n</ol>\n</li>\n</ol>\n<p>其中几个细节点：</p>\n<ol>\n<li>怎么样检查是不是左括号？<ol>\n<li>方法一，需要一个左括号的列表</li>\n<li>方法二，检查 括号是不是字典的一个 key：<code>if xxx in dict.keys():</code></li>\n</ol>\n</li>\n</ol>\n<h1 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><!-- Hot 100 问题 --></h1><h2 id=\"5-最长回文子串问题\"><a href=\"#5-最长回文子串问题\" class=\"headerlink\" title=\"5. 最长回文子串问题\"></a>5. 最长回文子串问题</h2><p>问题描述：</p>\n<p>给一个字符串，请返回该字符串中最长的回文子串（串，应该是连续的）</p>\n<hr>\n<p>首先想到暴力解法：</p>\n<p>枚举所有可能的字符串（的左右两边）</p>\n<p>然后判断这个子串是不是回文的，并记录最长的回文子串</p>\n<p>我的写法超时了，最大问题在于怎么判断是不是回文的，如果对于每一个可疑的子串都采用<code>双指针</code>的方法进行判断，那么肯定会超时，所以才需要用算法</p>\n<hr>\n<p>方法一：动态规划</p>\n<p>从大的角度讲，枚举所有可能的子串是必要的，这个复杂度可能少不了</p>\n<p>但是</p>\n<ol>\n<li>判断回文串的方法可以采用动态规划方法，如果 <code>[i+1, j-1]</code> 的子串是回文串，那么<code>[i, j] 且 s[i]==s[j]</code>的子串就是一个回文串，这样的判断方法比每一次都用双指针要好得多；</li>\n<li>怎么样知道 <code>[i+1, j-1]</code> 的子串是不是回文串呢，这里就需要记录一定的信息了，怎么样既能记录开头，也能记录结尾，还能记录是不是回文串呢？<code>二维数组</code></li>\n</ol>\n<p>注意两种情况：</p>\n<ol>\n<li><code>[i, i]</code> 一定是回文的</li>\n<li><code>[i, i+1]</code> 是不是回文的，要看 <code>s[i]</code> 和 <code>s[i+1]</code> 是不是相等</li>\n</ol>\n<p>官方解答中使用的遍历方法是按照 子串长度 和 起始位置 进行枚举，这种方法确实可以实现枚举，而且优点是对同一个长度的子串，可以使用一个简单的判断条件进行排除</p>\n<hr>\n<p>方法二：中心扩展</p>\n<p>这个方法很有意思</p>\n<p>回文串有两种：奇数形和偶数形</p>\n<p>奇数形的中心应该是 <code>s[i] == s[i]</code></p>\n<p>偶数形的中心应该是 <code>s[i] == s[i+1]</code></p>\n<p>然后所有的回文串都是有这样的中心的，并且应该根据这个中心向两边进行扩展，所以我们的步骤就是：</p>\n<ol>\n<li>枚举中心，并检查奇数形和偶数形两种可能</li>\n<li>向两边进行扩展，直到出现不对称的情况</li>\n<li>返回最长长度</li>\n</ol>\n<p>这个方法其实时间复杂度还是 <code>O(n^2)</code>，因为少不了要向两边进行扩展</p>\n<p>但是这个思路可能比较清晰</p>\n<hr>\n<p>细节一：原字符串长度为1</p>\n<p>按照第二个思路进行尝试，部分错误，案例为：<code>a</code> ，结果输出为空</p>\n<p>问题还是没有对一个字母，或者一个数字的情况做很好的处理</p>\n<p>我的错误方法是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = len(s)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ans = s[elft, right]</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>这样导致一个问题就是，如果 n = 1，那么会直接跳过循环遍历，直接把空的 ans 导出了</p>\n<p>官方的方法是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start, end = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">    修改 start, end 的值</span><br><span class=\"line\"><span class=\"keyword\">return</span> s[start: end+<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>其实主要还是最后一句的功劳，就是把0，0的情况也考虑在内了</p>\n<p>可以对我的方法进行一点点修改，保证不是空的就可以了</p>\n<p><code>return s[0] if not ans else ans</code></p>\n<p>细节二：索引相减 和 字符串长度不一定相等</p>\n<p> <code>right - left</code> 和 <code>len()</code> 不是相等的，差了1</p>\n<p>所以应该要 <code>right-left == len(ans)-1</code></p>\n<p>但是如果要更新 <code>ans</code> 结果子串的时候，又应该是 <code>ans = s[left:right+1]</code>以免 right 字符没有加入到子串当中</p>\n<h2 id=\"10-正则表达式匹配\"><a href=\"#10-正则表达式匹配\" class=\"headerlink\" title=\"10. 正则表达式匹配\"></a>10. 正则表达式匹配</h2><p>输入：</p>\n<p>两个字符串，s - 要匹配的字符串，p-正则表达式</p>\n<p>正则表达式中会有三种值：</p>\n<ul>\n<li>字母，直接匹配，必须相等</li>\n<li><code>.</code> 匹配任意一个单个字符</li>\n<li><code>*</code> 匹配任意个前面的一个元素</li>\n</ul>\n<p>需要返回的是，是否能够进行匹配</p>\n<hr>\n<p>这个题的关键难点在 <code>.*</code> 表示可以匹配任意多个任意字符</p>\n<p>如果正则表达式中这两个后面还有字符呢，那就会非常棘手</p>\n<p>这类问题之前其实也有，就是有多种可能性的问题 —— 动态规划</p>\n<hr>\n<p>这道题做动态规划，最难的一点是怎么样把问题思考全面，还有就是初始化非常容易出错</p>\n<p>动态规划思路：</p>\n<ol>\n<li><code>p[j] == s[i]</code> ，最方便，<code>dp[i][j] = dp[i-1][j-1]</code></li>\n<li><code>p[j] == &#39;.&#39;</code>，也还可以，<code>dp[i][j] = dp[i-1][j-1]</code></li>\n<li><code>p[j] == &#39;*&#39;</code>，比较麻烦，需要分两种情况<ol>\n<li><code>p[j-1] != s[i]</code>，那么就是说 <code>*</code> 前面的字母也不匹配，那么直接<code>dp[i][j] = dp[i][j-2]</code></li>\n<li><code>p[j-1] == &#39;.&#39;</code>或<code>p[j-1] == s[i]</code>，那么就要考虑匹配多少的问题呢，有两种情况，匹配了很多，或者一个都没有匹配==【这里给出了一个很好的例子，比如 “###b”和“###b*”】==<ol>\n<li>匹配了很多 <code>dp[i][j] = dp[i-1][j]</code></li>\n<li>一个都没有匹配 <code>dp[i][j] = dp[i][j-2]</code></li>\n<li>以上两种情况，只要出现一种就可以了，所以是 or 的关系</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>初始化问题：</p>\n<ol>\n<li>如果全部初始化为 False，那么不管怎么变，最后都是 False，所以一定要有Ture，但是又不能直接判断出某一个是True，所以方法有在 s 和 p 前面都加一个空格，然后定义第一个 <code>dp[0][0]=True</code></li>\n<li><code>dp</code>矩阵是个二维矩阵，到底需要多大？而且它的索引又会和<code>s</code>和<code>p</code>的索引相关</li>\n<li>如果 <code>p</code> 字符串并不能覆盖 <code>s</code>字符串呢？</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        m = len(s)</span><br><span class=\"line\">        n = len(p)</span><br><span class=\"line\">        dp = [[<span class=\"literal\">False</span>] * (n+<span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p[j<span class=\"number\">-1</span>] ==<span class=\"string\">'*'</span>: dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j<span class=\"number\">-2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># i 指针，在 s 上滑动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m+<span class=\"number\">1</span>):</span><br><span class=\"line\">            r = i - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">                c = j - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[c] == s[r] <span class=\"keyword\">or</span> p[c] == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> p[c] == <span class=\"string\">'*'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> p[c<span class=\"number\">-1</span>] == s[r] <span class=\"keyword\">or</span> p[c<span class=\"number\">-1</span>] == <span class=\"string\">'.'</span>:</span><br><span class=\"line\">                        dp[i][j] = dp[i<span class=\"number\">-1</span>][j] <span class=\"keyword\">or</span> dp[i][j<span class=\"number\">-2</span>]</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        dp[i][j] = dp[i][j<span class=\"number\">-2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>最后参考内容：</p>\n<p><a href=\"https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/</a></p>\n</blockquote>\n<h2 id=\"11-盛水最多的容器\"><a href=\"#11-盛水最多的容器\" class=\"headerlink\" title=\"11. 盛水最多的容器\"></a>11. 盛水最多的容器</h2><p>是接雨水问题、柱状图中最大矩形问题的前序问题</p>\n<p>这个相对比较简单一点</p>\n<p>两个柱子之间有阻挡也没有关系</p>\n<p>用双指针-左右指针进行收缩</p>\n<p>如果左边高度比较低，就移动左边指针</p>\n<p>如果右边高度比较低，就移动右边指针</p>\n<p>但是这道题的耗时有点离谱，大家都是怎么刷时间的</p>\n<h2 id=\"34-在排序数组中查找元素的第一个和最后一个位置-二分法\"><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置-二分法\" class=\"headerlink\" title=\"34. 在排序数组中查找元素的第一个和最后一个位置 - 二分法\"></a>34. 在排序数组中查找元素的第一个和最后一个位置 - 二分法</h2><p>数组是有序的，给定一个target</p>\n<p>查找 target 在数组中的位置</p>\n<hr>\n<p>这个题其实是看过算法的，但是二分法就是 细节魔鬼！</p>\n<p>有一个非常好的题解：<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/34po-shi-wu-hua-de-er-fen-cha-zhao-zan-men-yi-bu-y/\" target=\"_blank\" rel=\"noopener\">34.【朴实无华的二分查找】咱们一步一步来！</a></p>\n<p>这篇文章中的思路非常好，在不会跑的时候，就先用走的。</p>\n<p>二分法在本问题中的应用是：</p>\n<ol>\n<li>找到target的左边界</li>\n<li>找到target的右边界</li>\n</ol>\n<p>整个流程是：</p>\n<ol>\n<li>找到target在区间中的左右边界：用二分法</li>\n<li>对左右边界进行判断，决定最后输出情况</li>\n</ol>\n<hr>\n<p>核心：怎样找到 target 的左右边界，注意细节</p>\n<p>找左边界：</p>\n<ol>\n<li>left 取开头，right 取结尾，先把左边界的原始值设置为-2，如果根本就不需要进行下面的判断，左边界将为-2</li>\n<li>循环，条件是 left &lt;= right<ol>\n<li>二分法，找中间位置 mid</li>\n<li>如果 mid 位置数值 小于 target【说明左边界在 mid 的右边】，那就<ol>\n<li>left 换到 mid+1 的位置</li>\n</ol>\n</li>\n<li>如果 mid 位置数值 大于等于 target【说明左边界在 mid 的左边，但是具体在哪还不确定】<ol>\n<li>right 换到 mid-1 的位置</li>\n<li>把 左边界 也移到 right 的位置</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>找右边界：【虽说左边和右边可以类比，但是细节真的还是不太一样】</p>\n<ol>\n<li>left 取开头，right 取结尾，先把右边界的原始值设置为-2，如果根本就不需要进行下面的判断，右边界将为-2【这一步基本相同】</li>\n<li>循环，条件是 left &lt;= right<ol>\n<li>二分法，找中间位置 mid</li>\n<li>如果 mid 位置数值 大于 target【说明右边界在 mid 的左边】<ol>\n<li>right = mid - 1</li>\n</ol>\n</li>\n<li>如果 mid 位置数值 小于等于 target【说明左边界在 mid 的右边，但是具体在哪还不确定】<ol>\n<li>先把left移过去，缩小区间，left = mid + 1</li>\n<li>把右边界也移过去，rightBorder = left</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>上面两个过程就把寻找左右边界的工作走完了，这样也比较清晰，但是里面到底是什么时候修改 left 或者 right，什么时候记录左右边界值，其实还是需要一点讲究的，需要注意一下！</p>\n<p>接下来是判断，会有几种情况：</p>\n<ol>\n<li>最简单的肯定是有target，那么左右边界之间应该是不太一样的，返回 [leftBorder+1, rightBorder-1]</li>\n<li>如果全部比 target 大，或者全部比 target 小呢？这个时候肯定会有一侧的边界为-2，就是没有变化过，所以也可以进行得出了【-1， -1】</li>\n<li>其他情况，【-1， -1】</li>\n</ol>\n<p>可能最不容易判断的情况是 [1], target=1的情况，其实这个时候，leftBorder为-1，rightBorder为2，所以是可以得出结论的【0，0】</p>\n<h1 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><!-- ASCII --></h1><h2 id=\"804-唯一摩尔斯密码词\"><a href=\"#804-唯一摩尔斯密码词\" class=\"headerlink\" title=\"804. 唯一摩尔斯密码词\"></a>804. 唯一摩尔斯密码词</h2><p>这个问题是说，给了一个写有多个词的 list</p>\n<p>根据摩尔斯密码分别进行转化，然后判断这些词的摩尔斯密码中有没有相同的</p>\n<p>返回的是不相同的摩尔斯密码的数量</p>\n<hr>\n<p>补充知识：</p>\n<h3 id=\"python-与-ASCII码\"><a href=\"#python-与-ASCII码\" class=\"headerlink\" title=\"python 与 ASCII码\"></a>python 与 ASCII码</h3><p>这道题给的是小写字母</p>\n<p>密码本也是一个list，怎么样进行检索</p>\n<p>小写字母的 ASCII 码是 97-122</p>\n<p>大写字母的 ASCII 码是 65-90</p>\n<p>数字的 ASCII 码是 48-57</p>\n<p>可以使用 <code>ord(str)</code> 函数将字符转换为相应的 ASCII 码</p>\n<p>还可以使用 <code>chr(int)</code> 将 ASCII 码转换为相应的字符</p>\n<p>还可以直接使用 <code>ord(x) - ord(&#39;a&#39;)</code> ，这样即使不知道 a 的ASCII 码是多少也可以进行使用</p>\n<hr>\n<p>第一步，获得所有单词的摩尔斯密码串：</p>\n<p>本题使用就这样使用</p>\n<p><code>ord(str)-97</code> 就是这个小写字母在密码本中的索引值了</p>\n<p>获得摩尔斯密码串是比较容易的</p>\n<p>第二步，分析这些密码穿是不是又重复的：</p>\n<ul>\n<li>我用了 set() 集合，主要是存储和查询</li>\n<li>官方用了哈希表进行存储，其实差不多</li>\n</ul>\n<hr>\n<p>再补充知识：</p>\n<h3 id=\"python中的集合\"><a href=\"#python中的集合\" class=\"headerlink\" title=\"python中的集合\"></a>python中的集合</h3><p>创建一个集合，可以用</p>\n<p><code>B = {a, b, &#39;c&#39;}</code> 这样的形式</p>\n<p>但是如果创建 空集合，必须是 <code>A = set()</code>， 如果是 <code>{}</code> 就成了创建空的字典了</p>\n<p>增加元素：<code>add</code></p>\n<p>将元素拆分成一个一个字符再添加进集合：<code>update</code></p>\n<p>删除某个元素：</p>\n<ul>\n<li><code>remove</code>，不存在会报错</li>\n<li><code>discard</code>， 不存在也不报错</li>\n<li><code>pop</code>，删除并返回【注意是任意元素】</li>\n<li><code>clear</code>，清空集合</li>\n</ul>\n<p>集合与集合之间可以进行数学运算：交并包含等关系</p>\n<hr>\n<p>本期十题就到这里，接下来将会主攻 LeetCode Hot 100 问题！</p>"},{"title":"LeetCode刷题笔记（三）","date":"2020-12-29T12:46:39.000Z","_content":"\n每期10题，上一期参见[LeetCode刷题笔记（二）](https://sunyoe.github.io/2020/12/06/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/)。\n\n本期内容多以动态规划为主。\n\n# 动态规划\n\n## 392. 判断子序列 - 动态规划\n\n输入：长序列 t，短序列 s\n\n判断：s 是不是 t 的子序列\n\n条件：\n\n- 从原始序列到子序列，可以删除部分字符，可以不连续，但是**相对位置**不能变\n- 两个序列全是英文小写字母\n\n<!--more-->\n\n传统方法：\n\n- 如果可以不改变顺序地去重，那么就可以直接取筛选了\n\n**怎么样使用动态规划呢？**\n\n到了 t 的第 n 个字符，已经发现了 s 的字符数为 f(n)\n\n那么\n\n- 如果这一个（t_n）不是s中的下一个（s_(f(n-1)+1)），那么f(n) = f(n-1)\n- 如果是，那么f(n) = f(n-1) + 1\n\n推导至 t 的结尾，或者到了s 的结尾，就要停止了\n\n如果s到了结尾，那就说明是子序列\n\n特殊情况：\n\n（1）短字符为空\n\n~~（2）长字符和短字符一样长【如果不相等可以直接判断为False了】，那相等直接判定为True【其实这个也不必了】~~\n\n这个问题最容易出错的地方是list的索引问题，上代码：\n\n```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        yes_num = 0\n        if not len(s):\n            return True\n        # if len(s) == len(t):\n        #     return False if s != t else True\n        for i in range(len(t)):\n            if t[i] == s[yes_num]:\n                yes_num += 1\n            if yes_num == len(s):\n                return True\n        return True if yes_num == len(s) else False\n```\n\nyes_sum 直接代表了 s 中的下一个位置【因为list从0开始】，也表示了 s 已经匹配的字符数量\n\n**所以最后对比yes_num和s的长度就不用长度减一了！！**\n\n所以长字符和短字符一样长的情况也就不再是特殊情况了\n\n最后，最简化版本，特殊情况不特殊，最后判断也多余：\n\n```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        yes_num = 0\n        if not len(s):\n            return True\n        for i in range(len(t)):\n            if t[i] == s[yes_num]:\n                yes_num += 1\n            if yes_num == len(s):\n                return True\n        return False\n```\n\n## 746. 使用最小花费爬楼梯 - 动态规划\n\n本题确实是一个动态规划方面的问题，但是我得说这个问题的描述有点迷糊\n\n输入：一个列表，全是数值，长度至少是2\n\n输出：最小子序列的和\n\n要求：\n\n- 该子序列可以连续，也可以间隔1个；\n- 该子序列可以不包含第1个元素（索引为0）；\n- 该子序列可以不包含最后一个元素（索引为 n-1）；\n\n假设到第 n 个数值，最小和为 f(n)\n\n有三种可能：怎么样去选择？\n\n- $f(n) = f(n-1)$（可以从第2个数，也就是索引为1开始）【跳当前数值】\n  - 问题：**【那这个肯定比第二种要小，怎么说？】**\n\n- $f(n) = f(n-1) + i$（可以从第2个数，也就是索引为1开始）【连续】\n  - 如果此时 n 是最后一个，那么 i 是不能加的**【但问题是我不知道 n 到底是不是最后一个】**\n\n- $f(n) = f(n-2) + i$（可以从第3个数，也就是索引为2开始）【跳前一个数值】\n  - 如果此时 n 是最后一个，那么 i 是必须加的\n\n初始条件：\n\n- $f(1) = i_0$\n- $f(2)=min(f(1), i_1)$【如果能跳过2个，那么一定会跳过，否则和一定会变大】\n\n终止条件：\n\n- $n$ 到了结尾\n\n现在思路开始混乱了：\n\n在第 n 个数值，有几种情况？选择当前，不选择当前，不管选不选当前，都有可能选前一个数值\n\n- 一般情况下，我肯定不会连续选择数值，除非旁边的数值更大，或者没得选\n\n### 阅读题解\n\n**递归关系**似乎是 $f(n) = i + min(f(n-1), f(n-2))$\n\n最后一步，为了防止最后一步需要判断取舍，可以直接在最后选择 f(n) 和 f(n-1) 中比较小的，那就实现了最优\n\n还有一点就是，这样的话，初始化就和上面略有不同了：\n\n- f(1) = i_0\n- f(2) = i_1\n\n因为最后已经增加了判断最后一个数值取舍的步骤，这里的 f(2) 就没有必要多一次判断了\n\n```python\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        sum_cost = []\n        sum_cost.append(cost[0])\n        sum_cost.append(cost[1])\n        if len(cost) == 2:\n            return sum_cost[-1]\n        for i in range(2, len(cost)):\n            sum_cost.append(cost[i] + min(sum_cost[-1], sum_cost[-2]))\n        return min(sum_cost[-1], sum_cost[-2])\n```\n\n## 面试题 17.16 按摩师 - 动态规划\n\n输入：一个序列\n\n输出：子序列的和，最大和\n\n要求：子序列元素不能相邻\n\n本题就是比较典型的动态规划\n\n状态表达式：$f(n)$ 表示到第 n 个数的最大和\n\n状态转移方程及条件：\n\n（1）$f(n) = f(n-1)$，什么条件？\n\n（2）$f(n) = f(n-2) + i$\n\n那本题岂不是和198题相同？？\n\n> 在746题中，因为可以连续，或者只能间隔一个，所以是先比较最大值（最小值），然后再加当前值\n>\n> 但是本题不能连续，不能先比较最大值\n\n本题有个问题，一定会选择当前数值吗？不一定\n\n和198题还真是一样的，就考虑三个特殊情况：\n\n列表长度为0，1，2，分别是0，sum(list)，max(list)，有没有什么方法可以一句话搞定的？\n\n## 389. 找不同 - 运算，ASCII和异或\n\n输入：两个字符串 s 和 t\n\n输出：t 中 s 没有的字符\n\n要求：t 由 s 随机重排并添加了一个字母\n\n**本题居然是简单？**\n\n观察示例发现：\n\n添加的字母有可能是s 中已有字母重复的，那么这样的话使用 set 元组做去重就是不太好的方法了\n\n如果遍历 s 中的字符，找 t 中的位置，然后找出那个字符呢，时间复杂度为 o(n)，可能不是最好的方法【尤其如果s本身含有重复字母，那么t中肯定也有重复字母了】还好s最长只是1000，那么肯定会有重复的，这样确实不是太好难道说要统计s中每个字母的数量，然后去对比吗？普通的list并没有找出全部索引的功能吧\n\n### 官方题解\n\n（1）计数，还真的可以对字符串中出现的字母进行计数，然后比较（这里使用的方法是在t中进行递减计数，当数字为负，那就找到了数字）\n\n（2）位运算【这个思路比较好】\n\n把两个字符串合二为一，肯定有一个字母出现次数不是偶数，就是ta\n\n> 类似 136题，这个题我做过了，但是说实话，这个异或我还是没有太明白\n>\n> 好像明白一点了，如果 一个字母是唯一的，那么任何字母和它异或，都不会改变它，而且由于其他的成双成对，最后一定都会相当于和自身异或一次，会最后剩下一个字母\n>\n> 这个方法的空间复杂度和时间复杂度都是一定的，而且没有优化的空间\n\n（3）求和\n\n这个方法用的是ASCII码的方法，ASCII码的和的差值就是多出来的那个字母的ASCII码\n\npython ASCII码 `ord('a')`\n\n从ASCII码反读字母呢：`chr(num)`\n\n## 1025. 除数博弈 - 动态规划，数学\n\n输入：int 数字 n，1到1000之间\n\n输出：布尔值\n\n功能：每一轮的要求如下，最后要求出来的是总轮数，如果为奇数那么返回True，如果为偶数返回False\n\n- 对于任意 ==x<n==，余数如果为0就是true\n\n- 然后 n=n-x，对于新的任意 y<新的n，余数为0就是true\n\n- 直到找不到使余数为0的除数 z<新的新的n\n\n\n\n题目中举了一个很有意思的例子：3\n\n- 第一位选择 1，那么余数是0【其实对于任意 n，总可以以1为除数，得到余数为0】，然后3-1=2\n- 第二位选择 1，余数还是0，然后 2-1=1\n- 然后不能再选1了，因为不满足 x<n(此时n=1了)\n\n\n\n也就是说每一轮，n在更新，除数的上限也在更新，除数也在更新，如果被除数变为1，那么游戏就结束了\n\n难点：\n\n- 找整除的数，1是万能的，除1以外-永远可以整除，但问题是也要防止给对方留下赢的空间\n  - 比如4\n    - 选2，剩下2，选1，输了\n    - 选1，剩下3，选1，剩下2，选1，赢了\n    - 那这样的话肯定第二种思路要比第一种要好\n- 也就是说要最优化 - 尽可能赢，除非必输\n\n本题居然是简单？\n\n假设当前剩余数字 n，最佳轮数\\路径是 f(n) 【这样不行】\n\n> 问题是本题是数字n越小越容易发现正确路径，数字越大反而越不容易\n>\n> 比如 n = 1，直接**输**，1步\n>\n> n = 2，直接**赢**，1步\n>\n> n = 3，一定会**输**，没得选，2步\n>\n> n = 4，可以**赢**，2步，3步（赢）\n>\n> n = 5，\n>\n> - 选1，为4\n> - 这下选择权在对方手里，一定**输**【每轮都是按照最优方法】2步（输），3步\n>\n> n = 6，\n>\n> - 选1，为5，1+1+2或3，最后一定输\n> - 选2，为4，2或3一定输\n> - 选3，为3，一定**赢**\n>\n> 【问题就在于这个关系是一个可以递推的关系吗？所以要怎么样才能实现动态规划？】\n>\n> 如果这一步过后，留给对手的总轮数可以是奇数，也可以是偶数，那么对手一定会选择偶数，那么我方一定会选择奇数，永远在博弈\n\n其实已经渐渐发现规律了！\n\n### 题解\n\n非官方：https://leetcode-cn.com/problems/divisor-game/solution/qi-shi-shi-yi-dao-shu-xue-ti-by-coder233/\n\n刚才比较的对剩下数字来说，轮数的奇偶比较\n\n换一个思路：\n\n1. 什么时候能判断最终结果？N = 2时。那么就是看到谁手里为2。\n2. 剩下的数字是奇数还是偶数？\n\n核心思想：==奇数的约数一定是奇数，偶数的约束可奇可偶==\n\n如果开局奇数：第一次不管选什么，对方手里都是偶数\n\n如果开局偶数：只要一直选1，那么对方手里一定是奇数（2一定不在对方手里），这样就到了上面的情况【妙啊，太妙了！】\n\n所以，总结出来就是，开局奇数，必输，开局偶数，必赢\n\n所以，只要判断奇偶数就好了【炸】\n\n\n\n官方题解中还有一种思路是找让对方处于“必败态”的情况\n\n# 分治法\n\n## 50. Pow（x, n）- 基础，复杂度 - 分治\n\n输入：正负100以内的浮点数 x 和 32位带符号 int 数 n\n\n输出： x 的 n 次幂\n\n本题就是纯粹的数学问题的算法实现，关键是这个幂的范围异常大，所以如果真的一个一个乘，时间复杂度会爆炸，所以就是为了尽量压缩时间复杂度诞生的问题！\n\n首先计算不大于 n 的 $2^k$ 幂，k也就是循环的次数，这样能够尽量减少时间复杂度\n\n- k = 0，那么就是 x\n- k = 1， x * x\n- k = 2，x^2 * x^2\n- k = n，x^n * x^n\n\n然后对于剩下的 $n-2^k$ 次幂，就转化为求解 x 的 $n-2^k$ 次幂的问题，就可以迭代了\n\n细节：\n\n（1）x 化为正数，直接把 x 变成 正数，但是最后结果的正负还要看 n 是奇数还是偶数\n\n（2）指数为负时，直接把x的倒数求出来\n\n（3）特殊情况：\n\n- x 为0，直接为0\n- n 为0，直接为1\n- n 为1，直接为x\n\n以下是我成功的代码：\n\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if x == 0:\n            return 0\n        if x == 1 or n == 0:\n            return 1\n        if n < 0:\n            x, n = 1/x, abs(n)\n        weight = 1\n        if x < 0 and n % 2:\n            weight = -1\n            x = abs(x)\n        result = 1\n        res = n\n        while res:\n            this_k, this_pow_2 = self.max_2_pow(res)\n            this_x = x\n            print(this_k, this_pow_2)\n            while this_k:\n                this_x *= this_x\n                this_k -= 1\n            result *= this_x\n            res -= this_pow_2\n        return weight * result\n        \n    def max_2_pow(self, n: int) -> int:\n        # 求不大于 n 的 2 的 k 次幂\n        pow_2 = 1\n        k = 0\n        while n >= pow_2:\n            pow_2 *= 2\n            k += 1\n        return max(k-1, 0), max(1, pow_2 / 2)\n```\n\n其中，多次修改的部分是关于“不大于 n 的 2 的 k 次幂”的求解\n\n一般情况下，$2^k \\leq n < 2^{k+1}$，此时需要输出的是 k，但是因为满足 while 的循环条件，会多计算一层，所以最后的结果又要扒去一层，但是又要考虑 $ n = 1$ 的情况【这里n不可能为0，因为已经被其他的条件约束了】，所以又要防止把 k=0 和 n=1 又给削了\n\n> **还有一种找 $2^k$ 的方式，是观察余数，如果 $n \\% 2^k < 2^k$，那么自然是介于$2^k$ 和 $2^{k+1}$之间了** \n\n### 阅读题解\n\n官方题解说的分治思想确实很不错，从 n 开始，从后往前看，每次对指数向下取整，指数为偶数和奇数分两种结果，也很不错，而且优势在于这种方式可以递归！\n\n第二种方法绝了，如果不是对二进制非常熟悉，恐怕很难发现这种规律。\n\n## 53 同剑指offer42.连续子数组的最大和 - 动态规划、分治法\n\n输入：数组（全为整数，有正负，不会超过10000个数字，绝对值不会大于100）\n\n输出：最大子序列和\n\n要求：子序列如果包含2个及以上数字，必须连续；可以是原数组中的任何片段\n\n假设移动到数组中的第n个数字，此时满足条件的最大和是 f(n)，应该解释为：前n个数字中满足题干条件的最大序列和是f(n)\n\n> 我怎么知道现在是不是连续的？\n>\n> 假设有某个连续序列比较大，是当前最大，那么后续数组是加还是减，是从后往前进行计算吗？\n\n那么当新的 n+1 加入后，首先要看当前数 i 是正的还是负的\n\n- 如果是负的，只需要比较和 f(n) 的大小就好了，不可能让 f(n) 更大， f(n+1)=max(f(n), i)\n- 如果是正的，那么有可能让 f(n+1) 更大\n  - 一方面是比较 f(n) 和 f(n+1)\n  - 另一方面，从当前值 i 从后往前加各个数字，观察和能不能超过 f(n)\n    - 但是这样会导致复杂度比较高，大概是 $O(n^2)$ ==要求$O(n)$==\n    - 怎么样进行更加方便的判断呢？\n\n> 我印象中前面有一个很类似的问题\n>\n> 有一种方法是从中间断开然后进行两段计算的方法\n>\n> 没错，是很类似前面的“买卖股票的最佳时机问题”，不过不一样的地方是，要把中间的数字也加上，而不是只计算头尾\n>\n> 前面做过的两道题都没有很好地进行学习\n\n关键问题是一个数组是否吸收下一个数字不止取决于下一个数字，而是取决于下一个数字之后的一个连续序列是不是能够对当前序列进行增加。\n\n> 这里本来是剑指offer42，结果和53题相同\n\n！！！应该说53题当时没有好好学习\n\n==<u>这里注意 f(i) 的解释：表示以第 i 个数字结尾的连续子数组的最大和</u>==\n\n那么 $f(i+1) = max(f(i)+a_i, a_i)$ 就非常正确了，就不用再考虑从后往前加那么多了！\n\n这道题的第二种方法是分治，其实是本题的深化：求序列的 [l, r] 区间内的最大连续子段和\n\n# 贪心法\n\n## 376. 摆动序列 - 动态规划、贪心法\n\n输入：一个数组\n\n输出：最长子数组的长度\n\n要求：子数值后一项减前一项的差值必须是一正一反交替的；只有一个元素，或者只有两个元素的也算。\n\n怎么样检测差值是不是交替？可以用乘法，差值乘积小于0，那么就是了\n\n但是怎么样获得最长数组？\n\n个人觉得还是一个动态规划的问题，题解标题来看也有说是贪心法的，如果用动态规划来说，最大问题是不一定后面的元素和前面的元素存在关系\n\n思路：\n\n比方说**先计算一遍差值，形成一个新的数组**，然后选择正负交替，最后差值数量 + 1 就是最后的结果吗\n\n**连续的正数，或者连续的负数**都不会增加差值的数量，**只有出现改变**才增加一次\n\n如果用一个数组记录新数组，那么这个空间占用率会很高，最好是一个循环直接带走，也是需要两个量来进行交替取值\n\n- 新问题：如果差值为0，那么也是不能算的\n- 另外：如果出现一个差值为0， 那么不能继续乘以它了，这样后面就无效了\n\n<!--重要-->\n\n==重新整理思路：==\n\n- 第一个数，索引0，结果直接加1，不会比1小\n\n- 从第2个数（索引1）开始，如果其和前一个数的差值 * 索引1与索引0的差值 < 0 ，那么结果就要加1了\n\n- 如果差值为0，那么又不能使用这一个差值<!--【这是最大的问题】-->\n\n- 所以就是，计算差值\n\n  - 如果差值为0自然是不加不减\n    - ==而且不能改变前一个趋势值 s1==\n  - 如果前面差值为负数，当前为正，或者前面差值为正数，当前为负，则会加1\n\n  - 如果前面差值为0呢？\n    - 按照上面的说法，其实只有一种可能前面的趋势值 s1 为0，那就是从开头以来，s1就是0，而且还没有变过\n    - 一旦 s2不是0，一定会把 s1变化一次的\n\n<!--重要-->\n\n其实我的方法是**贪心法**的思路！！\n\n- 但是问题是我没有很好地==处理 0 的问题==，如果不能用乘法一劳永逸地解决，不妨直接==用不等号进行尝试==！\n- 而且，也不要最后再加1，这样针对【0，0】这样的数组就会多加一次，应该在最开始就加到位，后面就是不停地补充就好了\n\n### 阅读题解\n\n[摆动序列官方题解](https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/)\n\n峰谷思想：\n\n- 两侧均小为峰，两侧均大为谷，非峰非谷为过渡\n- 两端元素只有一侧，小为谷，大为峰\n- 最后一个元素上升趋势，则为上升摆动序列，下降趋势则为下降摆动序列\n\n> 状态表达式\n>\n> 状态转移规则（方程）\n>\n> 初始条件\n\n**动态规划思路：**\n\n**状态表达**\n\n- 以当前元素结尾的序列中，最长上升摆动序列为 up[i]，最长下降摆动序列为 down[i]\n\n**状态转移规则**\n\n- 针对 up[i]\n  - 当前元素小于上一个元素（包括等于），那么最长上升摆动序列不变\n  - 当前元素大于上一个元素，那么既可以从 up[i-1]转移，也可以从 down[i-1]转移\n- 针对 down[i]\n  - 当前元素大于上一个元素（包括等于），那么最长下降摆动序列不变\n  - 当前元素小于上一个元素，那么可以从 up[i-1]转移，也可以从 down[i-1]转移\n\n<img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201212135251108.png\" alt=\"image-20201212135251108\" style=\"zoom: 67%;\" />\n\n最后的答案也是从 up[n-1] 和 down[i-1]中选择比较大的那个\n\n## 135. 分发糖果 - 贪心法\n\n这道题有一点像华为今年的题\n\n输入：一个整数序列\n\n输出：重建序列和\n\n要求：对输入序列，对比相邻元素\n\n- 如果元素比较大，重建序列中该值位置的数字应当+1\n- 元素相等，不用+1，直接给1\n\n当前元素有几颗糖完全取决于前面一个的糖？\n\n- [0, 2, 1]，第三个数字介于前两个数字之间，如果0给1，2给2，那么1给1，完全没问题\n- [2, 2, 1]，2给1，2给1，但是后一个是1，至少给1，所以第2个2不能为1\n\n我的想法：\n\n到第 i 个数字，首先给 1\n\n从前往后的序列是相对比较容易的，直接对比，然后加就可以了\n\n从后往前的序列是比较难的，需要对前面的序列一个一个对比大小和调整，直到遇到比较小的数字\n\n如果一个序列就按照从大到小降序排列呢？那就要处理很多，复杂度就高了，这样显然不是太好\n\n### 官方题解\n\n其实刚才的想法中暗含了本问题的额正确解决思路：==就是需要反过来进行计算==，其实两个递减序列肯定是互不相关的，那么直接反过来再计算一遍不就好了？\n\n总体想法：正着一遍，反着一遍\n\n注意一个问题：\n\n- 正着一遍，我们需要得到新的序列\n- 反着一遍，其实序列本身并不是我们需要的，数字的和才是我们需要的\n\n`range(n-1, -1, -1)`，从 n-1 一直到 0\n\n官方题解中的 `ret += max(left[i], right)` 一句点明了两点：\n\n（1）每一次循环其实决定的是新序列右侧值\n\n（2）反向序列满足规律时才会修改，如果不满足规律那么right会是1，也就不怎么改变了\n\n总结：贪心法，两遍扫描，已有相关题解\n\n# 其他\n\n## 118. 杨辉三角 - 基础\n\n输入：非负整数 n\n\n输出：杨辉三角的前 n 行\n\n理论上可以硬解\n\n特点：\n\n- 每一行首尾都是1，其他数字i是上一行第i个和第i-1个数字的加和\n- 第 i 行 i 个数字\n\n按我自己的方法，主要是会有三种特殊情况：\n\n（1）n=0，那么返回是空\n\n（2）n=1，那么返回是[[1]]\n\n（3）n=2，那么返回是[[1],[1,1]]\n\n只有从n=3开始，才建立起递推关系\n\n---\n\nOK！本期10题就先到这里了，应该说在这段期间对代码的理解有了提高，但是对知识的巩固一如既往地糟糕，需要经常复习。\n\n期待下一个10题快点到来！","source":"_posts/LeetCode刷题笔记三.md","raw":"---\ntitle: LeetCode刷题笔记（三）\ndate: 2020-12-29 20:46:39\ncategories:\n\t- 算法\ntags:\n\t- LeetCode\n\t- 动态规划\n\t- 贪心法\n\t- 分治法\n---\n\n每期10题，上一期参见[LeetCode刷题笔记（二）](https://sunyoe.github.io/2020/12/06/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/)。\n\n本期内容多以动态规划为主。\n\n# 动态规划\n\n## 392. 判断子序列 - 动态规划\n\n输入：长序列 t，短序列 s\n\n判断：s 是不是 t 的子序列\n\n条件：\n\n- 从原始序列到子序列，可以删除部分字符，可以不连续，但是**相对位置**不能变\n- 两个序列全是英文小写字母\n\n<!--more-->\n\n传统方法：\n\n- 如果可以不改变顺序地去重，那么就可以直接取筛选了\n\n**怎么样使用动态规划呢？**\n\n到了 t 的第 n 个字符，已经发现了 s 的字符数为 f(n)\n\n那么\n\n- 如果这一个（t_n）不是s中的下一个（s_(f(n-1)+1)），那么f(n) = f(n-1)\n- 如果是，那么f(n) = f(n-1) + 1\n\n推导至 t 的结尾，或者到了s 的结尾，就要停止了\n\n如果s到了结尾，那就说明是子序列\n\n特殊情况：\n\n（1）短字符为空\n\n~~（2）长字符和短字符一样长【如果不相等可以直接判断为False了】，那相等直接判定为True【其实这个也不必了】~~\n\n这个问题最容易出错的地方是list的索引问题，上代码：\n\n```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        yes_num = 0\n        if not len(s):\n            return True\n        # if len(s) == len(t):\n        #     return False if s != t else True\n        for i in range(len(t)):\n            if t[i] == s[yes_num]:\n                yes_num += 1\n            if yes_num == len(s):\n                return True\n        return True if yes_num == len(s) else False\n```\n\nyes_sum 直接代表了 s 中的下一个位置【因为list从0开始】，也表示了 s 已经匹配的字符数量\n\n**所以最后对比yes_num和s的长度就不用长度减一了！！**\n\n所以长字符和短字符一样长的情况也就不再是特殊情况了\n\n最后，最简化版本，特殊情况不特殊，最后判断也多余：\n\n```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        yes_num = 0\n        if not len(s):\n            return True\n        for i in range(len(t)):\n            if t[i] == s[yes_num]:\n                yes_num += 1\n            if yes_num == len(s):\n                return True\n        return False\n```\n\n## 746. 使用最小花费爬楼梯 - 动态规划\n\n本题确实是一个动态规划方面的问题，但是我得说这个问题的描述有点迷糊\n\n输入：一个列表，全是数值，长度至少是2\n\n输出：最小子序列的和\n\n要求：\n\n- 该子序列可以连续，也可以间隔1个；\n- 该子序列可以不包含第1个元素（索引为0）；\n- 该子序列可以不包含最后一个元素（索引为 n-1）；\n\n假设到第 n 个数值，最小和为 f(n)\n\n有三种可能：怎么样去选择？\n\n- $f(n) = f(n-1)$（可以从第2个数，也就是索引为1开始）【跳当前数值】\n  - 问题：**【那这个肯定比第二种要小，怎么说？】**\n\n- $f(n) = f(n-1) + i$（可以从第2个数，也就是索引为1开始）【连续】\n  - 如果此时 n 是最后一个，那么 i 是不能加的**【但问题是我不知道 n 到底是不是最后一个】**\n\n- $f(n) = f(n-2) + i$（可以从第3个数，也就是索引为2开始）【跳前一个数值】\n  - 如果此时 n 是最后一个，那么 i 是必须加的\n\n初始条件：\n\n- $f(1) = i_0$\n- $f(2)=min(f(1), i_1)$【如果能跳过2个，那么一定会跳过，否则和一定会变大】\n\n终止条件：\n\n- $n$ 到了结尾\n\n现在思路开始混乱了：\n\n在第 n 个数值，有几种情况？选择当前，不选择当前，不管选不选当前，都有可能选前一个数值\n\n- 一般情况下，我肯定不会连续选择数值，除非旁边的数值更大，或者没得选\n\n### 阅读题解\n\n**递归关系**似乎是 $f(n) = i + min(f(n-1), f(n-2))$\n\n最后一步，为了防止最后一步需要判断取舍，可以直接在最后选择 f(n) 和 f(n-1) 中比较小的，那就实现了最优\n\n还有一点就是，这样的话，初始化就和上面略有不同了：\n\n- f(1) = i_0\n- f(2) = i_1\n\n因为最后已经增加了判断最后一个数值取舍的步骤，这里的 f(2) 就没有必要多一次判断了\n\n```python\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        sum_cost = []\n        sum_cost.append(cost[0])\n        sum_cost.append(cost[1])\n        if len(cost) == 2:\n            return sum_cost[-1]\n        for i in range(2, len(cost)):\n            sum_cost.append(cost[i] + min(sum_cost[-1], sum_cost[-2]))\n        return min(sum_cost[-1], sum_cost[-2])\n```\n\n## 面试题 17.16 按摩师 - 动态规划\n\n输入：一个序列\n\n输出：子序列的和，最大和\n\n要求：子序列元素不能相邻\n\n本题就是比较典型的动态规划\n\n状态表达式：$f(n)$ 表示到第 n 个数的最大和\n\n状态转移方程及条件：\n\n（1）$f(n) = f(n-1)$，什么条件？\n\n（2）$f(n) = f(n-2) + i$\n\n那本题岂不是和198题相同？？\n\n> 在746题中，因为可以连续，或者只能间隔一个，所以是先比较最大值（最小值），然后再加当前值\n>\n> 但是本题不能连续，不能先比较最大值\n\n本题有个问题，一定会选择当前数值吗？不一定\n\n和198题还真是一样的，就考虑三个特殊情况：\n\n列表长度为0，1，2，分别是0，sum(list)，max(list)，有没有什么方法可以一句话搞定的？\n\n## 389. 找不同 - 运算，ASCII和异或\n\n输入：两个字符串 s 和 t\n\n输出：t 中 s 没有的字符\n\n要求：t 由 s 随机重排并添加了一个字母\n\n**本题居然是简单？**\n\n观察示例发现：\n\n添加的字母有可能是s 中已有字母重复的，那么这样的话使用 set 元组做去重就是不太好的方法了\n\n如果遍历 s 中的字符，找 t 中的位置，然后找出那个字符呢，时间复杂度为 o(n)，可能不是最好的方法【尤其如果s本身含有重复字母，那么t中肯定也有重复字母了】还好s最长只是1000，那么肯定会有重复的，这样确实不是太好难道说要统计s中每个字母的数量，然后去对比吗？普通的list并没有找出全部索引的功能吧\n\n### 官方题解\n\n（1）计数，还真的可以对字符串中出现的字母进行计数，然后比较（这里使用的方法是在t中进行递减计数，当数字为负，那就找到了数字）\n\n（2）位运算【这个思路比较好】\n\n把两个字符串合二为一，肯定有一个字母出现次数不是偶数，就是ta\n\n> 类似 136题，这个题我做过了，但是说实话，这个异或我还是没有太明白\n>\n> 好像明白一点了，如果 一个字母是唯一的，那么任何字母和它异或，都不会改变它，而且由于其他的成双成对，最后一定都会相当于和自身异或一次，会最后剩下一个字母\n>\n> 这个方法的空间复杂度和时间复杂度都是一定的，而且没有优化的空间\n\n（3）求和\n\n这个方法用的是ASCII码的方法，ASCII码的和的差值就是多出来的那个字母的ASCII码\n\npython ASCII码 `ord('a')`\n\n从ASCII码反读字母呢：`chr(num)`\n\n## 1025. 除数博弈 - 动态规划，数学\n\n输入：int 数字 n，1到1000之间\n\n输出：布尔值\n\n功能：每一轮的要求如下，最后要求出来的是总轮数，如果为奇数那么返回True，如果为偶数返回False\n\n- 对于任意 ==x<n==，余数如果为0就是true\n\n- 然后 n=n-x，对于新的任意 y<新的n，余数为0就是true\n\n- 直到找不到使余数为0的除数 z<新的新的n\n\n\n\n题目中举了一个很有意思的例子：3\n\n- 第一位选择 1，那么余数是0【其实对于任意 n，总可以以1为除数，得到余数为0】，然后3-1=2\n- 第二位选择 1，余数还是0，然后 2-1=1\n- 然后不能再选1了，因为不满足 x<n(此时n=1了)\n\n\n\n也就是说每一轮，n在更新，除数的上限也在更新，除数也在更新，如果被除数变为1，那么游戏就结束了\n\n难点：\n\n- 找整除的数，1是万能的，除1以外-永远可以整除，但问题是也要防止给对方留下赢的空间\n  - 比如4\n    - 选2，剩下2，选1，输了\n    - 选1，剩下3，选1，剩下2，选1，赢了\n    - 那这样的话肯定第二种思路要比第一种要好\n- 也就是说要最优化 - 尽可能赢，除非必输\n\n本题居然是简单？\n\n假设当前剩余数字 n，最佳轮数\\路径是 f(n) 【这样不行】\n\n> 问题是本题是数字n越小越容易发现正确路径，数字越大反而越不容易\n>\n> 比如 n = 1，直接**输**，1步\n>\n> n = 2，直接**赢**，1步\n>\n> n = 3，一定会**输**，没得选，2步\n>\n> n = 4，可以**赢**，2步，3步（赢）\n>\n> n = 5，\n>\n> - 选1，为4\n> - 这下选择权在对方手里，一定**输**【每轮都是按照最优方法】2步（输），3步\n>\n> n = 6，\n>\n> - 选1，为5，1+1+2或3，最后一定输\n> - 选2，为4，2或3一定输\n> - 选3，为3，一定**赢**\n>\n> 【问题就在于这个关系是一个可以递推的关系吗？所以要怎么样才能实现动态规划？】\n>\n> 如果这一步过后，留给对手的总轮数可以是奇数，也可以是偶数，那么对手一定会选择偶数，那么我方一定会选择奇数，永远在博弈\n\n其实已经渐渐发现规律了！\n\n### 题解\n\n非官方：https://leetcode-cn.com/problems/divisor-game/solution/qi-shi-shi-yi-dao-shu-xue-ti-by-coder233/\n\n刚才比较的对剩下数字来说，轮数的奇偶比较\n\n换一个思路：\n\n1. 什么时候能判断最终结果？N = 2时。那么就是看到谁手里为2。\n2. 剩下的数字是奇数还是偶数？\n\n核心思想：==奇数的约数一定是奇数，偶数的约束可奇可偶==\n\n如果开局奇数：第一次不管选什么，对方手里都是偶数\n\n如果开局偶数：只要一直选1，那么对方手里一定是奇数（2一定不在对方手里），这样就到了上面的情况【妙啊，太妙了！】\n\n所以，总结出来就是，开局奇数，必输，开局偶数，必赢\n\n所以，只要判断奇偶数就好了【炸】\n\n\n\n官方题解中还有一种思路是找让对方处于“必败态”的情况\n\n# 分治法\n\n## 50. Pow（x, n）- 基础，复杂度 - 分治\n\n输入：正负100以内的浮点数 x 和 32位带符号 int 数 n\n\n输出： x 的 n 次幂\n\n本题就是纯粹的数学问题的算法实现，关键是这个幂的范围异常大，所以如果真的一个一个乘，时间复杂度会爆炸，所以就是为了尽量压缩时间复杂度诞生的问题！\n\n首先计算不大于 n 的 $2^k$ 幂，k也就是循环的次数，这样能够尽量减少时间复杂度\n\n- k = 0，那么就是 x\n- k = 1， x * x\n- k = 2，x^2 * x^2\n- k = n，x^n * x^n\n\n然后对于剩下的 $n-2^k$ 次幂，就转化为求解 x 的 $n-2^k$ 次幂的问题，就可以迭代了\n\n细节：\n\n（1）x 化为正数，直接把 x 变成 正数，但是最后结果的正负还要看 n 是奇数还是偶数\n\n（2）指数为负时，直接把x的倒数求出来\n\n（3）特殊情况：\n\n- x 为0，直接为0\n- n 为0，直接为1\n- n 为1，直接为x\n\n以下是我成功的代码：\n\n```python\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if x == 0:\n            return 0\n        if x == 1 or n == 0:\n            return 1\n        if n < 0:\n            x, n = 1/x, abs(n)\n        weight = 1\n        if x < 0 and n % 2:\n            weight = -1\n            x = abs(x)\n        result = 1\n        res = n\n        while res:\n            this_k, this_pow_2 = self.max_2_pow(res)\n            this_x = x\n            print(this_k, this_pow_2)\n            while this_k:\n                this_x *= this_x\n                this_k -= 1\n            result *= this_x\n            res -= this_pow_2\n        return weight * result\n        \n    def max_2_pow(self, n: int) -> int:\n        # 求不大于 n 的 2 的 k 次幂\n        pow_2 = 1\n        k = 0\n        while n >= pow_2:\n            pow_2 *= 2\n            k += 1\n        return max(k-1, 0), max(1, pow_2 / 2)\n```\n\n其中，多次修改的部分是关于“不大于 n 的 2 的 k 次幂”的求解\n\n一般情况下，$2^k \\leq n < 2^{k+1}$，此时需要输出的是 k，但是因为满足 while 的循环条件，会多计算一层，所以最后的结果又要扒去一层，但是又要考虑 $ n = 1$ 的情况【这里n不可能为0，因为已经被其他的条件约束了】，所以又要防止把 k=0 和 n=1 又给削了\n\n> **还有一种找 $2^k$ 的方式，是观察余数，如果 $n \\% 2^k < 2^k$，那么自然是介于$2^k$ 和 $2^{k+1}$之间了** \n\n### 阅读题解\n\n官方题解说的分治思想确实很不错，从 n 开始，从后往前看，每次对指数向下取整，指数为偶数和奇数分两种结果，也很不错，而且优势在于这种方式可以递归！\n\n第二种方法绝了，如果不是对二进制非常熟悉，恐怕很难发现这种规律。\n\n## 53 同剑指offer42.连续子数组的最大和 - 动态规划、分治法\n\n输入：数组（全为整数，有正负，不会超过10000个数字，绝对值不会大于100）\n\n输出：最大子序列和\n\n要求：子序列如果包含2个及以上数字，必须连续；可以是原数组中的任何片段\n\n假设移动到数组中的第n个数字，此时满足条件的最大和是 f(n)，应该解释为：前n个数字中满足题干条件的最大序列和是f(n)\n\n> 我怎么知道现在是不是连续的？\n>\n> 假设有某个连续序列比较大，是当前最大，那么后续数组是加还是减，是从后往前进行计算吗？\n\n那么当新的 n+1 加入后，首先要看当前数 i 是正的还是负的\n\n- 如果是负的，只需要比较和 f(n) 的大小就好了，不可能让 f(n) 更大， f(n+1)=max(f(n), i)\n- 如果是正的，那么有可能让 f(n+1) 更大\n  - 一方面是比较 f(n) 和 f(n+1)\n  - 另一方面，从当前值 i 从后往前加各个数字，观察和能不能超过 f(n)\n    - 但是这样会导致复杂度比较高，大概是 $O(n^2)$ ==要求$O(n)$==\n    - 怎么样进行更加方便的判断呢？\n\n> 我印象中前面有一个很类似的问题\n>\n> 有一种方法是从中间断开然后进行两段计算的方法\n>\n> 没错，是很类似前面的“买卖股票的最佳时机问题”，不过不一样的地方是，要把中间的数字也加上，而不是只计算头尾\n>\n> 前面做过的两道题都没有很好地进行学习\n\n关键问题是一个数组是否吸收下一个数字不止取决于下一个数字，而是取决于下一个数字之后的一个连续序列是不是能够对当前序列进行增加。\n\n> 这里本来是剑指offer42，结果和53题相同\n\n！！！应该说53题当时没有好好学习\n\n==<u>这里注意 f(i) 的解释：表示以第 i 个数字结尾的连续子数组的最大和</u>==\n\n那么 $f(i+1) = max(f(i)+a_i, a_i)$ 就非常正确了，就不用再考虑从后往前加那么多了！\n\n这道题的第二种方法是分治，其实是本题的深化：求序列的 [l, r] 区间内的最大连续子段和\n\n# 贪心法\n\n## 376. 摆动序列 - 动态规划、贪心法\n\n输入：一个数组\n\n输出：最长子数组的长度\n\n要求：子数值后一项减前一项的差值必须是一正一反交替的；只有一个元素，或者只有两个元素的也算。\n\n怎么样检测差值是不是交替？可以用乘法，差值乘积小于0，那么就是了\n\n但是怎么样获得最长数组？\n\n个人觉得还是一个动态规划的问题，题解标题来看也有说是贪心法的，如果用动态规划来说，最大问题是不一定后面的元素和前面的元素存在关系\n\n思路：\n\n比方说**先计算一遍差值，形成一个新的数组**，然后选择正负交替，最后差值数量 + 1 就是最后的结果吗\n\n**连续的正数，或者连续的负数**都不会增加差值的数量，**只有出现改变**才增加一次\n\n如果用一个数组记录新数组，那么这个空间占用率会很高，最好是一个循环直接带走，也是需要两个量来进行交替取值\n\n- 新问题：如果差值为0，那么也是不能算的\n- 另外：如果出现一个差值为0， 那么不能继续乘以它了，这样后面就无效了\n\n<!--重要-->\n\n==重新整理思路：==\n\n- 第一个数，索引0，结果直接加1，不会比1小\n\n- 从第2个数（索引1）开始，如果其和前一个数的差值 * 索引1与索引0的差值 < 0 ，那么结果就要加1了\n\n- 如果差值为0，那么又不能使用这一个差值<!--【这是最大的问题】-->\n\n- 所以就是，计算差值\n\n  - 如果差值为0自然是不加不减\n    - ==而且不能改变前一个趋势值 s1==\n  - 如果前面差值为负数，当前为正，或者前面差值为正数，当前为负，则会加1\n\n  - 如果前面差值为0呢？\n    - 按照上面的说法，其实只有一种可能前面的趋势值 s1 为0，那就是从开头以来，s1就是0，而且还没有变过\n    - 一旦 s2不是0，一定会把 s1变化一次的\n\n<!--重要-->\n\n其实我的方法是**贪心法**的思路！！\n\n- 但是问题是我没有很好地==处理 0 的问题==，如果不能用乘法一劳永逸地解决，不妨直接==用不等号进行尝试==！\n- 而且，也不要最后再加1，这样针对【0，0】这样的数组就会多加一次，应该在最开始就加到位，后面就是不停地补充就好了\n\n### 阅读题解\n\n[摆动序列官方题解](https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/)\n\n峰谷思想：\n\n- 两侧均小为峰，两侧均大为谷，非峰非谷为过渡\n- 两端元素只有一侧，小为谷，大为峰\n- 最后一个元素上升趋势，则为上升摆动序列，下降趋势则为下降摆动序列\n\n> 状态表达式\n>\n> 状态转移规则（方程）\n>\n> 初始条件\n\n**动态规划思路：**\n\n**状态表达**\n\n- 以当前元素结尾的序列中，最长上升摆动序列为 up[i]，最长下降摆动序列为 down[i]\n\n**状态转移规则**\n\n- 针对 up[i]\n  - 当前元素小于上一个元素（包括等于），那么最长上升摆动序列不变\n  - 当前元素大于上一个元素，那么既可以从 up[i-1]转移，也可以从 down[i-1]转移\n- 针对 down[i]\n  - 当前元素大于上一个元素（包括等于），那么最长下降摆动序列不变\n  - 当前元素小于上一个元素，那么可以从 up[i-1]转移，也可以从 down[i-1]转移\n\n<img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201212135251108.png\" alt=\"image-20201212135251108\" style=\"zoom: 67%;\" />\n\n最后的答案也是从 up[n-1] 和 down[i-1]中选择比较大的那个\n\n## 135. 分发糖果 - 贪心法\n\n这道题有一点像华为今年的题\n\n输入：一个整数序列\n\n输出：重建序列和\n\n要求：对输入序列，对比相邻元素\n\n- 如果元素比较大，重建序列中该值位置的数字应当+1\n- 元素相等，不用+1，直接给1\n\n当前元素有几颗糖完全取决于前面一个的糖？\n\n- [0, 2, 1]，第三个数字介于前两个数字之间，如果0给1，2给2，那么1给1，完全没问题\n- [2, 2, 1]，2给1，2给1，但是后一个是1，至少给1，所以第2个2不能为1\n\n我的想法：\n\n到第 i 个数字，首先给 1\n\n从前往后的序列是相对比较容易的，直接对比，然后加就可以了\n\n从后往前的序列是比较难的，需要对前面的序列一个一个对比大小和调整，直到遇到比较小的数字\n\n如果一个序列就按照从大到小降序排列呢？那就要处理很多，复杂度就高了，这样显然不是太好\n\n### 官方题解\n\n其实刚才的想法中暗含了本问题的额正确解决思路：==就是需要反过来进行计算==，其实两个递减序列肯定是互不相关的，那么直接反过来再计算一遍不就好了？\n\n总体想法：正着一遍，反着一遍\n\n注意一个问题：\n\n- 正着一遍，我们需要得到新的序列\n- 反着一遍，其实序列本身并不是我们需要的，数字的和才是我们需要的\n\n`range(n-1, -1, -1)`，从 n-1 一直到 0\n\n官方题解中的 `ret += max(left[i], right)` 一句点明了两点：\n\n（1）每一次循环其实决定的是新序列右侧值\n\n（2）反向序列满足规律时才会修改，如果不满足规律那么right会是1，也就不怎么改变了\n\n总结：贪心法，两遍扫描，已有相关题解\n\n# 其他\n\n## 118. 杨辉三角 - 基础\n\n输入：非负整数 n\n\n输出：杨辉三角的前 n 行\n\n理论上可以硬解\n\n特点：\n\n- 每一行首尾都是1，其他数字i是上一行第i个和第i-1个数字的加和\n- 第 i 行 i 个数字\n\n按我自己的方法，主要是会有三种特殊情况：\n\n（1）n=0，那么返回是空\n\n（2）n=1，那么返回是[[1]]\n\n（3）n=2，那么返回是[[1],[1,1]]\n\n只有从n=3开始，才建立起递推关系\n\n---\n\nOK！本期10题就先到这里了，应该说在这段期间对代码的理解有了提高，但是对知识的巩固一如既往地糟糕，需要经常复习。\n\n期待下一个10题快点到来！","slug":"LeetCode刷题笔记三","published":1,"updated":"2021-01-26T06:17:21.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n89h0044k8tl7q8c13su","content":"<p>每期10题，上一期参见<a href=\"https://sunyoe.github.io/2020/12/06/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/\" target=\"_blank\" rel=\"noopener\">LeetCode刷题笔记（二）</a>。</p>\n<p>本期内容多以动态规划为主。</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"392-判断子序列-动态规划\"><a href=\"#392-判断子序列-动态规划\" class=\"headerlink\" title=\"392. 判断子序列 - 动态规划\"></a>392. 判断子序列 - 动态规划</h2><p>输入：长序列 t，短序列 s</p>\n<p>判断：s 是不是 t 的子序列</p>\n<p>条件：</p>\n<ul>\n<li>从原始序列到子序列，可以删除部分字符，可以不连续，但是<strong>相对位置</strong>不能变</li>\n<li>两个序列全是英文小写字母</li>\n</ul>\n<a id=\"more\"></a>\n<p>传统方法：</p>\n<ul>\n<li>如果可以不改变顺序地去重，那么就可以直接取筛选了</li>\n</ul>\n<p><strong>怎么样使用动态规划呢？</strong></p>\n<p>到了 t 的第 n 个字符，已经发现了 s 的字符数为 f(n)</p>\n<p>那么</p>\n<ul>\n<li>如果这一个（t_n）不是s中的下一个（s_(f(n-1)+1)），那么f(n) = f(n-1)</li>\n<li>如果是，那么f(n) = f(n-1) + 1</li>\n</ul>\n<p>推导至 t 的结尾，或者到了s 的结尾，就要停止了</p>\n<p>如果s到了结尾，那就说明是子序列</p>\n<p>特殊情况：</p>\n<p>（1）短字符为空</p>\n<p><del>（2）长字符和短字符一样长【如果不相等可以直接判断为False了】，那相等直接判定为True【其实这个也不必了】</del></p>\n<p>这个问题最容易出错的地方是list的索引问题，上代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubsequence</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        yes_num = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len(s):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"comment\"># if len(s) == len(t):</span></span><br><span class=\"line\">        <span class=\"comment\">#     return False if s != t else True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(t)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> t[i] == s[yes_num]:</span><br><span class=\"line\">                yes_num += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> yes_num == len(s):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span> <span class=\"keyword\">if</span> yes_num == len(s) <span class=\"keyword\">else</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>yes_sum 直接代表了 s 中的下一个位置【因为list从0开始】，也表示了 s 已经匹配的字符数量</p>\n<p><strong>所以最后对比yes_num和s的长度就不用长度减一了！！</strong></p>\n<p>所以长字符和短字符一样长的情况也就不再是特殊情况了</p>\n<p>最后，最简化版本，特殊情况不特殊，最后判断也多余：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubsequence</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        yes_num = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len(s):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(t)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> t[i] == s[yes_num]:</span><br><span class=\"line\">                yes_num += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> yes_num == len(s):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"746-使用最小花费爬楼梯-动态规划\"><a href=\"#746-使用最小花费爬楼梯-动态规划\" class=\"headerlink\" title=\"746. 使用最小花费爬楼梯 - 动态规划\"></a>746. 使用最小花费爬楼梯 - 动态规划</h2><p>本题确实是一个动态规划方面的问题，但是我得说这个问题的描述有点迷糊</p>\n<p>输入：一个列表，全是数值，长度至少是2</p>\n<p>输出：最小子序列的和</p>\n<p>要求：</p>\n<ul>\n<li>该子序列可以连续，也可以间隔1个；</li>\n<li>该子序列可以不包含第1个元素（索引为0）；</li>\n<li>该子序列可以不包含最后一个元素（索引为 n-1）；</li>\n</ul>\n<p>假设到第 n 个数值，最小和为 f(n)</p>\n<p>有三种可能：怎么样去选择？</p>\n<ul>\n<li><p>$f(n) = f(n-1)$（可以从第2个数，也就是索引为1开始）【跳当前数值】</p>\n<ul>\n<li>问题：<strong>【那这个肯定比第二种要小，怎么说？】</strong></li>\n</ul>\n</li>\n<li><p>$f(n) = f(n-1) + i$（可以从第2个数，也就是索引为1开始）【连续】</p>\n<ul>\n<li>如果此时 n 是最后一个，那么 i 是不能加的<strong>【但问题是我不知道 n 到底是不是最后一个】</strong></li>\n</ul>\n</li>\n<li><p>$f(n) = f(n-2) + i$（可以从第3个数，也就是索引为2开始）【跳前一个数值】</p>\n<ul>\n<li>如果此时 n 是最后一个，那么 i 是必须加的</li>\n</ul>\n</li>\n</ul>\n<p>初始条件：</p>\n<ul>\n<li>$f(1) = i_0$</li>\n<li>$f(2)=min(f(1), i_1)$【如果能跳过2个，那么一定会跳过，否则和一定会变大】</li>\n</ul>\n<p>终止条件：</p>\n<ul>\n<li>$n$ 到了结尾</li>\n</ul>\n<p>现在思路开始混乱了：</p>\n<p>在第 n 个数值，有几种情况？选择当前，不选择当前，不管选不选当前，都有可能选前一个数值</p>\n<ul>\n<li>一般情况下，我肯定不会连续选择数值，除非旁边的数值更大，或者没得选</li>\n</ul>\n<h3 id=\"阅读题解\"><a href=\"#阅读题解\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p><strong>递归关系</strong>似乎是 $f(n) = i + min(f(n-1), f(n-2))$</p>\n<p>最后一步，为了防止最后一步需要判断取舍，可以直接在最后选择 f(n) 和 f(n-1) 中比较小的，那就实现了最优</p>\n<p>还有一点就是，这样的话，初始化就和上面略有不同了：</p>\n<ul>\n<li>f(1) = i_0</li>\n<li>f(2) = i_1</li>\n</ul>\n<p>因为最后已经增加了判断最后一个数值取舍的步骤，这里的 f(2) 就没有必要多一次判断了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        sum_cost = []</span><br><span class=\"line\">        sum_cost.append(cost[<span class=\"number\">0</span>])</span><br><span class=\"line\">        sum_cost.append(cost[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(cost) == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum_cost[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, len(cost)):</span><br><span class=\"line\">            sum_cost.append(cost[i] + min(sum_cost[<span class=\"number\">-1</span>], sum_cost[<span class=\"number\">-2</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(sum_cost[<span class=\"number\">-1</span>], sum_cost[<span class=\"number\">-2</span>])</span><br></pre></td></tr></table></figure>\n<h2 id=\"面试题-17-16-按摩师-动态规划\"><a href=\"#面试题-17-16-按摩师-动态规划\" class=\"headerlink\" title=\"面试题 17.16 按摩师 - 动态规划\"></a>面试题 17.16 按摩师 - 动态规划</h2><p>输入：一个序列</p>\n<p>输出：子序列的和，最大和</p>\n<p>要求：子序列元素不能相邻</p>\n<p>本题就是比较典型的动态规划</p>\n<p>状态表达式：$f(n)$ 表示到第 n 个数的最大和</p>\n<p>状态转移方程及条件：</p>\n<p>（1）$f(n) = f(n-1)$，什么条件？</p>\n<p>（2）$f(n) = f(n-2) + i$</p>\n<p>那本题岂不是和198题相同？？</p>\n<blockquote>\n<p>在746题中，因为可以连续，或者只能间隔一个，所以是先比较最大值（最小值），然后再加当前值</p>\n<p>但是本题不能连续，不能先比较最大值</p>\n</blockquote>\n<p>本题有个问题，一定会选择当前数值吗？不一定</p>\n<p>和198题还真是一样的，就考虑三个特殊情况：</p>\n<p>列表长度为0，1，2，分别是0，sum(list)，max(list)，有没有什么方法可以一句话搞定的？</p>\n<h2 id=\"389-找不同-运算，ASCII和异或\"><a href=\"#389-找不同-运算，ASCII和异或\" class=\"headerlink\" title=\"389. 找不同 - 运算，ASCII和异或\"></a>389. 找不同 - 运算，ASCII和异或</h2><p>输入：两个字符串 s 和 t</p>\n<p>输出：t 中 s 没有的字符</p>\n<p>要求：t 由 s 随机重排并添加了一个字母</p>\n<p><strong>本题居然是简单？</strong></p>\n<p>观察示例发现：</p>\n<p>添加的字母有可能是s 中已有字母重复的，那么这样的话使用 set 元组做去重就是不太好的方法了</p>\n<p>如果遍历 s 中的字符，找 t 中的位置，然后找出那个字符呢，时间复杂度为 o(n)，可能不是最好的方法【尤其如果s本身含有重复字母，那么t中肯定也有重复字母了】还好s最长只是1000，那么肯定会有重复的，这样确实不是太好难道说要统计s中每个字母的数量，然后去对比吗？普通的list并没有找出全部索引的功能吧</p>\n<h3 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>（1）计数，还真的可以对字符串中出现的字母进行计数，然后比较（这里使用的方法是在t中进行递减计数，当数字为负，那就找到了数字）</p>\n<p>（2）位运算【这个思路比较好】</p>\n<p>把两个字符串合二为一，肯定有一个字母出现次数不是偶数，就是ta</p>\n<blockquote>\n<p>类似 136题，这个题我做过了，但是说实话，这个异或我还是没有太明白</p>\n<p>好像明白一点了，如果 一个字母是唯一的，那么任何字母和它异或，都不会改变它，而且由于其他的成双成对，最后一定都会相当于和自身异或一次，会最后剩下一个字母</p>\n<p>这个方法的空间复杂度和时间复杂度都是一定的，而且没有优化的空间</p>\n</blockquote>\n<p>（3）求和</p>\n<p>这个方法用的是ASCII码的方法，ASCII码的和的差值就是多出来的那个字母的ASCII码</p>\n<p>python ASCII码 <code>ord(&#39;a&#39;)</code></p>\n<p>从ASCII码反读字母呢：<code>chr(num)</code></p>\n<h2 id=\"1025-除数博弈-动态规划，数学\"><a href=\"#1025-除数博弈-动态规划，数学\" class=\"headerlink\" title=\"1025. 除数博弈 - 动态规划，数学\"></a>1025. 除数博弈 - 动态规划，数学</h2><p>输入：int 数字 n，1到1000之间</p>\n<p>输出：布尔值</p>\n<p>功能：每一轮的要求如下，最后要求出来的是总轮数，如果为奇数那么返回True，如果为偶数返回False</p>\n<ul>\n<li><p>对于任意 ==x&lt;n==，余数如果为0就是true</p>\n</li>\n<li><p>然后 n=n-x，对于新的任意 y&lt;新的n，余数为0就是true</p>\n</li>\n<li><p>直到找不到使余数为0的除数 z&lt;新的新的n</p>\n</li>\n</ul>\n<p>题目中举了一个很有意思的例子：3</p>\n<ul>\n<li>第一位选择 1，那么余数是0【其实对于任意 n，总可以以1为除数，得到余数为0】，然后3-1=2</li>\n<li>第二位选择 1，余数还是0，然后 2-1=1</li>\n<li>然后不能再选1了，因为不满足 x&lt;n(此时n=1了)</li>\n</ul>\n<p>也就是说每一轮，n在更新，除数的上限也在更新，除数也在更新，如果被除数变为1，那么游戏就结束了</p>\n<p>难点：</p>\n<ul>\n<li>找整除的数，1是万能的，除1以外-永远可以整除，但问题是也要防止给对方留下赢的空间<ul>\n<li>比如4<ul>\n<li>选2，剩下2，选1，输了</li>\n<li>选1，剩下3，选1，剩下2，选1，赢了</li>\n<li>那这样的话肯定第二种思路要比第一种要好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>也就是说要最优化 - 尽可能赢，除非必输</li>\n</ul>\n<p>本题居然是简单？</p>\n<p>假设当前剩余数字 n，最佳轮数\\路径是 f(n) 【这样不行】</p>\n<blockquote>\n<p>问题是本题是数字n越小越容易发现正确路径，数字越大反而越不容易</p>\n<p>比如 n = 1，直接<strong>输</strong>，1步</p>\n<p>n = 2，直接<strong>赢</strong>，1步</p>\n<p>n = 3，一定会<strong>输</strong>，没得选，2步</p>\n<p>n = 4，可以<strong>赢</strong>，2步，3步（赢）</p>\n<p>n = 5，</p>\n<ul>\n<li>选1，为4</li>\n<li>这下选择权在对方手里，一定<strong>输</strong>【每轮都是按照最优方法】2步（输），3步</li>\n</ul>\n<p>n = 6，</p>\n<ul>\n<li>选1，为5，1+1+2或3，最后一定输</li>\n<li>选2，为4，2或3一定输</li>\n<li>选3，为3，一定<strong>赢</strong></li>\n</ul>\n<p>【问题就在于这个关系是一个可以递推的关系吗？所以要怎么样才能实现动态规划？】</p>\n<p>如果这一步过后，留给对手的总轮数可以是奇数，也可以是偶数，那么对手一定会选择偶数，那么我方一定会选择奇数，永远在博弈</p>\n</blockquote>\n<p>其实已经渐渐发现规律了！</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>非官方：<a href=\"https://leetcode-cn.com/problems/divisor-game/solution/qi-shi-shi-yi-dao-shu-xue-ti-by-coder233/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/divisor-game/solution/qi-shi-shi-yi-dao-shu-xue-ti-by-coder233/</a></p>\n<p>刚才比较的对剩下数字来说，轮数的奇偶比较</p>\n<p>换一个思路：</p>\n<ol>\n<li>什么时候能判断最终结果？N = 2时。那么就是看到谁手里为2。</li>\n<li>剩下的数字是奇数还是偶数？</li>\n</ol>\n<p>核心思想：==奇数的约数一定是奇数，偶数的约束可奇可偶==</p>\n<p>如果开局奇数：第一次不管选什么，对方手里都是偶数</p>\n<p>如果开局偶数：只要一直选1，那么对方手里一定是奇数（2一定不在对方手里），这样就到了上面的情况【妙啊，太妙了！】</p>\n<p>所以，总结出来就是，开局奇数，必输，开局偶数，必赢</p>\n<p>所以，只要判断奇偶数就好了【炸】</p>\n<p>官方题解中还有一种思路是找让对方处于“必败态”的情况</p>\n<h1 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h1><h2 id=\"50-Pow（x-n）-基础，复杂度-分治\"><a href=\"#50-Pow（x-n）-基础，复杂度-分治\" class=\"headerlink\" title=\"50. Pow（x, n）- 基础，复杂度 - 分治\"></a>50. Pow（x, n）- 基础，复杂度 - 分治</h2><p>输入：正负100以内的浮点数 x 和 32位带符号 int 数 n</p>\n<p>输出： x 的 n 次幂</p>\n<p>本题就是纯粹的数学问题的算法实现，关键是这个幂的范围异常大，所以如果真的一个一个乘，时间复杂度会爆炸，所以就是为了尽量压缩时间复杂度诞生的问题！</p>\n<p>首先计算不大于 n 的 $2^k$ 幂，k也就是循环的次数，这样能够尽量减少时间复杂度</p>\n<ul>\n<li>k = 0，那么就是 x</li>\n<li>k = 1， x * x</li>\n<li>k = 2，x^2 * x^2</li>\n<li>k = n，x^n * x^n</li>\n</ul>\n<p>然后对于剩下的 $n-2^k$ 次幂，就转化为求解 x 的 $n-2^k$ 次幂的问题，就可以迭代了</p>\n<p>细节：</p>\n<p>（1）x 化为正数，直接把 x 变成 正数，但是最后结果的正负还要看 n 是奇数还是偶数</p>\n<p>（2）指数为负时，直接把x的倒数求出来</p>\n<p>（3）特殊情况：</p>\n<ul>\n<li>x 为0，直接为0</li>\n<li>n 为0，直接为1</li>\n<li>n 为1，直接为x</li>\n</ul>\n<p>以下是我成功的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x == <span class=\"number\">1</span> <span class=\"keyword\">or</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            x, n = <span class=\"number\">1</span>/x, abs(n)</span><br><span class=\"line\">        weight = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> n % <span class=\"number\">2</span>:</span><br><span class=\"line\">            weight = <span class=\"number\">-1</span></span><br><span class=\"line\">            x = abs(x)</span><br><span class=\"line\">        result = <span class=\"number\">1</span></span><br><span class=\"line\">        res = n</span><br><span class=\"line\">        <span class=\"keyword\">while</span> res:</span><br><span class=\"line\">            this_k, this_pow_2 = self.max_2_pow(res)</span><br><span class=\"line\">            this_x = x</span><br><span class=\"line\">            print(this_k, this_pow_2)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> this_k:</span><br><span class=\"line\">                this_x *= this_x</span><br><span class=\"line\">                this_k -= <span class=\"number\">1</span></span><br><span class=\"line\">            result *= this_x</span><br><span class=\"line\">            res -= this_pow_2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> weight * result</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_2_pow</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 求不大于 n 的 2 的 k 次幂</span></span><br><span class=\"line\">        pow_2 = <span class=\"number\">1</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> n &gt;= pow_2:</span><br><span class=\"line\">            pow_2 *= <span class=\"number\">2</span></span><br><span class=\"line\">            k += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(k<span class=\"number\">-1</span>, <span class=\"number\">0</span>), max(<span class=\"number\">1</span>, pow_2 / <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>其中，多次修改的部分是关于“不大于 n 的 2 的 k 次幂”的求解</p>\n<p>一般情况下，$2^k \\leq n &lt; 2^{k+1}$，此时需要输出的是 k，但是因为满足 while 的循环条件，会多计算一层，所以最后的结果又要扒去一层，但是又要考虑 $ n = 1$ 的情况【这里n不可能为0，因为已经被其他的条件约束了】，所以又要防止把 k=0 和 n=1 又给削了</p>\n<blockquote>\n<p><strong>还有一种找 $2^k$ 的方式，是观察余数，如果 $n \\% 2^k &lt; 2^k$，那么自然是介于$2^k$ 和 $2^{k+1}$之间了</strong> </p>\n</blockquote>\n<h3 id=\"阅读题解-1\"><a href=\"#阅读题解-1\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>官方题解说的分治思想确实很不错，从 n 开始，从后往前看，每次对指数向下取整，指数为偶数和奇数分两种结果，也很不错，而且优势在于这种方式可以递归！</p>\n<p>第二种方法绝了，如果不是对二进制非常熟悉，恐怕很难发现这种规律。</p>\n<h2 id=\"53-同剑指offer42-连续子数组的最大和-动态规划、分治法\"><a href=\"#53-同剑指offer42-连续子数组的最大和-动态规划、分治法\" class=\"headerlink\" title=\"53 同剑指offer42.连续子数组的最大和 - 动态规划、分治法\"></a>53 同剑指offer42.连续子数组的最大和 - 动态规划、分治法</h2><p>输入：数组（全为整数，有正负，不会超过10000个数字，绝对值不会大于100）</p>\n<p>输出：最大子序列和</p>\n<p>要求：子序列如果包含2个及以上数字，必须连续；可以是原数组中的任何片段</p>\n<p>假设移动到数组中的第n个数字，此时满足条件的最大和是 f(n)，应该解释为：前n个数字中满足题干条件的最大序列和是f(n)</p>\n<blockquote>\n<p>我怎么知道现在是不是连续的？</p>\n<p>假设有某个连续序列比较大，是当前最大，那么后续数组是加还是减，是从后往前进行计算吗？</p>\n</blockquote>\n<p>那么当新的 n+1 加入后，首先要看当前数 i 是正的还是负的</p>\n<ul>\n<li>如果是负的，只需要比较和 f(n) 的大小就好了，不可能让 f(n) 更大， f(n+1)=max(f(n), i)</li>\n<li>如果是正的，那么有可能让 f(n+1) 更大<ul>\n<li>一方面是比较 f(n) 和 f(n+1)</li>\n<li>另一方面，从当前值 i 从后往前加各个数字，观察和能不能超过 f(n)<ul>\n<li>但是这样会导致复杂度比较高，大概是 $O(n^2)$ ==要求$O(n)$==</li>\n<li>怎么样进行更加方便的判断呢？</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>我印象中前面有一个很类似的问题</p>\n<p>有一种方法是从中间断开然后进行两段计算的方法</p>\n<p>没错，是很类似前面的“买卖股票的最佳时机问题”，不过不一样的地方是，要把中间的数字也加上，而不是只计算头尾</p>\n<p>前面做过的两道题都没有很好地进行学习</p>\n</blockquote>\n<p>关键问题是一个数组是否吸收下一个数字不止取决于下一个数字，而是取决于下一个数字之后的一个连续序列是不是能够对当前序列进行增加。</p>\n<blockquote>\n<p>这里本来是剑指offer42，结果和53题相同</p>\n</blockquote>\n<p>！！！应该说53题当时没有好好学习</p>\n<p>==<u>这里注意 f(i) 的解释：表示以第 i 个数字结尾的连续子数组的最大和</u>==</p>\n<p>那么 $f(i+1) = max(f(i)+a_i, a_i)$ 就非常正确了，就不用再考虑从后往前加那么多了！</p>\n<p>这道题的第二种方法是分治，其实是本题的深化：求序列的 [l, r] 区间内的最大连续子段和</p>\n<h1 id=\"贪心法\"><a href=\"#贪心法\" class=\"headerlink\" title=\"贪心法\"></a>贪心法</h1><h2 id=\"376-摆动序列-动态规划、贪心法\"><a href=\"#376-摆动序列-动态规划、贪心法\" class=\"headerlink\" title=\"376. 摆动序列 - 动态规划、贪心法\"></a>376. 摆动序列 - 动态规划、贪心法</h2><p>输入：一个数组</p>\n<p>输出：最长子数组的长度</p>\n<p>要求：子数值后一项减前一项的差值必须是一正一反交替的；只有一个元素，或者只有两个元素的也算。</p>\n<p>怎么样检测差值是不是交替？可以用乘法，差值乘积小于0，那么就是了</p>\n<p>但是怎么样获得最长数组？</p>\n<p>个人觉得还是一个动态规划的问题，题解标题来看也有说是贪心法的，如果用动态规划来说，最大问题是不一定后面的元素和前面的元素存在关系</p>\n<p>思路：</p>\n<p>比方说<strong>先计算一遍差值，形成一个新的数组</strong>，然后选择正负交替，最后差值数量 + 1 就是最后的结果吗</p>\n<p><strong>连续的正数，或者连续的负数</strong>都不会增加差值的数量，<strong>只有出现改变</strong>才增加一次</p>\n<p>如果用一个数组记录新数组，那么这个空间占用率会很高，最好是一个循环直接带走，也是需要两个量来进行交替取值</p>\n<ul>\n<li>新问题：如果差值为0，那么也是不能算的</li>\n<li>另外：如果出现一个差值为0， 那么不能继续乘以它了，这样后面就无效了</li>\n</ul>\n<!--重要-->\n<p>==重新整理思路：==</p>\n<ul>\n<li><p>第一个数，索引0，结果直接加1，不会比1小</p>\n</li>\n<li><p>从第2个数（索引1）开始，如果其和前一个数的差值 * 索引1与索引0的差值 &lt; 0 ，那么结果就要加1了</p>\n</li>\n<li><p>如果差值为0，那么又不能使用这一个差值<!--【这是最大的问题】--></p>\n</li>\n<li><p>所以就是，计算差值</p>\n<ul>\n<li>如果差值为0自然是不加不减<ul>\n<li>==而且不能改变前一个趋势值 s1==</li>\n</ul>\n</li>\n<li><p>如果前面差值为负数，当前为正，或者前面差值为正数，当前为负，则会加1</p>\n</li>\n<li><p>如果前面差值为0呢？</p>\n<ul>\n<li>按照上面的说法，其实只有一种可能前面的趋势值 s1 为0，那就是从开头以来，s1就是0，而且还没有变过</li>\n<li>一旦 s2不是0，一定会把 s1变化一次的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!--重要-->\n<p>其实我的方法是<strong>贪心法</strong>的思路！！</p>\n<ul>\n<li>但是问题是我没有很好地==处理 0 的问题==，如果不能用乘法一劳永逸地解决，不妨直接==用不等号进行尝试==！</li>\n<li>而且，也不要最后再加1，这样针对【0，0】这样的数组就会多加一次，应该在最开始就加到位，后面就是不停地补充就好了</li>\n</ul>\n<h3 id=\"阅读题解-2\"><a href=\"#阅读题解-2\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p><a href=\"https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/\" target=\"_blank\" rel=\"noopener\">摆动序列官方题解</a></p>\n<p>峰谷思想：</p>\n<ul>\n<li>两侧均小为峰，两侧均大为谷，非峰非谷为过渡</li>\n<li>两端元素只有一侧，小为谷，大为峰</li>\n<li>最后一个元素上升趋势，则为上升摆动序列，下降趋势则为下降摆动序列</li>\n</ul>\n<blockquote>\n<p>状态表达式</p>\n<p>状态转移规则（方程）</p>\n<p>初始条件</p>\n</blockquote>\n<p><strong>动态规划思路：</strong></p>\n<p><strong>状态表达</strong></p>\n<ul>\n<li>以当前元素结尾的序列中，最长上升摆动序列为 up[i]，最长下降摆动序列为 down[i]</li>\n</ul>\n<p><strong>状态转移规则</strong></p>\n<ul>\n<li>针对 up[i]<ul>\n<li>当前元素小于上一个元素（包括等于），那么最长上升摆动序列不变</li>\n<li>当前元素大于上一个元素，那么既可以从 up[i-1]转移，也可以从 down[i-1]转移</li>\n</ul>\n</li>\n<li>针对 down[i]<ul>\n<li>当前元素大于上一个元素（包括等于），那么最长下降摆动序列不变</li>\n<li>当前元素小于上一个元素，那么可以从 up[i-1]转移，也可以从 down[i-1]转移</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201212135251108.png\" alt=\"image-20201212135251108\" style=\"zoom: 67%;\" /></p>\n<p>最后的答案也是从 up[n-1] 和 down[i-1]中选择比较大的那个</p>\n<h2 id=\"135-分发糖果-贪心法\"><a href=\"#135-分发糖果-贪心法\" class=\"headerlink\" title=\"135. 分发糖果 - 贪心法\"></a>135. 分发糖果 - 贪心法</h2><p>这道题有一点像华为今年的题</p>\n<p>输入：一个整数序列</p>\n<p>输出：重建序列和</p>\n<p>要求：对输入序列，对比相邻元素</p>\n<ul>\n<li>如果元素比较大，重建序列中该值位置的数字应当+1</li>\n<li>元素相等，不用+1，直接给1</li>\n</ul>\n<p>当前元素有几颗糖完全取决于前面一个的糖？</p>\n<ul>\n<li>[0, 2, 1]，第三个数字介于前两个数字之间，如果0给1，2给2，那么1给1，完全没问题</li>\n<li>[2, 2, 1]，2给1，2给1，但是后一个是1，至少给1，所以第2个2不能为1</li>\n</ul>\n<p>我的想法：</p>\n<p>到第 i 个数字，首先给 1</p>\n<p>从前往后的序列是相对比较容易的，直接对比，然后加就可以了</p>\n<p>从后往前的序列是比较难的，需要对前面的序列一个一个对比大小和调整，直到遇到比较小的数字</p>\n<p>如果一个序列就按照从大到小降序排列呢？那就要处理很多，复杂度就高了，这样显然不是太好</p>\n<h3 id=\"官方题解-1\"><a href=\"#官方题解-1\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>其实刚才的想法中暗含了本问题的额正确解决思路：==就是需要反过来进行计算==，其实两个递减序列肯定是互不相关的，那么直接反过来再计算一遍不就好了？</p>\n<p>总体想法：正着一遍，反着一遍</p>\n<p>注意一个问题：</p>\n<ul>\n<li>正着一遍，我们需要得到新的序列</li>\n<li>反着一遍，其实序列本身并不是我们需要的，数字的和才是我们需要的</li>\n</ul>\n<p><code>range(n-1, -1, -1)</code>，从 n-1 一直到 0</p>\n<p>官方题解中的 <code>ret += max(left[i], right)</code> 一句点明了两点：</p>\n<p>（1）每一次循环其实决定的是新序列右侧值</p>\n<p>（2）反向序列满足规律时才会修改，如果不满足规律那么right会是1，也就不怎么改变了</p>\n<p>总结：贪心法，两遍扫描，已有相关题解</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"118-杨辉三角-基础\"><a href=\"#118-杨辉三角-基础\" class=\"headerlink\" title=\"118. 杨辉三角 - 基础\"></a>118. 杨辉三角 - 基础</h2><p>输入：非负整数 n</p>\n<p>输出：杨辉三角的前 n 行</p>\n<p>理论上可以硬解</p>\n<p>特点：</p>\n<ul>\n<li>每一行首尾都是1，其他数字i是上一行第i个和第i-1个数字的加和</li>\n<li>第 i 行 i 个数字</li>\n</ul>\n<p>按我自己的方法，主要是会有三种特殊情况：</p>\n<p>（1）n=0，那么返回是空</p>\n<p>（2）n=1，那么返回是[[1]]</p>\n<p>（3）n=2，那么返回是[[1],[1,1]]</p>\n<p>只有从n=3开始，才建立起递推关系</p>\n<hr>\n<p>OK！本期10题就先到这里了，应该说在这段期间对代码的理解有了提高，但是对知识的巩固一如既往地糟糕，需要经常复习。</p>\n<p>期待下一个10题快点到来！</p>\n","site":{"data":{}},"excerpt":"<p>每期10题，上一期参见<a href=\"https://sunyoe.github.io/2020/12/06/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/\" target=\"_blank\" rel=\"noopener\">LeetCode刷题笔记（二）</a>。</p>\n<p>本期内容多以动态规划为主。</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"392-判断子序列-动态规划\"><a href=\"#392-判断子序列-动态规划\" class=\"headerlink\" title=\"392. 判断子序列 - 动态规划\"></a>392. 判断子序列 - 动态规划</h2><p>输入：长序列 t，短序列 s</p>\n<p>判断：s 是不是 t 的子序列</p>\n<p>条件：</p>\n<ul>\n<li>从原始序列到子序列，可以删除部分字符，可以不连续，但是<strong>相对位置</strong>不能变</li>\n<li>两个序列全是英文小写字母</li>\n</ul>","more":"<p>传统方法：</p>\n<ul>\n<li>如果可以不改变顺序地去重，那么就可以直接取筛选了</li>\n</ul>\n<p><strong>怎么样使用动态规划呢？</strong></p>\n<p>到了 t 的第 n 个字符，已经发现了 s 的字符数为 f(n)</p>\n<p>那么</p>\n<ul>\n<li>如果这一个（t_n）不是s中的下一个（s_(f(n-1)+1)），那么f(n) = f(n-1)</li>\n<li>如果是，那么f(n) = f(n-1) + 1</li>\n</ul>\n<p>推导至 t 的结尾，或者到了s 的结尾，就要停止了</p>\n<p>如果s到了结尾，那就说明是子序列</p>\n<p>特殊情况：</p>\n<p>（1）短字符为空</p>\n<p><del>（2）长字符和短字符一样长【如果不相等可以直接判断为False了】，那相等直接判定为True【其实这个也不必了】</del></p>\n<p>这个问题最容易出错的地方是list的索引问题，上代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubsequence</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        yes_num = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len(s):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"comment\"># if len(s) == len(t):</span></span><br><span class=\"line\">        <span class=\"comment\">#     return False if s != t else True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(t)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> t[i] == s[yes_num]:</span><br><span class=\"line\">                yes_num += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> yes_num == len(s):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span> <span class=\"keyword\">if</span> yes_num == len(s) <span class=\"keyword\">else</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>yes_sum 直接代表了 s 中的下一个位置【因为list从0开始】，也表示了 s 已经匹配的字符数量</p>\n<p><strong>所以最后对比yes_num和s的长度就不用长度减一了！！</strong></p>\n<p>所以长字符和短字符一样长的情况也就不再是特殊情况了</p>\n<p>最后，最简化版本，特殊情况不特殊，最后判断也多余：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSubsequence</span><span class=\"params\">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        yes_num = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len(s):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(t)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> t[i] == s[yes_num]:</span><br><span class=\"line\">                yes_num += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> yes_num == len(s):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"746-使用最小花费爬楼梯-动态规划\"><a href=\"#746-使用最小花费爬楼梯-动态规划\" class=\"headerlink\" title=\"746. 使用最小花费爬楼梯 - 动态规划\"></a>746. 使用最小花费爬楼梯 - 动态规划</h2><p>本题确实是一个动态规划方面的问题，但是我得说这个问题的描述有点迷糊</p>\n<p>输入：一个列表，全是数值，长度至少是2</p>\n<p>输出：最小子序列的和</p>\n<p>要求：</p>\n<ul>\n<li>该子序列可以连续，也可以间隔1个；</li>\n<li>该子序列可以不包含第1个元素（索引为0）；</li>\n<li>该子序列可以不包含最后一个元素（索引为 n-1）；</li>\n</ul>\n<p>假设到第 n 个数值，最小和为 f(n)</p>\n<p>有三种可能：怎么样去选择？</p>\n<ul>\n<li><p>$f(n) = f(n-1)$（可以从第2个数，也就是索引为1开始）【跳当前数值】</p>\n<ul>\n<li>问题：<strong>【那这个肯定比第二种要小，怎么说？】</strong></li>\n</ul>\n</li>\n<li><p>$f(n) = f(n-1) + i$（可以从第2个数，也就是索引为1开始）【连续】</p>\n<ul>\n<li>如果此时 n 是最后一个，那么 i 是不能加的<strong>【但问题是我不知道 n 到底是不是最后一个】</strong></li>\n</ul>\n</li>\n<li><p>$f(n) = f(n-2) + i$（可以从第3个数，也就是索引为2开始）【跳前一个数值】</p>\n<ul>\n<li>如果此时 n 是最后一个，那么 i 是必须加的</li>\n</ul>\n</li>\n</ul>\n<p>初始条件：</p>\n<ul>\n<li>$f(1) = i_0$</li>\n<li>$f(2)=min(f(1), i_1)$【如果能跳过2个，那么一定会跳过，否则和一定会变大】</li>\n</ul>\n<p>终止条件：</p>\n<ul>\n<li>$n$ 到了结尾</li>\n</ul>\n<p>现在思路开始混乱了：</p>\n<p>在第 n 个数值，有几种情况？选择当前，不选择当前，不管选不选当前，都有可能选前一个数值</p>\n<ul>\n<li>一般情况下，我肯定不会连续选择数值，除非旁边的数值更大，或者没得选</li>\n</ul>\n<h3 id=\"阅读题解\"><a href=\"#阅读题解\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p><strong>递归关系</strong>似乎是 $f(n) = i + min(f(n-1), f(n-2))$</p>\n<p>最后一步，为了防止最后一步需要判断取舍，可以直接在最后选择 f(n) 和 f(n-1) 中比较小的，那就实现了最优</p>\n<p>还有一点就是，这样的话，初始化就和上面略有不同了：</p>\n<ul>\n<li>f(1) = i_0</li>\n<li>f(2) = i_1</li>\n</ul>\n<p>因为最后已经增加了判断最后一个数值取舍的步骤，这里的 f(2) 就没有必要多一次判断了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minCostClimbingStairs</span><span class=\"params\">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        sum_cost = []</span><br><span class=\"line\">        sum_cost.append(cost[<span class=\"number\">0</span>])</span><br><span class=\"line\">        sum_cost.append(cost[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(cost) == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum_cost[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, len(cost)):</span><br><span class=\"line\">            sum_cost.append(cost[i] + min(sum_cost[<span class=\"number\">-1</span>], sum_cost[<span class=\"number\">-2</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(sum_cost[<span class=\"number\">-1</span>], sum_cost[<span class=\"number\">-2</span>])</span><br></pre></td></tr></table></figure>\n<h2 id=\"面试题-17-16-按摩师-动态规划\"><a href=\"#面试题-17-16-按摩师-动态规划\" class=\"headerlink\" title=\"面试题 17.16 按摩师 - 动态规划\"></a>面试题 17.16 按摩师 - 动态规划</h2><p>输入：一个序列</p>\n<p>输出：子序列的和，最大和</p>\n<p>要求：子序列元素不能相邻</p>\n<p>本题就是比较典型的动态规划</p>\n<p>状态表达式：$f(n)$ 表示到第 n 个数的最大和</p>\n<p>状态转移方程及条件：</p>\n<p>（1）$f(n) = f(n-1)$，什么条件？</p>\n<p>（2）$f(n) = f(n-2) + i$</p>\n<p>那本题岂不是和198题相同？？</p>\n<blockquote>\n<p>在746题中，因为可以连续，或者只能间隔一个，所以是先比较最大值（最小值），然后再加当前值</p>\n<p>但是本题不能连续，不能先比较最大值</p>\n</blockquote>\n<p>本题有个问题，一定会选择当前数值吗？不一定</p>\n<p>和198题还真是一样的，就考虑三个特殊情况：</p>\n<p>列表长度为0，1，2，分别是0，sum(list)，max(list)，有没有什么方法可以一句话搞定的？</p>\n<h2 id=\"389-找不同-运算，ASCII和异或\"><a href=\"#389-找不同-运算，ASCII和异或\" class=\"headerlink\" title=\"389. 找不同 - 运算，ASCII和异或\"></a>389. 找不同 - 运算，ASCII和异或</h2><p>输入：两个字符串 s 和 t</p>\n<p>输出：t 中 s 没有的字符</p>\n<p>要求：t 由 s 随机重排并添加了一个字母</p>\n<p><strong>本题居然是简单？</strong></p>\n<p>观察示例发现：</p>\n<p>添加的字母有可能是s 中已有字母重复的，那么这样的话使用 set 元组做去重就是不太好的方法了</p>\n<p>如果遍历 s 中的字符，找 t 中的位置，然后找出那个字符呢，时间复杂度为 o(n)，可能不是最好的方法【尤其如果s本身含有重复字母，那么t中肯定也有重复字母了】还好s最长只是1000，那么肯定会有重复的，这样确实不是太好难道说要统计s中每个字母的数量，然后去对比吗？普通的list并没有找出全部索引的功能吧</p>\n<h3 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>（1）计数，还真的可以对字符串中出现的字母进行计数，然后比较（这里使用的方法是在t中进行递减计数，当数字为负，那就找到了数字）</p>\n<p>（2）位运算【这个思路比较好】</p>\n<p>把两个字符串合二为一，肯定有一个字母出现次数不是偶数，就是ta</p>\n<blockquote>\n<p>类似 136题，这个题我做过了，但是说实话，这个异或我还是没有太明白</p>\n<p>好像明白一点了，如果 一个字母是唯一的，那么任何字母和它异或，都不会改变它，而且由于其他的成双成对，最后一定都会相当于和自身异或一次，会最后剩下一个字母</p>\n<p>这个方法的空间复杂度和时间复杂度都是一定的，而且没有优化的空间</p>\n</blockquote>\n<p>（3）求和</p>\n<p>这个方法用的是ASCII码的方法，ASCII码的和的差值就是多出来的那个字母的ASCII码</p>\n<p>python ASCII码 <code>ord(&#39;a&#39;)</code></p>\n<p>从ASCII码反读字母呢：<code>chr(num)</code></p>\n<h2 id=\"1025-除数博弈-动态规划，数学\"><a href=\"#1025-除数博弈-动态规划，数学\" class=\"headerlink\" title=\"1025. 除数博弈 - 动态规划，数学\"></a>1025. 除数博弈 - 动态规划，数学</h2><p>输入：int 数字 n，1到1000之间</p>\n<p>输出：布尔值</p>\n<p>功能：每一轮的要求如下，最后要求出来的是总轮数，如果为奇数那么返回True，如果为偶数返回False</p>\n<ul>\n<li><p>对于任意 ==x&lt;n==，余数如果为0就是true</p>\n</li>\n<li><p>然后 n=n-x，对于新的任意 y&lt;新的n，余数为0就是true</p>\n</li>\n<li><p>直到找不到使余数为0的除数 z&lt;新的新的n</p>\n</li>\n</ul>\n<p>题目中举了一个很有意思的例子：3</p>\n<ul>\n<li>第一位选择 1，那么余数是0【其实对于任意 n，总可以以1为除数，得到余数为0】，然后3-1=2</li>\n<li>第二位选择 1，余数还是0，然后 2-1=1</li>\n<li>然后不能再选1了，因为不满足 x&lt;n(此时n=1了)</li>\n</ul>\n<p>也就是说每一轮，n在更新，除数的上限也在更新，除数也在更新，如果被除数变为1，那么游戏就结束了</p>\n<p>难点：</p>\n<ul>\n<li>找整除的数，1是万能的，除1以外-永远可以整除，但问题是也要防止给对方留下赢的空间<ul>\n<li>比如4<ul>\n<li>选2，剩下2，选1，输了</li>\n<li>选1，剩下3，选1，剩下2，选1，赢了</li>\n<li>那这样的话肯定第二种思路要比第一种要好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>也就是说要最优化 - 尽可能赢，除非必输</li>\n</ul>\n<p>本题居然是简单？</p>\n<p>假设当前剩余数字 n，最佳轮数\\路径是 f(n) 【这样不行】</p>\n<blockquote>\n<p>问题是本题是数字n越小越容易发现正确路径，数字越大反而越不容易</p>\n<p>比如 n = 1，直接<strong>输</strong>，1步</p>\n<p>n = 2，直接<strong>赢</strong>，1步</p>\n<p>n = 3，一定会<strong>输</strong>，没得选，2步</p>\n<p>n = 4，可以<strong>赢</strong>，2步，3步（赢）</p>\n<p>n = 5，</p>\n<ul>\n<li>选1，为4</li>\n<li>这下选择权在对方手里，一定<strong>输</strong>【每轮都是按照最优方法】2步（输），3步</li>\n</ul>\n<p>n = 6，</p>\n<ul>\n<li>选1，为5，1+1+2或3，最后一定输</li>\n<li>选2，为4，2或3一定输</li>\n<li>选3，为3，一定<strong>赢</strong></li>\n</ul>\n<p>【问题就在于这个关系是一个可以递推的关系吗？所以要怎么样才能实现动态规划？】</p>\n<p>如果这一步过后，留给对手的总轮数可以是奇数，也可以是偶数，那么对手一定会选择偶数，那么我方一定会选择奇数，永远在博弈</p>\n</blockquote>\n<p>其实已经渐渐发现规律了！</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>非官方：<a href=\"https://leetcode-cn.com/problems/divisor-game/solution/qi-shi-shi-yi-dao-shu-xue-ti-by-coder233/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/divisor-game/solution/qi-shi-shi-yi-dao-shu-xue-ti-by-coder233/</a></p>\n<p>刚才比较的对剩下数字来说，轮数的奇偶比较</p>\n<p>换一个思路：</p>\n<ol>\n<li>什么时候能判断最终结果？N = 2时。那么就是看到谁手里为2。</li>\n<li>剩下的数字是奇数还是偶数？</li>\n</ol>\n<p>核心思想：==奇数的约数一定是奇数，偶数的约束可奇可偶==</p>\n<p>如果开局奇数：第一次不管选什么，对方手里都是偶数</p>\n<p>如果开局偶数：只要一直选1，那么对方手里一定是奇数（2一定不在对方手里），这样就到了上面的情况【妙啊，太妙了！】</p>\n<p>所以，总结出来就是，开局奇数，必输，开局偶数，必赢</p>\n<p>所以，只要判断奇偶数就好了【炸】</p>\n<p>官方题解中还有一种思路是找让对方处于“必败态”的情况</p>\n<h1 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h1><h2 id=\"50-Pow（x-n）-基础，复杂度-分治\"><a href=\"#50-Pow（x-n）-基础，复杂度-分治\" class=\"headerlink\" title=\"50. Pow（x, n）- 基础，复杂度 - 分治\"></a>50. Pow（x, n）- 基础，复杂度 - 分治</h2><p>输入：正负100以内的浮点数 x 和 32位带符号 int 数 n</p>\n<p>输出： x 的 n 次幂</p>\n<p>本题就是纯粹的数学问题的算法实现，关键是这个幂的范围异常大，所以如果真的一个一个乘，时间复杂度会爆炸，所以就是为了尽量压缩时间复杂度诞生的问题！</p>\n<p>首先计算不大于 n 的 $2^k$ 幂，k也就是循环的次数，这样能够尽量减少时间复杂度</p>\n<ul>\n<li>k = 0，那么就是 x</li>\n<li>k = 1， x * x</li>\n<li>k = 2，x^2 * x^2</li>\n<li>k = n，x^n * x^n</li>\n</ul>\n<p>然后对于剩下的 $n-2^k$ 次幂，就转化为求解 x 的 $n-2^k$ 次幂的问题，就可以迭代了</p>\n<p>细节：</p>\n<p>（1）x 化为正数，直接把 x 变成 正数，但是最后结果的正负还要看 n 是奇数还是偶数</p>\n<p>（2）指数为负时，直接把x的倒数求出来</p>\n<p>（3）特殊情况：</p>\n<ul>\n<li>x 为0，直接为0</li>\n<li>n 为0，直接为1</li>\n<li>n 为1，直接为x</li>\n</ul>\n<p>以下是我成功的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x == <span class=\"number\">1</span> <span class=\"keyword\">or</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            x, n = <span class=\"number\">1</span>/x, abs(n)</span><br><span class=\"line\">        weight = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> n % <span class=\"number\">2</span>:</span><br><span class=\"line\">            weight = <span class=\"number\">-1</span></span><br><span class=\"line\">            x = abs(x)</span><br><span class=\"line\">        result = <span class=\"number\">1</span></span><br><span class=\"line\">        res = n</span><br><span class=\"line\">        <span class=\"keyword\">while</span> res:</span><br><span class=\"line\">            this_k, this_pow_2 = self.max_2_pow(res)</span><br><span class=\"line\">            this_x = x</span><br><span class=\"line\">            print(this_k, this_pow_2)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> this_k:</span><br><span class=\"line\">                this_x *= this_x</span><br><span class=\"line\">                this_k -= <span class=\"number\">1</span></span><br><span class=\"line\">            result *= this_x</span><br><span class=\"line\">            res -= this_pow_2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> weight * result</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_2_pow</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 求不大于 n 的 2 的 k 次幂</span></span><br><span class=\"line\">        pow_2 = <span class=\"number\">1</span></span><br><span class=\"line\">        k = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> n &gt;= pow_2:</span><br><span class=\"line\">            pow_2 *= <span class=\"number\">2</span></span><br><span class=\"line\">            k += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(k<span class=\"number\">-1</span>, <span class=\"number\">0</span>), max(<span class=\"number\">1</span>, pow_2 / <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>其中，多次修改的部分是关于“不大于 n 的 2 的 k 次幂”的求解</p>\n<p>一般情况下，$2^k \\leq n &lt; 2^{k+1}$，此时需要输出的是 k，但是因为满足 while 的循环条件，会多计算一层，所以最后的结果又要扒去一层，但是又要考虑 $ n = 1$ 的情况【这里n不可能为0，因为已经被其他的条件约束了】，所以又要防止把 k=0 和 n=1 又给削了</p>\n<blockquote>\n<p><strong>还有一种找 $2^k$ 的方式，是观察余数，如果 $n \\% 2^k &lt; 2^k$，那么自然是介于$2^k$ 和 $2^{k+1}$之间了</strong> </p>\n</blockquote>\n<h3 id=\"阅读题解-1\"><a href=\"#阅读题解-1\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>官方题解说的分治思想确实很不错，从 n 开始，从后往前看，每次对指数向下取整，指数为偶数和奇数分两种结果，也很不错，而且优势在于这种方式可以递归！</p>\n<p>第二种方法绝了，如果不是对二进制非常熟悉，恐怕很难发现这种规律。</p>\n<h2 id=\"53-同剑指offer42-连续子数组的最大和-动态规划、分治法\"><a href=\"#53-同剑指offer42-连续子数组的最大和-动态规划、分治法\" class=\"headerlink\" title=\"53 同剑指offer42.连续子数组的最大和 - 动态规划、分治法\"></a>53 同剑指offer42.连续子数组的最大和 - 动态规划、分治法</h2><p>输入：数组（全为整数，有正负，不会超过10000个数字，绝对值不会大于100）</p>\n<p>输出：最大子序列和</p>\n<p>要求：子序列如果包含2个及以上数字，必须连续；可以是原数组中的任何片段</p>\n<p>假设移动到数组中的第n个数字，此时满足条件的最大和是 f(n)，应该解释为：前n个数字中满足题干条件的最大序列和是f(n)</p>\n<blockquote>\n<p>我怎么知道现在是不是连续的？</p>\n<p>假设有某个连续序列比较大，是当前最大，那么后续数组是加还是减，是从后往前进行计算吗？</p>\n</blockquote>\n<p>那么当新的 n+1 加入后，首先要看当前数 i 是正的还是负的</p>\n<ul>\n<li>如果是负的，只需要比较和 f(n) 的大小就好了，不可能让 f(n) 更大， f(n+1)=max(f(n), i)</li>\n<li>如果是正的，那么有可能让 f(n+1) 更大<ul>\n<li>一方面是比较 f(n) 和 f(n+1)</li>\n<li>另一方面，从当前值 i 从后往前加各个数字，观察和能不能超过 f(n)<ul>\n<li>但是这样会导致复杂度比较高，大概是 $O(n^2)$ ==要求$O(n)$==</li>\n<li>怎么样进行更加方便的判断呢？</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>我印象中前面有一个很类似的问题</p>\n<p>有一种方法是从中间断开然后进行两段计算的方法</p>\n<p>没错，是很类似前面的“买卖股票的最佳时机问题”，不过不一样的地方是，要把中间的数字也加上，而不是只计算头尾</p>\n<p>前面做过的两道题都没有很好地进行学习</p>\n</blockquote>\n<p>关键问题是一个数组是否吸收下一个数字不止取决于下一个数字，而是取决于下一个数字之后的一个连续序列是不是能够对当前序列进行增加。</p>\n<blockquote>\n<p>这里本来是剑指offer42，结果和53题相同</p>\n</blockquote>\n<p>！！！应该说53题当时没有好好学习</p>\n<p>==<u>这里注意 f(i) 的解释：表示以第 i 个数字结尾的连续子数组的最大和</u>==</p>\n<p>那么 $f(i+1) = max(f(i)+a_i, a_i)$ 就非常正确了，就不用再考虑从后往前加那么多了！</p>\n<p>这道题的第二种方法是分治，其实是本题的深化：求序列的 [l, r] 区间内的最大连续子段和</p>\n<h1 id=\"贪心法\"><a href=\"#贪心法\" class=\"headerlink\" title=\"贪心法\"></a>贪心法</h1><h2 id=\"376-摆动序列-动态规划、贪心法\"><a href=\"#376-摆动序列-动态规划、贪心法\" class=\"headerlink\" title=\"376. 摆动序列 - 动态规划、贪心法\"></a>376. 摆动序列 - 动态规划、贪心法</h2><p>输入：一个数组</p>\n<p>输出：最长子数组的长度</p>\n<p>要求：子数值后一项减前一项的差值必须是一正一反交替的；只有一个元素，或者只有两个元素的也算。</p>\n<p>怎么样检测差值是不是交替？可以用乘法，差值乘积小于0，那么就是了</p>\n<p>但是怎么样获得最长数组？</p>\n<p>个人觉得还是一个动态规划的问题，题解标题来看也有说是贪心法的，如果用动态规划来说，最大问题是不一定后面的元素和前面的元素存在关系</p>\n<p>思路：</p>\n<p>比方说<strong>先计算一遍差值，形成一个新的数组</strong>，然后选择正负交替，最后差值数量 + 1 就是最后的结果吗</p>\n<p><strong>连续的正数，或者连续的负数</strong>都不会增加差值的数量，<strong>只有出现改变</strong>才增加一次</p>\n<p>如果用一个数组记录新数组，那么这个空间占用率会很高，最好是一个循环直接带走，也是需要两个量来进行交替取值</p>\n<ul>\n<li>新问题：如果差值为0，那么也是不能算的</li>\n<li>另外：如果出现一个差值为0， 那么不能继续乘以它了，这样后面就无效了</li>\n</ul>\n<!--重要-->\n<p>==重新整理思路：==</p>\n<ul>\n<li><p>第一个数，索引0，结果直接加1，不会比1小</p>\n</li>\n<li><p>从第2个数（索引1）开始，如果其和前一个数的差值 * 索引1与索引0的差值 &lt; 0 ，那么结果就要加1了</p>\n</li>\n<li><p>如果差值为0，那么又不能使用这一个差值<!--【这是最大的问题】--></p>\n</li>\n<li><p>所以就是，计算差值</p>\n<ul>\n<li>如果差值为0自然是不加不减<ul>\n<li>==而且不能改变前一个趋势值 s1==</li>\n</ul>\n</li>\n<li><p>如果前面差值为负数，当前为正，或者前面差值为正数，当前为负，则会加1</p>\n</li>\n<li><p>如果前面差值为0呢？</p>\n<ul>\n<li>按照上面的说法，其实只有一种可能前面的趋势值 s1 为0，那就是从开头以来，s1就是0，而且还没有变过</li>\n<li>一旦 s2不是0，一定会把 s1变化一次的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!--重要-->\n<p>其实我的方法是<strong>贪心法</strong>的思路！！</p>\n<ul>\n<li>但是问题是我没有很好地==处理 0 的问题==，如果不能用乘法一劳永逸地解决，不妨直接==用不等号进行尝试==！</li>\n<li>而且，也不要最后再加1，这样针对【0，0】这样的数组就会多加一次，应该在最开始就加到位，后面就是不停地补充就好了</li>\n</ul>\n<h3 id=\"阅读题解-2\"><a href=\"#阅读题解-2\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p><a href=\"https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/\" target=\"_blank\" rel=\"noopener\">摆动序列官方题解</a></p>\n<p>峰谷思想：</p>\n<ul>\n<li>两侧均小为峰，两侧均大为谷，非峰非谷为过渡</li>\n<li>两端元素只有一侧，小为谷，大为峰</li>\n<li>最后一个元素上升趋势，则为上升摆动序列，下降趋势则为下降摆动序列</li>\n</ul>\n<blockquote>\n<p>状态表达式</p>\n<p>状态转移规则（方程）</p>\n<p>初始条件</p>\n</blockquote>\n<p><strong>动态规划思路：</strong></p>\n<p><strong>状态表达</strong></p>\n<ul>\n<li>以当前元素结尾的序列中，最长上升摆动序列为 up[i]，最长下降摆动序列为 down[i]</li>\n</ul>\n<p><strong>状态转移规则</strong></p>\n<ul>\n<li>针对 up[i]<ul>\n<li>当前元素小于上一个元素（包括等于），那么最长上升摆动序列不变</li>\n<li>当前元素大于上一个元素，那么既可以从 up[i-1]转移，也可以从 down[i-1]转移</li>\n</ul>\n</li>\n<li>针对 down[i]<ul>\n<li>当前元素大于上一个元素（包括等于），那么最长下降摆动序列不变</li>\n<li>当前元素小于上一个元素，那么可以从 up[i-1]转移，也可以从 down[i-1]转移</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20201212135251108.png\" alt=\"image-20201212135251108\" style=\"zoom: 67%;\" /></p>\n<p>最后的答案也是从 up[n-1] 和 down[i-1]中选择比较大的那个</p>\n<h2 id=\"135-分发糖果-贪心法\"><a href=\"#135-分发糖果-贪心法\" class=\"headerlink\" title=\"135. 分发糖果 - 贪心法\"></a>135. 分发糖果 - 贪心法</h2><p>这道题有一点像华为今年的题</p>\n<p>输入：一个整数序列</p>\n<p>输出：重建序列和</p>\n<p>要求：对输入序列，对比相邻元素</p>\n<ul>\n<li>如果元素比较大，重建序列中该值位置的数字应当+1</li>\n<li>元素相等，不用+1，直接给1</li>\n</ul>\n<p>当前元素有几颗糖完全取决于前面一个的糖？</p>\n<ul>\n<li>[0, 2, 1]，第三个数字介于前两个数字之间，如果0给1，2给2，那么1给1，完全没问题</li>\n<li>[2, 2, 1]，2给1，2给1，但是后一个是1，至少给1，所以第2个2不能为1</li>\n</ul>\n<p>我的想法：</p>\n<p>到第 i 个数字，首先给 1</p>\n<p>从前往后的序列是相对比较容易的，直接对比，然后加就可以了</p>\n<p>从后往前的序列是比较难的，需要对前面的序列一个一个对比大小和调整，直到遇到比较小的数字</p>\n<p>如果一个序列就按照从大到小降序排列呢？那就要处理很多，复杂度就高了，这样显然不是太好</p>\n<h3 id=\"官方题解-1\"><a href=\"#官方题解-1\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>其实刚才的想法中暗含了本问题的额正确解决思路：==就是需要反过来进行计算==，其实两个递减序列肯定是互不相关的，那么直接反过来再计算一遍不就好了？</p>\n<p>总体想法：正着一遍，反着一遍</p>\n<p>注意一个问题：</p>\n<ul>\n<li>正着一遍，我们需要得到新的序列</li>\n<li>反着一遍，其实序列本身并不是我们需要的，数字的和才是我们需要的</li>\n</ul>\n<p><code>range(n-1, -1, -1)</code>，从 n-1 一直到 0</p>\n<p>官方题解中的 <code>ret += max(left[i], right)</code> 一句点明了两点：</p>\n<p>（1）每一次循环其实决定的是新序列右侧值</p>\n<p>（2）反向序列满足规律时才会修改，如果不满足规律那么right会是1，也就不怎么改变了</p>\n<p>总结：贪心法，两遍扫描，已有相关题解</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"118-杨辉三角-基础\"><a href=\"#118-杨辉三角-基础\" class=\"headerlink\" title=\"118. 杨辉三角 - 基础\"></a>118. 杨辉三角 - 基础</h2><p>输入：非负整数 n</p>\n<p>输出：杨辉三角的前 n 行</p>\n<p>理论上可以硬解</p>\n<p>特点：</p>\n<ul>\n<li>每一行首尾都是1，其他数字i是上一行第i个和第i-1个数字的加和</li>\n<li>第 i 行 i 个数字</li>\n</ul>\n<p>按我自己的方法，主要是会有三种特殊情况：</p>\n<p>（1）n=0，那么返回是空</p>\n<p>（2）n=1，那么返回是[[1]]</p>\n<p>（3）n=2，那么返回是[[1],[1,1]]</p>\n<p>只有从n=3开始，才建立起递推关系</p>\n<hr>\n<p>OK！本期10题就先到这里了，应该说在这段期间对代码的理解有了提高，但是对知识的巩固一如既往地糟糕，需要经常复习。</p>\n<p>期待下一个10题快点到来！</p>"},{"title":"LeetCode刷题笔记（六）","date":"2021-03-18T01:47:17.000Z","_content":"\n# <!-- 双指针 -->\n\n## 424. 替换后的最长重复字符\n\n输入：字符串 s，全部是大写字母； 整数 k\n\n要求：最多可以将字符串s中的任意 k 个字符进行替换\n\n输出：最长重复字符的数量\n\n---\n\n### 官方题解\n\n官方题解的方法确实很妙：\n\n![image-20210202103753750](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103753750.png)\n\n如果该数值大于 k ，自然是不符合题意，那么右指针移动，左指针也移动：\n\n![image-20210202103935966](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103935966.png)\n\n如果数值小于等于 k，那么说明符合题意，右指针移动，左指针不用移动：\n\n![image-20210202104027261](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202104027261.png)\n\n右指针 - 左指针 就是最长重复子字符串的长度\n\n**问题在于，怎么计算区间内非重复字符的数量？**\n\n<!--more-->\n\n从代码来看，每次移动右指针后，都是以右指针的新字符作为标准，认为该字符就是最多的字符\n\n> 参考：https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/\n>\n> 该回答中的第二个小问题似乎回答了这一点\n\n如果右边界读到了移出左边界的字符，那么最长子串得以被正确维护\n\n如果右边界不是移出左边界的字符，要让子串更长，总长度肯定要比之前的值还要长，也不会错过最优解\n\n这个回答还是稍微有点拐弯。\n\n> 还有一个细节，就是再移动左端点的时候，当然也会把左端点排除出去\n>\n> 也就是说永远只统计区间内各数值的情况\n\n**此外，如何更新最长子串长度值maxCount？**\n\n这要对比右端点的重复情况与当前最大子串长度\n\n## 42. 接雨水\n\n输入：一个整数数组，表示的是一些柱子的高度\n\n要求：如果两根高柱子之间有矮柱子，或者有空隙，那么就可以存储雨水\n\n输出：总共能够存储的雨水的最大量是多少\n\n![rainwatertrap](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/rainwatertrap.png)\n\n**本质**：\n\n对于每一个位置，需要知道该位置左边的最高高度，和右边的最高高度，像木桶原理一样决定了当前位置能够存储的水量\n\n**暴力解法**：\n\n每到一个位置，进行遍历\n\n**稍微优化**：\n\n那就是先通过遍历的方法记录每一个位置左侧的最大值，反向遍历记录每一个位置右侧的最大值\n\n如果该位置确实有空间，就可以计算出可以增加的水量\n\n**双指针方法**：\n\n这个方法确实很妙\n\n（1）其实决定一个位置水量的，是最短的木板，比如说一个位置的左右都有高木板，近处的木板可能比远处还要高，但是这其实并不是很影响此处的存水量\n\n![image-20210204114211048](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210204114211048.png)\n\n比如上面这张图的位置5：右侧，7位置可能比位置10还要高，但是从位置10就能看出，5位置至少可以存放2个单位的雨水\n\n（2）边界处的存水量，其实只需要一个短边就能判断\n\n比如上面的图片，left位置能不能存放雨水，我们可以简单比较一下 leftmax 和 rightmax，发现 leftmax 更小，那么leftmax就是影响更大的“短板”——minVal\n\n而且因为这个短板更靠近左边，所以对 left 位置影响更大，需要考虑left位置的情况，而不需要考虑 right 位置\n\n> 关键因素是，在考虑left位置的时候也需要对leftmax进行调整\n>\n> 如果这个时候考虑 right 位置，那么可能需要 rightmax 的值，这是不太明智的（太远了）\n\n所以这样，每一次移动时：\n\n我们需要对比左右两端，找出影响比较大的短板；\n\n找出短板影响比较严重的一端（左还是右），在这一端对比短板大小和当前值的大小，看能不能存储雨水；\n\n不管能不能存储雨水，我们都需要对 当前端的max值（leftmax或者rightmax）进行更新，并且移动端点；\n\n最后当两个端点移动到中间的时候，就说明这一次遍历结束了，获得了想要的结果。\n\n## 19. 删除链表中的倒数第N个结点\n\n目标有2：\n\n- 删除倒数第N个结点【单向链表，不太可能反向进行遍历】\n- 返回头节点【如果去掉的就是头节点，所以不能直接把原来的头节点返回】\n\n要求：\n\n- 只扫描一次\n\n问题是：单向链表，怎么样实现只扫描一次呢？\n\n> 没想到，这也是一个双指针的问题\n\n使用两个指针，一个快，一个慢\n\n或者说保持它们之间的距离 为 n-1【n代表要删除的节点的倒数顺序号】\n\n那么当 一个节点移动到末尾的时候，另一个节点就移动到要删除的倒数第n个节点上了！【妙啊】\n\n为了更好地删除，还可以添加 **哑结点** 【也就是在head前的节点，指向head，这个方法确实很常用】，这样的话第二个节点就可以指向要删除的节点的前一个节点\n\n---\n\n还有一个更绝的解答\n\n```C++\nclass Solution {\npublic:\n    int cur=0;\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n       if(!head) return NULL;\n       head->next = removeNthFromEnd(head->next,n);\n       cur++;\n       if(n==cur) return head->next;\n       return head;\n    }\n};\n```\n\n我现在看懂了\n\n单向链表确实没有办法实现倒序的遍历\n\n但是上面这个的做法就是每次到底，到底一次，cur+1，所以就相当于是实现了一个倒序的遍历，只不过递归套循环，时间上可能不占优势\n\n---\n\n传统方法是\n\n先对链表遍历一遍确定总长度\n\n然后再遍历链表，删除要删的那个节点就好了\n\n---\n\n按照以下几个步骤，应该默写出代码：\n\n（1）定义一个新的头节点【其实是哑节点】\n\n（2）定义两个指针，第一个动起来，直到两者间距达到要求\n\n（3）两个指针都动起来，直到第一个指针到结尾了\n\n（4）链表的删除就是，指向删除元素的下一个元素，那么被删除的元素自然就没有了\n\n（3）最后还要把新增的节点删除掉\n\n## 75. 颜色分类\n\n输入：一个数组，其中只有三种整数：0，1，2\n\n要求：进行排序，原地排序，最终结果应该是 所有 0 在最前面，然后是 所有的1，最后是所有的2\n\n那么首先上来就能找到的一个想法是：\n\n- 找到0就放到最开头\n- 找到2就放到结尾\n\n这不就解决了排序的问题了\n\n但是问题是会多用空间\n\n所以有两个方法：\n\n### 单指针\n\n这个方法虽然需要遍历两遍，但是是基础思路，很值得学习\n\n我们设定一个 str 指针，指向所谓的开头\n\n然后从 i = 0 开始遍历数组，如果找到了 0，那么就和开头 str 进行交换，然后 str +1，这样就能保证 比str 小的部分都是0 了\n\n然后再遍历一遍，这次找1，str不要变，让str-1到xx之前都是1，就完成了\n\n```python\nstr = 0\ni = 0\nwhile i < len(nums):\n    if nums[i] == 0:\n        swap(nums, i, str)\n        str += 1\n    i += 1\ni = str\nwhile i < len(nums):\n    if nums[i] == 1:\n        swap(nums, i, str)\n        str += 1\n    i += 1    \n```\n\n注意细节： 第二次遍历，还是要从 str 开始，这一位并没有完成排序\n\n![image-20210311211647039](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211647039.png)\n\n### 双指针\n\n接下来是双指针，只需要遍历一次\n\n这是我第一次再做题的过程中主动想到双指针\n\n但是又放弃了\n\n接着上面的方法，如果我们有两个指针，一个 p0 指向开头，一个 p2 指向结尾\n\n然后，找到 0 就插入到开头位置，找到 2 就插入到结尾的位置，这样就达到了我们想要的效果\n\n但是：\n\n和结尾换位置一定要小心，比如我们找到了 2， 和结尾换了位置，原本结尾这个数值换到了 i 的位置\n\n如果直接让 i+1，那么这一个数值就不会再被计算了！！！！\n\n所以，必须要让 新的 i 位数值，继续和新的结尾（str-1，也变化了）比较\n\n直到找到 数值的正确位置为止\n\n```python\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        p0, p2 = 0, len(nums)-1\n        i = 0\n        while i <= p2:\n            while i <= p2 and nums[i] == 2:\n                # 对 nums[i] 需要不停交换\n                nums = self.swap(nums, i, p2)\n                p2 -= 1\n            if nums[i] == 0:\n                nums = self.swap(nums, i, p0)\n                p0 += 1\n            i += 1\n\n    def swap(self, nums, i, j):\n        nums[i], nums[j] = nums[j], nums[i]\n        return nums\n```\n\n![image-20210311211733805](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211733805.png)\n\n## 60. 第k个排列\n\n给出一个数字n，那么从1到n的数字，拍成一个含有n个数字的数字，有$n!$ 种排列情况【按照大小顺序排列的】\n\n【题目中限定了n:1-9】\n\n输出第k个排列\n\n---\n\n这是一个数学问题\n\n比如说如果我知道了\n\n$n!,(n-1)!...2!,1!$\n\n那么是不是一定可以解决这个问题？\n\n`k/(n!)` 是本位的大小，余数是剩下的数量，当 n 比较大的时候，这种除法还是比较麻烦的 \n\n然后 $(n-1)!=n!/n$ 这样，计算也不会太复杂\n\n---\n\n看答案题解，有点妙：\n\n```python\nvalid = [1] * (n + 1)\nfor j in range(1, n + 1):\n    order -= valid[j]\n    if order == 0:\n        ans.append(str(j))\n        valid[j] = 0\n        break\n```\n\n这里的order就是我说的计算出来的本位的大小，但是不是直接就是我们要的数字了，而是剩下的数字里面按顺序的一位数字\n\n这里的方法是使用了valid数组做连接，如果某一个数字已经被用了，那么valid那一位就是0，这样的话，order就会滑过该数字，就完美地实现了不重复取数的想法\n\n是非常妙，但是这个算法也有点难以想出来\n\n---\n\n最后一点细节：\n\n- 其实这道题并不需要 n的阶乘，只需要 n-1 的阶乘\n- 为什么 k 要减 1 ？\n  - 因为第k个排列的首位数字是 $a_1 = \\frac{k-1}{(n-1)!}+1$\n\n# <!-- 分治 -->\n\n## 215. 数组中第K个最大的元素\n\n复习\n\n欣赏官方给出的java语言的题解，主要是学习 分治思想的应用：[数组中的第K个最大元素-官方题解](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/)\n\n```mermaid\ngraph LR\nA(findKthLargest) --> B(quickSelect)\nB --> C1(randomPartition)\nB --> B\nC1 --> D1(partition)\nC1 --> D2(swap)\nD1 --> D2\nC1 --> D3(random.nextInt)\n```\n\n主函数：`findKthLargest()` \n\n- 直接调用 快速排序 函数\n\n快速排序函数：`quickselect()` 参数比较多\n\n- a - 待排序的数组\n- l - 左侧个数\n- r - 右侧个数\n- index ： len -k 就是说我们现在要找的数值，它的索引应该是 len-k\n\n该函数调用了 `randomPartition()` 函数：作用是\n\n- 首先 调用 `random.nextInt(x)` 生成一个范围在 0-x 内的任意正整数\n  - 这里使用的方法是 `i = random.nextInt(r-l+1)+l`\n  - 这里 `r = len -1`，那么这个 random 最后就是大于 l 的一个随机数值\n  - 也就是说这里随机选择呢右侧的一个 位置\n- 然后 `swap(a, i, r)` 就是把 `a[i]` 和 `a[r]` 互相调换位置\n  - 注意这里，i 比 l 要大，一定在当前值的右边\n  - 而 r 可能是从 len -1 开始进行计算的\n- 接下来交给 `partition` 函数\n\n说实在的，这个官方的题解一点都不容易看懂\n\n---\n\n还是看一下第三方的题解：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/\n\n这个清晰多了\n\n主代码：\n\n```java\nwhile(true){\n    int index = patition(nums, left, right);\n    if (index == target){\n        return nums[index];\n    }else if (index < target){\n        left = index + 1;\n    }else {\n        right = index - 1;\n    }\n}\n```\n\n非常契合思想，那就是如果索引小了，那就查看右边，如果索引大了，就看左边\n\n下来关键就是看这个 partition 函数，它的作用是给 nums 做一个排序，最后返回想要的 索引值\n\n这个函数其实是对 [left, right] 区间的nums 进行操作\n\n所以首先 找一个标准数 pivot， 比如 nums[left]，索引也放过来\n\n然后 从 left 开始遍历，看 nums[i] 有没有比 left 小的\n\n如果比 left 小，那肯定要把这个 nums[i] 和 nums[left] 交换一下了\n\n**但是，这个程序巧妙的地方是** \n\n没有直接把 nums[left] 换掉\n\n而是把 nums[left] 先排除在外，然后 把小的放在前面，大的放在后面，找到了一个中间位置 j，最后直接把 nums[j] 和 nums[left] 换一下就可以\n\n就是说 [left+1, j] 都比 nums[left] 小了，(j, i] 都比 nums[left] 大，那么这个时候，就可以把 j 和 left 换一下，因为不会影响 j 位置处成功分割了左右两边，我们要的也是 这个位置 j \n\n> 注意这个地方， j++ 和 j += 1 是不一样的\n>\n> - 后面这个会直接运算，然后改变了 j 的值\n> - 但是 j++ 是先用，再改变，所以暂时还没有改变\n\n接下来，后面说了一个问题\n\n最好是随机初始化 我们的 标准数 pivot，否则极端测试用例可能会很耗时间\n\n一个方法是，随机交换 第一个元素和后面的任意元素\n\n> 怪不得官方题解 上来就是一个随机交换，搞得莫名其妙\n>\n> 现在再回头看官方题解，就会发现其实是一样的了\n\n# <!-- 贪心 -->\n\n## 984. 不含AAA或BBB的字符串\n\n输入：a 的数量m，b 的数量n\n\n要求：写一个字符串，其中有 m个a和n个b，但是不能出现连续 3个a，或者 3个b\n\n---\n\n我自己的思路：\n\n我曾在脑海中冒出过以下想法：\n\n哈希表-斗地主问题 —— 发现问题在于不能顾头不顾尾\n\n贪心算法 —— 想先找出所有的对a，然后往里面插入 b【超时了】\n\n动态规划，不知道是不是\n\n还想了双指针，但是不行\n\n总的来说，贪心应该是的，但是应该怎么贪心\n\n---\n\n按我说的贪心算法：【首先假设 a 比 b 多】\n\n先找出所有的对a：double_a = a // 2，余数 res_a 就是剩下的a【就是0或者1】\n\n然后给b的位置就是：double_a + res_a\n\n然后对b的数量是：double_b = b % (a_block - 1)\n\n最后剩下的就是单个的b\n\n【超时了】\n\n> 这种方法可以称之为 插空法\n>\n> [贪心+插空](https://leetcode-cn.com/problems/string-without-aaa-or-bbb/solution/tan-xin-cha-kong-by-zhang191031/)\n>\n> 但是插孔的具体实现略有不同\n\n---\n\n姑且不说这个方法是不是正确的\n\n其中一点确实是解题的关键： 找 a 和 b 中比较多的\n\n但是我只找了一次\n\n---\n\n### 官方题解\n\n（1）定调： 贪心算法\n\n但是，下一个写入的字母应该是当前所剩最多的待写字母，除非前两个都是它了，才改用另一个字母\n\n（2）确实使用 list，最后转 str\n\n（3）我们说写a还是b看谁更多，怎么样知道是 a 多还是 b 多呢？其实不一定要知道 a，b 的数量，只要知道下一个 写 a 还是写 b 就好了\n\n【所以就是来判断下一个是不是要写a】\n\n比如这一句：`writeA = ans[-1]=='b'`\n\n如果`ans[-1] `是 b，那么这个writeA就是true了，就表示确实要写A\n\n还有：`writeA = A >= B` \n\n就是说，如果 A 比较多，那么就写 A\n\n（4）一个大问题，不要把 b 和bb，a和aa 分开思考\n\n把 两个 a看成和一个 a 是不一样的情况，是一种错误的想法，容易走上面向过程\n\n而不是面向对象的道路\n\n这样一来就简单多了：\n\n```python\nclass Solution:\n    def strWithout3a3b(self, a: int, b: int) -> str:\n        ans = []\n        while a or b:\n            if len(ans) >= 2 and ans[-1] == ans[-2]:\n                writeA = ans[-1] == 'b'\n            else:\n                writeA = a >= b\n\t\t\t# 根据是不是 写a，来进行填写\n            if writeA:\n                a -= 1\n                ans.append('a')\n            else:\n                b -= 1\n                ans.append('b')\n            \n        return ''.join(ans)\n```\n\n## 999. 可以被一步捕获的棋子数\n\n这道题虽然是涉及二维数组，但是确实是一道简单题\n\n问题描述：\n\n国际象棋棋盘\n\nR - 白车（只有一个），B - 白象（可能有），p - 黑卒（可能有）\n\n白车可以四个方向移动：\n\n- 如果遇到 黑卒，可以吃掉，然后停止\n- 如果遇到 白象，停止\n- 如果遇到 边界，停止\n\n如果给了一张棋盘，请问在该棋盘上，可以被一步捕获的棋子有多少\n\n---\n\n分析，贪心法\n\n首先要找到白色的车 - R\n\n似乎没有什么好办法，就是遍历，最糟糕的情况 O(N)\n\n然后分别遍历四个方向，每个方向一直到底：\n\n- 如果 到边了，返回\n- 如果 到B了，返回\n- 如果 到p了，加1，返回\n\n这里面的四方向遍历方法是我之前学到的，这样可以重用一部分代码：\n\n```python\n# 设置一个代表四个方向的数组\n# 方法1：直接设置表达式，这样其实不容易继续\ndirc = [[i+1, j], [i-1, j], [i, j+1], [i, j-1]]\n# 方法2：设置步长，这个方法更好\ndirc = [[1, 0], [-1, 0], [0, 1], [0, -1]]\nfor k in range(len(dirc)):\n    x += dirc[k][0]\n    y += dirc[k][0]\n```\n\n这样就实现了四个方向的遍历\n\n接下来的判断过程其实比较容易，注意一个细节即可：如果遇到 黑卒-p，加 1 后也是需要进行返回的，否则会有问题\n\n---\n\n## 59. 螺旋矩阵 II\n\n题目描述：\n\n给一个正整数 n，可以用 1 到 n^2的所有元素，填满一个 nxn 的正方形矩阵\n\n要求：\n\n填满的顺序应该是螺旋的，比如：\n\n![matrix_img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n\n---\n\n贪心法：四方向 - 碰壁法\n\n碰壁，改变移动方向\n\n设置了四个方向的移动模式，这一点和 999 题（上面一题）是完全相同的\n\n也需要进行模式切换，但是问题是什么时候需要切换模式呢？\n\n---\n\n方法一：贪心\n\n- 到边界需要切换\n- 原本要去的下一个位置有数字了需要进行切换\n\n怎么样检测是不是到了边界？\n\n- 现在的位置到了 n-1 ，说明是一个边界\n- 下一个位置到了 n，说明是一个边界\n\n怎么样检测下一个位置是不是0？\n\n- 首先要按照原来的模式求出下一个位置的坐标\n- 然后看下一个位置是不是0\n\n这样一来，就需要先用一个假的位置 next_i，next_j先求一边下一个位置的坐标，并且同时判断是不是超出了边界，是不是0，好的一点是，这样可以直接进行模式的判断和修改\n\n然后最后再对真正的位置 i，j 进行修改\n\n---\n\n方法二：数学\n\n观察一下可以发现，每次进行模式的切换需要走过的长度是：\n\nn, n-1, n-1, n-2, n-2,  n-3,  n-3, n-4, …, 2, 2, 1.\n\n除了头和尾，其他位置都是需要走两个相同的长度\n\n这个其实也是可以用循环去实现出来的\n\n比如说，可以先出一个循环，能够写出上面的数组\n\n此时，什么时候需要转换模式？\n\n- 当每一条边写的数字的数量达到了数组中对应位置的数字，就说明这条边写完了，需要写下一条了\n\n这种方法不需要判断下一个位置是不是满了，只需要计数，还是会占一点时间，但是空间上可能会小一点点\n\n# <!-- 递归 -->\n\n## 222. 完全二叉树的节点个数\n\n给你一棵二叉树的根节点 root，求出该树的节点个数\n\n比如：\n\n![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)\n\n输入： root = [1, 2, 3, 4, 5, 6]\n\n输出：6\n\n这个题的输入是 TreeNode，所以不能按照普通的数组进行对待\n\n按照正常的递归方法，非常简单\n\n```python\nclass Solution:\n    def countNodes(self, root: TreeNode) -> int:\n        if not root: return 0\n        else: return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n```\n\n只有2行代码\n\n如果 root 是空，说明到底了，返回0\n\n如果不是空，自身是一个节点 +1，然后计算左子树和右子树\n\n完美通过\n\n![image-20210316194121543](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210316194121543.png)\n\n递归的空间占的大了一点，但是耗时还可以\n\n---\n\n观看题解：\n\n1. 对于没有约束的二叉树，递归当然是没有问题的\n2. 但是本题说的是 **完全二叉树**\n\n**完全二叉树**\n\n特点：叶子节点只出现在最后两层，最后一层如果不满，则叶子节点只在最左侧，或者是空树\n\n如果是**满二叉树**，那么总节点数 =  2*h -1，h 是层数\n\n所以完全二叉树最好是利用好结构特点\n\n---\n\n本次更新距离上次更新比较久，期间经过一系列的算法学习，有了一定的认识和进步，LeetCode刷题数量也已经达到了77题，目前正处于春招当中，继续加油吧！\n\n","source":"_posts/LeetCode刷题笔记六.md","raw":"---\ntitle: LeetCode刷题笔记（六）\ndate: 2021-03-18 09:47:17\ncategories:\n\t- 算法\ntags:\n\t- 双指针\n\t- 分治\n\t- 贪心\n\t- 递归\n---\n\n# <!-- 双指针 -->\n\n## 424. 替换后的最长重复字符\n\n输入：字符串 s，全部是大写字母； 整数 k\n\n要求：最多可以将字符串s中的任意 k 个字符进行替换\n\n输出：最长重复字符的数量\n\n---\n\n### 官方题解\n\n官方题解的方法确实很妙：\n\n![image-20210202103753750](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103753750.png)\n\n如果该数值大于 k ，自然是不符合题意，那么右指针移动，左指针也移动：\n\n![image-20210202103935966](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103935966.png)\n\n如果数值小于等于 k，那么说明符合题意，右指针移动，左指针不用移动：\n\n![image-20210202104027261](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202104027261.png)\n\n右指针 - 左指针 就是最长重复子字符串的长度\n\n**问题在于，怎么计算区间内非重复字符的数量？**\n\n<!--more-->\n\n从代码来看，每次移动右指针后，都是以右指针的新字符作为标准，认为该字符就是最多的字符\n\n> 参考：https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/\n>\n> 该回答中的第二个小问题似乎回答了这一点\n\n如果右边界读到了移出左边界的字符，那么最长子串得以被正确维护\n\n如果右边界不是移出左边界的字符，要让子串更长，总长度肯定要比之前的值还要长，也不会错过最优解\n\n这个回答还是稍微有点拐弯。\n\n> 还有一个细节，就是再移动左端点的时候，当然也会把左端点排除出去\n>\n> 也就是说永远只统计区间内各数值的情况\n\n**此外，如何更新最长子串长度值maxCount？**\n\n这要对比右端点的重复情况与当前最大子串长度\n\n## 42. 接雨水\n\n输入：一个整数数组，表示的是一些柱子的高度\n\n要求：如果两根高柱子之间有矮柱子，或者有空隙，那么就可以存储雨水\n\n输出：总共能够存储的雨水的最大量是多少\n\n![rainwatertrap](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/rainwatertrap.png)\n\n**本质**：\n\n对于每一个位置，需要知道该位置左边的最高高度，和右边的最高高度，像木桶原理一样决定了当前位置能够存储的水量\n\n**暴力解法**：\n\n每到一个位置，进行遍历\n\n**稍微优化**：\n\n那就是先通过遍历的方法记录每一个位置左侧的最大值，反向遍历记录每一个位置右侧的最大值\n\n如果该位置确实有空间，就可以计算出可以增加的水量\n\n**双指针方法**：\n\n这个方法确实很妙\n\n（1）其实决定一个位置水量的，是最短的木板，比如说一个位置的左右都有高木板，近处的木板可能比远处还要高，但是这其实并不是很影响此处的存水量\n\n![image-20210204114211048](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210204114211048.png)\n\n比如上面这张图的位置5：右侧，7位置可能比位置10还要高，但是从位置10就能看出，5位置至少可以存放2个单位的雨水\n\n（2）边界处的存水量，其实只需要一个短边就能判断\n\n比如上面的图片，left位置能不能存放雨水，我们可以简单比较一下 leftmax 和 rightmax，发现 leftmax 更小，那么leftmax就是影响更大的“短板”——minVal\n\n而且因为这个短板更靠近左边，所以对 left 位置影响更大，需要考虑left位置的情况，而不需要考虑 right 位置\n\n> 关键因素是，在考虑left位置的时候也需要对leftmax进行调整\n>\n> 如果这个时候考虑 right 位置，那么可能需要 rightmax 的值，这是不太明智的（太远了）\n\n所以这样，每一次移动时：\n\n我们需要对比左右两端，找出影响比较大的短板；\n\n找出短板影响比较严重的一端（左还是右），在这一端对比短板大小和当前值的大小，看能不能存储雨水；\n\n不管能不能存储雨水，我们都需要对 当前端的max值（leftmax或者rightmax）进行更新，并且移动端点；\n\n最后当两个端点移动到中间的时候，就说明这一次遍历结束了，获得了想要的结果。\n\n## 19. 删除链表中的倒数第N个结点\n\n目标有2：\n\n- 删除倒数第N个结点【单向链表，不太可能反向进行遍历】\n- 返回头节点【如果去掉的就是头节点，所以不能直接把原来的头节点返回】\n\n要求：\n\n- 只扫描一次\n\n问题是：单向链表，怎么样实现只扫描一次呢？\n\n> 没想到，这也是一个双指针的问题\n\n使用两个指针，一个快，一个慢\n\n或者说保持它们之间的距离 为 n-1【n代表要删除的节点的倒数顺序号】\n\n那么当 一个节点移动到末尾的时候，另一个节点就移动到要删除的倒数第n个节点上了！【妙啊】\n\n为了更好地删除，还可以添加 **哑结点** 【也就是在head前的节点，指向head，这个方法确实很常用】，这样的话第二个节点就可以指向要删除的节点的前一个节点\n\n---\n\n还有一个更绝的解答\n\n```C++\nclass Solution {\npublic:\n    int cur=0;\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n       if(!head) return NULL;\n       head->next = removeNthFromEnd(head->next,n);\n       cur++;\n       if(n==cur) return head->next;\n       return head;\n    }\n};\n```\n\n我现在看懂了\n\n单向链表确实没有办法实现倒序的遍历\n\n但是上面这个的做法就是每次到底，到底一次，cur+1，所以就相当于是实现了一个倒序的遍历，只不过递归套循环，时间上可能不占优势\n\n---\n\n传统方法是\n\n先对链表遍历一遍确定总长度\n\n然后再遍历链表，删除要删的那个节点就好了\n\n---\n\n按照以下几个步骤，应该默写出代码：\n\n（1）定义一个新的头节点【其实是哑节点】\n\n（2）定义两个指针，第一个动起来，直到两者间距达到要求\n\n（3）两个指针都动起来，直到第一个指针到结尾了\n\n（4）链表的删除就是，指向删除元素的下一个元素，那么被删除的元素自然就没有了\n\n（3）最后还要把新增的节点删除掉\n\n## 75. 颜色分类\n\n输入：一个数组，其中只有三种整数：0，1，2\n\n要求：进行排序，原地排序，最终结果应该是 所有 0 在最前面，然后是 所有的1，最后是所有的2\n\n那么首先上来就能找到的一个想法是：\n\n- 找到0就放到最开头\n- 找到2就放到结尾\n\n这不就解决了排序的问题了\n\n但是问题是会多用空间\n\n所以有两个方法：\n\n### 单指针\n\n这个方法虽然需要遍历两遍，但是是基础思路，很值得学习\n\n我们设定一个 str 指针，指向所谓的开头\n\n然后从 i = 0 开始遍历数组，如果找到了 0，那么就和开头 str 进行交换，然后 str +1，这样就能保证 比str 小的部分都是0 了\n\n然后再遍历一遍，这次找1，str不要变，让str-1到xx之前都是1，就完成了\n\n```python\nstr = 0\ni = 0\nwhile i < len(nums):\n    if nums[i] == 0:\n        swap(nums, i, str)\n        str += 1\n    i += 1\ni = str\nwhile i < len(nums):\n    if nums[i] == 1:\n        swap(nums, i, str)\n        str += 1\n    i += 1    \n```\n\n注意细节： 第二次遍历，还是要从 str 开始，这一位并没有完成排序\n\n![image-20210311211647039](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211647039.png)\n\n### 双指针\n\n接下来是双指针，只需要遍历一次\n\n这是我第一次再做题的过程中主动想到双指针\n\n但是又放弃了\n\n接着上面的方法，如果我们有两个指针，一个 p0 指向开头，一个 p2 指向结尾\n\n然后，找到 0 就插入到开头位置，找到 2 就插入到结尾的位置，这样就达到了我们想要的效果\n\n但是：\n\n和结尾换位置一定要小心，比如我们找到了 2， 和结尾换了位置，原本结尾这个数值换到了 i 的位置\n\n如果直接让 i+1，那么这一个数值就不会再被计算了！！！！\n\n所以，必须要让 新的 i 位数值，继续和新的结尾（str-1，也变化了）比较\n\n直到找到 数值的正确位置为止\n\n```python\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        p0, p2 = 0, len(nums)-1\n        i = 0\n        while i <= p2:\n            while i <= p2 and nums[i] == 2:\n                # 对 nums[i] 需要不停交换\n                nums = self.swap(nums, i, p2)\n                p2 -= 1\n            if nums[i] == 0:\n                nums = self.swap(nums, i, p0)\n                p0 += 1\n            i += 1\n\n    def swap(self, nums, i, j):\n        nums[i], nums[j] = nums[j], nums[i]\n        return nums\n```\n\n![image-20210311211733805](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211733805.png)\n\n## 60. 第k个排列\n\n给出一个数字n，那么从1到n的数字，拍成一个含有n个数字的数字，有$n!$ 种排列情况【按照大小顺序排列的】\n\n【题目中限定了n:1-9】\n\n输出第k个排列\n\n---\n\n这是一个数学问题\n\n比如说如果我知道了\n\n$n!,(n-1)!...2!,1!$\n\n那么是不是一定可以解决这个问题？\n\n`k/(n!)` 是本位的大小，余数是剩下的数量，当 n 比较大的时候，这种除法还是比较麻烦的 \n\n然后 $(n-1)!=n!/n$ 这样，计算也不会太复杂\n\n---\n\n看答案题解，有点妙：\n\n```python\nvalid = [1] * (n + 1)\nfor j in range(1, n + 1):\n    order -= valid[j]\n    if order == 0:\n        ans.append(str(j))\n        valid[j] = 0\n        break\n```\n\n这里的order就是我说的计算出来的本位的大小，但是不是直接就是我们要的数字了，而是剩下的数字里面按顺序的一位数字\n\n这里的方法是使用了valid数组做连接，如果某一个数字已经被用了，那么valid那一位就是0，这样的话，order就会滑过该数字，就完美地实现了不重复取数的想法\n\n是非常妙，但是这个算法也有点难以想出来\n\n---\n\n最后一点细节：\n\n- 其实这道题并不需要 n的阶乘，只需要 n-1 的阶乘\n- 为什么 k 要减 1 ？\n  - 因为第k个排列的首位数字是 $a_1 = \\frac{k-1}{(n-1)!}+1$\n\n# <!-- 分治 -->\n\n## 215. 数组中第K个最大的元素\n\n复习\n\n欣赏官方给出的java语言的题解，主要是学习 分治思想的应用：[数组中的第K个最大元素-官方题解](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/)\n\n```mermaid\ngraph LR\nA(findKthLargest) --> B(quickSelect)\nB --> C1(randomPartition)\nB --> B\nC1 --> D1(partition)\nC1 --> D2(swap)\nD1 --> D2\nC1 --> D3(random.nextInt)\n```\n\n主函数：`findKthLargest()` \n\n- 直接调用 快速排序 函数\n\n快速排序函数：`quickselect()` 参数比较多\n\n- a - 待排序的数组\n- l - 左侧个数\n- r - 右侧个数\n- index ： len -k 就是说我们现在要找的数值，它的索引应该是 len-k\n\n该函数调用了 `randomPartition()` 函数：作用是\n\n- 首先 调用 `random.nextInt(x)` 生成一个范围在 0-x 内的任意正整数\n  - 这里使用的方法是 `i = random.nextInt(r-l+1)+l`\n  - 这里 `r = len -1`，那么这个 random 最后就是大于 l 的一个随机数值\n  - 也就是说这里随机选择呢右侧的一个 位置\n- 然后 `swap(a, i, r)` 就是把 `a[i]` 和 `a[r]` 互相调换位置\n  - 注意这里，i 比 l 要大，一定在当前值的右边\n  - 而 r 可能是从 len -1 开始进行计算的\n- 接下来交给 `partition` 函数\n\n说实在的，这个官方的题解一点都不容易看懂\n\n---\n\n还是看一下第三方的题解：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/\n\n这个清晰多了\n\n主代码：\n\n```java\nwhile(true){\n    int index = patition(nums, left, right);\n    if (index == target){\n        return nums[index];\n    }else if (index < target){\n        left = index + 1;\n    }else {\n        right = index - 1;\n    }\n}\n```\n\n非常契合思想，那就是如果索引小了，那就查看右边，如果索引大了，就看左边\n\n下来关键就是看这个 partition 函数，它的作用是给 nums 做一个排序，最后返回想要的 索引值\n\n这个函数其实是对 [left, right] 区间的nums 进行操作\n\n所以首先 找一个标准数 pivot， 比如 nums[left]，索引也放过来\n\n然后 从 left 开始遍历，看 nums[i] 有没有比 left 小的\n\n如果比 left 小，那肯定要把这个 nums[i] 和 nums[left] 交换一下了\n\n**但是，这个程序巧妙的地方是** \n\n没有直接把 nums[left] 换掉\n\n而是把 nums[left] 先排除在外，然后 把小的放在前面，大的放在后面，找到了一个中间位置 j，最后直接把 nums[j] 和 nums[left] 换一下就可以\n\n就是说 [left+1, j] 都比 nums[left] 小了，(j, i] 都比 nums[left] 大，那么这个时候，就可以把 j 和 left 换一下，因为不会影响 j 位置处成功分割了左右两边，我们要的也是 这个位置 j \n\n> 注意这个地方， j++ 和 j += 1 是不一样的\n>\n> - 后面这个会直接运算，然后改变了 j 的值\n> - 但是 j++ 是先用，再改变，所以暂时还没有改变\n\n接下来，后面说了一个问题\n\n最好是随机初始化 我们的 标准数 pivot，否则极端测试用例可能会很耗时间\n\n一个方法是，随机交换 第一个元素和后面的任意元素\n\n> 怪不得官方题解 上来就是一个随机交换，搞得莫名其妙\n>\n> 现在再回头看官方题解，就会发现其实是一样的了\n\n# <!-- 贪心 -->\n\n## 984. 不含AAA或BBB的字符串\n\n输入：a 的数量m，b 的数量n\n\n要求：写一个字符串，其中有 m个a和n个b，但是不能出现连续 3个a，或者 3个b\n\n---\n\n我自己的思路：\n\n我曾在脑海中冒出过以下想法：\n\n哈希表-斗地主问题 —— 发现问题在于不能顾头不顾尾\n\n贪心算法 —— 想先找出所有的对a，然后往里面插入 b【超时了】\n\n动态规划，不知道是不是\n\n还想了双指针，但是不行\n\n总的来说，贪心应该是的，但是应该怎么贪心\n\n---\n\n按我说的贪心算法：【首先假设 a 比 b 多】\n\n先找出所有的对a：double_a = a // 2，余数 res_a 就是剩下的a【就是0或者1】\n\n然后给b的位置就是：double_a + res_a\n\n然后对b的数量是：double_b = b % (a_block - 1)\n\n最后剩下的就是单个的b\n\n【超时了】\n\n> 这种方法可以称之为 插空法\n>\n> [贪心+插空](https://leetcode-cn.com/problems/string-without-aaa-or-bbb/solution/tan-xin-cha-kong-by-zhang191031/)\n>\n> 但是插孔的具体实现略有不同\n\n---\n\n姑且不说这个方法是不是正确的\n\n其中一点确实是解题的关键： 找 a 和 b 中比较多的\n\n但是我只找了一次\n\n---\n\n### 官方题解\n\n（1）定调： 贪心算法\n\n但是，下一个写入的字母应该是当前所剩最多的待写字母，除非前两个都是它了，才改用另一个字母\n\n（2）确实使用 list，最后转 str\n\n（3）我们说写a还是b看谁更多，怎么样知道是 a 多还是 b 多呢？其实不一定要知道 a，b 的数量，只要知道下一个 写 a 还是写 b 就好了\n\n【所以就是来判断下一个是不是要写a】\n\n比如这一句：`writeA = ans[-1]=='b'`\n\n如果`ans[-1] `是 b，那么这个writeA就是true了，就表示确实要写A\n\n还有：`writeA = A >= B` \n\n就是说，如果 A 比较多，那么就写 A\n\n（4）一个大问题，不要把 b 和bb，a和aa 分开思考\n\n把 两个 a看成和一个 a 是不一样的情况，是一种错误的想法，容易走上面向过程\n\n而不是面向对象的道路\n\n这样一来就简单多了：\n\n```python\nclass Solution:\n    def strWithout3a3b(self, a: int, b: int) -> str:\n        ans = []\n        while a or b:\n            if len(ans) >= 2 and ans[-1] == ans[-2]:\n                writeA = ans[-1] == 'b'\n            else:\n                writeA = a >= b\n\t\t\t# 根据是不是 写a，来进行填写\n            if writeA:\n                a -= 1\n                ans.append('a')\n            else:\n                b -= 1\n                ans.append('b')\n            \n        return ''.join(ans)\n```\n\n## 999. 可以被一步捕获的棋子数\n\n这道题虽然是涉及二维数组，但是确实是一道简单题\n\n问题描述：\n\n国际象棋棋盘\n\nR - 白车（只有一个），B - 白象（可能有），p - 黑卒（可能有）\n\n白车可以四个方向移动：\n\n- 如果遇到 黑卒，可以吃掉，然后停止\n- 如果遇到 白象，停止\n- 如果遇到 边界，停止\n\n如果给了一张棋盘，请问在该棋盘上，可以被一步捕获的棋子有多少\n\n---\n\n分析，贪心法\n\n首先要找到白色的车 - R\n\n似乎没有什么好办法，就是遍历，最糟糕的情况 O(N)\n\n然后分别遍历四个方向，每个方向一直到底：\n\n- 如果 到边了，返回\n- 如果 到B了，返回\n- 如果 到p了，加1，返回\n\n这里面的四方向遍历方法是我之前学到的，这样可以重用一部分代码：\n\n```python\n# 设置一个代表四个方向的数组\n# 方法1：直接设置表达式，这样其实不容易继续\ndirc = [[i+1, j], [i-1, j], [i, j+1], [i, j-1]]\n# 方法2：设置步长，这个方法更好\ndirc = [[1, 0], [-1, 0], [0, 1], [0, -1]]\nfor k in range(len(dirc)):\n    x += dirc[k][0]\n    y += dirc[k][0]\n```\n\n这样就实现了四个方向的遍历\n\n接下来的判断过程其实比较容易，注意一个细节即可：如果遇到 黑卒-p，加 1 后也是需要进行返回的，否则会有问题\n\n---\n\n## 59. 螺旋矩阵 II\n\n题目描述：\n\n给一个正整数 n，可以用 1 到 n^2的所有元素，填满一个 nxn 的正方形矩阵\n\n要求：\n\n填满的顺序应该是螺旋的，比如：\n\n![matrix_img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n\n---\n\n贪心法：四方向 - 碰壁法\n\n碰壁，改变移动方向\n\n设置了四个方向的移动模式，这一点和 999 题（上面一题）是完全相同的\n\n也需要进行模式切换，但是问题是什么时候需要切换模式呢？\n\n---\n\n方法一：贪心\n\n- 到边界需要切换\n- 原本要去的下一个位置有数字了需要进行切换\n\n怎么样检测是不是到了边界？\n\n- 现在的位置到了 n-1 ，说明是一个边界\n- 下一个位置到了 n，说明是一个边界\n\n怎么样检测下一个位置是不是0？\n\n- 首先要按照原来的模式求出下一个位置的坐标\n- 然后看下一个位置是不是0\n\n这样一来，就需要先用一个假的位置 next_i，next_j先求一边下一个位置的坐标，并且同时判断是不是超出了边界，是不是0，好的一点是，这样可以直接进行模式的判断和修改\n\n然后最后再对真正的位置 i，j 进行修改\n\n---\n\n方法二：数学\n\n观察一下可以发现，每次进行模式的切换需要走过的长度是：\n\nn, n-1, n-1, n-2, n-2,  n-3,  n-3, n-4, …, 2, 2, 1.\n\n除了头和尾，其他位置都是需要走两个相同的长度\n\n这个其实也是可以用循环去实现出来的\n\n比如说，可以先出一个循环，能够写出上面的数组\n\n此时，什么时候需要转换模式？\n\n- 当每一条边写的数字的数量达到了数组中对应位置的数字，就说明这条边写完了，需要写下一条了\n\n这种方法不需要判断下一个位置是不是满了，只需要计数，还是会占一点时间，但是空间上可能会小一点点\n\n# <!-- 递归 -->\n\n## 222. 完全二叉树的节点个数\n\n给你一棵二叉树的根节点 root，求出该树的节点个数\n\n比如：\n\n![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)\n\n输入： root = [1, 2, 3, 4, 5, 6]\n\n输出：6\n\n这个题的输入是 TreeNode，所以不能按照普通的数组进行对待\n\n按照正常的递归方法，非常简单\n\n```python\nclass Solution:\n    def countNodes(self, root: TreeNode) -> int:\n        if not root: return 0\n        else: return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n```\n\n只有2行代码\n\n如果 root 是空，说明到底了，返回0\n\n如果不是空，自身是一个节点 +1，然后计算左子树和右子树\n\n完美通过\n\n![image-20210316194121543](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210316194121543.png)\n\n递归的空间占的大了一点，但是耗时还可以\n\n---\n\n观看题解：\n\n1. 对于没有约束的二叉树，递归当然是没有问题的\n2. 但是本题说的是 **完全二叉树**\n\n**完全二叉树**\n\n特点：叶子节点只出现在最后两层，最后一层如果不满，则叶子节点只在最左侧，或者是空树\n\n如果是**满二叉树**，那么总节点数 =  2*h -1，h 是层数\n\n所以完全二叉树最好是利用好结构特点\n\n---\n\n本次更新距离上次更新比较久，期间经过一系列的算法学习，有了一定的认识和进步，LeetCode刷题数量也已经达到了77题，目前正处于春招当中，继续加油吧！\n\n","slug":"LeetCode刷题笔记六","published":1,"updated":"2021-03-18T01:50:09.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n89i0045k8tlc94t6zsi","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><!-- 双指针 --></h1><h2 id=\"424-替换后的最长重复字符\"><a href=\"#424-替换后的最长重复字符\" class=\"headerlink\" title=\"424. 替换后的最长重复字符\"></a>424. 替换后的最长重复字符</h2><p>输入：字符串 s，全部是大写字母； 整数 k</p>\n<p>要求：最多可以将字符串s中的任意 k 个字符进行替换</p>\n<p>输出：最长重复字符的数量</p>\n<hr>\n<h3 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>官方题解的方法确实很妙：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103753750.png\" alt=\"image-20210202103753750\"></p>\n<p>如果该数值大于 k ，自然是不符合题意，那么右指针移动，左指针也移动：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103935966.png\" alt=\"image-20210202103935966\"></p>\n<p>如果数值小于等于 k，那么说明符合题意，右指针移动，左指针不用移动：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202104027261.png\" alt=\"image-20210202104027261\"></p>\n<p>右指针 - 左指针 就是最长重复子字符串的长度</p>\n<p><strong>问题在于，怎么计算区间内非重复字符的数量？</strong></p>\n<a id=\"more\"></a>\n<p>从代码来看，每次移动右指针后，都是以右指针的新字符作为标准，认为该字符就是最多的字符</p>\n<blockquote>\n<p>参考：<a href=\"https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/</a></p>\n<p>该回答中的第二个小问题似乎回答了这一点</p>\n</blockquote>\n<p>如果右边界读到了移出左边界的字符，那么最长子串得以被正确维护</p>\n<p>如果右边界不是移出左边界的字符，要让子串更长，总长度肯定要比之前的值还要长，也不会错过最优解</p>\n<p>这个回答还是稍微有点拐弯。</p>\n<blockquote>\n<p>还有一个细节，就是再移动左端点的时候，当然也会把左端点排除出去</p>\n<p>也就是说永远只统计区间内各数值的情况</p>\n</blockquote>\n<p><strong>此外，如何更新最长子串长度值maxCount？</strong></p>\n<p>这要对比右端点的重复情况与当前最大子串长度</p>\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. 接雨水</h2><p>输入：一个整数数组，表示的是一些柱子的高度</p>\n<p>要求：如果两根高柱子之间有矮柱子，或者有空隙，那么就可以存储雨水</p>\n<p>输出：总共能够存储的雨水的最大量是多少</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/rainwatertrap.png\" alt=\"rainwatertrap\"></p>\n<p><strong>本质</strong>：</p>\n<p>对于每一个位置，需要知道该位置左边的最高高度，和右边的最高高度，像木桶原理一样决定了当前位置能够存储的水量</p>\n<p><strong>暴力解法</strong>：</p>\n<p>每到一个位置，进行遍历</p>\n<p><strong>稍微优化</strong>：</p>\n<p>那就是先通过遍历的方法记录每一个位置左侧的最大值，反向遍历记录每一个位置右侧的最大值</p>\n<p>如果该位置确实有空间，就可以计算出可以增加的水量</p>\n<p><strong>双指针方法</strong>：</p>\n<p>这个方法确实很妙</p>\n<p>（1）其实决定一个位置水量的，是最短的木板，比如说一个位置的左右都有高木板，近处的木板可能比远处还要高，但是这其实并不是很影响此处的存水量</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210204114211048.png\" alt=\"image-20210204114211048\"></p>\n<p>比如上面这张图的位置5：右侧，7位置可能比位置10还要高，但是从位置10就能看出，5位置至少可以存放2个单位的雨水</p>\n<p>（2）边界处的存水量，其实只需要一个短边就能判断</p>\n<p>比如上面的图片，left位置能不能存放雨水，我们可以简单比较一下 leftmax 和 rightmax，发现 leftmax 更小，那么leftmax就是影响更大的“短板”——minVal</p>\n<p>而且因为这个短板更靠近左边，所以对 left 位置影响更大，需要考虑left位置的情况，而不需要考虑 right 位置</p>\n<blockquote>\n<p>关键因素是，在考虑left位置的时候也需要对leftmax进行调整</p>\n<p>如果这个时候考虑 right 位置，那么可能需要 rightmax 的值，这是不太明智的（太远了）</p>\n</blockquote>\n<p>所以这样，每一次移动时：</p>\n<p>我们需要对比左右两端，找出影响比较大的短板；</p>\n<p>找出短板影响比较严重的一端（左还是右），在这一端对比短板大小和当前值的大小，看能不能存储雨水；</p>\n<p>不管能不能存储雨水，我们都需要对 当前端的max值（leftmax或者rightmax）进行更新，并且移动端点；</p>\n<p>最后当两个端点移动到中间的时候，就说明这一次遍历结束了，获得了想要的结果。</p>\n<h2 id=\"19-删除链表中的倒数第N个结点\"><a href=\"#19-删除链表中的倒数第N个结点\" class=\"headerlink\" title=\"19. 删除链表中的倒数第N个结点\"></a>19. 删除链表中的倒数第N个结点</h2><p>目标有2：</p>\n<ul>\n<li>删除倒数第N个结点【单向链表，不太可能反向进行遍历】</li>\n<li>返回头节点【如果去掉的就是头节点，所以不能直接把原来的头节点返回】</li>\n</ul>\n<p>要求：</p>\n<ul>\n<li>只扫描一次</li>\n</ul>\n<p>问题是：单向链表，怎么样实现只扫描一次呢？</p>\n<blockquote>\n<p>没想到，这也是一个双指针的问题</p>\n</blockquote>\n<p>使用两个指针，一个快，一个慢</p>\n<p>或者说保持它们之间的距离 为 n-1【n代表要删除的节点的倒数顺序号】</p>\n<p>那么当 一个节点移动到末尾的时候，另一个节点就移动到要删除的倒数第n个节点上了！【妙啊】</p>\n<p>为了更好地删除，还可以添加 <strong>哑结点</strong> 【也就是在head前的节点，指向head，这个方法确实很常用】，这样的话第二个节点就可以指向要删除的节点的前一个节点</p>\n<hr>\n<p>还有一个更绝的解答</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cur=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!head) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       head-&gt;next = removeNthFromEnd(head-&gt;next,n);</span><br><span class=\"line\">       cur++;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(n==cur) <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我现在看懂了</p>\n<p>单向链表确实没有办法实现倒序的遍历</p>\n<p>但是上面这个的做法就是每次到底，到底一次，cur+1，所以就相当于是实现了一个倒序的遍历，只不过递归套循环，时间上可能不占优势</p>\n<hr>\n<p>传统方法是</p>\n<p>先对链表遍历一遍确定总长度</p>\n<p>然后再遍历链表，删除要删的那个节点就好了</p>\n<hr>\n<p>按照以下几个步骤，应该默写出代码：</p>\n<p>（1）定义一个新的头节点【其实是哑节点】</p>\n<p>（2）定义两个指针，第一个动起来，直到两者间距达到要求</p>\n<p>（3）两个指针都动起来，直到第一个指针到结尾了</p>\n<p>（4）链表的删除就是，指向删除元素的下一个元素，那么被删除的元素自然就没有了</p>\n<p>（3）最后还要把新增的节点删除掉</p>\n<h2 id=\"75-颜色分类\"><a href=\"#75-颜色分类\" class=\"headerlink\" title=\"75. 颜色分类\"></a>75. 颜色分类</h2><p>输入：一个数组，其中只有三种整数：0，1，2</p>\n<p>要求：进行排序，原地排序，最终结果应该是 所有 0 在最前面，然后是 所有的1，最后是所有的2</p>\n<p>那么首先上来就能找到的一个想法是：</p>\n<ul>\n<li>找到0就放到最开头</li>\n<li>找到2就放到结尾</li>\n</ul>\n<p>这不就解决了排序的问题了</p>\n<p>但是问题是会多用空间</p>\n<p>所以有两个方法：</p>\n<h3 id=\"单指针\"><a href=\"#单指针\" class=\"headerlink\" title=\"单指针\"></a>单指针</h3><p>这个方法虽然需要遍历两遍，但是是基础思路，很值得学习</p>\n<p>我们设定一个 str 指针，指向所谓的开头</p>\n<p>然后从 i = 0 开始遍历数组，如果找到了 0，那么就和开头 str 进行交换，然后 str +1，这样就能保证 比str 小的部分都是0 了</p>\n<p>然后再遍历一遍，这次找1，str不要变，让str-1到xx之前都是1，就完成了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = <span class=\"number\">0</span></span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; len(nums):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">        swap(nums, i, str)</span><br><span class=\"line\">        str += <span class=\"number\">1</span></span><br><span class=\"line\">    i += <span class=\"number\">1</span></span><br><span class=\"line\">i = str</span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; len(nums):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">1</span>:</span><br><span class=\"line\">        swap(nums, i, str)</span><br><span class=\"line\">        str += <span class=\"number\">1</span></span><br><span class=\"line\">    i += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>注意细节： 第二次遍历，还是要从 str 开始，这一位并没有完成排序</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211647039.png\" alt=\"image-20210311211647039\"></p>\n<h3 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><p>接下来是双指针，只需要遍历一次</p>\n<p>这是我第一次再做题的过程中主动想到双指针</p>\n<p>但是又放弃了</p>\n<p>接着上面的方法，如果我们有两个指针，一个 p0 指向开头，一个 p2 指向结尾</p>\n<p>然后，找到 0 就插入到开头位置，找到 2 就插入到结尾的位置，这样就达到了我们想要的效果</p>\n<p>但是：</p>\n<p>和结尾换位置一定要小心，比如我们找到了 2， 和结尾换了位置，原本结尾这个数值换到了 i 的位置</p>\n<p>如果直接让 i+1，那么这一个数值就不会再被计算了！！！！</p>\n<p>所以，必须要让 新的 i 位数值，继续和新的结尾（str-1，也变化了）比较</p>\n<p>直到找到 数值的正确位置为止</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors</span><span class=\"params\">(self, nums: List[int])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p0, p2 = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt;= p2:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt;= p2 <span class=\"keyword\">and</span> nums[i] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 对 nums[i] 需要不停交换</span></span><br><span class=\"line\">                nums = self.swap(nums, i, p2)</span><br><span class=\"line\">                p2 -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums = self.swap(nums, i, p0)</span><br><span class=\"line\">                p0 += <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swap</span><span class=\"params\">(self, nums, i, j)</span>:</span></span><br><span class=\"line\">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211733805.png\" alt=\"image-20210311211733805\"></p>\n<h2 id=\"60-第k个排列\"><a href=\"#60-第k个排列\" class=\"headerlink\" title=\"60. 第k个排列\"></a>60. 第k个排列</h2><p>给出一个数字n，那么从1到n的数字，拍成一个含有n个数字的数字，有$n!$ 种排列情况【按照大小顺序排列的】</p>\n<p>【题目中限定了n:1-9】</p>\n<p>输出第k个排列</p>\n<hr>\n<p>这是一个数学问题</p>\n<p>比如说如果我知道了</p>\n<p>$n!,(n-1)!…2!,1!$</p>\n<p>那么是不是一定可以解决这个问题？</p>\n<p><code>k/(n!)</code> 是本位的大小，余数是剩下的数量，当 n 比较大的时候，这种除法还是比较麻烦的 </p>\n<p>然后 $(n-1)!=n!/n$ 这样，计算也不会太复杂</p>\n<hr>\n<p>看答案题解，有点妙：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">valid = [<span class=\"number\">1</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    order -= valid[j]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> order == <span class=\"number\">0</span>:</span><br><span class=\"line\">        ans.append(str(j))</span><br><span class=\"line\">        valid[j] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n<p>这里的order就是我说的计算出来的本位的大小，但是不是直接就是我们要的数字了，而是剩下的数字里面按顺序的一位数字</p>\n<p>这里的方法是使用了valid数组做连接，如果某一个数字已经被用了，那么valid那一位就是0，这样的话，order就会滑过该数字，就完美地实现了不重复取数的想法</p>\n<p>是非常妙，但是这个算法也有点难以想出来</p>\n<hr>\n<p>最后一点细节：</p>\n<ul>\n<li>其实这道题并不需要 n的阶乘，只需要 n-1 的阶乘</li>\n<li>为什么 k 要减 1 ？<ul>\n<li>因为第k个排列的首位数字是 $a_1 = \\frac{k-1}{(n-1)!}+1$</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><!-- 分治 --></h1><h2 id=\"215-数组中第K个最大的元素\"><a href=\"#215-数组中第K个最大的元素\" class=\"headerlink\" title=\"215. 数组中第K个最大的元素\"></a>215. 数组中第K个最大的元素</h2><p>复习</p>\n<p>欣赏官方给出的java语言的题解，主要是学习 分治思想的应用：<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/\" target=\"_blank\" rel=\"noopener\">数组中的第K个最大元素-官方题解</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A(findKthLargest) --&gt; B(quickSelect)</span><br><span class=\"line\">B --&gt; C1(randomPartition)</span><br><span class=\"line\">B --&gt; B</span><br><span class=\"line\">C1 --&gt; D1(partition)</span><br><span class=\"line\">C1 --&gt; D2(swap)</span><br><span class=\"line\">D1 --&gt; D2</span><br><span class=\"line\">C1 --&gt; D3(random.nextInt)</span><br></pre></td></tr></table></figure>\n<p>主函数：<code>findKthLargest()</code> </p>\n<ul>\n<li>直接调用 快速排序 函数</li>\n</ul>\n<p>快速排序函数：<code>quickselect()</code> 参数比较多</p>\n<ul>\n<li>a - 待排序的数组</li>\n<li>l - 左侧个数</li>\n<li>r - 右侧个数</li>\n<li>index ： len -k 就是说我们现在要找的数值，它的索引应该是 len-k</li>\n</ul>\n<p>该函数调用了 <code>randomPartition()</code> 函数：作用是</p>\n<ul>\n<li>首先 调用 <code>random.nextInt(x)</code> 生成一个范围在 0-x 内的任意正整数<ul>\n<li>这里使用的方法是 <code>i = random.nextInt(r-l+1)+l</code></li>\n<li>这里 <code>r = len -1</code>，那么这个 random 最后就是大于 l 的一个随机数值</li>\n<li>也就是说这里随机选择呢右侧的一个 位置</li>\n</ul>\n</li>\n<li>然后 <code>swap(a, i, r)</code> 就是把 <code>a[i]</code> 和 <code>a[r]</code> 互相调换位置<ul>\n<li>注意这里，i 比 l 要大，一定在当前值的右边</li>\n<li>而 r 可能是从 len -1 开始进行计算的</li>\n</ul>\n</li>\n<li>接下来交给 <code>partition</code> 函数</li>\n</ul>\n<p>说实在的，这个官方的题解一点都不容易看懂</p>\n<hr>\n<p>还是看一下第三方的题解：<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</a></p>\n<p>这个清晰多了</p>\n<p>主代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = patition(nums, left, right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == target)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[index];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index &lt; target)&#123;</span><br><span class=\"line\">        left = index + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        right = index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常契合思想，那就是如果索引小了，那就查看右边，如果索引大了，就看左边</p>\n<p>下来关键就是看这个 partition 函数，它的作用是给 nums 做一个排序，最后返回想要的 索引值</p>\n<p>这个函数其实是对 [left, right] 区间的nums 进行操作</p>\n<p>所以首先 找一个标准数 pivot， 比如 nums[left]，索引也放过来</p>\n<p>然后 从 left 开始遍历，看 nums[i] 有没有比 left 小的</p>\n<p>如果比 left 小，那肯定要把这个 nums[i] 和 nums[left] 交换一下了</p>\n<p><strong>但是，这个程序巧妙的地方是</strong> </p>\n<p>没有直接把 nums[left] 换掉</p>\n<p>而是把 nums[left] 先排除在外，然后 把小的放在前面，大的放在后面，找到了一个中间位置 j，最后直接把 nums[j] 和 nums[left] 换一下就可以</p>\n<p>就是说 [left+1, j] 都比 nums[left] 小了，(j, i] 都比 nums[left] 大，那么这个时候，就可以把 j 和 left 换一下，因为不会影响 j 位置处成功分割了左右两边，我们要的也是 这个位置 j </p>\n<blockquote>\n<p>注意这个地方， j++ 和 j += 1 是不一样的</p>\n<ul>\n<li>后面这个会直接运算，然后改变了 j 的值</li>\n<li>但是 j++ 是先用，再改变，所以暂时还没有改变</li>\n</ul>\n</blockquote>\n<p>接下来，后面说了一个问题</p>\n<p>最好是随机初始化 我们的 标准数 pivot，否则极端测试用例可能会很耗时间</p>\n<p>一个方法是，随机交换 第一个元素和后面的任意元素</p>\n<blockquote>\n<p>怪不得官方题解 上来就是一个随机交换，搞得莫名其妙</p>\n<p>现在再回头看官方题解，就会发现其实是一样的了</p>\n</blockquote>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><!-- 贪心 --></h1><h2 id=\"984-不含AAA或BBB的字符串\"><a href=\"#984-不含AAA或BBB的字符串\" class=\"headerlink\" title=\"984. 不含AAA或BBB的字符串\"></a>984. 不含AAA或BBB的字符串</h2><p>输入：a 的数量m，b 的数量n</p>\n<p>要求：写一个字符串，其中有 m个a和n个b，但是不能出现连续 3个a，或者 3个b</p>\n<hr>\n<p>我自己的思路：</p>\n<p>我曾在脑海中冒出过以下想法：</p>\n<p>哈希表-斗地主问题 —— 发现问题在于不能顾头不顾尾</p>\n<p>贪心算法 —— 想先找出所有的对a，然后往里面插入 b【超时了】</p>\n<p>动态规划，不知道是不是</p>\n<p>还想了双指针，但是不行</p>\n<p>总的来说，贪心应该是的，但是应该怎么贪心</p>\n<hr>\n<p>按我说的贪心算法：【首先假设 a 比 b 多】</p>\n<p>先找出所有的对a：double_a = a // 2，余数 res_a 就是剩下的a【就是0或者1】</p>\n<p>然后给b的位置就是：double_a + res_a</p>\n<p>然后对b的数量是：double_b = b % (a_block - 1)</p>\n<p>最后剩下的就是单个的b</p>\n<p>【超时了】</p>\n<blockquote>\n<p>这种方法可以称之为 插空法</p>\n<p><a href=\"https://leetcode-cn.com/problems/string-without-aaa-or-bbb/solution/tan-xin-cha-kong-by-zhang191031/\" target=\"_blank\" rel=\"noopener\">贪心+插空</a></p>\n<p>但是插孔的具体实现略有不同</p>\n</blockquote>\n<hr>\n<p>姑且不说这个方法是不是正确的</p>\n<p>其中一点确实是解题的关键： 找 a 和 b 中比较多的</p>\n<p>但是我只找了一次</p>\n<hr>\n<h3 id=\"官方题解-1\"><a href=\"#官方题解-1\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>（1）定调： 贪心算法</p>\n<p>但是，下一个写入的字母应该是当前所剩最多的待写字母，除非前两个都是它了，才改用另一个字母</p>\n<p>（2）确实使用 list，最后转 str</p>\n<p>（3）我们说写a还是b看谁更多，怎么样知道是 a 多还是 b 多呢？其实不一定要知道 a，b 的数量，只要知道下一个 写 a 还是写 b 就好了</p>\n<p>【所以就是来判断下一个是不是要写a】</p>\n<p>比如这一句：<code>writeA = ans[-1]==&#39;b&#39;</code></p>\n<p>如果<code>ans[-1]</code>是 b，那么这个writeA就是true了，就表示确实要写A</p>\n<p>还有：<code>writeA = A &gt;= B</code> </p>\n<p>就是说，如果 A 比较多，那么就写 A</p>\n<p>（4）一个大问题，不要把 b 和bb，a和aa 分开思考</p>\n<p>把 两个 a看成和一个 a 是不一样的情况，是一种错误的想法，容易走上面向过程</p>\n<p>而不是面向对象的道路</p>\n<p>这样一来就简单多了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strWithout3a3b</span><span class=\"params\">(self, a: int, b: int)</span> -&gt; str:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> b:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(ans) &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> ans[<span class=\"number\">-1</span>] == ans[<span class=\"number\">-2</span>]:</span><br><span class=\"line\">                writeA = ans[<span class=\"number\">-1</span>] == <span class=\"string\">'b'</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                writeA = a &gt;= b</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># 根据是不是 写a，来进行填写</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> writeA:</span><br><span class=\"line\">                a -= <span class=\"number\">1</span></span><br><span class=\"line\">                ans.append(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                b -= <span class=\"number\">1</span></span><br><span class=\"line\">                ans.append(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(ans)</span><br></pre></td></tr></table></figure>\n<h2 id=\"999-可以被一步捕获的棋子数\"><a href=\"#999-可以被一步捕获的棋子数\" class=\"headerlink\" title=\"999. 可以被一步捕获的棋子数\"></a>999. 可以被一步捕获的棋子数</h2><p>这道题虽然是涉及二维数组，但是确实是一道简单题</p>\n<p>问题描述：</p>\n<p>国际象棋棋盘</p>\n<p>R - 白车（只有一个），B - 白象（可能有），p - 黑卒（可能有）</p>\n<p>白车可以四个方向移动：</p>\n<ul>\n<li>如果遇到 黑卒，可以吃掉，然后停止</li>\n<li>如果遇到 白象，停止</li>\n<li>如果遇到 边界，停止</li>\n</ul>\n<p>如果给了一张棋盘，请问在该棋盘上，可以被一步捕获的棋子有多少</p>\n<hr>\n<p>分析，贪心法</p>\n<p>首先要找到白色的车 - R</p>\n<p>似乎没有什么好办法，就是遍历，最糟糕的情况 O(N)</p>\n<p>然后分别遍历四个方向，每个方向一直到底：</p>\n<ul>\n<li>如果 到边了，返回</li>\n<li>如果 到B了，返回</li>\n<li>如果 到p了，加1，返回</li>\n</ul>\n<p>这里面的四方向遍历方法是我之前学到的，这样可以重用一部分代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置一个代表四个方向的数组</span></span><br><span class=\"line\"><span class=\"comment\"># 方法1：直接设置表达式，这样其实不容易继续</span></span><br><span class=\"line\">dirc = [[i+<span class=\"number\">1</span>, j], [i<span class=\"number\">-1</span>, j], [i, j+<span class=\"number\">1</span>], [i, j<span class=\"number\">-1</span>]]</span><br><span class=\"line\"><span class=\"comment\"># 方法2：设置步长，这个方法更好</span></span><br><span class=\"line\">dirc = [[<span class=\"number\">1</span>, <span class=\"number\">0</span>], [<span class=\"number\">-1</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>], [<span class=\"number\">0</span>, <span class=\"number\">-1</span>]]</span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(len(dirc)):</span><br><span class=\"line\">    x += dirc[k][<span class=\"number\">0</span>]</span><br><span class=\"line\">    y += dirc[k][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>这样就实现了四个方向的遍历</p>\n<p>接下来的判断过程其实比较容易，注意一个细节即可：如果遇到 黑卒-p，加 1 后也是需要进行返回的，否则会有问题</p>\n<hr>\n<h2 id=\"59-螺旋矩阵-II\"><a href=\"#59-螺旋矩阵-II\" class=\"headerlink\" title=\"59. 螺旋矩阵 II\"></a>59. 螺旋矩阵 II</h2><p>题目描述：</p>\n<p>给一个正整数 n，可以用 1 到 n^2的所有元素，填满一个 nxn 的正方形矩阵</p>\n<p>要求：</p>\n<p>填满的顺序应该是螺旋的，比如：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" alt=\"matrix_img\"></p>\n<hr>\n<p>贪心法：四方向 - 碰壁法</p>\n<p>碰壁，改变移动方向</p>\n<p>设置了四个方向的移动模式，这一点和 999 题（上面一题）是完全相同的</p>\n<p>也需要进行模式切换，但是问题是什么时候需要切换模式呢？</p>\n<hr>\n<p>方法一：贪心</p>\n<ul>\n<li>到边界需要切换</li>\n<li>原本要去的下一个位置有数字了需要进行切换</li>\n</ul>\n<p>怎么样检测是不是到了边界？</p>\n<ul>\n<li>现在的位置到了 n-1 ，说明是一个边界</li>\n<li>下一个位置到了 n，说明是一个边界</li>\n</ul>\n<p>怎么样检测下一个位置是不是0？</p>\n<ul>\n<li>首先要按照原来的模式求出下一个位置的坐标</li>\n<li>然后看下一个位置是不是0</li>\n</ul>\n<p>这样一来，就需要先用一个假的位置 next_i，next_j先求一边下一个位置的坐标，并且同时判断是不是超出了边界，是不是0，好的一点是，这样可以直接进行模式的判断和修改</p>\n<p>然后最后再对真正的位置 i，j 进行修改</p>\n<hr>\n<p>方法二：数学</p>\n<p>观察一下可以发现，每次进行模式的切换需要走过的长度是：</p>\n<p>n, n-1, n-1, n-2, n-2,  n-3,  n-3, n-4, …, 2, 2, 1.</p>\n<p>除了头和尾，其他位置都是需要走两个相同的长度</p>\n<p>这个其实也是可以用循环去实现出来的</p>\n<p>比如说，可以先出一个循环，能够写出上面的数组</p>\n<p>此时，什么时候需要转换模式？</p>\n<ul>\n<li>当每一条边写的数字的数量达到了数组中对应位置的数字，就说明这条边写完了，需要写下一条了</li>\n</ul>\n<p>这种方法不需要判断下一个位置是不是满了，只需要计数，还是会占一点时间，但是空间上可能会小一点点</p>\n<h1 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><!-- 递归 --></h1><h2 id=\"222-完全二叉树的节点个数\"><a href=\"#222-完全二叉树的节点个数\" class=\"headerlink\" title=\"222. 完全二叉树的节点个数\"></a>222. 完全二叉树的节点个数</h2><p>给你一棵二叉树的根节点 root，求出该树的节点个数</p>\n<p>比如：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" alt=\"img\"></p>\n<p>输入： root = [1, 2, 3, 4, 5, 6]</p>\n<p>输出：6</p>\n<p>这个题的输入是 TreeNode，所以不能按照普通的数组进行对待</p>\n<p>按照正常的递归方法，非常简单</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countNodes</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span> + self.countNodes(root.left) + self.countNodes(root.right)</span><br></pre></td></tr></table></figure>\n<p>只有2行代码</p>\n<p>如果 root 是空，说明到底了，返回0</p>\n<p>如果不是空，自身是一个节点 +1，然后计算左子树和右子树</p>\n<p>完美通过</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210316194121543.png\" alt=\"image-20210316194121543\"></p>\n<p>递归的空间占的大了一点，但是耗时还可以</p>\n<hr>\n<p>观看题解：</p>\n<ol>\n<li>对于没有约束的二叉树，递归当然是没有问题的</li>\n<li>但是本题说的是 <strong>完全二叉树</strong></li>\n</ol>\n<p><strong>完全二叉树</strong></p>\n<p>特点：叶子节点只出现在最后两层，最后一层如果不满，则叶子节点只在最左侧，或者是空树</p>\n<p>如果是<strong>满二叉树</strong>，那么总节点数 =  2*h -1，h 是层数</p>\n<p>所以完全二叉树最好是利用好结构特点</p>\n<hr>\n<p>本次更新距离上次更新比较久，期间经过一系列的算法学习，有了一定的认识和进步，LeetCode刷题数量也已经达到了77题，目前正处于春招当中，继续加油吧！</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><!-- 双指针 --></h1><h2 id=\"424-替换后的最长重复字符\"><a href=\"#424-替换后的最长重复字符\" class=\"headerlink\" title=\"424. 替换后的最长重复字符\"></a>424. 替换后的最长重复字符</h2><p>输入：字符串 s，全部是大写字母； 整数 k</p>\n<p>要求：最多可以将字符串s中的任意 k 个字符进行替换</p>\n<p>输出：最长重复字符的数量</p>\n<hr>\n<h3 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>官方题解的方法确实很妙：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103753750.png\" alt=\"image-20210202103753750\"></p>\n<p>如果该数值大于 k ，自然是不符合题意，那么右指针移动，左指针也移动：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202103935966.png\" alt=\"image-20210202103935966\"></p>\n<p>如果数值小于等于 k，那么说明符合题意，右指针移动，左指针不用移动：</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210202104027261.png\" alt=\"image-20210202104027261\"></p>\n<p>右指针 - 左指针 就是最长重复子字符串的长度</p>\n<p><strong>问题在于，怎么计算区间内非重复字符的数量？</strong></p>","more":"<p>从代码来看，每次移动右指针后，都是以右指针的新字符作为标准，认为该字符就是最多的字符</p>\n<blockquote>\n<p>参考：<a href=\"https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/</a></p>\n<p>该回答中的第二个小问题似乎回答了这一点</p>\n</blockquote>\n<p>如果右边界读到了移出左边界的字符，那么最长子串得以被正确维护</p>\n<p>如果右边界不是移出左边界的字符，要让子串更长，总长度肯定要比之前的值还要长，也不会错过最优解</p>\n<p>这个回答还是稍微有点拐弯。</p>\n<blockquote>\n<p>还有一个细节，就是再移动左端点的时候，当然也会把左端点排除出去</p>\n<p>也就是说永远只统计区间内各数值的情况</p>\n</blockquote>\n<p><strong>此外，如何更新最长子串长度值maxCount？</strong></p>\n<p>这要对比右端点的重复情况与当前最大子串长度</p>\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. 接雨水</h2><p>输入：一个整数数组，表示的是一些柱子的高度</p>\n<p>要求：如果两根高柱子之间有矮柱子，或者有空隙，那么就可以存储雨水</p>\n<p>输出：总共能够存储的雨水的最大量是多少</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/rainwatertrap.png\" alt=\"rainwatertrap\"></p>\n<p><strong>本质</strong>：</p>\n<p>对于每一个位置，需要知道该位置左边的最高高度，和右边的最高高度，像木桶原理一样决定了当前位置能够存储的水量</p>\n<p><strong>暴力解法</strong>：</p>\n<p>每到一个位置，进行遍历</p>\n<p><strong>稍微优化</strong>：</p>\n<p>那就是先通过遍历的方法记录每一个位置左侧的最大值，反向遍历记录每一个位置右侧的最大值</p>\n<p>如果该位置确实有空间，就可以计算出可以增加的水量</p>\n<p><strong>双指针方法</strong>：</p>\n<p>这个方法确实很妙</p>\n<p>（1）其实决定一个位置水量的，是最短的木板，比如说一个位置的左右都有高木板，近处的木板可能比远处还要高，但是这其实并不是很影响此处的存水量</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210204114211048.png\" alt=\"image-20210204114211048\"></p>\n<p>比如上面这张图的位置5：右侧，7位置可能比位置10还要高，但是从位置10就能看出，5位置至少可以存放2个单位的雨水</p>\n<p>（2）边界处的存水量，其实只需要一个短边就能判断</p>\n<p>比如上面的图片，left位置能不能存放雨水，我们可以简单比较一下 leftmax 和 rightmax，发现 leftmax 更小，那么leftmax就是影响更大的“短板”——minVal</p>\n<p>而且因为这个短板更靠近左边，所以对 left 位置影响更大，需要考虑left位置的情况，而不需要考虑 right 位置</p>\n<blockquote>\n<p>关键因素是，在考虑left位置的时候也需要对leftmax进行调整</p>\n<p>如果这个时候考虑 right 位置，那么可能需要 rightmax 的值，这是不太明智的（太远了）</p>\n</blockquote>\n<p>所以这样，每一次移动时：</p>\n<p>我们需要对比左右两端，找出影响比较大的短板；</p>\n<p>找出短板影响比较严重的一端（左还是右），在这一端对比短板大小和当前值的大小，看能不能存储雨水；</p>\n<p>不管能不能存储雨水，我们都需要对 当前端的max值（leftmax或者rightmax）进行更新，并且移动端点；</p>\n<p>最后当两个端点移动到中间的时候，就说明这一次遍历结束了，获得了想要的结果。</p>\n<h2 id=\"19-删除链表中的倒数第N个结点\"><a href=\"#19-删除链表中的倒数第N个结点\" class=\"headerlink\" title=\"19. 删除链表中的倒数第N个结点\"></a>19. 删除链表中的倒数第N个结点</h2><p>目标有2：</p>\n<ul>\n<li>删除倒数第N个结点【单向链表，不太可能反向进行遍历】</li>\n<li>返回头节点【如果去掉的就是头节点，所以不能直接把原来的头节点返回】</li>\n</ul>\n<p>要求：</p>\n<ul>\n<li>只扫描一次</li>\n</ul>\n<p>问题是：单向链表，怎么样实现只扫描一次呢？</p>\n<blockquote>\n<p>没想到，这也是一个双指针的问题</p>\n</blockquote>\n<p>使用两个指针，一个快，一个慢</p>\n<p>或者说保持它们之间的距离 为 n-1【n代表要删除的节点的倒数顺序号】</p>\n<p>那么当 一个节点移动到末尾的时候，另一个节点就移动到要删除的倒数第n个节点上了！【妙啊】</p>\n<p>为了更好地删除，还可以添加 <strong>哑结点</strong> 【也就是在head前的节点，指向head，这个方法确实很常用】，这样的话第二个节点就可以指向要删除的节点的前一个节点</p>\n<hr>\n<p>还有一个更绝的解答</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cur=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!head) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       head-&gt;next = removeNthFromEnd(head-&gt;next,n);</span><br><span class=\"line\">       cur++;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(n==cur) <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我现在看懂了</p>\n<p>单向链表确实没有办法实现倒序的遍历</p>\n<p>但是上面这个的做法就是每次到底，到底一次，cur+1，所以就相当于是实现了一个倒序的遍历，只不过递归套循环，时间上可能不占优势</p>\n<hr>\n<p>传统方法是</p>\n<p>先对链表遍历一遍确定总长度</p>\n<p>然后再遍历链表，删除要删的那个节点就好了</p>\n<hr>\n<p>按照以下几个步骤，应该默写出代码：</p>\n<p>（1）定义一个新的头节点【其实是哑节点】</p>\n<p>（2）定义两个指针，第一个动起来，直到两者间距达到要求</p>\n<p>（3）两个指针都动起来，直到第一个指针到结尾了</p>\n<p>（4）链表的删除就是，指向删除元素的下一个元素，那么被删除的元素自然就没有了</p>\n<p>（3）最后还要把新增的节点删除掉</p>\n<h2 id=\"75-颜色分类\"><a href=\"#75-颜色分类\" class=\"headerlink\" title=\"75. 颜色分类\"></a>75. 颜色分类</h2><p>输入：一个数组，其中只有三种整数：0，1，2</p>\n<p>要求：进行排序，原地排序，最终结果应该是 所有 0 在最前面，然后是 所有的1，最后是所有的2</p>\n<p>那么首先上来就能找到的一个想法是：</p>\n<ul>\n<li>找到0就放到最开头</li>\n<li>找到2就放到结尾</li>\n</ul>\n<p>这不就解决了排序的问题了</p>\n<p>但是问题是会多用空间</p>\n<p>所以有两个方法：</p>\n<h3 id=\"单指针\"><a href=\"#单指针\" class=\"headerlink\" title=\"单指针\"></a>单指针</h3><p>这个方法虽然需要遍历两遍，但是是基础思路，很值得学习</p>\n<p>我们设定一个 str 指针，指向所谓的开头</p>\n<p>然后从 i = 0 开始遍历数组，如果找到了 0，那么就和开头 str 进行交换，然后 str +1，这样就能保证 比str 小的部分都是0 了</p>\n<p>然后再遍历一遍，这次找1，str不要变，让str-1到xx之前都是1，就完成了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = <span class=\"number\">0</span></span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; len(nums):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">        swap(nums, i, str)</span><br><span class=\"line\">        str += <span class=\"number\">1</span></span><br><span class=\"line\">    i += <span class=\"number\">1</span></span><br><span class=\"line\">i = str</span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; len(nums):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">1</span>:</span><br><span class=\"line\">        swap(nums, i, str)</span><br><span class=\"line\">        str += <span class=\"number\">1</span></span><br><span class=\"line\">    i += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>注意细节： 第二次遍历，还是要从 str 开始，这一位并没有完成排序</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211647039.png\" alt=\"image-20210311211647039\"></p>\n<h3 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><p>接下来是双指针，只需要遍历一次</p>\n<p>这是我第一次再做题的过程中主动想到双指针</p>\n<p>但是又放弃了</p>\n<p>接着上面的方法，如果我们有两个指针，一个 p0 指向开头，一个 p2 指向结尾</p>\n<p>然后，找到 0 就插入到开头位置，找到 2 就插入到结尾的位置，这样就达到了我们想要的效果</p>\n<p>但是：</p>\n<p>和结尾换位置一定要小心，比如我们找到了 2， 和结尾换了位置，原本结尾这个数值换到了 i 的位置</p>\n<p>如果直接让 i+1，那么这一个数值就不会再被计算了！！！！</p>\n<p>所以，必须要让 新的 i 位数值，继续和新的结尾（str-1，也变化了）比较</p>\n<p>直到找到 数值的正确位置为止</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortColors</span><span class=\"params\">(self, nums: List[int])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        p0, p2 = <span class=\"number\">0</span>, len(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt;= p2:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt;= p2 <span class=\"keyword\">and</span> nums[i] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 对 nums[i] 需要不停交换</span></span><br><span class=\"line\">                nums = self.swap(nums, i, p2)</span><br><span class=\"line\">                p2 -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                nums = self.swap(nums, i, p0)</span><br><span class=\"line\">                p0 += <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swap</span><span class=\"params\">(self, nums, i, j)</span>:</span></span><br><span class=\"line\">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210311211733805.png\" alt=\"image-20210311211733805\"></p>\n<h2 id=\"60-第k个排列\"><a href=\"#60-第k个排列\" class=\"headerlink\" title=\"60. 第k个排列\"></a>60. 第k个排列</h2><p>给出一个数字n，那么从1到n的数字，拍成一个含有n个数字的数字，有$n!$ 种排列情况【按照大小顺序排列的】</p>\n<p>【题目中限定了n:1-9】</p>\n<p>输出第k个排列</p>\n<hr>\n<p>这是一个数学问题</p>\n<p>比如说如果我知道了</p>\n<p>$n!,(n-1)!…2!,1!$</p>\n<p>那么是不是一定可以解决这个问题？</p>\n<p><code>k/(n!)</code> 是本位的大小，余数是剩下的数量，当 n 比较大的时候，这种除法还是比较麻烦的 </p>\n<p>然后 $(n-1)!=n!/n$ 这样，计算也不会太复杂</p>\n<hr>\n<p>看答案题解，有点妙：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">valid = [<span class=\"number\">1</span>] * (n + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    order -= valid[j]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> order == <span class=\"number\">0</span>:</span><br><span class=\"line\">        ans.append(str(j))</span><br><span class=\"line\">        valid[j] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n<p>这里的order就是我说的计算出来的本位的大小，但是不是直接就是我们要的数字了，而是剩下的数字里面按顺序的一位数字</p>\n<p>这里的方法是使用了valid数组做连接，如果某一个数字已经被用了，那么valid那一位就是0，这样的话，order就会滑过该数字，就完美地实现了不重复取数的想法</p>\n<p>是非常妙，但是这个算法也有点难以想出来</p>\n<hr>\n<p>最后一点细节：</p>\n<ul>\n<li>其实这道题并不需要 n的阶乘，只需要 n-1 的阶乘</li>\n<li>为什么 k 要减 1 ？<ul>\n<li>因为第k个排列的首位数字是 $a_1 = \\frac{k-1}{(n-1)!}+1$</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><!-- 分治 --></h1><h2 id=\"215-数组中第K个最大的元素\"><a href=\"#215-数组中第K个最大的元素\" class=\"headerlink\" title=\"215. 数组中第K个最大的元素\"></a>215. 数组中第K个最大的元素</h2><p>复习</p>\n<p>欣赏官方给出的java语言的题解，主要是学习 分治思想的应用：<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/\" target=\"_blank\" rel=\"noopener\">数组中的第K个最大元素-官方题解</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A(findKthLargest) --&gt; B(quickSelect)</span><br><span class=\"line\">B --&gt; C1(randomPartition)</span><br><span class=\"line\">B --&gt; B</span><br><span class=\"line\">C1 --&gt; D1(partition)</span><br><span class=\"line\">C1 --&gt; D2(swap)</span><br><span class=\"line\">D1 --&gt; D2</span><br><span class=\"line\">C1 --&gt; D3(random.nextInt)</span><br></pre></td></tr></table></figure>\n<p>主函数：<code>findKthLargest()</code> </p>\n<ul>\n<li>直接调用 快速排序 函数</li>\n</ul>\n<p>快速排序函数：<code>quickselect()</code> 参数比较多</p>\n<ul>\n<li>a - 待排序的数组</li>\n<li>l - 左侧个数</li>\n<li>r - 右侧个数</li>\n<li>index ： len -k 就是说我们现在要找的数值，它的索引应该是 len-k</li>\n</ul>\n<p>该函数调用了 <code>randomPartition()</code> 函数：作用是</p>\n<ul>\n<li>首先 调用 <code>random.nextInt(x)</code> 生成一个范围在 0-x 内的任意正整数<ul>\n<li>这里使用的方法是 <code>i = random.nextInt(r-l+1)+l</code></li>\n<li>这里 <code>r = len -1</code>，那么这个 random 最后就是大于 l 的一个随机数值</li>\n<li>也就是说这里随机选择呢右侧的一个 位置</li>\n</ul>\n</li>\n<li>然后 <code>swap(a, i, r)</code> 就是把 <code>a[i]</code> 和 <code>a[r]</code> 互相调换位置<ul>\n<li>注意这里，i 比 l 要大，一定在当前值的右边</li>\n<li>而 r 可能是从 len -1 开始进行计算的</li>\n</ul>\n</li>\n<li>接下来交给 <code>partition</code> 函数</li>\n</ul>\n<p>说实在的，这个官方的题解一点都不容易看懂</p>\n<hr>\n<p>还是看一下第三方的题解：<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</a></p>\n<p>这个清晰多了</p>\n<p>主代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = patition(nums, left, right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == target)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[index];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index &lt; target)&#123;</span><br><span class=\"line\">        left = index + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        right = index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常契合思想，那就是如果索引小了，那就查看右边，如果索引大了，就看左边</p>\n<p>下来关键就是看这个 partition 函数，它的作用是给 nums 做一个排序，最后返回想要的 索引值</p>\n<p>这个函数其实是对 [left, right] 区间的nums 进行操作</p>\n<p>所以首先 找一个标准数 pivot， 比如 nums[left]，索引也放过来</p>\n<p>然后 从 left 开始遍历，看 nums[i] 有没有比 left 小的</p>\n<p>如果比 left 小，那肯定要把这个 nums[i] 和 nums[left] 交换一下了</p>\n<p><strong>但是，这个程序巧妙的地方是</strong> </p>\n<p>没有直接把 nums[left] 换掉</p>\n<p>而是把 nums[left] 先排除在外，然后 把小的放在前面，大的放在后面，找到了一个中间位置 j，最后直接把 nums[j] 和 nums[left] 换一下就可以</p>\n<p>就是说 [left+1, j] 都比 nums[left] 小了，(j, i] 都比 nums[left] 大，那么这个时候，就可以把 j 和 left 换一下，因为不会影响 j 位置处成功分割了左右两边，我们要的也是 这个位置 j </p>\n<blockquote>\n<p>注意这个地方， j++ 和 j += 1 是不一样的</p>\n<ul>\n<li>后面这个会直接运算，然后改变了 j 的值</li>\n<li>但是 j++ 是先用，再改变，所以暂时还没有改变</li>\n</ul>\n</blockquote>\n<p>接下来，后面说了一个问题</p>\n<p>最好是随机初始化 我们的 标准数 pivot，否则极端测试用例可能会很耗时间</p>\n<p>一个方法是，随机交换 第一个元素和后面的任意元素</p>\n<blockquote>\n<p>怪不得官方题解 上来就是一个随机交换，搞得莫名其妙</p>\n<p>现在再回头看官方题解，就会发现其实是一样的了</p>\n</blockquote>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><!-- 贪心 --></h1><h2 id=\"984-不含AAA或BBB的字符串\"><a href=\"#984-不含AAA或BBB的字符串\" class=\"headerlink\" title=\"984. 不含AAA或BBB的字符串\"></a>984. 不含AAA或BBB的字符串</h2><p>输入：a 的数量m，b 的数量n</p>\n<p>要求：写一个字符串，其中有 m个a和n个b，但是不能出现连续 3个a，或者 3个b</p>\n<hr>\n<p>我自己的思路：</p>\n<p>我曾在脑海中冒出过以下想法：</p>\n<p>哈希表-斗地主问题 —— 发现问题在于不能顾头不顾尾</p>\n<p>贪心算法 —— 想先找出所有的对a，然后往里面插入 b【超时了】</p>\n<p>动态规划，不知道是不是</p>\n<p>还想了双指针，但是不行</p>\n<p>总的来说，贪心应该是的，但是应该怎么贪心</p>\n<hr>\n<p>按我说的贪心算法：【首先假设 a 比 b 多】</p>\n<p>先找出所有的对a：double_a = a // 2，余数 res_a 就是剩下的a【就是0或者1】</p>\n<p>然后给b的位置就是：double_a + res_a</p>\n<p>然后对b的数量是：double_b = b % (a_block - 1)</p>\n<p>最后剩下的就是单个的b</p>\n<p>【超时了】</p>\n<blockquote>\n<p>这种方法可以称之为 插空法</p>\n<p><a href=\"https://leetcode-cn.com/problems/string-without-aaa-or-bbb/solution/tan-xin-cha-kong-by-zhang191031/\" target=\"_blank\" rel=\"noopener\">贪心+插空</a></p>\n<p>但是插孔的具体实现略有不同</p>\n</blockquote>\n<hr>\n<p>姑且不说这个方法是不是正确的</p>\n<p>其中一点确实是解题的关键： 找 a 和 b 中比较多的</p>\n<p>但是我只找了一次</p>\n<hr>\n<h3 id=\"官方题解-1\"><a href=\"#官方题解-1\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>（1）定调： 贪心算法</p>\n<p>但是，下一个写入的字母应该是当前所剩最多的待写字母，除非前两个都是它了，才改用另一个字母</p>\n<p>（2）确实使用 list，最后转 str</p>\n<p>（3）我们说写a还是b看谁更多，怎么样知道是 a 多还是 b 多呢？其实不一定要知道 a，b 的数量，只要知道下一个 写 a 还是写 b 就好了</p>\n<p>【所以就是来判断下一个是不是要写a】</p>\n<p>比如这一句：<code>writeA = ans[-1]==&#39;b&#39;</code></p>\n<p>如果<code>ans[-1]</code>是 b，那么这个writeA就是true了，就表示确实要写A</p>\n<p>还有：<code>writeA = A &gt;= B</code> </p>\n<p>就是说，如果 A 比较多，那么就写 A</p>\n<p>（4）一个大问题，不要把 b 和bb，a和aa 分开思考</p>\n<p>把 两个 a看成和一个 a 是不一样的情况，是一种错误的想法，容易走上面向过程</p>\n<p>而不是面向对象的道路</p>\n<p>这样一来就简单多了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strWithout3a3b</span><span class=\"params\">(self, a: int, b: int)</span> -&gt; str:</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> b:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(ans) &gt;= <span class=\"number\">2</span> <span class=\"keyword\">and</span> ans[<span class=\"number\">-1</span>] == ans[<span class=\"number\">-2</span>]:</span><br><span class=\"line\">                writeA = ans[<span class=\"number\">-1</span>] == <span class=\"string\">'b'</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                writeA = a &gt;= b</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># 根据是不是 写a，来进行填写</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> writeA:</span><br><span class=\"line\">                a -= <span class=\"number\">1</span></span><br><span class=\"line\">                ans.append(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                b -= <span class=\"number\">1</span></span><br><span class=\"line\">                ans.append(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(ans)</span><br></pre></td></tr></table></figure>\n<h2 id=\"999-可以被一步捕获的棋子数\"><a href=\"#999-可以被一步捕获的棋子数\" class=\"headerlink\" title=\"999. 可以被一步捕获的棋子数\"></a>999. 可以被一步捕获的棋子数</h2><p>这道题虽然是涉及二维数组，但是确实是一道简单题</p>\n<p>问题描述：</p>\n<p>国际象棋棋盘</p>\n<p>R - 白车（只有一个），B - 白象（可能有），p - 黑卒（可能有）</p>\n<p>白车可以四个方向移动：</p>\n<ul>\n<li>如果遇到 黑卒，可以吃掉，然后停止</li>\n<li>如果遇到 白象，停止</li>\n<li>如果遇到 边界，停止</li>\n</ul>\n<p>如果给了一张棋盘，请问在该棋盘上，可以被一步捕获的棋子有多少</p>\n<hr>\n<p>分析，贪心法</p>\n<p>首先要找到白色的车 - R</p>\n<p>似乎没有什么好办法，就是遍历，最糟糕的情况 O(N)</p>\n<p>然后分别遍历四个方向，每个方向一直到底：</p>\n<ul>\n<li>如果 到边了，返回</li>\n<li>如果 到B了，返回</li>\n<li>如果 到p了，加1，返回</li>\n</ul>\n<p>这里面的四方向遍历方法是我之前学到的，这样可以重用一部分代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置一个代表四个方向的数组</span></span><br><span class=\"line\"><span class=\"comment\"># 方法1：直接设置表达式，这样其实不容易继续</span></span><br><span class=\"line\">dirc = [[i+<span class=\"number\">1</span>, j], [i<span class=\"number\">-1</span>, j], [i, j+<span class=\"number\">1</span>], [i, j<span class=\"number\">-1</span>]]</span><br><span class=\"line\"><span class=\"comment\"># 方法2：设置步长，这个方法更好</span></span><br><span class=\"line\">dirc = [[<span class=\"number\">1</span>, <span class=\"number\">0</span>], [<span class=\"number\">-1</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>], [<span class=\"number\">0</span>, <span class=\"number\">-1</span>]]</span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(len(dirc)):</span><br><span class=\"line\">    x += dirc[k][<span class=\"number\">0</span>]</span><br><span class=\"line\">    y += dirc[k][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>这样就实现了四个方向的遍历</p>\n<p>接下来的判断过程其实比较容易，注意一个细节即可：如果遇到 黑卒-p，加 1 后也是需要进行返回的，否则会有问题</p>\n<hr>\n<h2 id=\"59-螺旋矩阵-II\"><a href=\"#59-螺旋矩阵-II\" class=\"headerlink\" title=\"59. 螺旋矩阵 II\"></a>59. 螺旋矩阵 II</h2><p>题目描述：</p>\n<p>给一个正整数 n，可以用 1 到 n^2的所有元素，填满一个 nxn 的正方形矩阵</p>\n<p>要求：</p>\n<p>填满的顺序应该是螺旋的，比如：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" alt=\"matrix_img\"></p>\n<hr>\n<p>贪心法：四方向 - 碰壁法</p>\n<p>碰壁，改变移动方向</p>\n<p>设置了四个方向的移动模式，这一点和 999 题（上面一题）是完全相同的</p>\n<p>也需要进行模式切换，但是问题是什么时候需要切换模式呢？</p>\n<hr>\n<p>方法一：贪心</p>\n<ul>\n<li>到边界需要切换</li>\n<li>原本要去的下一个位置有数字了需要进行切换</li>\n</ul>\n<p>怎么样检测是不是到了边界？</p>\n<ul>\n<li>现在的位置到了 n-1 ，说明是一个边界</li>\n<li>下一个位置到了 n，说明是一个边界</li>\n</ul>\n<p>怎么样检测下一个位置是不是0？</p>\n<ul>\n<li>首先要按照原来的模式求出下一个位置的坐标</li>\n<li>然后看下一个位置是不是0</li>\n</ul>\n<p>这样一来，就需要先用一个假的位置 next_i，next_j先求一边下一个位置的坐标，并且同时判断是不是超出了边界，是不是0，好的一点是，这样可以直接进行模式的判断和修改</p>\n<p>然后最后再对真正的位置 i，j 进行修改</p>\n<hr>\n<p>方法二：数学</p>\n<p>观察一下可以发现，每次进行模式的切换需要走过的长度是：</p>\n<p>n, n-1, n-1, n-2, n-2,  n-3,  n-3, n-4, …, 2, 2, 1.</p>\n<p>除了头和尾，其他位置都是需要走两个相同的长度</p>\n<p>这个其实也是可以用循环去实现出来的</p>\n<p>比如说，可以先出一个循环，能够写出上面的数组</p>\n<p>此时，什么时候需要转换模式？</p>\n<ul>\n<li>当每一条边写的数字的数量达到了数组中对应位置的数字，就说明这条边写完了，需要写下一条了</li>\n</ul>\n<p>这种方法不需要判断下一个位置是不是满了，只需要计数，还是会占一点时间，但是空间上可能会小一点点</p>\n<h1 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><!-- 递归 --></h1><h2 id=\"222-完全二叉树的节点个数\"><a href=\"#222-完全二叉树的节点个数\" class=\"headerlink\" title=\"222. 完全二叉树的节点个数\"></a>222. 完全二叉树的节点个数</h2><p>给你一棵二叉树的根节点 root，求出该树的节点个数</p>\n<p>比如：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" alt=\"img\"></p>\n<p>输入： root = [1, 2, 3, 4, 5, 6]</p>\n<p>输出：6</p>\n<p>这个题的输入是 TreeNode，所以不能按照普通的数组进行对待</p>\n<p>按照正常的递归方法，非常简单</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countNodes</span><span class=\"params\">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span> + self.countNodes(root.left) + self.countNodes(root.right)</span><br></pre></td></tr></table></figure>\n<p>只有2行代码</p>\n<p>如果 root 是空，说明到底了，返回0</p>\n<p>如果不是空，自身是一个节点 +1，然后计算左子树和右子树</p>\n<p>完美通过</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210316194121543.png\" alt=\"image-20210316194121543\"></p>\n<p>递归的空间占的大了一点，但是耗时还可以</p>\n<hr>\n<p>观看题解：</p>\n<ol>\n<li>对于没有约束的二叉树，递归当然是没有问题的</li>\n<li>但是本题说的是 <strong>完全二叉树</strong></li>\n</ol>\n<p><strong>完全二叉树</strong></p>\n<p>特点：叶子节点只出现在最后两层，最后一层如果不满，则叶子节点只在最左侧，或者是空树</p>\n<p>如果是<strong>满二叉树</strong>，那么总节点数 =  2*h -1，h 是层数</p>\n<p>所以完全二叉树最好是利用好结构特点</p>\n<hr>\n<p>本次更新距离上次更新比较久，期间经过一系列的算法学习，有了一定的认识和进步，LeetCode刷题数量也已经达到了77题，目前正处于春招当中，继续加油吧！</p>"},{"title":"LeetCode刷题笔记（二）","date":"2020-12-06T02:53:41.000Z","_content":"\n每期10题，上一期参见[LeetCode刷题笔记（一）](https://sunyoe.github.io/2020/09/03/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/)。\n\n本期内容多以List操作和动态规划为主，同时针对链表内容结合上篇笔记进行了整理。\n\n---\n\n# 链表\n\n## 147. 对【链表】进行插入排序\n\n每次取出一个待排序元素\n\n然后将它放入已经排好的序列的合适位置【升序排列，可能有负数】\n\n关键是怎么样进行排序，从动画来看是从末尾开始进行比较，直到当前数的大小合适就可以放入了\n\n<!--more-->\n\npython中的这个链表很有意思，感受一下：\n\n```python\n## 原始定义\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n```\n\n假如说一个 链表 `head`\n\n其内容看似是 `[4, 2, 1, 3]`\n\n但是实际调用应该是 `head.val = 4` 头部的第一个数\n\n那么第二个数就应该是` head.next.val = 2`\n\n所以就要对 `head.next  `进行迭代，使用的都是同样的方法\n\n问题：\n\n- 那么怎么产生一个ListNode，继承父类吗，**如何进行实例化**\n- 可以向后推演，如何向前呢？就是当前数字的前一个是什么【找不到，因此，要从前往后地找插入点】\n\n总体推演\n\n- 每一个循环应该是head向后移动一位\n- 此时在新的listnode中也会从头开始进行比较，什么时候停\n  - 第一是比当前的值大了一点\n  - 第二是个数够了\n    - 比如当前是第 k 轮，最多只能 k-1 次比较\n    - 那么当比较的次数是 k 时，就要退出比较的部分，还要将 k 归0，以便下一次是从头开始进行比较\n    - 那么下一轮 的轮数也要进行变化，这样就会出现两个参数了\n\n时间复杂度问题\n\n- 只需要更新相邻节点的指针，时间复杂度 O(1)\n- 但是需要进行遍历链表的节点，时间复杂度 O(n)\n- 总的时间复杂度就是 $O(n^2)$\n\n【11月21日】想法\n\n（1）对比head 和head.next，如果head大，就要交换一下\n\n（2）移动head【如果**==移动==**的话，是不是还需要一个东西来存储一下】\n\n> 所以说，应该是在一个链表上，自己和自己进行比较，交换数字容易，但是移动到下一个数字应该怎么做\n>\n> 还是复制成两个链表进行比较？\n>\n> 【阅读题解】\n>\n> 发现不只是两个链表了，而是要新建几个链表用来放置数据\n\n#### 阅读题解\n\n重点的几个内容：\n\n1. **链表前的节点** —— 哑节点 —— 便于在head前插入节点`zeroHead.next = head`\n2. **已排序部分的最后一个节点 ** `lastSorted = head`\n3. **待插入元素** `current = head.next`\n4. **插入元素的位置**的前一个节点 `prev`\n\n然后的思路和上面的分析其实很像\n\n怎么样将 `current`插入到链表中呢？\n\n几种情况\n\n1. 空的链表\n2. 比较`lastSorted.val`和`current.val`的值，发现不用变化\n3. 第2步比较之后发现确实需要进行变化：\n\n```python\nlastSorted.next = current.next # 相当于把 lastSorted 向后移动了一位\ncurrent.next = prev.next # 相当于把排序的那个链表断开，从 prev 这里断开\nprev.next = current\t# 然后把 current放在了 prev 的后面\n\ncurrent = lastSorted.next # 更新将要插入的值\n```\n\n然后是判断的条件：\n\n- 计数是不太明智的方法\n- 其实从上面的分析可以看出，current才是最直接从head复制出来的东西，直接判断current是不是空的，就能终止程序\n\n可以直接判断链表是不是空的：`while curr: `如果是空的就会直接跳出\n\n> **链表的恼火之处在于不断地覆盖**\n>\n> - 每次取出来一个值的时候，是ta后面的一长串全部都被取出了\n> - 如果只想改变这一个值，就要精准地覆盖这个值后面的链表，用不同的东西覆盖得到的效果就是不同的\n>\n> **链表的神奇之处在于消失**\n>\n> - 其实你并没有把一个值赋值到链表当中\n> - 而是把它添加到了前一个元素的next中，又把ta的next全部改成了原来的元素，这样，其实你根本没有对这个值进行操作，一个新链表已经形成了，就好像这个元素消失了一样\n>\n> **几个基本操作：**\n>\n> - 把链表自己移动一位：`list_node = list_node.next`\n> - 把链表 head 的头换成另一个数字：`head.val = xxx` 固然是可以的\n> - 在链表前面添加另一个链表：`another_list_node.next = list_node`\n> - 在链表 head 的头后插入一个新的数字（其格式应该也是链表）：`curr.next = head.next; head.next = curr`【也就是先要复制后面的内容，然后再把这些内容加到head 的后面】\n> - 遍历链表：`while head.next.val <= curr.val: prev = prev.next`\n>\n> 链表总是最大限度地发挥next的作用\n\n---\n\n# 动态规划\n\n## LCP 19. 秋叶收藏集\n\n本题的好处是：替换，而不是交换，这样数学过程会简单一点\n\n现在主要考虑的就是，黄叶是不是在一起，左右是不是有红叶，感觉是动态规划\n\n3片叶子：\n\n- 找黄色的\n  - 如果没有，直接换中间的， 换一次\n  - 如果开头，要换两次\n  - 如果结尾，换两次\n  - 如果全是黄叶，换两次\n  - 如果两片黄叶在一块，换一次\n  - 两片黄叶分开，换三次\n\n有很多叶子\n\n- 找黄色的，标记为1\n- 加和？还是找到它的位置？\n- 看有没有断开？\n  - 取首项索引，末项索引\n  - 中间各项进行检测\n  - 但是这样不见得是最好的方式\n\n**【10月1日思路】按照数量来决定换还是不换**\n\n首先找出黄叶的位置（索引）\n\n> python字符串中查找的方法有四种：\n>\n> - find()，返回找到的第一个字符的索引，找不到返回 -1\n> - index()，返回找到的第一个字符的索引，找不到报错\n> - rfind()和rindex()是倒着找\n>\n> 如果是列表，那么是\n>\n> - list.index 也是找第一个匹配项的索引\n> - 用enumerate函数\n>\n> numpy可以找指定元素的索引\n>\n> - np.argwhere\n>\n> [Python从列表中找出所有元素索引的几种方法](https://blog.csdn.net/Jerry_1126/article/details/88924288?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-88924288.nonecase&utm_term=python%20%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95&spm=1000.2123.3001.4430)\n>\n> [python找出一个列表中相同元素的多个索引](https://blog.csdn.net/Kerrwy/article/details/82419132?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-3-82419132.nonecase&utm_term=python%20%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95&spm=1000.2123.3001.4430)\n>\n> [Python3 返回字符串中某个给定字符的全部索引](https://blog.csdn.net/chenhequanlalala/article/details/100991793)\n>\n> matlab中对矩阵直接判断：A>a，就能得到同样大小的矩阵，但是python似乎不可以\n\n- 取首末索引，计算中间段数量\n- 计算出黄叶数量\n\n中间段有没有红\n\n- 有\n  - 有多少红叶\n    - 红叶比黄叶多，换黄叶\n    - 红叶比黄叶少，换红叶\n    - 有一些情况，比如`yrrrryyyy`，这要怎么换，肯定是只换第一个黄叶最好\n\n特殊情况\n\n- 全是红叶，换一次\n- 全是黄叶，换两次\n- 首尾是黄叶，各处要换一次\n\n> 我做题总有一种被套住的感觉\n>\n> 被带入到了题目中，而没有跳出来\n>\n> 这个问题相当于是在分段，把集中的部分放在一起，怎么样来判断集中和零散？\n>\n> - 一种方法是首尾判断，然后确定中间是不是掺杂，掺杂则是零散，不掺杂则是集中\n> - 但是掺多掺少也是问题\n>\n> 我掌握的计数方法过少了，只有循环计数\n\n### 阅读题解\n\n动态规划\n\n分为三种状态：然后分析需要将某一片叶子变色时，当前这片叶子和之前的叶子共同作用的情况，而且需要把次数传递下去\n\n> python中的`float(\"inf\")`表示正无穷，`float(\"-inf\")`表示负无穷，可以做简单加、乘算术运算，当然结果还是inf\n\n从公式角度来说，如果用$f[i][j]$ 表示对前 i 片叶子进行操作的次数，而且当前的第 i 片叶子处于状态 j。\n\nj 有三种：0 表示前面的红色，1 表示黄色部分，2表示后面的红色部分\n\n- j = 0， 第 i 片叶子需要变成红色时，i 之前的叶子都是 j = 0 的状态\n\n  $f[i][0]=f[i-1][0]+isYellow(i)$\n\n  如果是黄色，才会增加变换的次数\n\n- j = 1，需要把第 i 片叶子变成黄色，i 之前的叶子可以是 j = 0，也可以是 j = 1\n\n  $f[i][1]=min\\{f[i-1][0], f[i-1][1]\\}+isRed(i)$\n\n  如果是红色，才会增加变换的次数\n\n- j = 2，需要把第 i 片叶子变成红色，i 之前的叶子可以是 j = 1或2\n\n  $f[i][2]=min\\{f[i-1][1], f[i-1][2]\\} + isYellow(i)$\n\n  如果是黄色，才会增加变换的次数\n\n但是问题有\n\n- 什么时候改变状态呢？\n  - 从代码来看，其实并没有改变状态\n  - 不同状态的值一直存在，只不过看选用那个状态罢了\n  - 好比说，刚开始是一片红叶，isRed(i) 会是1，这样 $f[i][1]$ 就有值了，但是等到下一次循环时，选择的是最小的那个，也就是 $f[i][0]$，而不会选择有值的这个，所以，并不影响\n  - 直到出现一篇黄叶，局势才会变化\n  - 可以自己做推演，这个方法确实很妙\n- 此外，叶子的数量必须是大于状态数量的，所以像$ f_{01}, f_{02}, f_{12}$ 其实是不存在的\n- 初始值 $f_{00}$ 也是要考虑一下的\n\n> 学习：` f = [[0, 0, 0] for _ in range(n)]`\n>\n> 这句是把 f 变成了一个n行3列的全零数组，便于后面的计算\n\n最后，注意两个问题：\n\n- range(1, n)，必须是从1开始，因为00已经在前面初始化了\n- i >= 2，要包括2，不然就会失败了\n\n## 70. 爬楼梯【经典&基础】\n\nn阶楼梯，每次可以爬1或2级台阶，问：爬完的方法有多少种\n\n【仅作为**数学问题**】\n\nn阶台阶，最多n步（1种）\n\n然后减少步数，少一步=一个2级台阶（n-1步，n-1种）\n\n少两步=2个二级台阶（n-2步，$C_{n-2}^2$）\n\n······\n\n最少也要 n/2 步（1种）\n\n- 如果 n 是偶数，最少 n/2\n- 如果 n 是奇数，最少 n+1/2\n- 不管 n 是奇数还是偶数，统统加1，然后除以2取整就好了\n\n次少要加1步（$C_{\\frac{n}{2}+1}^1$）\n\n所以总共就是\n\n偶数：$S_o(n)=C_n^0+C_{n-1}^1+C_{n-2}^2+···+C_{\\frac{n}{2}+1}^1+C_{\\frac{n}{2}}^0$【这里面的数字都是整数吗？确实都是吧】\n\n奇数：$S_j(n)=n+S_o(n-1)$【其实奇数的时候，少不了有1步代替不了，直接拎出来，剩下就是整数问题了】\n\n下来是计算问题\n\n- 传统方法是阶乘，复杂度爆炸了，不可以\n- 巧妙一点的方法，有没给有简单一点的级数？\n- 或者能不能进行转化【可能还是要回到动态规划】\n\n【动态规划怎么做】\n\n假设已经爬了 k级，i步，还有j=n-k级\n\n- 下一步爬1级，k+1级，i+1步，还剩j-1级\n- 下一步爬2级，k+2级，i+1步，还剩j-2级\n\n像一个二叉树，但是一直这样开枝散叶下去不是太妙，感觉复杂度会比较高\n\n> 动态规划问题的基本思路\n\n联系方程：例如本题，$f(x)=f(x-1)+f(x-2)$\n\n转移方程：\n\n边界条件：f(0)=0【定义】, f(1)=0【实际】\n\n…到这里，再看上面的方程，这已经成为一个很基本的数学问题了\n\n（1）不断进行滑动就可以实现了【不过这样的复杂度为什么是$O(1)$而不是$O(n)$】确实，时间复杂度是O(n)，空间复杂度是O(1)\n\n（2）使用矩阵的方法\n\n$\\left[\\begin{matrix} f(n+1) \\\\f(n)\\end{matrix}\\right]=\\left[\\begin{matrix}1 & 1\\\\1 &0\\end{matrix}\\right]\\left[\\begin{matrix}f(n)\\\\f(n-1)\\end{matrix}\\right]$\n\n那么就是要求矩阵的n次方了\n\n（3）上面的递归方程其实可以用特征方程的方式求解通项公式，当然这个感觉会稍微有一点难\n\n总结：\n\n本题形成的序列是斐波那契数列。！！所以就是求斐波那契数列了！\n\n- n比较小，可以用递归法，不做记忆化操作\n- 一般情况下用转移方程，递推、递归、滚动数组\n- n不断扩大时，需要使用矩阵快速幂的方法\n- 也可以直接使用斐波那契数列的通项公式计算\n\n使用python使用方法（1）进行解题\n\n需要有个东西记录数字\n\n终止条件是什么？f(n)是要求的数字，n是台阶的数量\n\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int: \n        a, b = 1, 1 # f(0), f(1)\n        c = a + b   # f(2)\n        times = 2   # 2\n        if n == 1:\n            return 1\n        while times < n:\n            a, b = b, c\n            c = a + b   # f(times+1)\n            times += 1\n        return c\n```\n\n这里刚开始用的是for循环，最后改成了while\n\nfor 不能这么用，for的话这是for i in range···\n\n## 53. 最大子序和\n\n输入：整数数组\n\n操作：找一个连续子数组（至少一个元素，重点是连续）\n\n输出：最大和\n\n从给的例子来看：\n\n```\n输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n**并不是遇到负数就断了**\n\n而是如果负数将这个序列和归0了，甚至是变为负数了，那么这个子序列就中断了\n\n**也不是要从头加到尾**\n\n比如开头的负数就不要了\n\n几个特例：\n\n（1）`[1]`\n\n只有一个元素，而且是正数\n\n（2）`[-1]`\n\n只有一个元素，而且是负数\n\n（3）`[-2, -1]`\n\n两个都是负数\n\n我的算法为什么会遇到上述问题：\n\n- 首先是起始项，如果选择0，那么会对全负数不友好\n- 如果选择nums[0]，也就是第一个数\n\n我其实并没有用动态规划，而是用了一种存储的方法：\n\n（1）当前值是正还是负，主要看负的情况：\n\n如果当前是负的，那么比较当前值和过去sum的大小：\n\n如果当前值稍大，那就记录当前值，如果过去值稍大，那就记录过去值\n\n（2）如果当前是正的，就要考虑过去值还需不需要了\n\n如果过去值sum是负的，那就不用加了，直接重新开始\n\n其他情况，都直接往sum上加就好了\n\n> 所以：\n>\n> - 更新开头有两种方式\n>   - sum < 0，i > 0\n>   - sum < i < 0\n>   - 总结就是 sum < 0，sum < i\n> - 遇到负数也会加，只是要把本次加负数之前的数字保存下来\n\n### 阅读题解\n\n==妙蛙种子吃了妙脆角到了米奇妙妙屋，妙到家了==\n\n这里讲的第一种方法是动态规划的方法：\n\n每一步，我们计算到该位置的最大子序和$f(i)=max\\{f(i-1)+a_i, a_i\\}$\n\n站的角度不同，我是考虑“要不要把当前的值加入 过去的序列 sum中”\n\n而这个方法则是观察每一个位置的最大子序和 ，考虑的是 “前面的子序和对我当前数值有没有用”\n\n## 198. 打家劫舍\n\n输入：非负整数数组\n\n输出：从数组中取出最大数字和的子串，要求，数字之间不能相邻\n\n这个题感觉很有意思啊\n\n钱的数量：`f(n)`，应该叫 **到第n个数值，最多的钱数**\n\n- n 表示当前字符串的长度\n\n只有两种可能：没有取当前的数字，那就等于 `f(n-1)`；如果取了当前的数值，那就等于跳过了一个数值 `f(n-2)+i`，把这两种情况比较一下，就是当前位置应该的情况\n\n`f(n) = max( f(n-2) + i, f(n-1))`\n\n初始条件：\n\n- `f(0)=0`\n- `f(1)=i`\n- `f(2)=max(f(0)+i, f(1))`\n\n==喜极而泣！！！==\n\n这是我第一次用动态规划的方法完成了解题！！！\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return sum(nums)\n        max_sum = []\n        max_sum.append(0)\n        max_sum.append(nums[0])\n        for i in range(2, len(nums)+1):\n            max_sum.append(max(max_sum[i-1], max_sum[i-2] + nums[i-1]))\n        return max_sum[-1]\n```\n\n非常完美，一次过！\n\n---\n\n# List操作\n\n## 977. 有序数组的平方\n\n定性：python排序问题\n\n给定一个非递减顺序排序的整数数组A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。\n\n这个题思考一种方法还是比较简单的：\n\n- 看绝对值，绝对值进行排序\n- 然后平方\n\n已经是非递减顺序了\n\n主要问题是有可能出现两个一样的数字\n\n还有就是绝对值一样的\n\n> 列表的排序\n>\n> `list.sort()` list 本身会被修改\n>\n> `sorted(list)` list 本身不会被修改\n\n思考其他的思路：\n\n如果能找到负数和非负数的分界线\n\n就可以进行“归并排序”：\n\n- 两个指针分别移动，选择小的那个放入其中\n\n再进一步，我们甚至不需要知道分界点在哪里，就从头和尾两端开始对比，哪个大就放在列表中，是最后一项\n\n这样也是可以的\n\n> list 中进行添加元素\n>\n> - append 在末尾添加一个\n> - extend 在列表末尾一次性追加另一个序列中的多个值\n\n## 463. 岛屿的周长\n\n输入：一个矩阵，只由0和1构成，大小不定【宽和高不会超过100】\n\n计算：0和1的接触称为边界，计算这些边界的总数\n\n在一行中，当 1 开始，就有 1 个横向边界，也会有一个 横向出的边界，也就是穿越法，穿过几次\n\n在一列中，从1开始进入边界，然后穿越边界\n\n所以关键就是检查是不是连续的？这样的计算方法感觉反而要困难一点\n\n从大的方向来说，分两次进行计算：\n\n1. 横向遍历一遍\n2. 纵向遍历一遍\n\n在每一次计算的过程中，进入1则＋1，出1的区域则+1\n\n> python中关于二维list的遍历？\n>\n> 只能使用二维索引？那复杂度有点高了\n\n或者还有一个方法：\n\n找出所有的1，然后观察周围的元素，如果有0，加个1，那就是计算周围四个元素的和，然后用4减一下，这个方法可以\n\n## 349. 两个数组的交集\n\n给定两个数组，用函数计算交集\n\n一个方法：\n\n先找出比较短的那个数组，\n\n然后针对该数组中的每一个数字，\n\n在另一个数组中找一下有没有，\n\n有的话加入交集数组，\n\n最后输出交集数组。\n\n还有更快的方法吗？\n\n> 有，两个元组可以使用 `&`直接得到交集\n>\n> 然后再使用`list`进行转化\n>\n> 前面两个之所以为元组，是因为两边都用`set`进行了去重\n\n这个方法确实是可以的，但是问题在于没有办法去重，\n\n为了去重，在计算出比较短的那个数组后，需要首先去一下重，可以使用`set(list)`，该函数会返回去重后的结果，值得注意的是转化为了元组，但是仍然可以使用`for`循环进行索引\n\n## 402. 移掉k位数字\n\n给定一个以字符串表示的非负整数num：比如“1432219”\n\n移除其中的k个数字：比如`k=3`，可以移除4，3，2\n\n使得剩下的数字最小：按上面的移除方式，最后剩下的就是1219，最小\n\n发现：\n\n- 仅仅是去除，不改变顺序\n- 如果用排列的方法，但n比较大或者k比较小的时候是比较难的\n\n发现规律：\n\n- 如果当前数字比左侧的大，就要删去\n  - 【不对，如果129，k=1，显然删9更小，但很有可能会把2删掉】\n  - 【其二，如果左边的数字大，更应该删除左边的数字，因为它让整个数字更大了】\n  - **所以官方给出的办法是找比左边数字小的数字，然后把左边的数字删掉，单调不降删最后一个就可以了**\n- 如果当前数字是0，就要删去左边的数字【此时，索引值要跳到一个不是0的位置，左边的数字也会跳】\n\n涉及两个步骤：\n\n- 第一，找出数字的位置\n- 第二，把数字去掉【怎么样更快速地去掉那一位上的数字了，而且0也要去掉】\n\n列表转字符串用join方法：\n\n`\"\".join(list)`也就是使用没有字符的方法合并list中的数值\n\n### 阅读题解\n\n官方题解的解释我觉得是很不错的\n\n其主要思路就是：\n\n- 如果当前数字比左边的小，那么就要删除左边的数字【这说明，我发现的规律还是不够严谨】\n\n需要处理的细节问题是：\n\n- 如果整列遍历完，单调不降，那么就要删除最后一个\n\n退出条件：\n\n- 整个数列已经是空的了\n- 新的栈顶元素不大于当前数字【注意这里的栈中，栈顶是队尾，栈底是队首】\n- 或者已经删除了k个数字\n\n额外情况：\n\n- 如果删除的数量不足，那么就要从最后面开始删\n- 前导0的问题，要删掉前导0\n- 如果最终数字序列为空，返回0\n\n**一个高赞题解的思路：**\n\n大致上是一致的，不过又增加了一点东西：\n\n**从丢弃和保留两个方面入手**\n\n- 也就是说先按照我们的原理丢弃一遍\n- 然后再把丢弃完毕后的list再保留我们需要的位数\n- 【这个保留操作确实是一个考验，就是说我们不能直接使用原来的list减去应该去除的数量，而是需要把字符串也给改掉】\n\n人家的方法确实是不错：\n\n- 首先用 for 循环遍历 num 中的每一个数字【我则是用index的方式进行平移】\n- 然后使用 while 进行判断，也就是实现一个不断进行删除的操作【这样就避免了嵌套或者是递归的问题】\n- 最后是活用 pop 和 append 的问题【一个减，一个加，来回推拉】\n- 针对全部都删除的特殊情况，使用一个`or` 【字符串的`or`操作？】\n\n**我觉得这个方法里面最好的一点是：**\n\n- **充分考虑到每一个数字被遍历了【for循环】**\n- **对每一个数字的操作，都操作到底，又兼顾条件【while循环】**\n- **向空列表中推拉数据，形成新的数据**\n\n> 在python中使用栈的结构：\n>\n> - 其实就是list列表\n> - `list.pop()` 用于移除列表中的一个元素（默认最后一个元素）\n>   - 输入可以是index：`list.pop(-1)`，可以没有参数\n>   - 输出，返回的是该元素的值\n> - 再用`list.append()`向列表中添加元素\n> - 还有`str.lstrip(chars)`，用于截掉字符串左边的空格或指定字符\n>\n> 字符串之间使用`or`\n>\n> - 两侧非空则取左\n> - 有非空则取另一侧\n>\n> 参考：[字符串的and和or操作](https://blog.csdn.net/weixin_46274079/article/details/108467544)\n\n我用了一种偷懒的方式，希望把原来的代码稍加修改就能实现新的目标，但是这样是很错误的，例如：`1234567890`，如果按照我的代码，首先会去除`9`，然后保留`len(num)-k`个数字，那就会删除9个数字，最后剩下的是 1 ，而不是 0\n\n第一版代码：\n\n```python\n# 冗长而不能解\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        left_num_idx = 0\n        index = 1\n        del_num = 0\n        del_num_idx = []\n        # 去除操作\n        while del_num != k and index < len(num):\n            print(num[index])\n            if num[index] < num[left_num_idx]:\n                del_num += 1\n                del_num_idx.append(left_num_idx)\n                left_num_idx = index\n            else:\n                left_num_idx = index\n            index += 1\n\n        new_num = []\n        for i in range(len(num)):\n            if i not in del_num_idx:\n                new_num.append(num[i])\n        new_num_str = \"\".join(new_num)\n\n        # 保留操作，避免去除的数量不够\n        new_num_str = new_num_str[:len(num)-k].lstrip('0')\n\n        if not len(new_num_str):\n            new_num_str = '0'\n        return new_num_str\n```\n\n新的代码思路：\n\n- 要删除左侧较大的数字，而且一直要删到小于等于它为止\n- 能不能首先将数据变成一个可以进行方便删改的数据形式——比如list，按照索引进行删改确实要比str要方便的多\n\n删除的原则：\n\n- 左侧比当前的数字大\n\n那么以下几个问题：\n\n- 左侧没有了\n- 怎么跳出删除\n\n新的代码基本是照搬高赞代码：\n\n```python\nclass Solution(object):\n    def removeKdigits(self, num, k):\n        stack = []\n        remain = len(num) - k\n        for digit in num:\n            while k and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n        return ''.join(stack[:remain]).lstrip('0') or '0'\n```\n\n## 121. 买卖股票的最佳时机\n\n输入：一个数组【股票场景，第i个数字表示股票第i天价格】\n\n输出：数组中后面数字减前面的数字，能减出的最大差值【股票场景，最多一笔交易，计算获取的最大利润】\n\n给一个位置记录最大值，如果出现更大的最大值，更新记录\n\n给一个位置记录最小值，如果出现更小的最小值，最小值重新记录，最大值也重新记录？【也不对，万一后面并没有更大值了就不行了】\n\n给一个位置记录利润，当每次需要更新最小值的时候，就会刷新一下利润；循环结束之后也需要刷新一下利润\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) <= 1:\n            return 0\n        maxPrice = prices[0]\n        minPrice = prices[0]\n        profit = []\n        profit.append(maxPrice - minPrice)\n        n = 1\n        while n < len(prices):\n            if prices[n] < minPrice:\n                profit.append(maxPrice - minPrice)\n                minPrice = prices[n]\n                maxPrice = prices[n]\n                # print(profit)\n            elif prices[n] > maxPrice:\n                maxPrice = prices[n]\n            n += 1\n        profit.append(maxPrice - minPrice)\n        # print(profit)\n        return max(profit)\n```\n\n看上去这个代码好像是可以了\n\n但是，题目是真的狠，输入是10000到0倒着数，而且还写了好多0\n\n最后还是可以通过的，就是不要print！！！\n\n### 阅读题解\n\n官方题解的第二种理解，文字似乎有点问题，仔细看代码，其实和我的方法几乎是一样的原理\n\n但是官方题解没有用list去记录，而是巧妙使用max，min进行比较\n\n---\n\nOK！本期10题就先到这里了，期待下一个10题快点到来！","source":"_posts/LeetCode刷题笔记二.md","raw":"---\ntitle: LeetCode刷题笔记（二）\ndate: 2020-12-06 10:53:41\ncategories:\n\t- 算法\ntags:\n\t- LeetCode\n\t- 链表\n\t- List数组操作\n\t- 动态规划\n---\n\n每期10题，上一期参见[LeetCode刷题笔记（一）](https://sunyoe.github.io/2020/09/03/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/)。\n\n本期内容多以List操作和动态规划为主，同时针对链表内容结合上篇笔记进行了整理。\n\n---\n\n# 链表\n\n## 147. 对【链表】进行插入排序\n\n每次取出一个待排序元素\n\n然后将它放入已经排好的序列的合适位置【升序排列，可能有负数】\n\n关键是怎么样进行排序，从动画来看是从末尾开始进行比较，直到当前数的大小合适就可以放入了\n\n<!--more-->\n\npython中的这个链表很有意思，感受一下：\n\n```python\n## 原始定义\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n```\n\n假如说一个 链表 `head`\n\n其内容看似是 `[4, 2, 1, 3]`\n\n但是实际调用应该是 `head.val = 4` 头部的第一个数\n\n那么第二个数就应该是` head.next.val = 2`\n\n所以就要对 `head.next  `进行迭代，使用的都是同样的方法\n\n问题：\n\n- 那么怎么产生一个ListNode，继承父类吗，**如何进行实例化**\n- 可以向后推演，如何向前呢？就是当前数字的前一个是什么【找不到，因此，要从前往后地找插入点】\n\n总体推演\n\n- 每一个循环应该是head向后移动一位\n- 此时在新的listnode中也会从头开始进行比较，什么时候停\n  - 第一是比当前的值大了一点\n  - 第二是个数够了\n    - 比如当前是第 k 轮，最多只能 k-1 次比较\n    - 那么当比较的次数是 k 时，就要退出比较的部分，还要将 k 归0，以便下一次是从头开始进行比较\n    - 那么下一轮 的轮数也要进行变化，这样就会出现两个参数了\n\n时间复杂度问题\n\n- 只需要更新相邻节点的指针，时间复杂度 O(1)\n- 但是需要进行遍历链表的节点，时间复杂度 O(n)\n- 总的时间复杂度就是 $O(n^2)$\n\n【11月21日】想法\n\n（1）对比head 和head.next，如果head大，就要交换一下\n\n（2）移动head【如果**==移动==**的话，是不是还需要一个东西来存储一下】\n\n> 所以说，应该是在一个链表上，自己和自己进行比较，交换数字容易，但是移动到下一个数字应该怎么做\n>\n> 还是复制成两个链表进行比较？\n>\n> 【阅读题解】\n>\n> 发现不只是两个链表了，而是要新建几个链表用来放置数据\n\n#### 阅读题解\n\n重点的几个内容：\n\n1. **链表前的节点** —— 哑节点 —— 便于在head前插入节点`zeroHead.next = head`\n2. **已排序部分的最后一个节点 ** `lastSorted = head`\n3. **待插入元素** `current = head.next`\n4. **插入元素的位置**的前一个节点 `prev`\n\n然后的思路和上面的分析其实很像\n\n怎么样将 `current`插入到链表中呢？\n\n几种情况\n\n1. 空的链表\n2. 比较`lastSorted.val`和`current.val`的值，发现不用变化\n3. 第2步比较之后发现确实需要进行变化：\n\n```python\nlastSorted.next = current.next # 相当于把 lastSorted 向后移动了一位\ncurrent.next = prev.next # 相当于把排序的那个链表断开，从 prev 这里断开\nprev.next = current\t# 然后把 current放在了 prev 的后面\n\ncurrent = lastSorted.next # 更新将要插入的值\n```\n\n然后是判断的条件：\n\n- 计数是不太明智的方法\n- 其实从上面的分析可以看出，current才是最直接从head复制出来的东西，直接判断current是不是空的，就能终止程序\n\n可以直接判断链表是不是空的：`while curr: `如果是空的就会直接跳出\n\n> **链表的恼火之处在于不断地覆盖**\n>\n> - 每次取出来一个值的时候，是ta后面的一长串全部都被取出了\n> - 如果只想改变这一个值，就要精准地覆盖这个值后面的链表，用不同的东西覆盖得到的效果就是不同的\n>\n> **链表的神奇之处在于消失**\n>\n> - 其实你并没有把一个值赋值到链表当中\n> - 而是把它添加到了前一个元素的next中，又把ta的next全部改成了原来的元素，这样，其实你根本没有对这个值进行操作，一个新链表已经形成了，就好像这个元素消失了一样\n>\n> **几个基本操作：**\n>\n> - 把链表自己移动一位：`list_node = list_node.next`\n> - 把链表 head 的头换成另一个数字：`head.val = xxx` 固然是可以的\n> - 在链表前面添加另一个链表：`another_list_node.next = list_node`\n> - 在链表 head 的头后插入一个新的数字（其格式应该也是链表）：`curr.next = head.next; head.next = curr`【也就是先要复制后面的内容，然后再把这些内容加到head 的后面】\n> - 遍历链表：`while head.next.val <= curr.val: prev = prev.next`\n>\n> 链表总是最大限度地发挥next的作用\n\n---\n\n# 动态规划\n\n## LCP 19. 秋叶收藏集\n\n本题的好处是：替换，而不是交换，这样数学过程会简单一点\n\n现在主要考虑的就是，黄叶是不是在一起，左右是不是有红叶，感觉是动态规划\n\n3片叶子：\n\n- 找黄色的\n  - 如果没有，直接换中间的， 换一次\n  - 如果开头，要换两次\n  - 如果结尾，换两次\n  - 如果全是黄叶，换两次\n  - 如果两片黄叶在一块，换一次\n  - 两片黄叶分开，换三次\n\n有很多叶子\n\n- 找黄色的，标记为1\n- 加和？还是找到它的位置？\n- 看有没有断开？\n  - 取首项索引，末项索引\n  - 中间各项进行检测\n  - 但是这样不见得是最好的方式\n\n**【10月1日思路】按照数量来决定换还是不换**\n\n首先找出黄叶的位置（索引）\n\n> python字符串中查找的方法有四种：\n>\n> - find()，返回找到的第一个字符的索引，找不到返回 -1\n> - index()，返回找到的第一个字符的索引，找不到报错\n> - rfind()和rindex()是倒着找\n>\n> 如果是列表，那么是\n>\n> - list.index 也是找第一个匹配项的索引\n> - 用enumerate函数\n>\n> numpy可以找指定元素的索引\n>\n> - np.argwhere\n>\n> [Python从列表中找出所有元素索引的几种方法](https://blog.csdn.net/Jerry_1126/article/details/88924288?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-88924288.nonecase&utm_term=python%20%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95&spm=1000.2123.3001.4430)\n>\n> [python找出一个列表中相同元素的多个索引](https://blog.csdn.net/Kerrwy/article/details/82419132?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-3-82419132.nonecase&utm_term=python%20%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95&spm=1000.2123.3001.4430)\n>\n> [Python3 返回字符串中某个给定字符的全部索引](https://blog.csdn.net/chenhequanlalala/article/details/100991793)\n>\n> matlab中对矩阵直接判断：A>a，就能得到同样大小的矩阵，但是python似乎不可以\n\n- 取首末索引，计算中间段数量\n- 计算出黄叶数量\n\n中间段有没有红\n\n- 有\n  - 有多少红叶\n    - 红叶比黄叶多，换黄叶\n    - 红叶比黄叶少，换红叶\n    - 有一些情况，比如`yrrrryyyy`，这要怎么换，肯定是只换第一个黄叶最好\n\n特殊情况\n\n- 全是红叶，换一次\n- 全是黄叶，换两次\n- 首尾是黄叶，各处要换一次\n\n> 我做题总有一种被套住的感觉\n>\n> 被带入到了题目中，而没有跳出来\n>\n> 这个问题相当于是在分段，把集中的部分放在一起，怎么样来判断集中和零散？\n>\n> - 一种方法是首尾判断，然后确定中间是不是掺杂，掺杂则是零散，不掺杂则是集中\n> - 但是掺多掺少也是问题\n>\n> 我掌握的计数方法过少了，只有循环计数\n\n### 阅读题解\n\n动态规划\n\n分为三种状态：然后分析需要将某一片叶子变色时，当前这片叶子和之前的叶子共同作用的情况，而且需要把次数传递下去\n\n> python中的`float(\"inf\")`表示正无穷，`float(\"-inf\")`表示负无穷，可以做简单加、乘算术运算，当然结果还是inf\n\n从公式角度来说，如果用$f[i][j]$ 表示对前 i 片叶子进行操作的次数，而且当前的第 i 片叶子处于状态 j。\n\nj 有三种：0 表示前面的红色，1 表示黄色部分，2表示后面的红色部分\n\n- j = 0， 第 i 片叶子需要变成红色时，i 之前的叶子都是 j = 0 的状态\n\n  $f[i][0]=f[i-1][0]+isYellow(i)$\n\n  如果是黄色，才会增加变换的次数\n\n- j = 1，需要把第 i 片叶子变成黄色，i 之前的叶子可以是 j = 0，也可以是 j = 1\n\n  $f[i][1]=min\\{f[i-1][0], f[i-1][1]\\}+isRed(i)$\n\n  如果是红色，才会增加变换的次数\n\n- j = 2，需要把第 i 片叶子变成红色，i 之前的叶子可以是 j = 1或2\n\n  $f[i][2]=min\\{f[i-1][1], f[i-1][2]\\} + isYellow(i)$\n\n  如果是黄色，才会增加变换的次数\n\n但是问题有\n\n- 什么时候改变状态呢？\n  - 从代码来看，其实并没有改变状态\n  - 不同状态的值一直存在，只不过看选用那个状态罢了\n  - 好比说，刚开始是一片红叶，isRed(i) 会是1，这样 $f[i][1]$ 就有值了，但是等到下一次循环时，选择的是最小的那个，也就是 $f[i][0]$，而不会选择有值的这个，所以，并不影响\n  - 直到出现一篇黄叶，局势才会变化\n  - 可以自己做推演，这个方法确实很妙\n- 此外，叶子的数量必须是大于状态数量的，所以像$ f_{01}, f_{02}, f_{12}$ 其实是不存在的\n- 初始值 $f_{00}$ 也是要考虑一下的\n\n> 学习：` f = [[0, 0, 0] for _ in range(n)]`\n>\n> 这句是把 f 变成了一个n行3列的全零数组，便于后面的计算\n\n最后，注意两个问题：\n\n- range(1, n)，必须是从1开始，因为00已经在前面初始化了\n- i >= 2，要包括2，不然就会失败了\n\n## 70. 爬楼梯【经典&基础】\n\nn阶楼梯，每次可以爬1或2级台阶，问：爬完的方法有多少种\n\n【仅作为**数学问题**】\n\nn阶台阶，最多n步（1种）\n\n然后减少步数，少一步=一个2级台阶（n-1步，n-1种）\n\n少两步=2个二级台阶（n-2步，$C_{n-2}^2$）\n\n······\n\n最少也要 n/2 步（1种）\n\n- 如果 n 是偶数，最少 n/2\n- 如果 n 是奇数，最少 n+1/2\n- 不管 n 是奇数还是偶数，统统加1，然后除以2取整就好了\n\n次少要加1步（$C_{\\frac{n}{2}+1}^1$）\n\n所以总共就是\n\n偶数：$S_o(n)=C_n^0+C_{n-1}^1+C_{n-2}^2+···+C_{\\frac{n}{2}+1}^1+C_{\\frac{n}{2}}^0$【这里面的数字都是整数吗？确实都是吧】\n\n奇数：$S_j(n)=n+S_o(n-1)$【其实奇数的时候，少不了有1步代替不了，直接拎出来，剩下就是整数问题了】\n\n下来是计算问题\n\n- 传统方法是阶乘，复杂度爆炸了，不可以\n- 巧妙一点的方法，有没给有简单一点的级数？\n- 或者能不能进行转化【可能还是要回到动态规划】\n\n【动态规划怎么做】\n\n假设已经爬了 k级，i步，还有j=n-k级\n\n- 下一步爬1级，k+1级，i+1步，还剩j-1级\n- 下一步爬2级，k+2级，i+1步，还剩j-2级\n\n像一个二叉树，但是一直这样开枝散叶下去不是太妙，感觉复杂度会比较高\n\n> 动态规划问题的基本思路\n\n联系方程：例如本题，$f(x)=f(x-1)+f(x-2)$\n\n转移方程：\n\n边界条件：f(0)=0【定义】, f(1)=0【实际】\n\n…到这里，再看上面的方程，这已经成为一个很基本的数学问题了\n\n（1）不断进行滑动就可以实现了【不过这样的复杂度为什么是$O(1)$而不是$O(n)$】确实，时间复杂度是O(n)，空间复杂度是O(1)\n\n（2）使用矩阵的方法\n\n$\\left[\\begin{matrix} f(n+1) \\\\f(n)\\end{matrix}\\right]=\\left[\\begin{matrix}1 & 1\\\\1 &0\\end{matrix}\\right]\\left[\\begin{matrix}f(n)\\\\f(n-1)\\end{matrix}\\right]$\n\n那么就是要求矩阵的n次方了\n\n（3）上面的递归方程其实可以用特征方程的方式求解通项公式，当然这个感觉会稍微有一点难\n\n总结：\n\n本题形成的序列是斐波那契数列。！！所以就是求斐波那契数列了！\n\n- n比较小，可以用递归法，不做记忆化操作\n- 一般情况下用转移方程，递推、递归、滚动数组\n- n不断扩大时，需要使用矩阵快速幂的方法\n- 也可以直接使用斐波那契数列的通项公式计算\n\n使用python使用方法（1）进行解题\n\n需要有个东西记录数字\n\n终止条件是什么？f(n)是要求的数字，n是台阶的数量\n\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int: \n        a, b = 1, 1 # f(0), f(1)\n        c = a + b   # f(2)\n        times = 2   # 2\n        if n == 1:\n            return 1\n        while times < n:\n            a, b = b, c\n            c = a + b   # f(times+1)\n            times += 1\n        return c\n```\n\n这里刚开始用的是for循环，最后改成了while\n\nfor 不能这么用，for的话这是for i in range···\n\n## 53. 最大子序和\n\n输入：整数数组\n\n操作：找一个连续子数组（至少一个元素，重点是连续）\n\n输出：最大和\n\n从给的例子来看：\n\n```\n输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n**并不是遇到负数就断了**\n\n而是如果负数将这个序列和归0了，甚至是变为负数了，那么这个子序列就中断了\n\n**也不是要从头加到尾**\n\n比如开头的负数就不要了\n\n几个特例：\n\n（1）`[1]`\n\n只有一个元素，而且是正数\n\n（2）`[-1]`\n\n只有一个元素，而且是负数\n\n（3）`[-2, -1]`\n\n两个都是负数\n\n我的算法为什么会遇到上述问题：\n\n- 首先是起始项，如果选择0，那么会对全负数不友好\n- 如果选择nums[0]，也就是第一个数\n\n我其实并没有用动态规划，而是用了一种存储的方法：\n\n（1）当前值是正还是负，主要看负的情况：\n\n如果当前是负的，那么比较当前值和过去sum的大小：\n\n如果当前值稍大，那就记录当前值，如果过去值稍大，那就记录过去值\n\n（2）如果当前是正的，就要考虑过去值还需不需要了\n\n如果过去值sum是负的，那就不用加了，直接重新开始\n\n其他情况，都直接往sum上加就好了\n\n> 所以：\n>\n> - 更新开头有两种方式\n>   - sum < 0，i > 0\n>   - sum < i < 0\n>   - 总结就是 sum < 0，sum < i\n> - 遇到负数也会加，只是要把本次加负数之前的数字保存下来\n\n### 阅读题解\n\n==妙蛙种子吃了妙脆角到了米奇妙妙屋，妙到家了==\n\n这里讲的第一种方法是动态规划的方法：\n\n每一步，我们计算到该位置的最大子序和$f(i)=max\\{f(i-1)+a_i, a_i\\}$\n\n站的角度不同，我是考虑“要不要把当前的值加入 过去的序列 sum中”\n\n而这个方法则是观察每一个位置的最大子序和 ，考虑的是 “前面的子序和对我当前数值有没有用”\n\n## 198. 打家劫舍\n\n输入：非负整数数组\n\n输出：从数组中取出最大数字和的子串，要求，数字之间不能相邻\n\n这个题感觉很有意思啊\n\n钱的数量：`f(n)`，应该叫 **到第n个数值，最多的钱数**\n\n- n 表示当前字符串的长度\n\n只有两种可能：没有取当前的数字，那就等于 `f(n-1)`；如果取了当前的数值，那就等于跳过了一个数值 `f(n-2)+i`，把这两种情况比较一下，就是当前位置应该的情况\n\n`f(n) = max( f(n-2) + i, f(n-1))`\n\n初始条件：\n\n- `f(0)=0`\n- `f(1)=i`\n- `f(2)=max(f(0)+i, f(1))`\n\n==喜极而泣！！！==\n\n这是我第一次用动态规划的方法完成了解题！！！\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return sum(nums)\n        max_sum = []\n        max_sum.append(0)\n        max_sum.append(nums[0])\n        for i in range(2, len(nums)+1):\n            max_sum.append(max(max_sum[i-1], max_sum[i-2] + nums[i-1]))\n        return max_sum[-1]\n```\n\n非常完美，一次过！\n\n---\n\n# List操作\n\n## 977. 有序数组的平方\n\n定性：python排序问题\n\n给定一个非递减顺序排序的整数数组A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。\n\n这个题思考一种方法还是比较简单的：\n\n- 看绝对值，绝对值进行排序\n- 然后平方\n\n已经是非递减顺序了\n\n主要问题是有可能出现两个一样的数字\n\n还有就是绝对值一样的\n\n> 列表的排序\n>\n> `list.sort()` list 本身会被修改\n>\n> `sorted(list)` list 本身不会被修改\n\n思考其他的思路：\n\n如果能找到负数和非负数的分界线\n\n就可以进行“归并排序”：\n\n- 两个指针分别移动，选择小的那个放入其中\n\n再进一步，我们甚至不需要知道分界点在哪里，就从头和尾两端开始对比，哪个大就放在列表中，是最后一项\n\n这样也是可以的\n\n> list 中进行添加元素\n>\n> - append 在末尾添加一个\n> - extend 在列表末尾一次性追加另一个序列中的多个值\n\n## 463. 岛屿的周长\n\n输入：一个矩阵，只由0和1构成，大小不定【宽和高不会超过100】\n\n计算：0和1的接触称为边界，计算这些边界的总数\n\n在一行中，当 1 开始，就有 1 个横向边界，也会有一个 横向出的边界，也就是穿越法，穿过几次\n\n在一列中，从1开始进入边界，然后穿越边界\n\n所以关键就是检查是不是连续的？这样的计算方法感觉反而要困难一点\n\n从大的方向来说，分两次进行计算：\n\n1. 横向遍历一遍\n2. 纵向遍历一遍\n\n在每一次计算的过程中，进入1则＋1，出1的区域则+1\n\n> python中关于二维list的遍历？\n>\n> 只能使用二维索引？那复杂度有点高了\n\n或者还有一个方法：\n\n找出所有的1，然后观察周围的元素，如果有0，加个1，那就是计算周围四个元素的和，然后用4减一下，这个方法可以\n\n## 349. 两个数组的交集\n\n给定两个数组，用函数计算交集\n\n一个方法：\n\n先找出比较短的那个数组，\n\n然后针对该数组中的每一个数字，\n\n在另一个数组中找一下有没有，\n\n有的话加入交集数组，\n\n最后输出交集数组。\n\n还有更快的方法吗？\n\n> 有，两个元组可以使用 `&`直接得到交集\n>\n> 然后再使用`list`进行转化\n>\n> 前面两个之所以为元组，是因为两边都用`set`进行了去重\n\n这个方法确实是可以的，但是问题在于没有办法去重，\n\n为了去重，在计算出比较短的那个数组后，需要首先去一下重，可以使用`set(list)`，该函数会返回去重后的结果，值得注意的是转化为了元组，但是仍然可以使用`for`循环进行索引\n\n## 402. 移掉k位数字\n\n给定一个以字符串表示的非负整数num：比如“1432219”\n\n移除其中的k个数字：比如`k=3`，可以移除4，3，2\n\n使得剩下的数字最小：按上面的移除方式，最后剩下的就是1219，最小\n\n发现：\n\n- 仅仅是去除，不改变顺序\n- 如果用排列的方法，但n比较大或者k比较小的时候是比较难的\n\n发现规律：\n\n- 如果当前数字比左侧的大，就要删去\n  - 【不对，如果129，k=1，显然删9更小，但很有可能会把2删掉】\n  - 【其二，如果左边的数字大，更应该删除左边的数字，因为它让整个数字更大了】\n  - **所以官方给出的办法是找比左边数字小的数字，然后把左边的数字删掉，单调不降删最后一个就可以了**\n- 如果当前数字是0，就要删去左边的数字【此时，索引值要跳到一个不是0的位置，左边的数字也会跳】\n\n涉及两个步骤：\n\n- 第一，找出数字的位置\n- 第二，把数字去掉【怎么样更快速地去掉那一位上的数字了，而且0也要去掉】\n\n列表转字符串用join方法：\n\n`\"\".join(list)`也就是使用没有字符的方法合并list中的数值\n\n### 阅读题解\n\n官方题解的解释我觉得是很不错的\n\n其主要思路就是：\n\n- 如果当前数字比左边的小，那么就要删除左边的数字【这说明，我发现的规律还是不够严谨】\n\n需要处理的细节问题是：\n\n- 如果整列遍历完，单调不降，那么就要删除最后一个\n\n退出条件：\n\n- 整个数列已经是空的了\n- 新的栈顶元素不大于当前数字【注意这里的栈中，栈顶是队尾，栈底是队首】\n- 或者已经删除了k个数字\n\n额外情况：\n\n- 如果删除的数量不足，那么就要从最后面开始删\n- 前导0的问题，要删掉前导0\n- 如果最终数字序列为空，返回0\n\n**一个高赞题解的思路：**\n\n大致上是一致的，不过又增加了一点东西：\n\n**从丢弃和保留两个方面入手**\n\n- 也就是说先按照我们的原理丢弃一遍\n- 然后再把丢弃完毕后的list再保留我们需要的位数\n- 【这个保留操作确实是一个考验，就是说我们不能直接使用原来的list减去应该去除的数量，而是需要把字符串也给改掉】\n\n人家的方法确实是不错：\n\n- 首先用 for 循环遍历 num 中的每一个数字【我则是用index的方式进行平移】\n- 然后使用 while 进行判断，也就是实现一个不断进行删除的操作【这样就避免了嵌套或者是递归的问题】\n- 最后是活用 pop 和 append 的问题【一个减，一个加，来回推拉】\n- 针对全部都删除的特殊情况，使用一个`or` 【字符串的`or`操作？】\n\n**我觉得这个方法里面最好的一点是：**\n\n- **充分考虑到每一个数字被遍历了【for循环】**\n- **对每一个数字的操作，都操作到底，又兼顾条件【while循环】**\n- **向空列表中推拉数据，形成新的数据**\n\n> 在python中使用栈的结构：\n>\n> - 其实就是list列表\n> - `list.pop()` 用于移除列表中的一个元素（默认最后一个元素）\n>   - 输入可以是index：`list.pop(-1)`，可以没有参数\n>   - 输出，返回的是该元素的值\n> - 再用`list.append()`向列表中添加元素\n> - 还有`str.lstrip(chars)`，用于截掉字符串左边的空格或指定字符\n>\n> 字符串之间使用`or`\n>\n> - 两侧非空则取左\n> - 有非空则取另一侧\n>\n> 参考：[字符串的and和or操作](https://blog.csdn.net/weixin_46274079/article/details/108467544)\n\n我用了一种偷懒的方式，希望把原来的代码稍加修改就能实现新的目标，但是这样是很错误的，例如：`1234567890`，如果按照我的代码，首先会去除`9`，然后保留`len(num)-k`个数字，那就会删除9个数字，最后剩下的是 1 ，而不是 0\n\n第一版代码：\n\n```python\n# 冗长而不能解\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        left_num_idx = 0\n        index = 1\n        del_num = 0\n        del_num_idx = []\n        # 去除操作\n        while del_num != k and index < len(num):\n            print(num[index])\n            if num[index] < num[left_num_idx]:\n                del_num += 1\n                del_num_idx.append(left_num_idx)\n                left_num_idx = index\n            else:\n                left_num_idx = index\n            index += 1\n\n        new_num = []\n        for i in range(len(num)):\n            if i not in del_num_idx:\n                new_num.append(num[i])\n        new_num_str = \"\".join(new_num)\n\n        # 保留操作，避免去除的数量不够\n        new_num_str = new_num_str[:len(num)-k].lstrip('0')\n\n        if not len(new_num_str):\n            new_num_str = '0'\n        return new_num_str\n```\n\n新的代码思路：\n\n- 要删除左侧较大的数字，而且一直要删到小于等于它为止\n- 能不能首先将数据变成一个可以进行方便删改的数据形式——比如list，按照索引进行删改确实要比str要方便的多\n\n删除的原则：\n\n- 左侧比当前的数字大\n\n那么以下几个问题：\n\n- 左侧没有了\n- 怎么跳出删除\n\n新的代码基本是照搬高赞代码：\n\n```python\nclass Solution(object):\n    def removeKdigits(self, num, k):\n        stack = []\n        remain = len(num) - k\n        for digit in num:\n            while k and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n        return ''.join(stack[:remain]).lstrip('0') or '0'\n```\n\n## 121. 买卖股票的最佳时机\n\n输入：一个数组【股票场景，第i个数字表示股票第i天价格】\n\n输出：数组中后面数字减前面的数字，能减出的最大差值【股票场景，最多一笔交易，计算获取的最大利润】\n\n给一个位置记录最大值，如果出现更大的最大值，更新记录\n\n给一个位置记录最小值，如果出现更小的最小值，最小值重新记录，最大值也重新记录？【也不对，万一后面并没有更大值了就不行了】\n\n给一个位置记录利润，当每次需要更新最小值的时候，就会刷新一下利润；循环结束之后也需要刷新一下利润\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) <= 1:\n            return 0\n        maxPrice = prices[0]\n        minPrice = prices[0]\n        profit = []\n        profit.append(maxPrice - minPrice)\n        n = 1\n        while n < len(prices):\n            if prices[n] < minPrice:\n                profit.append(maxPrice - minPrice)\n                minPrice = prices[n]\n                maxPrice = prices[n]\n                # print(profit)\n            elif prices[n] > maxPrice:\n                maxPrice = prices[n]\n            n += 1\n        profit.append(maxPrice - minPrice)\n        # print(profit)\n        return max(profit)\n```\n\n看上去这个代码好像是可以了\n\n但是，题目是真的狠，输入是10000到0倒着数，而且还写了好多0\n\n最后还是可以通过的，就是不要print！！！\n\n### 阅读题解\n\n官方题解的第二种理解，文字似乎有点问题，仔细看代码，其实和我的方法几乎是一样的原理\n\n但是官方题解没有用list去记录，而是巧妙使用max，min进行比较\n\n---\n\nOK！本期10题就先到这里了，期待下一个10题快点到来！","slug":"LeetCode刷题笔记二","published":1,"updated":"2021-01-26T06:17:02.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n89w0055k8tl1htkhqql","content":"<p>每期10题，上一期参见<a href=\"https://sunyoe.github.io/2020/09/03/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/\" target=\"_blank\" rel=\"noopener\">LeetCode刷题笔记（一）</a>。</p>\n<p>本期内容多以List操作和动态规划为主，同时针对链表内容结合上篇笔记进行了整理。</p>\n<hr>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><h2 id=\"147-对【链表】进行插入排序\"><a href=\"#147-对【链表】进行插入排序\" class=\"headerlink\" title=\"147. 对【链表】进行插入排序\"></a>147. 对【链表】进行插入排序</h2><p>每次取出一个待排序元素</p>\n<p>然后将它放入已经排好的序列的合适位置【升序排列，可能有负数】</p>\n<p>关键是怎么样进行排序，从动画来看是从末尾开始进行比较，直到当前数的大小合适就可以放入了</p>\n<a id=\"more\"></a>\n<p>python中的这个链表很有意思，感受一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 原始定义</span></span><br><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        self.val = x</span><br><span class=\"line\">        self.next = <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>假如说一个 链表 <code>head</code></p>\n<p>其内容看似是 <code>[4, 2, 1, 3]</code></p>\n<p>但是实际调用应该是 <code>head.val = 4</code> 头部的第一个数</p>\n<p>那么第二个数就应该是<code>head.next.val = 2</code></p>\n<p>所以就要对 <code>head.next</code>进行迭代，使用的都是同样的方法</p>\n<p>问题：</p>\n<ul>\n<li>那么怎么产生一个ListNode，继承父类吗，<strong>如何进行实例化</strong></li>\n<li>可以向后推演，如何向前呢？就是当前数字的前一个是什么【找不到，因此，要从前往后地找插入点】</li>\n</ul>\n<p>总体推演</p>\n<ul>\n<li>每一个循环应该是head向后移动一位</li>\n<li>此时在新的listnode中也会从头开始进行比较，什么时候停<ul>\n<li>第一是比当前的值大了一点</li>\n<li>第二是个数够了<ul>\n<li>比如当前是第 k 轮，最多只能 k-1 次比较</li>\n<li>那么当比较的次数是 k 时，就要退出比较的部分，还要将 k 归0，以便下一次是从头开始进行比较</li>\n<li>那么下一轮 的轮数也要进行变化，这样就会出现两个参数了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>时间复杂度问题</p>\n<ul>\n<li>只需要更新相邻节点的指针，时间复杂度 O(1)</li>\n<li>但是需要进行遍历链表的节点，时间复杂度 O(n)</li>\n<li>总的时间复杂度就是 $O(n^2)$</li>\n</ul>\n<p>【11月21日】想法</p>\n<p>（1）对比head 和head.next，如果head大，就要交换一下</p>\n<p>（2）移动head【如果<strong>==移动==</strong>的话，是不是还需要一个东西来存储一下】</p>\n<blockquote>\n<p>所以说，应该是在一个链表上，自己和自己进行比较，交换数字容易，但是移动到下一个数字应该怎么做</p>\n<p>还是复制成两个链表进行比较？</p>\n<p>【阅读题解】</p>\n<p>发现不只是两个链表了，而是要新建几个链表用来放置数据</p>\n</blockquote>\n<h4 id=\"阅读题解\"><a href=\"#阅读题解\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h4><p>重点的几个内容：</p>\n<ol>\n<li><strong>链表前的节点</strong> —— 哑节点 —— 便于在head前插入节点<code>zeroHead.next = head</code></li>\n<li><strong>已排序部分的最后一个节点 </strong> <code>lastSorted = head</code></li>\n<li><strong>待插入元素</strong> <code>current = head.next</code></li>\n<li><strong>插入元素的位置</strong>的前一个节点 <code>prev</code></li>\n</ol>\n<p>然后的思路和上面的分析其实很像</p>\n<p>怎么样将 <code>current</code>插入到链表中呢？</p>\n<p>几种情况</p>\n<ol>\n<li>空的链表</li>\n<li>比较<code>lastSorted.val</code>和<code>current.val</code>的值，发现不用变化</li>\n<li>第2步比较之后发现确实需要进行变化：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lastSorted.next = current.next <span class=\"comment\"># 相当于把 lastSorted 向后移动了一位</span></span><br><span class=\"line\">current.next = prev.next <span class=\"comment\"># 相当于把排序的那个链表断开，从 prev 这里断开</span></span><br><span class=\"line\">prev.next = current\t<span class=\"comment\"># 然后把 current放在了 prev 的后面</span></span><br><span class=\"line\"></span><br><span class=\"line\">current = lastSorted.next <span class=\"comment\"># 更新将要插入的值</span></span><br></pre></td></tr></table></figure>\n<p>然后是判断的条件：</p>\n<ul>\n<li>计数是不太明智的方法</li>\n<li>其实从上面的分析可以看出，current才是最直接从head复制出来的东西，直接判断current是不是空的，就能终止程序</li>\n</ul>\n<p>可以直接判断链表是不是空的：<code>while curr:</code>如果是空的就会直接跳出</p>\n<blockquote>\n<p><strong>链表的恼火之处在于不断地覆盖</strong></p>\n<ul>\n<li>每次取出来一个值的时候，是ta后面的一长串全部都被取出了</li>\n<li>如果只想改变这一个值，就要精准地覆盖这个值后面的链表，用不同的东西覆盖得到的效果就是不同的</li>\n</ul>\n<p><strong>链表的神奇之处在于消失</strong></p>\n<ul>\n<li>其实你并没有把一个值赋值到链表当中</li>\n<li>而是把它添加到了前一个元素的next中，又把ta的next全部改成了原来的元素，这样，其实你根本没有对这个值进行操作，一个新链表已经形成了，就好像这个元素消失了一样</li>\n</ul>\n<p><strong>几个基本操作：</strong></p>\n<ul>\n<li>把链表自己移动一位：<code>list_node = list_node.next</code></li>\n<li>把链表 head 的头换成另一个数字：<code>head.val = xxx</code> 固然是可以的</li>\n<li>在链表前面添加另一个链表：<code>another_list_node.next = list_node</code></li>\n<li>在链表 head 的头后插入一个新的数字（其格式应该也是链表）：<code>curr.next = head.next; head.next = curr</code>【也就是先要复制后面的内容，然后再把这些内容加到head 的后面】</li>\n<li>遍历链表：<code>while head.next.val &lt;= curr.val: prev = prev.next</code></li>\n</ul>\n<p>链表总是最大限度地发挥next的作用</p>\n</blockquote>\n<hr>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"LCP-19-秋叶收藏集\"><a href=\"#LCP-19-秋叶收藏集\" class=\"headerlink\" title=\"LCP 19. 秋叶收藏集\"></a>LCP 19. 秋叶收藏集</h2><p>本题的好处是：替换，而不是交换，这样数学过程会简单一点</p>\n<p>现在主要考虑的就是，黄叶是不是在一起，左右是不是有红叶，感觉是动态规划</p>\n<p>3片叶子：</p>\n<ul>\n<li>找黄色的<ul>\n<li>如果没有，直接换中间的， 换一次</li>\n<li>如果开头，要换两次</li>\n<li>如果结尾，换两次</li>\n<li>如果全是黄叶，换两次</li>\n<li>如果两片黄叶在一块，换一次</li>\n<li>两片黄叶分开，换三次</li>\n</ul>\n</li>\n</ul>\n<p>有很多叶子</p>\n<ul>\n<li>找黄色的，标记为1</li>\n<li>加和？还是找到它的位置？</li>\n<li>看有没有断开？<ul>\n<li>取首项索引，末项索引</li>\n<li>中间各项进行检测</li>\n<li>但是这样不见得是最好的方式</li>\n</ul>\n</li>\n</ul>\n<p><strong>【10月1日思路】按照数量来决定换还是不换</strong></p>\n<p>首先找出黄叶的位置（索引）</p>\n<blockquote>\n<p>python字符串中查找的方法有四种：</p>\n<ul>\n<li>find()，返回找到的第一个字符的索引，找不到返回 -1</li>\n<li>index()，返回找到的第一个字符的索引，找不到报错</li>\n<li>rfind()和rindex()是倒着找</li>\n</ul>\n<p>如果是列表，那么是</p>\n<ul>\n<li>list.index 也是找第一个匹配项的索引</li>\n<li>用enumerate函数</li>\n</ul>\n<p>numpy可以找指定元素的索引</p>\n<ul>\n<li>np.argwhere</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/Jerry_1126/article/details/88924288?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-88924288.nonecase&amp;utm_term=python%20%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95&amp;spm=1000.2123.3001.4430\" target=\"_blank\" rel=\"noopener\">Python从列表中找出所有元素索引的几种方法</a></p>\n<p><a href=\"https://blog.csdn.net/Kerrwy/article/details/82419132?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-3-82419132.nonecase&amp;utm_term=python%20%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95&amp;spm=1000.2123.3001.4430\" target=\"_blank\" rel=\"noopener\">python找出一个列表中相同元素的多个索引</a></p>\n<p><a href=\"https://blog.csdn.net/chenhequanlalala/article/details/100991793\" target=\"_blank\" rel=\"noopener\">Python3 返回字符串中某个给定字符的全部索引</a></p>\n<p>matlab中对矩阵直接判断：A&gt;a，就能得到同样大小的矩阵，但是python似乎不可以</p>\n</blockquote>\n<ul>\n<li>取首末索引，计算中间段数量</li>\n<li>计算出黄叶数量</li>\n</ul>\n<p>中间段有没有红</p>\n<ul>\n<li>有<ul>\n<li>有多少红叶<ul>\n<li>红叶比黄叶多，换黄叶</li>\n<li>红叶比黄叶少，换红叶</li>\n<li>有一些情况，比如<code>yrrrryyyy</code>，这要怎么换，肯定是只换第一个黄叶最好</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>特殊情况</p>\n<ul>\n<li>全是红叶，换一次</li>\n<li>全是黄叶，换两次</li>\n<li>首尾是黄叶，各处要换一次</li>\n</ul>\n<blockquote>\n<p>我做题总有一种被套住的感觉</p>\n<p>被带入到了题目中，而没有跳出来</p>\n<p>这个问题相当于是在分段，把集中的部分放在一起，怎么样来判断集中和零散？</p>\n<ul>\n<li>一种方法是首尾判断，然后确定中间是不是掺杂，掺杂则是零散，不掺杂则是集中</li>\n<li>但是掺多掺少也是问题</li>\n</ul>\n<p>我掌握的计数方法过少了，只有循环计数</p>\n</blockquote>\n<h3 id=\"阅读题解-1\"><a href=\"#阅读题解-1\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>动态规划</p>\n<p>分为三种状态：然后分析需要将某一片叶子变色时，当前这片叶子和之前的叶子共同作用的情况，而且需要把次数传递下去</p>\n<blockquote>\n<p>python中的<code>float(&quot;inf&quot;)</code>表示正无穷，<code>float(&quot;-inf&quot;)</code>表示负无穷，可以做简单加、乘算术运算，当然结果还是inf</p>\n</blockquote>\n<p>从公式角度来说，如果用$f[i][j]$ 表示对前 i 片叶子进行操作的次数，而且当前的第 i 片叶子处于状态 j。</p>\n<p>j 有三种：0 表示前面的红色，1 表示黄色部分，2表示后面的红色部分</p>\n<ul>\n<li><p>j = 0， 第 i 片叶子需要变成红色时，i 之前的叶子都是 j = 0 的状态</p>\n<p>$f[i][0]=f[i-1][0]+isYellow(i)$</p>\n<p>如果是黄色，才会增加变换的次数</p>\n</li>\n<li><p>j = 1，需要把第 i 片叶子变成黄色，i 之前的叶子可以是 j = 0，也可以是 j = 1</p>\n<p>$f[i][1]=min\\{f[i-1][0], f[i-1][1]\\}+isRed(i)$</p>\n<p>如果是红色，才会增加变换的次数</p>\n</li>\n<li><p>j = 2，需要把第 i 片叶子变成红色，i 之前的叶子可以是 j = 1或2</p>\n<p>$f[i][2]=min\\{f[i-1][1], f[i-1][2]\\} + isYellow(i)$</p>\n<p>如果是黄色，才会增加变换的次数</p>\n</li>\n</ul>\n<p>但是问题有</p>\n<ul>\n<li>什么时候改变状态呢？<ul>\n<li>从代码来看，其实并没有改变状态</li>\n<li>不同状态的值一直存在，只不过看选用那个状态罢了</li>\n<li>好比说，刚开始是一片红叶，isRed(i) 会是1，这样 $f[i][1]$ 就有值了，但是等到下一次循环时，选择的是最小的那个，也就是 $f[i][0]$，而不会选择有值的这个，所以，并不影响</li>\n<li>直到出现一篇黄叶，局势才会变化</li>\n<li>可以自己做推演，这个方法确实很妙</li>\n</ul>\n</li>\n<li>此外，叶子的数量必须是大于状态数量的，所以像$ f_{01}, f_{02}, f_{12}$ 其实是不存在的</li>\n<li>初始值 $f_{00}$ 也是要考虑一下的</li>\n</ul>\n<blockquote>\n<p>学习：<code>f = [[0, 0, 0] for _ in range(n)]</code></p>\n<p>这句是把 f 变成了一个n行3列的全零数组，便于后面的计算</p>\n</blockquote>\n<p>最后，注意两个问题：</p>\n<ul>\n<li>range(1, n)，必须是从1开始，因为00已经在前面初始化了</li>\n<li>i &gt;= 2，要包括2，不然就会失败了</li>\n</ul>\n<h2 id=\"70-爬楼梯【经典-amp-基础】\"><a href=\"#70-爬楼梯【经典-amp-基础】\" class=\"headerlink\" title=\"70. 爬楼梯【经典&amp;基础】\"></a>70. 爬楼梯【经典&amp;基础】</h2><p>n阶楼梯，每次可以爬1或2级台阶，问：爬完的方法有多少种</p>\n<p>【仅作为<strong>数学问题</strong>】</p>\n<p>n阶台阶，最多n步（1种）</p>\n<p>然后减少步数，少一步=一个2级台阶（n-1步，n-1种）</p>\n<p>少两步=2个二级台阶（n-2步，$C_{n-2}^2$）</p>\n<p>······</p>\n<p>最少也要 n/2 步（1种）</p>\n<ul>\n<li>如果 n 是偶数，最少 n/2</li>\n<li>如果 n 是奇数，最少 n+1/2</li>\n<li>不管 n 是奇数还是偶数，统统加1，然后除以2取整就好了</li>\n</ul>\n<p>次少要加1步（$C_{\\frac{n}{2}+1}^1$）</p>\n<p>所以总共就是</p>\n<p>偶数：$S_o(n)=C_n^0+C_{n-1}^1+C_{n-2}^2+···+C_{\\frac{n}{2}+1}^1+C_{\\frac{n}{2}}^0$【这里面的数字都是整数吗？确实都是吧】</p>\n<p>奇数：$S_j(n)=n+S_o(n-1)$【其实奇数的时候，少不了有1步代替不了，直接拎出来，剩下就是整数问题了】</p>\n<p>下来是计算问题</p>\n<ul>\n<li>传统方法是阶乘，复杂度爆炸了，不可以</li>\n<li>巧妙一点的方法，有没给有简单一点的级数？</li>\n<li>或者能不能进行转化【可能还是要回到动态规划】</li>\n</ul>\n<p>【动态规划怎么做】</p>\n<p>假设已经爬了 k级，i步，还有j=n-k级</p>\n<ul>\n<li>下一步爬1级，k+1级，i+1步，还剩j-1级</li>\n<li>下一步爬2级，k+2级，i+1步，还剩j-2级</li>\n</ul>\n<p>像一个二叉树，但是一直这样开枝散叶下去不是太妙，感觉复杂度会比较高</p>\n<blockquote>\n<p>动态规划问题的基本思路</p>\n</blockquote>\n<p>联系方程：例如本题，$f(x)=f(x-1)+f(x-2)$</p>\n<p>转移方程：</p>\n<p>边界条件：f(0)=0【定义】, f(1)=0【实际】</p>\n<p>…到这里，再看上面的方程，这已经成为一个很基本的数学问题了</p>\n<p>（1）不断进行滑动就可以实现了【不过这样的复杂度为什么是$O(1)$而不是$O(n)$】确实，时间复杂度是O(n)，空间复杂度是O(1)</p>\n<p>（2）使用矩阵的方法</p>\n<p>$\\left[\\begin{matrix} f(n+1) \\\\f(n)\\end{matrix}\\right]=\\left[\\begin{matrix}1 &amp; 1\\\\1 &amp;0\\end{matrix}\\right]\\left[\\begin{matrix}f(n)\\\\f(n-1)\\end{matrix}\\right]$</p>\n<p>那么就是要求矩阵的n次方了</p>\n<p>（3）上面的递归方程其实可以用特征方程的方式求解通项公式，当然这个感觉会稍微有一点难</p>\n<p>总结：</p>\n<p>本题形成的序列是斐波那契数列。！！所以就是求斐波那契数列了！</p>\n<ul>\n<li>n比较小，可以用递归法，不做记忆化操作</li>\n<li>一般情况下用转移方程，递推、递归、滚动数组</li>\n<li>n不断扩大时，需要使用矩阵快速幂的方法</li>\n<li>也可以直接使用斐波那契数列的通项公式计算</li>\n</ul>\n<p>使用python使用方法（1）进行解题</p>\n<p>需要有个东西记录数字</p>\n<p>终止条件是什么？f(n)是要求的数字，n是台阶的数量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">climbStairs</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span> </span><br><span class=\"line\">        a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span> <span class=\"comment\"># f(0), f(1)</span></span><br><span class=\"line\">        c = a + b   <span class=\"comment\"># f(2)</span></span><br><span class=\"line\">        times = <span class=\"number\">2</span>   <span class=\"comment\"># 2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> times &lt; n:</span><br><span class=\"line\">            a, b = b, c</span><br><span class=\"line\">            c = a + b   <span class=\"comment\"># f(times+1)</span></span><br><span class=\"line\">            times += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> c</span><br></pre></td></tr></table></figure>\n<p>这里刚开始用的是for循环，最后改成了while</p>\n<p>for 不能这么用，for的话这是for i in range···</p>\n<h2 id=\"53-最大子序和\"><a href=\"#53-最大子序和\" class=\"headerlink\" title=\"53. 最大子序和\"></a>53. 最大子序和</h2><p>输入：整数数组</p>\n<p>操作：找一个连续子数组（至少一个元素，重点是连续）</p>\n<p>输出：最大和</p>\n<p>从给的例子来看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出: 6</span><br><span class=\"line\">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>\n<p><strong>并不是遇到负数就断了</strong></p>\n<p>而是如果负数将这个序列和归0了，甚至是变为负数了，那么这个子序列就中断了</p>\n<p><strong>也不是要从头加到尾</strong></p>\n<p>比如开头的负数就不要了</p>\n<p>几个特例：</p>\n<p>（1）<code>[1]</code></p>\n<p>只有一个元素，而且是正数</p>\n<p>（2）<code>[-1]</code></p>\n<p>只有一个元素，而且是负数</p>\n<p>（3）<code>[-2, -1]</code></p>\n<p>两个都是负数</p>\n<p>我的算法为什么会遇到上述问题：</p>\n<ul>\n<li>首先是起始项，如果选择0，那么会对全负数不友好</li>\n<li>如果选择nums[0]，也就是第一个数</li>\n</ul>\n<p>我其实并没有用动态规划，而是用了一种存储的方法：</p>\n<p>（1）当前值是正还是负，主要看负的情况：</p>\n<p>如果当前是负的，那么比较当前值和过去sum的大小：</p>\n<p>如果当前值稍大，那就记录当前值，如果过去值稍大，那就记录过去值</p>\n<p>（2）如果当前是正的，就要考虑过去值还需不需要了</p>\n<p>如果过去值sum是负的，那就不用加了，直接重新开始</p>\n<p>其他情况，都直接往sum上加就好了</p>\n<blockquote>\n<p>所以：</p>\n<ul>\n<li>更新开头有两种方式<ul>\n<li>sum &lt; 0，i &gt; 0</li>\n<li>sum &lt; i &lt; 0</li>\n<li>总结就是 sum &lt; 0，sum &lt; i</li>\n</ul>\n</li>\n<li>遇到负数也会加，只是要把本次加负数之前的数字保存下来</li>\n</ul>\n</blockquote>\n<h3 id=\"阅读题解-2\"><a href=\"#阅读题解-2\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>==妙蛙种子吃了妙脆角到了米奇妙妙屋，妙到家了==</p>\n<p>这里讲的第一种方法是动态规划的方法：</p>\n<p>每一步，我们计算到该位置的最大子序和$f(i)=max\\{f(i-1)+a_i, a_i\\}$</p>\n<p>站的角度不同，我是考虑“要不要把当前的值加入 过去的序列 sum中”</p>\n<p>而这个方法则是观察每一个位置的最大子序和 ，考虑的是 “前面的子序和对我当前数值有没有用”</p>\n<h2 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198. 打家劫舍\"></a>198. 打家劫舍</h2><p>输入：非负整数数组</p>\n<p>输出：从数组中取出最大数字和的子串，要求，数字之间不能相邻</p>\n<p>这个题感觉很有意思啊</p>\n<p>钱的数量：<code>f(n)</code>，应该叫 <strong>到第n个数值，最多的钱数</strong></p>\n<ul>\n<li>n 表示当前字符串的长度</li>\n</ul>\n<p>只有两种可能：没有取当前的数字，那就等于 <code>f(n-1)</code>；如果取了当前的数值，那就等于跳过了一个数值 <code>f(n-2)+i</code>，把这两种情况比较一下，就是当前位置应该的情况</p>\n<p><code>f(n) = max( f(n-2) + i, f(n-1))</code></p>\n<p>初始条件：</p>\n<ul>\n<li><code>f(0)=0</code></li>\n<li><code>f(1)=i</code></li>\n<li><code>f(2)=max(f(0)+i, f(1))</code></li>\n</ul>\n<p>==喜极而泣！！！==</p>\n<p>这是我第一次用动态规划的方法完成了解题！！！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum(nums)</span><br><span class=\"line\">        max_sum = []</span><br><span class=\"line\">        max_sum.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        max_sum.append(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, len(nums)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            max_sum.append(max(max_sum[i<span class=\"number\">-1</span>], max_sum[i<span class=\"number\">-2</span>] + nums[i<span class=\"number\">-1</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_sum[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>非常完美，一次过！</p>\n<hr>\n<h1 id=\"List操作\"><a href=\"#List操作\" class=\"headerlink\" title=\"List操作\"></a>List操作</h1><h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977. 有序数组的平方\"></a>977. 有序数组的平方</h2><p>定性：python排序问题</p>\n<p>给定一个非递减顺序排序的整数数组A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>\n<p>这个题思考一种方法还是比较简单的：</p>\n<ul>\n<li>看绝对值，绝对值进行排序</li>\n<li>然后平方</li>\n</ul>\n<p>已经是非递减顺序了</p>\n<p>主要问题是有可能出现两个一样的数字</p>\n<p>还有就是绝对值一样的</p>\n<blockquote>\n<p>列表的排序</p>\n<p><code>list.sort()</code> list 本身会被修改</p>\n<p><code>sorted(list)</code> list 本身不会被修改</p>\n</blockquote>\n<p>思考其他的思路：</p>\n<p>如果能找到负数和非负数的分界线</p>\n<p>就可以进行“归并排序”：</p>\n<ul>\n<li>两个指针分别移动，选择小的那个放入其中</li>\n</ul>\n<p>再进一步，我们甚至不需要知道分界点在哪里，就从头和尾两端开始对比，哪个大就放在列表中，是最后一项</p>\n<p>这样也是可以的</p>\n<blockquote>\n<p>list 中进行添加元素</p>\n<ul>\n<li>append 在末尾添加一个</li>\n<li>extend 在列表末尾一次性追加另一个序列中的多个值</li>\n</ul>\n</blockquote>\n<h2 id=\"463-岛屿的周长\"><a href=\"#463-岛屿的周长\" class=\"headerlink\" title=\"463. 岛屿的周长\"></a>463. 岛屿的周长</h2><p>输入：一个矩阵，只由0和1构成，大小不定【宽和高不会超过100】</p>\n<p>计算：0和1的接触称为边界，计算这些边界的总数</p>\n<p>在一行中，当 1 开始，就有 1 个横向边界，也会有一个 横向出的边界，也就是穿越法，穿过几次</p>\n<p>在一列中，从1开始进入边界，然后穿越边界</p>\n<p>所以关键就是检查是不是连续的？这样的计算方法感觉反而要困难一点</p>\n<p>从大的方向来说，分两次进行计算：</p>\n<ol>\n<li>横向遍历一遍</li>\n<li>纵向遍历一遍</li>\n</ol>\n<p>在每一次计算的过程中，进入1则＋1，出1的区域则+1</p>\n<blockquote>\n<p>python中关于二维list的遍历？</p>\n<p>只能使用二维索引？那复杂度有点高了</p>\n</blockquote>\n<p>或者还有一个方法：</p>\n<p>找出所有的1，然后观察周围的元素，如果有0，加个1，那就是计算周围四个元素的和，然后用4减一下，这个方法可以</p>\n<h2 id=\"349-两个数组的交集\"><a href=\"#349-两个数组的交集\" class=\"headerlink\" title=\"349. 两个数组的交集\"></a>349. 两个数组的交集</h2><p>给定两个数组，用函数计算交集</p>\n<p>一个方法：</p>\n<p>先找出比较短的那个数组，</p>\n<p>然后针对该数组中的每一个数字，</p>\n<p>在另一个数组中找一下有没有，</p>\n<p>有的话加入交集数组，</p>\n<p>最后输出交集数组。</p>\n<p>还有更快的方法吗？</p>\n<blockquote>\n<p>有，两个元组可以使用 <code>&amp;</code>直接得到交集</p>\n<p>然后再使用<code>list</code>进行转化</p>\n<p>前面两个之所以为元组，是因为两边都用<code>set</code>进行了去重</p>\n</blockquote>\n<p>这个方法确实是可以的，但是问题在于没有办法去重，</p>\n<p>为了去重，在计算出比较短的那个数组后，需要首先去一下重，可以使用<code>set(list)</code>，该函数会返回去重后的结果，值得注意的是转化为了元组，但是仍然可以使用<code>for</code>循环进行索引</p>\n<h2 id=\"402-移掉k位数字\"><a href=\"#402-移掉k位数字\" class=\"headerlink\" title=\"402. 移掉k位数字\"></a>402. 移掉k位数字</h2><p>给定一个以字符串表示的非负整数num：比如“1432219”</p>\n<p>移除其中的k个数字：比如<code>k=3</code>，可以移除4，3，2</p>\n<p>使得剩下的数字最小：按上面的移除方式，最后剩下的就是1219，最小</p>\n<p>发现：</p>\n<ul>\n<li>仅仅是去除，不改变顺序</li>\n<li>如果用排列的方法，但n比较大或者k比较小的时候是比较难的</li>\n</ul>\n<p>发现规律：</p>\n<ul>\n<li>如果当前数字比左侧的大，就要删去<ul>\n<li>【不对，如果129，k=1，显然删9更小，但很有可能会把2删掉】</li>\n<li>【其二，如果左边的数字大，更应该删除左边的数字，因为它让整个数字更大了】</li>\n<li><strong>所以官方给出的办法是找比左边数字小的数字，然后把左边的数字删掉，单调不降删最后一个就可以了</strong></li>\n</ul>\n</li>\n<li>如果当前数字是0，就要删去左边的数字【此时，索引值要跳到一个不是0的位置，左边的数字也会跳】</li>\n</ul>\n<p>涉及两个步骤：</p>\n<ul>\n<li>第一，找出数字的位置</li>\n<li>第二，把数字去掉【怎么样更快速地去掉那一位上的数字了，而且0也要去掉】</li>\n</ul>\n<p>列表转字符串用join方法：</p>\n<p><code>&quot;&quot;.join(list)</code>也就是使用没有字符的方法合并list中的数值</p>\n<h3 id=\"阅读题解-3\"><a href=\"#阅读题解-3\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>官方题解的解释我觉得是很不错的</p>\n<p>其主要思路就是：</p>\n<ul>\n<li>如果当前数字比左边的小，那么就要删除左边的数字【这说明，我发现的规律还是不够严谨】</li>\n</ul>\n<p>需要处理的细节问题是：</p>\n<ul>\n<li>如果整列遍历完，单调不降，那么就要删除最后一个</li>\n</ul>\n<p>退出条件：</p>\n<ul>\n<li>整个数列已经是空的了</li>\n<li>新的栈顶元素不大于当前数字【注意这里的栈中，栈顶是队尾，栈底是队首】</li>\n<li>或者已经删除了k个数字</li>\n</ul>\n<p>额外情况：</p>\n<ul>\n<li>如果删除的数量不足，那么就要从最后面开始删</li>\n<li>前导0的问题，要删掉前导0</li>\n<li>如果最终数字序列为空，返回0</li>\n</ul>\n<p><strong>一个高赞题解的思路：</strong></p>\n<p>大致上是一致的，不过又增加了一点东西：</p>\n<p><strong>从丢弃和保留两个方面入手</strong></p>\n<ul>\n<li>也就是说先按照我们的原理丢弃一遍</li>\n<li>然后再把丢弃完毕后的list再保留我们需要的位数</li>\n<li>【这个保留操作确实是一个考验，就是说我们不能直接使用原来的list减去应该去除的数量，而是需要把字符串也给改掉】</li>\n</ul>\n<p>人家的方法确实是不错：</p>\n<ul>\n<li>首先用 for 循环遍历 num 中的每一个数字【我则是用index的方式进行平移】</li>\n<li>然后使用 while 进行判断，也就是实现一个不断进行删除的操作【这样就避免了嵌套或者是递归的问题】</li>\n<li>最后是活用 pop 和 append 的问题【一个减，一个加，来回推拉】</li>\n<li>针对全部都删除的特殊情况，使用一个<code>or</code> 【字符串的<code>or</code>操作？】</li>\n</ul>\n<p><strong>我觉得这个方法里面最好的一点是：</strong></p>\n<ul>\n<li><strong>充分考虑到每一个数字被遍历了【for循环】</strong></li>\n<li><strong>对每一个数字的操作，都操作到底，又兼顾条件【while循环】</strong></li>\n<li><strong>向空列表中推拉数据，形成新的数据</strong></li>\n</ul>\n<blockquote>\n<p>在python中使用栈的结构：</p>\n<ul>\n<li>其实就是list列表</li>\n<li><code>list.pop()</code> 用于移除列表中的一个元素（默认最后一个元素）<ul>\n<li>输入可以是index：<code>list.pop(-1)</code>，可以没有参数</li>\n<li>输出，返回的是该元素的值</li>\n</ul>\n</li>\n<li>再用<code>list.append()</code>向列表中添加元素</li>\n<li>还有<code>str.lstrip(chars)</code>，用于截掉字符串左边的空格或指定字符</li>\n</ul>\n<p>字符串之间使用<code>or</code></p>\n<ul>\n<li>两侧非空则取左</li>\n<li>有非空则取另一侧</li>\n</ul>\n<p>参考：<a href=\"https://blog.csdn.net/weixin_46274079/article/details/108467544\" target=\"_blank\" rel=\"noopener\">字符串的and和or操作</a></p>\n</blockquote>\n<p>我用了一种偷懒的方式，希望把原来的代码稍加修改就能实现新的目标，但是这样是很错误的，例如：<code>1234567890</code>，如果按照我的代码，首先会去除<code>9</code>，然后保留<code>len(num)-k</code>个数字，那就会删除9个数字，最后剩下的是 1 ，而不是 0</p>\n<p>第一版代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 冗长而不能解</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeKdigits</span><span class=\"params\">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">        left_num_idx = <span class=\"number\">0</span></span><br><span class=\"line\">        index = <span class=\"number\">1</span></span><br><span class=\"line\">        del_num = <span class=\"number\">0</span></span><br><span class=\"line\">        del_num_idx = []</span><br><span class=\"line\">        <span class=\"comment\"># 去除操作</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> del_num != k <span class=\"keyword\">and</span> index &lt; len(num):</span><br><span class=\"line\">            print(num[index])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num[index] &lt; num[left_num_idx]:</span><br><span class=\"line\">                del_num += <span class=\"number\">1</span></span><br><span class=\"line\">                del_num_idx.append(left_num_idx)</span><br><span class=\"line\">                left_num_idx = index</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left_num_idx = index</span><br><span class=\"line\">            index += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        new_num = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(num)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> del_num_idx:</span><br><span class=\"line\">                new_num.append(num[i])</span><br><span class=\"line\">        new_num_str = <span class=\"string\">\"\"</span>.join(new_num)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 保留操作，避免去除的数量不够</span></span><br><span class=\"line\">        new_num_str = new_num_str[:len(num)-k].lstrip(<span class=\"string\">'0'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len(new_num_str):</span><br><span class=\"line\">            new_num_str = <span class=\"string\">'0'</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_num_str</span><br></pre></td></tr></table></figure>\n<p>新的代码思路：</p>\n<ul>\n<li>要删除左侧较大的数字，而且一直要删到小于等于它为止</li>\n<li>能不能首先将数据变成一个可以进行方便删改的数据形式——比如list，按照索引进行删改确实要比str要方便的多</li>\n</ul>\n<p>删除的原则：</p>\n<ul>\n<li>左侧比当前的数字大</li>\n</ul>\n<p>那么以下几个问题：</p>\n<ul>\n<li>左侧没有了</li>\n<li>怎么跳出删除</li>\n</ul>\n<p>新的代码基本是照搬高赞代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeKdigits</span><span class=\"params\">(self, num, k)</span>:</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        remain = len(num) - k</span><br><span class=\"line\">        <span class=\"keyword\">for</span> digit <span class=\"keyword\">in</span> num:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> k <span class=\"keyword\">and</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>] &gt; digit:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">            stack.append(digit)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(stack[:remain]).lstrip(<span class=\"string\">'0'</span>) <span class=\"keyword\">or</span> <span class=\"string\">'0'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"121-买卖股票的最佳时机\"><a href=\"#121-买卖股票的最佳时机\" class=\"headerlink\" title=\"121. 买卖股票的最佳时机\"></a>121. 买卖股票的最佳时机</h2><p>输入：一个数组【股票场景，第i个数字表示股票第i天价格】</p>\n<p>输出：数组中后面数字减前面的数字，能减出的最大差值【股票场景，最多一笔交易，计算获取的最大利润】</p>\n<p>给一个位置记录最大值，如果出现更大的最大值，更新记录</p>\n<p>给一个位置记录最小值，如果出现更小的最小值，最小值重新记录，最大值也重新记录？【也不对，万一后面并没有更大值了就不行了】</p>\n<p>给一个位置记录利润，当每次需要更新最小值的时候，就会刷新一下利润；循环结束之后也需要刷新一下利润</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(prices) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        maxPrice = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">        minPrice = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">        profit = []</span><br><span class=\"line\">        profit.append(maxPrice - minPrice)</span><br><span class=\"line\">        n = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> n &lt; len(prices):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> prices[n] &lt; minPrice:</span><br><span class=\"line\">                profit.append(maxPrice - minPrice)</span><br><span class=\"line\">                minPrice = prices[n]</span><br><span class=\"line\">                maxPrice = prices[n]</span><br><span class=\"line\">                <span class=\"comment\"># print(profit)</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> prices[n] &gt; maxPrice:</span><br><span class=\"line\">                maxPrice = prices[n]</span><br><span class=\"line\">            n += <span class=\"number\">1</span></span><br><span class=\"line\">        profit.append(maxPrice - minPrice)</span><br><span class=\"line\">        <span class=\"comment\"># print(profit)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(profit)</span><br></pre></td></tr></table></figure>\n<p>看上去这个代码好像是可以了</p>\n<p>但是，题目是真的狠，输入是10000到0倒着数，而且还写了好多0</p>\n<p>最后还是可以通过的，就是不要print！！！</p>\n<h3 id=\"阅读题解-4\"><a href=\"#阅读题解-4\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>官方题解的第二种理解，文字似乎有点问题，仔细看代码，其实和我的方法几乎是一样的原理</p>\n<p>但是官方题解没有用list去记录，而是巧妙使用max，min进行比较</p>\n<hr>\n<p>OK！本期10题就先到这里了，期待下一个10题快点到来！</p>\n","site":{"data":{}},"excerpt":"<p>每期10题，上一期参见<a href=\"https://sunyoe.github.io/2020/09/03/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/\" target=\"_blank\" rel=\"noopener\">LeetCode刷题笔记（一）</a>。</p>\n<p>本期内容多以List操作和动态规划为主，同时针对链表内容结合上篇笔记进行了整理。</p>\n<hr>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><h2 id=\"147-对【链表】进行插入排序\"><a href=\"#147-对【链表】进行插入排序\" class=\"headerlink\" title=\"147. 对【链表】进行插入排序\"></a>147. 对【链表】进行插入排序</h2><p>每次取出一个待排序元素</p>\n<p>然后将它放入已经排好的序列的合适位置【升序排列，可能有负数】</p>\n<p>关键是怎么样进行排序，从动画来看是从末尾开始进行比较，直到当前数的大小合适就可以放入了</p>","more":"<p>python中的这个链表很有意思，感受一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 原始定义</span></span><br><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        self.val = x</span><br><span class=\"line\">        self.next = <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>假如说一个 链表 <code>head</code></p>\n<p>其内容看似是 <code>[4, 2, 1, 3]</code></p>\n<p>但是实际调用应该是 <code>head.val = 4</code> 头部的第一个数</p>\n<p>那么第二个数就应该是<code>head.next.val = 2</code></p>\n<p>所以就要对 <code>head.next</code>进行迭代，使用的都是同样的方法</p>\n<p>问题：</p>\n<ul>\n<li>那么怎么产生一个ListNode，继承父类吗，<strong>如何进行实例化</strong></li>\n<li>可以向后推演，如何向前呢？就是当前数字的前一个是什么【找不到，因此，要从前往后地找插入点】</li>\n</ul>\n<p>总体推演</p>\n<ul>\n<li>每一个循环应该是head向后移动一位</li>\n<li>此时在新的listnode中也会从头开始进行比较，什么时候停<ul>\n<li>第一是比当前的值大了一点</li>\n<li>第二是个数够了<ul>\n<li>比如当前是第 k 轮，最多只能 k-1 次比较</li>\n<li>那么当比较的次数是 k 时，就要退出比较的部分，还要将 k 归0，以便下一次是从头开始进行比较</li>\n<li>那么下一轮 的轮数也要进行变化，这样就会出现两个参数了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>时间复杂度问题</p>\n<ul>\n<li>只需要更新相邻节点的指针，时间复杂度 O(1)</li>\n<li>但是需要进行遍历链表的节点，时间复杂度 O(n)</li>\n<li>总的时间复杂度就是 $O(n^2)$</li>\n</ul>\n<p>【11月21日】想法</p>\n<p>（1）对比head 和head.next，如果head大，就要交换一下</p>\n<p>（2）移动head【如果<strong>==移动==</strong>的话，是不是还需要一个东西来存储一下】</p>\n<blockquote>\n<p>所以说，应该是在一个链表上，自己和自己进行比较，交换数字容易，但是移动到下一个数字应该怎么做</p>\n<p>还是复制成两个链表进行比较？</p>\n<p>【阅读题解】</p>\n<p>发现不只是两个链表了，而是要新建几个链表用来放置数据</p>\n</blockquote>\n<h4 id=\"阅读题解\"><a href=\"#阅读题解\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h4><p>重点的几个内容：</p>\n<ol>\n<li><strong>链表前的节点</strong> —— 哑节点 —— 便于在head前插入节点<code>zeroHead.next = head</code></li>\n<li><strong>已排序部分的最后一个节点 </strong> <code>lastSorted = head</code></li>\n<li><strong>待插入元素</strong> <code>current = head.next</code></li>\n<li><strong>插入元素的位置</strong>的前一个节点 <code>prev</code></li>\n</ol>\n<p>然后的思路和上面的分析其实很像</p>\n<p>怎么样将 <code>current</code>插入到链表中呢？</p>\n<p>几种情况</p>\n<ol>\n<li>空的链表</li>\n<li>比较<code>lastSorted.val</code>和<code>current.val</code>的值，发现不用变化</li>\n<li>第2步比较之后发现确实需要进行变化：</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lastSorted.next = current.next <span class=\"comment\"># 相当于把 lastSorted 向后移动了一位</span></span><br><span class=\"line\">current.next = prev.next <span class=\"comment\"># 相当于把排序的那个链表断开，从 prev 这里断开</span></span><br><span class=\"line\">prev.next = current\t<span class=\"comment\"># 然后把 current放在了 prev 的后面</span></span><br><span class=\"line\"></span><br><span class=\"line\">current = lastSorted.next <span class=\"comment\"># 更新将要插入的值</span></span><br></pre></td></tr></table></figure>\n<p>然后是判断的条件：</p>\n<ul>\n<li>计数是不太明智的方法</li>\n<li>其实从上面的分析可以看出，current才是最直接从head复制出来的东西，直接判断current是不是空的，就能终止程序</li>\n</ul>\n<p>可以直接判断链表是不是空的：<code>while curr:</code>如果是空的就会直接跳出</p>\n<blockquote>\n<p><strong>链表的恼火之处在于不断地覆盖</strong></p>\n<ul>\n<li>每次取出来一个值的时候，是ta后面的一长串全部都被取出了</li>\n<li>如果只想改变这一个值，就要精准地覆盖这个值后面的链表，用不同的东西覆盖得到的效果就是不同的</li>\n</ul>\n<p><strong>链表的神奇之处在于消失</strong></p>\n<ul>\n<li>其实你并没有把一个值赋值到链表当中</li>\n<li>而是把它添加到了前一个元素的next中，又把ta的next全部改成了原来的元素，这样，其实你根本没有对这个值进行操作，一个新链表已经形成了，就好像这个元素消失了一样</li>\n</ul>\n<p><strong>几个基本操作：</strong></p>\n<ul>\n<li>把链表自己移动一位：<code>list_node = list_node.next</code></li>\n<li>把链表 head 的头换成另一个数字：<code>head.val = xxx</code> 固然是可以的</li>\n<li>在链表前面添加另一个链表：<code>another_list_node.next = list_node</code></li>\n<li>在链表 head 的头后插入一个新的数字（其格式应该也是链表）：<code>curr.next = head.next; head.next = curr</code>【也就是先要复制后面的内容，然后再把这些内容加到head 的后面】</li>\n<li>遍历链表：<code>while head.next.val &lt;= curr.val: prev = prev.next</code></li>\n</ul>\n<p>链表总是最大限度地发挥next的作用</p>\n</blockquote>\n<hr>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"LCP-19-秋叶收藏集\"><a href=\"#LCP-19-秋叶收藏集\" class=\"headerlink\" title=\"LCP 19. 秋叶收藏集\"></a>LCP 19. 秋叶收藏集</h2><p>本题的好处是：替换，而不是交换，这样数学过程会简单一点</p>\n<p>现在主要考虑的就是，黄叶是不是在一起，左右是不是有红叶，感觉是动态规划</p>\n<p>3片叶子：</p>\n<ul>\n<li>找黄色的<ul>\n<li>如果没有，直接换中间的， 换一次</li>\n<li>如果开头，要换两次</li>\n<li>如果结尾，换两次</li>\n<li>如果全是黄叶，换两次</li>\n<li>如果两片黄叶在一块，换一次</li>\n<li>两片黄叶分开，换三次</li>\n</ul>\n</li>\n</ul>\n<p>有很多叶子</p>\n<ul>\n<li>找黄色的，标记为1</li>\n<li>加和？还是找到它的位置？</li>\n<li>看有没有断开？<ul>\n<li>取首项索引，末项索引</li>\n<li>中间各项进行检测</li>\n<li>但是这样不见得是最好的方式</li>\n</ul>\n</li>\n</ul>\n<p><strong>【10月1日思路】按照数量来决定换还是不换</strong></p>\n<p>首先找出黄叶的位置（索引）</p>\n<blockquote>\n<p>python字符串中查找的方法有四种：</p>\n<ul>\n<li>find()，返回找到的第一个字符的索引，找不到返回 -1</li>\n<li>index()，返回找到的第一个字符的索引，找不到报错</li>\n<li>rfind()和rindex()是倒着找</li>\n</ul>\n<p>如果是列表，那么是</p>\n<ul>\n<li>list.index 也是找第一个匹配项的索引</li>\n<li>用enumerate函数</li>\n</ul>\n<p>numpy可以找指定元素的索引</p>\n<ul>\n<li>np.argwhere</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/Jerry_1126/article/details/88924288?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-88924288.nonecase&amp;utm_term=python%20%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95&amp;spm=1000.2123.3001.4430\" target=\"_blank\" rel=\"noopener\">Python从列表中找出所有元素索引的几种方法</a></p>\n<p><a href=\"https://blog.csdn.net/Kerrwy/article/details/82419132?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-3-82419132.nonecase&amp;utm_term=python%20%E6%9F%A5%E6%89%BE%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%B4%A2%E5%BC%95&amp;spm=1000.2123.3001.4430\" target=\"_blank\" rel=\"noopener\">python找出一个列表中相同元素的多个索引</a></p>\n<p><a href=\"https://blog.csdn.net/chenhequanlalala/article/details/100991793\" target=\"_blank\" rel=\"noopener\">Python3 返回字符串中某个给定字符的全部索引</a></p>\n<p>matlab中对矩阵直接判断：A&gt;a，就能得到同样大小的矩阵，但是python似乎不可以</p>\n</blockquote>\n<ul>\n<li>取首末索引，计算中间段数量</li>\n<li>计算出黄叶数量</li>\n</ul>\n<p>中间段有没有红</p>\n<ul>\n<li>有<ul>\n<li>有多少红叶<ul>\n<li>红叶比黄叶多，换黄叶</li>\n<li>红叶比黄叶少，换红叶</li>\n<li>有一些情况，比如<code>yrrrryyyy</code>，这要怎么换，肯定是只换第一个黄叶最好</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>特殊情况</p>\n<ul>\n<li>全是红叶，换一次</li>\n<li>全是黄叶，换两次</li>\n<li>首尾是黄叶，各处要换一次</li>\n</ul>\n<blockquote>\n<p>我做题总有一种被套住的感觉</p>\n<p>被带入到了题目中，而没有跳出来</p>\n<p>这个问题相当于是在分段，把集中的部分放在一起，怎么样来判断集中和零散？</p>\n<ul>\n<li>一种方法是首尾判断，然后确定中间是不是掺杂，掺杂则是零散，不掺杂则是集中</li>\n<li>但是掺多掺少也是问题</li>\n</ul>\n<p>我掌握的计数方法过少了，只有循环计数</p>\n</blockquote>\n<h3 id=\"阅读题解-1\"><a href=\"#阅读题解-1\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>动态规划</p>\n<p>分为三种状态：然后分析需要将某一片叶子变色时，当前这片叶子和之前的叶子共同作用的情况，而且需要把次数传递下去</p>\n<blockquote>\n<p>python中的<code>float(&quot;inf&quot;)</code>表示正无穷，<code>float(&quot;-inf&quot;)</code>表示负无穷，可以做简单加、乘算术运算，当然结果还是inf</p>\n</blockquote>\n<p>从公式角度来说，如果用$f[i][j]$ 表示对前 i 片叶子进行操作的次数，而且当前的第 i 片叶子处于状态 j。</p>\n<p>j 有三种：0 表示前面的红色，1 表示黄色部分，2表示后面的红色部分</p>\n<ul>\n<li><p>j = 0， 第 i 片叶子需要变成红色时，i 之前的叶子都是 j = 0 的状态</p>\n<p>$f[i][0]=f[i-1][0]+isYellow(i)$</p>\n<p>如果是黄色，才会增加变换的次数</p>\n</li>\n<li><p>j = 1，需要把第 i 片叶子变成黄色，i 之前的叶子可以是 j = 0，也可以是 j = 1</p>\n<p>$f[i][1]=min\\{f[i-1][0], f[i-1][1]\\}+isRed(i)$</p>\n<p>如果是红色，才会增加变换的次数</p>\n</li>\n<li><p>j = 2，需要把第 i 片叶子变成红色，i 之前的叶子可以是 j = 1或2</p>\n<p>$f[i][2]=min\\{f[i-1][1], f[i-1][2]\\} + isYellow(i)$</p>\n<p>如果是黄色，才会增加变换的次数</p>\n</li>\n</ul>\n<p>但是问题有</p>\n<ul>\n<li>什么时候改变状态呢？<ul>\n<li>从代码来看，其实并没有改变状态</li>\n<li>不同状态的值一直存在，只不过看选用那个状态罢了</li>\n<li>好比说，刚开始是一片红叶，isRed(i) 会是1，这样 $f[i][1]$ 就有值了，但是等到下一次循环时，选择的是最小的那个，也就是 $f[i][0]$，而不会选择有值的这个，所以，并不影响</li>\n<li>直到出现一篇黄叶，局势才会变化</li>\n<li>可以自己做推演，这个方法确实很妙</li>\n</ul>\n</li>\n<li>此外，叶子的数量必须是大于状态数量的，所以像$ f_{01}, f_{02}, f_{12}$ 其实是不存在的</li>\n<li>初始值 $f_{00}$ 也是要考虑一下的</li>\n</ul>\n<blockquote>\n<p>学习：<code>f = [[0, 0, 0] for _ in range(n)]</code></p>\n<p>这句是把 f 变成了一个n行3列的全零数组，便于后面的计算</p>\n</blockquote>\n<p>最后，注意两个问题：</p>\n<ul>\n<li>range(1, n)，必须是从1开始，因为00已经在前面初始化了</li>\n<li>i &gt;= 2，要包括2，不然就会失败了</li>\n</ul>\n<h2 id=\"70-爬楼梯【经典-amp-基础】\"><a href=\"#70-爬楼梯【经典-amp-基础】\" class=\"headerlink\" title=\"70. 爬楼梯【经典&amp;基础】\"></a>70. 爬楼梯【经典&amp;基础】</h2><p>n阶楼梯，每次可以爬1或2级台阶，问：爬完的方法有多少种</p>\n<p>【仅作为<strong>数学问题</strong>】</p>\n<p>n阶台阶，最多n步（1种）</p>\n<p>然后减少步数，少一步=一个2级台阶（n-1步，n-1种）</p>\n<p>少两步=2个二级台阶（n-2步，$C_{n-2}^2$）</p>\n<p>······</p>\n<p>最少也要 n/2 步（1种）</p>\n<ul>\n<li>如果 n 是偶数，最少 n/2</li>\n<li>如果 n 是奇数，最少 n+1/2</li>\n<li>不管 n 是奇数还是偶数，统统加1，然后除以2取整就好了</li>\n</ul>\n<p>次少要加1步（$C_{\\frac{n}{2}+1}^1$）</p>\n<p>所以总共就是</p>\n<p>偶数：$S_o(n)=C_n^0+C_{n-1}^1+C_{n-2}^2+···+C_{\\frac{n}{2}+1}^1+C_{\\frac{n}{2}}^0$【这里面的数字都是整数吗？确实都是吧】</p>\n<p>奇数：$S_j(n)=n+S_o(n-1)$【其实奇数的时候，少不了有1步代替不了，直接拎出来，剩下就是整数问题了】</p>\n<p>下来是计算问题</p>\n<ul>\n<li>传统方法是阶乘，复杂度爆炸了，不可以</li>\n<li>巧妙一点的方法，有没给有简单一点的级数？</li>\n<li>或者能不能进行转化【可能还是要回到动态规划】</li>\n</ul>\n<p>【动态规划怎么做】</p>\n<p>假设已经爬了 k级，i步，还有j=n-k级</p>\n<ul>\n<li>下一步爬1级，k+1级，i+1步，还剩j-1级</li>\n<li>下一步爬2级，k+2级，i+1步，还剩j-2级</li>\n</ul>\n<p>像一个二叉树，但是一直这样开枝散叶下去不是太妙，感觉复杂度会比较高</p>\n<blockquote>\n<p>动态规划问题的基本思路</p>\n</blockquote>\n<p>联系方程：例如本题，$f(x)=f(x-1)+f(x-2)$</p>\n<p>转移方程：</p>\n<p>边界条件：f(0)=0【定义】, f(1)=0【实际】</p>\n<p>…到这里，再看上面的方程，这已经成为一个很基本的数学问题了</p>\n<p>（1）不断进行滑动就可以实现了【不过这样的复杂度为什么是$O(1)$而不是$O(n)$】确实，时间复杂度是O(n)，空间复杂度是O(1)</p>\n<p>（2）使用矩阵的方法</p>\n<p>$\\left[\\begin{matrix} f(n+1) \\\\f(n)\\end{matrix}\\right]=\\left[\\begin{matrix}1 &amp; 1\\\\1 &amp;0\\end{matrix}\\right]\\left[\\begin{matrix}f(n)\\\\f(n-1)\\end{matrix}\\right]$</p>\n<p>那么就是要求矩阵的n次方了</p>\n<p>（3）上面的递归方程其实可以用特征方程的方式求解通项公式，当然这个感觉会稍微有一点难</p>\n<p>总结：</p>\n<p>本题形成的序列是斐波那契数列。！！所以就是求斐波那契数列了！</p>\n<ul>\n<li>n比较小，可以用递归法，不做记忆化操作</li>\n<li>一般情况下用转移方程，递推、递归、滚动数组</li>\n<li>n不断扩大时，需要使用矩阵快速幂的方法</li>\n<li>也可以直接使用斐波那契数列的通项公式计算</li>\n</ul>\n<p>使用python使用方法（1）进行解题</p>\n<p>需要有个东西记录数字</p>\n<p>终止条件是什么？f(n)是要求的数字，n是台阶的数量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">climbStairs</span><span class=\"params\">(self, n: int)</span> -&gt; int:</span> </span><br><span class=\"line\">        a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span> <span class=\"comment\"># f(0), f(1)</span></span><br><span class=\"line\">        c = a + b   <span class=\"comment\"># f(2)</span></span><br><span class=\"line\">        times = <span class=\"number\">2</span>   <span class=\"comment\"># 2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> times &lt; n:</span><br><span class=\"line\">            a, b = b, c</span><br><span class=\"line\">            c = a + b   <span class=\"comment\"># f(times+1)</span></span><br><span class=\"line\">            times += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> c</span><br></pre></td></tr></table></figure>\n<p>这里刚开始用的是for循环，最后改成了while</p>\n<p>for 不能这么用，for的话这是for i in range···</p>\n<h2 id=\"53-最大子序和\"><a href=\"#53-最大子序和\" class=\"headerlink\" title=\"53. 最大子序和\"></a>53. 最大子序和</h2><p>输入：整数数组</p>\n<p>操作：找一个连续子数组（至少一个元素，重点是连续）</p>\n<p>输出：最大和</p>\n<p>从给的例子来看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出: 6</span><br><span class=\"line\">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>\n<p><strong>并不是遇到负数就断了</strong></p>\n<p>而是如果负数将这个序列和归0了，甚至是变为负数了，那么这个子序列就中断了</p>\n<p><strong>也不是要从头加到尾</strong></p>\n<p>比如开头的负数就不要了</p>\n<p>几个特例：</p>\n<p>（1）<code>[1]</code></p>\n<p>只有一个元素，而且是正数</p>\n<p>（2）<code>[-1]</code></p>\n<p>只有一个元素，而且是负数</p>\n<p>（3）<code>[-2, -1]</code></p>\n<p>两个都是负数</p>\n<p>我的算法为什么会遇到上述问题：</p>\n<ul>\n<li>首先是起始项，如果选择0，那么会对全负数不友好</li>\n<li>如果选择nums[0]，也就是第一个数</li>\n</ul>\n<p>我其实并没有用动态规划，而是用了一种存储的方法：</p>\n<p>（1）当前值是正还是负，主要看负的情况：</p>\n<p>如果当前是负的，那么比较当前值和过去sum的大小：</p>\n<p>如果当前值稍大，那就记录当前值，如果过去值稍大，那就记录过去值</p>\n<p>（2）如果当前是正的，就要考虑过去值还需不需要了</p>\n<p>如果过去值sum是负的，那就不用加了，直接重新开始</p>\n<p>其他情况，都直接往sum上加就好了</p>\n<blockquote>\n<p>所以：</p>\n<ul>\n<li>更新开头有两种方式<ul>\n<li>sum &lt; 0，i &gt; 0</li>\n<li>sum &lt; i &lt; 0</li>\n<li>总结就是 sum &lt; 0，sum &lt; i</li>\n</ul>\n</li>\n<li>遇到负数也会加，只是要把本次加负数之前的数字保存下来</li>\n</ul>\n</blockquote>\n<h3 id=\"阅读题解-2\"><a href=\"#阅读题解-2\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>==妙蛙种子吃了妙脆角到了米奇妙妙屋，妙到家了==</p>\n<p>这里讲的第一种方法是动态规划的方法：</p>\n<p>每一步，我们计算到该位置的最大子序和$f(i)=max\\{f(i-1)+a_i, a_i\\}$</p>\n<p>站的角度不同，我是考虑“要不要把当前的值加入 过去的序列 sum中”</p>\n<p>而这个方法则是观察每一个位置的最大子序和 ，考虑的是 “前面的子序和对我当前数值有没有用”</p>\n<h2 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198. 打家劫舍\"></a>198. 打家劫舍</h2><p>输入：非负整数数组</p>\n<p>输出：从数组中取出最大数字和的子串，要求，数字之间不能相邻</p>\n<p>这个题感觉很有意思啊</p>\n<p>钱的数量：<code>f(n)</code>，应该叫 <strong>到第n个数值，最多的钱数</strong></p>\n<ul>\n<li>n 表示当前字符串的长度</li>\n</ul>\n<p>只有两种可能：没有取当前的数字，那就等于 <code>f(n-1)</code>；如果取了当前的数值，那就等于跳过了一个数值 <code>f(n-2)+i</code>，把这两种情况比较一下，就是当前位置应该的情况</p>\n<p><code>f(n) = max( f(n-2) + i, f(n-1))</code></p>\n<p>初始条件：</p>\n<ul>\n<li><code>f(0)=0</code></li>\n<li><code>f(1)=i</code></li>\n<li><code>f(2)=max(f(0)+i, f(1))</code></li>\n</ul>\n<p>==喜极而泣！！！==</p>\n<p>这是我第一次用动态规划的方法完成了解题！！！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rob</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums) &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum(nums)</span><br><span class=\"line\">        max_sum = []</span><br><span class=\"line\">        max_sum.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        max_sum.append(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, len(nums)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            max_sum.append(max(max_sum[i<span class=\"number\">-1</span>], max_sum[i<span class=\"number\">-2</span>] + nums[i<span class=\"number\">-1</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_sum[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<p>非常完美，一次过！</p>\n<hr>\n<h1 id=\"List操作\"><a href=\"#List操作\" class=\"headerlink\" title=\"List操作\"></a>List操作</h1><h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977. 有序数组的平方\"></a>977. 有序数组的平方</h2><p>定性：python排序问题</p>\n<p>给定一个非递减顺序排序的整数数组A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>\n<p>这个题思考一种方法还是比较简单的：</p>\n<ul>\n<li>看绝对值，绝对值进行排序</li>\n<li>然后平方</li>\n</ul>\n<p>已经是非递减顺序了</p>\n<p>主要问题是有可能出现两个一样的数字</p>\n<p>还有就是绝对值一样的</p>\n<blockquote>\n<p>列表的排序</p>\n<p><code>list.sort()</code> list 本身会被修改</p>\n<p><code>sorted(list)</code> list 本身不会被修改</p>\n</blockquote>\n<p>思考其他的思路：</p>\n<p>如果能找到负数和非负数的分界线</p>\n<p>就可以进行“归并排序”：</p>\n<ul>\n<li>两个指针分别移动，选择小的那个放入其中</li>\n</ul>\n<p>再进一步，我们甚至不需要知道分界点在哪里，就从头和尾两端开始对比，哪个大就放在列表中，是最后一项</p>\n<p>这样也是可以的</p>\n<blockquote>\n<p>list 中进行添加元素</p>\n<ul>\n<li>append 在末尾添加一个</li>\n<li>extend 在列表末尾一次性追加另一个序列中的多个值</li>\n</ul>\n</blockquote>\n<h2 id=\"463-岛屿的周长\"><a href=\"#463-岛屿的周长\" class=\"headerlink\" title=\"463. 岛屿的周长\"></a>463. 岛屿的周长</h2><p>输入：一个矩阵，只由0和1构成，大小不定【宽和高不会超过100】</p>\n<p>计算：0和1的接触称为边界，计算这些边界的总数</p>\n<p>在一行中，当 1 开始，就有 1 个横向边界，也会有一个 横向出的边界，也就是穿越法，穿过几次</p>\n<p>在一列中，从1开始进入边界，然后穿越边界</p>\n<p>所以关键就是检查是不是连续的？这样的计算方法感觉反而要困难一点</p>\n<p>从大的方向来说，分两次进行计算：</p>\n<ol>\n<li>横向遍历一遍</li>\n<li>纵向遍历一遍</li>\n</ol>\n<p>在每一次计算的过程中，进入1则＋1，出1的区域则+1</p>\n<blockquote>\n<p>python中关于二维list的遍历？</p>\n<p>只能使用二维索引？那复杂度有点高了</p>\n</blockquote>\n<p>或者还有一个方法：</p>\n<p>找出所有的1，然后观察周围的元素，如果有0，加个1，那就是计算周围四个元素的和，然后用4减一下，这个方法可以</p>\n<h2 id=\"349-两个数组的交集\"><a href=\"#349-两个数组的交集\" class=\"headerlink\" title=\"349. 两个数组的交集\"></a>349. 两个数组的交集</h2><p>给定两个数组，用函数计算交集</p>\n<p>一个方法：</p>\n<p>先找出比较短的那个数组，</p>\n<p>然后针对该数组中的每一个数字，</p>\n<p>在另一个数组中找一下有没有，</p>\n<p>有的话加入交集数组，</p>\n<p>最后输出交集数组。</p>\n<p>还有更快的方法吗？</p>\n<blockquote>\n<p>有，两个元组可以使用 <code>&amp;</code>直接得到交集</p>\n<p>然后再使用<code>list</code>进行转化</p>\n<p>前面两个之所以为元组，是因为两边都用<code>set</code>进行了去重</p>\n</blockquote>\n<p>这个方法确实是可以的，但是问题在于没有办法去重，</p>\n<p>为了去重，在计算出比较短的那个数组后，需要首先去一下重，可以使用<code>set(list)</code>，该函数会返回去重后的结果，值得注意的是转化为了元组，但是仍然可以使用<code>for</code>循环进行索引</p>\n<h2 id=\"402-移掉k位数字\"><a href=\"#402-移掉k位数字\" class=\"headerlink\" title=\"402. 移掉k位数字\"></a>402. 移掉k位数字</h2><p>给定一个以字符串表示的非负整数num：比如“1432219”</p>\n<p>移除其中的k个数字：比如<code>k=3</code>，可以移除4，3，2</p>\n<p>使得剩下的数字最小：按上面的移除方式，最后剩下的就是1219，最小</p>\n<p>发现：</p>\n<ul>\n<li>仅仅是去除，不改变顺序</li>\n<li>如果用排列的方法，但n比较大或者k比较小的时候是比较难的</li>\n</ul>\n<p>发现规律：</p>\n<ul>\n<li>如果当前数字比左侧的大，就要删去<ul>\n<li>【不对，如果129，k=1，显然删9更小，但很有可能会把2删掉】</li>\n<li>【其二，如果左边的数字大，更应该删除左边的数字，因为它让整个数字更大了】</li>\n<li><strong>所以官方给出的办法是找比左边数字小的数字，然后把左边的数字删掉，单调不降删最后一个就可以了</strong></li>\n</ul>\n</li>\n<li>如果当前数字是0，就要删去左边的数字【此时，索引值要跳到一个不是0的位置，左边的数字也会跳】</li>\n</ul>\n<p>涉及两个步骤：</p>\n<ul>\n<li>第一，找出数字的位置</li>\n<li>第二，把数字去掉【怎么样更快速地去掉那一位上的数字了，而且0也要去掉】</li>\n</ul>\n<p>列表转字符串用join方法：</p>\n<p><code>&quot;&quot;.join(list)</code>也就是使用没有字符的方法合并list中的数值</p>\n<h3 id=\"阅读题解-3\"><a href=\"#阅读题解-3\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>官方题解的解释我觉得是很不错的</p>\n<p>其主要思路就是：</p>\n<ul>\n<li>如果当前数字比左边的小，那么就要删除左边的数字【这说明，我发现的规律还是不够严谨】</li>\n</ul>\n<p>需要处理的细节问题是：</p>\n<ul>\n<li>如果整列遍历完，单调不降，那么就要删除最后一个</li>\n</ul>\n<p>退出条件：</p>\n<ul>\n<li>整个数列已经是空的了</li>\n<li>新的栈顶元素不大于当前数字【注意这里的栈中，栈顶是队尾，栈底是队首】</li>\n<li>或者已经删除了k个数字</li>\n</ul>\n<p>额外情况：</p>\n<ul>\n<li>如果删除的数量不足，那么就要从最后面开始删</li>\n<li>前导0的问题，要删掉前导0</li>\n<li>如果最终数字序列为空，返回0</li>\n</ul>\n<p><strong>一个高赞题解的思路：</strong></p>\n<p>大致上是一致的，不过又增加了一点东西：</p>\n<p><strong>从丢弃和保留两个方面入手</strong></p>\n<ul>\n<li>也就是说先按照我们的原理丢弃一遍</li>\n<li>然后再把丢弃完毕后的list再保留我们需要的位数</li>\n<li>【这个保留操作确实是一个考验，就是说我们不能直接使用原来的list减去应该去除的数量，而是需要把字符串也给改掉】</li>\n</ul>\n<p>人家的方法确实是不错：</p>\n<ul>\n<li>首先用 for 循环遍历 num 中的每一个数字【我则是用index的方式进行平移】</li>\n<li>然后使用 while 进行判断，也就是实现一个不断进行删除的操作【这样就避免了嵌套或者是递归的问题】</li>\n<li>最后是活用 pop 和 append 的问题【一个减，一个加，来回推拉】</li>\n<li>针对全部都删除的特殊情况，使用一个<code>or</code> 【字符串的<code>or</code>操作？】</li>\n</ul>\n<p><strong>我觉得这个方法里面最好的一点是：</strong></p>\n<ul>\n<li><strong>充分考虑到每一个数字被遍历了【for循环】</strong></li>\n<li><strong>对每一个数字的操作，都操作到底，又兼顾条件【while循环】</strong></li>\n<li><strong>向空列表中推拉数据，形成新的数据</strong></li>\n</ul>\n<blockquote>\n<p>在python中使用栈的结构：</p>\n<ul>\n<li>其实就是list列表</li>\n<li><code>list.pop()</code> 用于移除列表中的一个元素（默认最后一个元素）<ul>\n<li>输入可以是index：<code>list.pop(-1)</code>，可以没有参数</li>\n<li>输出，返回的是该元素的值</li>\n</ul>\n</li>\n<li>再用<code>list.append()</code>向列表中添加元素</li>\n<li>还有<code>str.lstrip(chars)</code>，用于截掉字符串左边的空格或指定字符</li>\n</ul>\n<p>字符串之间使用<code>or</code></p>\n<ul>\n<li>两侧非空则取左</li>\n<li>有非空则取另一侧</li>\n</ul>\n<p>参考：<a href=\"https://blog.csdn.net/weixin_46274079/article/details/108467544\" target=\"_blank\" rel=\"noopener\">字符串的and和or操作</a></p>\n</blockquote>\n<p>我用了一种偷懒的方式，希望把原来的代码稍加修改就能实现新的目标，但是这样是很错误的，例如：<code>1234567890</code>，如果按照我的代码，首先会去除<code>9</code>，然后保留<code>len(num)-k</code>个数字，那就会删除9个数字，最后剩下的是 1 ，而不是 0</p>\n<p>第一版代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 冗长而不能解</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeKdigits</span><span class=\"params\">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class=\"line\">        left_num_idx = <span class=\"number\">0</span></span><br><span class=\"line\">        index = <span class=\"number\">1</span></span><br><span class=\"line\">        del_num = <span class=\"number\">0</span></span><br><span class=\"line\">        del_num_idx = []</span><br><span class=\"line\">        <span class=\"comment\"># 去除操作</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> del_num != k <span class=\"keyword\">and</span> index &lt; len(num):</span><br><span class=\"line\">            print(num[index])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num[index] &lt; num[left_num_idx]:</span><br><span class=\"line\">                del_num += <span class=\"number\">1</span></span><br><span class=\"line\">                del_num_idx.append(left_num_idx)</span><br><span class=\"line\">                left_num_idx = index</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left_num_idx = index</span><br><span class=\"line\">            index += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        new_num = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(num)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> del_num_idx:</span><br><span class=\"line\">                new_num.append(num[i])</span><br><span class=\"line\">        new_num_str = <span class=\"string\">\"\"</span>.join(new_num)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 保留操作，避免去除的数量不够</span></span><br><span class=\"line\">        new_num_str = new_num_str[:len(num)-k].lstrip(<span class=\"string\">'0'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len(new_num_str):</span><br><span class=\"line\">            new_num_str = <span class=\"string\">'0'</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_num_str</span><br></pre></td></tr></table></figure>\n<p>新的代码思路：</p>\n<ul>\n<li>要删除左侧较大的数字，而且一直要删到小于等于它为止</li>\n<li>能不能首先将数据变成一个可以进行方便删改的数据形式——比如list，按照索引进行删改确实要比str要方便的多</li>\n</ul>\n<p>删除的原则：</p>\n<ul>\n<li>左侧比当前的数字大</li>\n</ul>\n<p>那么以下几个问题：</p>\n<ul>\n<li>左侧没有了</li>\n<li>怎么跳出删除</li>\n</ul>\n<p>新的代码基本是照搬高赞代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeKdigits</span><span class=\"params\">(self, num, k)</span>:</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        remain = len(num) - k</span><br><span class=\"line\">        <span class=\"keyword\">for</span> digit <span class=\"keyword\">in</span> num:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> k <span class=\"keyword\">and</span> stack <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>] &gt; digit:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">                k -= <span class=\"number\">1</span></span><br><span class=\"line\">            stack.append(digit)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(stack[:remain]).lstrip(<span class=\"string\">'0'</span>) <span class=\"keyword\">or</span> <span class=\"string\">'0'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"121-买卖股票的最佳时机\"><a href=\"#121-买卖股票的最佳时机\" class=\"headerlink\" title=\"121. 买卖股票的最佳时机\"></a>121. 买卖股票的最佳时机</h2><p>输入：一个数组【股票场景，第i个数字表示股票第i天价格】</p>\n<p>输出：数组中后面数字减前面的数字，能减出的最大差值【股票场景，最多一笔交易，计算获取的最大利润】</p>\n<p>给一个位置记录最大值，如果出现更大的最大值，更新记录</p>\n<p>给一个位置记录最小值，如果出现更小的最小值，最小值重新记录，最大值也重新记录？【也不对，万一后面并没有更大值了就不行了】</p>\n<p>给一个位置记录利润，当每次需要更新最小值的时候，就会刷新一下利润；循环结束之后也需要刷新一下利润</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(prices) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        maxPrice = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">        minPrice = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">        profit = []</span><br><span class=\"line\">        profit.append(maxPrice - minPrice)</span><br><span class=\"line\">        n = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> n &lt; len(prices):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> prices[n] &lt; minPrice:</span><br><span class=\"line\">                profit.append(maxPrice - minPrice)</span><br><span class=\"line\">                minPrice = prices[n]</span><br><span class=\"line\">                maxPrice = prices[n]</span><br><span class=\"line\">                <span class=\"comment\"># print(profit)</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> prices[n] &gt; maxPrice:</span><br><span class=\"line\">                maxPrice = prices[n]</span><br><span class=\"line\">            n += <span class=\"number\">1</span></span><br><span class=\"line\">        profit.append(maxPrice - minPrice)</span><br><span class=\"line\">        <span class=\"comment\"># print(profit)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(profit)</span><br></pre></td></tr></table></figure>\n<p>看上去这个代码好像是可以了</p>\n<p>但是，题目是真的狠，输入是10000到0倒着数，而且还写了好多0</p>\n<p>最后还是可以通过的，就是不要print！！！</p>\n<h3 id=\"阅读题解-4\"><a href=\"#阅读题解-4\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>官方题解的第二种理解，文字似乎有点问题，仔细看代码，其实和我的方法几乎是一样的原理</p>\n<p>但是官方题解没有用list去记录，而是巧妙使用max，min进行比较</p>\n<hr>\n<p>OK！本期10题就先到这里了，期待下一个10题快点到来！</p>"},{"title":"LeetCode刷题笔记（四）","date":"2021-01-12T13:48:50.000Z","_content":"\n每期10题，上一期参见[LeetCode刷题笔记（三）](https://sunyoe.github.io/2020/12/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/)。\n\n本期内容动态规划内容出现复习情况，数组内容略有新意，图理论和拓扑排列初步入门。\n\n# 数组和排序\n\n## 1046. 最后一块石头的重量 - 排序问题\n\n输入：整数数组（不会超过30个数字，1到1000之间）\n\n输出：特定 int 值\n\n每次运算：选出两个最大数字，返回差值（如果是0就不用返回），直到只剩下0个或1个数值，无法比较，返回该数字\n\n<!--more-->\n\n（1）暴力解法\n\n每次需要找最大的两个数字，这一步的时间和空间复杂度就已经比较高了$O(n^2)$，然后再相减，加入到新的序列中，其实还可以接受\n\n> 对呀，这个问题：怎么给一个list排序（如果不使用现成的库）\n>\n> 首先：需要对比所有数字，确定是最大的，第二大那就排除第一个再对比一遍，做差\n>\n> 然后：把差值和所有数字对比，放在合适的位置（重排位置确实是用链表更好一点，但是如果执意要用列表呢，就需要拆一下再合并了）\n>\n> 这个方法确实是过于复杂\n\n（2）差值，有什么规律？\n\n简单一点，如果是1-10递增，那么每次相减都是1，连续四次之后，多了4个1，还剩1和2，然后5个1，可以预见最后有个1\n\n如果2，4，6，8，那么2，4，2，然后2，2，然后0\n\n这题好像确实也没有什么太多的方法就是按方法排好序就好了！\n\n相当于本题的核心目的就是实现排序！！\n\n排序的关键是找到数字在列表中的位置。\n\n> 如果需要排列一个从大到小的数列，那么就应该比较当前数字是不是比已有序列中的数字大\n\n所以我最后的步骤是：\n\n（1）先写一个独立函数，在已经排好顺序的序列中找到当前元素应该放置的位置，放进去\n\n（2）对原始序列进行一次排序（分两步）\n\n- 遍历原序列，移位\n- 把原序列中的当前数值放到新序列该放的位置上\n\n（3）不停做差值，把差值放到序列中\n\n> 看题解，很多用了sort\n>\n> 我没有用sort，除了一些list的用法，几乎是完全自主的\n\n## 605. 种花问题\n\n输入：整数数组 flowered（只有0和1），整数 n\n\n输入：布尔量\n\n功能：向数组中添加n个1，要求这些1不能相邻，如果能做到，返回true，做不到，返回false\n\n限制：数组长度在1到20000之间，n非负，不会超过数组大小；按照题目的意思来看，已经是1的位置应该是不能被替换\n\n思路：\n\n这首先是回答能不能，而不是回答怎么做，所以更像一个数学问题：\n\n如果当前数组中全部是在奇数位置，那么非常简单，计算有多少个奇数位置\n\n比较糟糕的是有的在奇数位置，有的在偶数位置，这样在非常紧密地排列时少不了要相遇，会少一\n\n怎么检查现有数值的位置？\n\n另一个思路：\n\n两个1之间有多少个0：\n\n（1）奇数个0，直接减1除以2\n\n（2）偶数个0，直接减2除以2\n\n特殊情况，头部为0，偶数不用减2\n\n尾部为0，偶数不用减2\n\n> 头部的确需要考虑，那么当遇到1了，就直接表示头部过了就可以了\n>\n> 但是尾部其实不用考虑，会跳出的\n\n现在遇到一个问题：[0] 的情况，那么这个应该是可以种植1个，但是按之前的计数方法是不可以的\n\n所以最终方法是：\n\n（1）全0的数组，直接加1除以2，比较就好了\n\n（2）开头为0，设置一个start的flag，遇到1就会转换，并计算开头情况\n\n（3）逐步前进，遇到1重置，计算中间的数量\n\n（4）来到末尾，根据最后一个数值是1还是0做最后叠加\n\n（5）最后判断输出即可\n\n![image-20210101123109261](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210101123109261.png)\n\n这个用时非常Amazing！\n\n## 303 区域和检索 - 数组不可变\n\n这道题我一开始有点懵逼\n\n题目的意思是完成一个class的编写，该类的初始函数需要完成的是实例化类（传递列表）\n\n另一个函数则是用来计算该数列第i个到第j个的总和\n\n那么我直接用sum就计算好了\n\n确实就这么完成了，但是问题当然是：这样相当于比如要计算多个总和的时候，就要一个一个计算了，是不是显得有一点冗余？\n\n那还应该怎么做？\n\n### 阅读题解\n\n其实关键问题就是上面说的，每次计算一次总和，肯定是重复了，这样是不好的\n\n比较省心的方法就是：\n\n计算到第i步的总和$f_i$，第j步的总和$f_j$，最后结果等于$f_j-f_i$\n\n而且$f_{i+1}=f_i+x_{i+1}$，这样的话就能避免循环，节省时间，确实是一种好方法\n\n但是我写完之后遇到一些小问题：\n\n（1）如果是从0到2的序列，那么$f_0$应该是0的，但是按以往的方法却不是的\n\n- 看到题解中有一种巧妙的方法：sums = [0, ]\n- 然后把每次计算好的 新的sums值 append 在后面：`nums.append(self.num_sum[i]+nums[i])`\n\n（2）关于 **序列为空**（NoneArray）的问题，如果是空的序列，**计算长度 len 函数**（`n = len(nums)`）是会出问题的！【我刚才的问题可能是返回了0，而没有返回None】\n\n- 但是奇怪的是，在 for 循环中使用 `for i in range(len(nums))` 即使nums是空的也没有问题\n\n## 剑指offer 03. 数组中重复的数值\n\n输入：整数数组\n\n输出：数组中的某个数值\n\n要求：该数值一定是在数组中重复出现过的\n\n老办法：计算所有数字出现过的次数，然后>2的都可以输出\n\n代码：\n\n```python\nclass Solution:\n    def findRepeatNumber(self, nums: List[int]) -> int:\n        sort = [0] * (max(nums)+1)\n        for i in nums:\n            sort[i] += 1\n        return sort.index(max(sort))\n```\n\n也的确可以通过，但是这种方法不太好\n\n![image-20210105161105089](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210105161105089.png)\n\n有没有其他减少复杂度的方法，比如先排个序？不行，并不能保证重复的数字出现在某个位置\n\n### 阅读题解\n\n（1）遍历数组\n\n这个方法告诉我们，根本就不用遍历完，只需要遇到重复的数字立马返回\n\n当然新的数字需要加入到一个新的集合中，然后判断下一个数字是新数字还是已经遇到的数字\n\n（2）原地交换\n\n本题中有一个条件：数组长度为n，而且所有数字小于 n\n\n那么可以让元素的索引和值一一对应\n\n第一次遇到，交换索引\n\n第二次遇到，直接能够判断$nums[x] = x$，所以就得到了重复的数字\n\n## 830. 较大分组的位置\n\n输入：字符串s，全是小写字母\n\n输出：二维数组，每个元素是一个还有两个整数的数组\n\n条件：较大分组指的是连续三个字符及以上的分组，两个整数分别是起始坐标和终止坐标\n\n这个简单啊，直接遍历不就好了，如果不相等直接重置\n\n相等累计，直到结尾\n\n然后把数组汇总一下就可以了\n\n一个特例：就是最后几个字母是一样的，那么就会一直continue，所以到最后再判断一次end和start是不是相等，得出答案\n\n代码：\n\n```python\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        if not len(s):\n            return []\n        output = []\n        start, end = 0, 0\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                end += 1\n                continue\n            if end - start >= 2:\n                output.append([start, end])\n            start, end = i, i\n        if end - start >= 2:\n            output.append([start, end])\n        return output\n```\n\n可以通过，但是速度和空间都比较糟糕\n\n![image-20210105163910474](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210105163910474.png)\n\n### 阅读题解\n\n就是一次遍历的方法，记录当前分组的长度，如果字符不同，那么就说明已经到尾部了\n\n但是为什么我的这个代码这么慢呢？\n\n（1）其实不用同时更新start和end，其实可以只记录start，因为end会直接由 i 来确定\n\n减少一个变量之后，确实减少了部分用时，但是内存还是比较大\n\n## 189. 旋转数组 - 数组\n\n输入：整数数组nums，非负数 k\n\n输出：没有输出，不要输出，直接对原数组进行调整即可\n\n功能：间数组中的元素向右移动 k 个位置\n\n---\n\n题目中说至少有三种方法可以解决该问题，而且要求空间复杂度 O(1) - 原地算法\n\n---\n\n从示例观察来看，直接把数组中 -k到最后一个数字整体搬到最前面就好了，但是如果 k 比数组长度还要大呢？\n\n问题是，没有输出，那我怎么输出呢\n\n我这种方法就是使用呢额外的数组，需要注意的是，必须要使用调整nums的方法，而不是生成nums的方法\n\n==这个方法的本质是把原数组中下标为 $i$ 的元素，放在了新数组的 $(i+k)\\mod n$的位置==\n\n---\n\n所给提示：\n\n（1）最简单的方法需要增加存储空间\n\n（2）比较困难的就是再不添加任何空间的情况下解决问题，这意味着需要使用某种方法在原始数组的基础上移动相关的元素\n\n（3）一种方法是 reversing the array（or part of it），翻转？\n\n---\n\n### 阅读题解\n\n**环状替换**\n\n![image-20210108104525947](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210108104525947.png)\n\n- 比如从 0 =》 到 $(0+k)\\mod n$，然后从 $(0+k)\\mod n$ 到$(0+2k)\\mod n$，一直到回到 0 位置，这个过程一定是走了整数个圈数\n- 比如 a 圈，总共遍历了 b 个元素\n- 那么 $ an = bk$ 总的元素数量是相等的，所以 an 一定是 n 和 k 的公倍数（不能重复，所以是最小公倍数 $lcm (n,k)$)\n- b 也就是这个最小公倍数 除以 k ，$lcm(n,k)/k$\n- 每次遍历会 访问 b 个元素，所以最后应该遍历 $n/b$ 次\n- 由于 b，n，k之间的关系\n\n![image-20210108105810711](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210108105810711.png)\n\n所以最后需要遍历 n 和 k 的最大公约数次\n\n应该说，这个方法看起来的可行性高，而且也不难\n\n**数组翻转**\n\n基于事实：将数组元素向右移动k次，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置\n\n所以就可以先把所有元素翻转，这样尾部的 k mod n 个元素被移至头部\n\n然后再翻转前后两个区间，以 k mod n -1 为界，就得到了最后的大浪\n\n这里的示例中写了一个翻转的函数，简单来说就是用 一个调换数组元素的方法 实现 整个数组的翻转\n\n（1）指定 start 和end结点\n\n（2）判断 start 和end 的关系，然后将两个数字对应的数组中的数字互换\n\n（3）start +1，end -1\n\n然后循环，这个方法很不错\n\n> 问：python中对数组的操作都有哪些？\n>\n> list.reverse() 就是对列表进行反向\n>\n> list.sort() 对原列表进行排序\n\n但是截取一段，然后进行翻转的方法是不可以的，这样其实还是相当于增加了空\n\n# 动态规划\n\n## 面试题08.01 三步问题\n\n输入：int 类型数值 n\n\n输出：int 类型数值\n\n功能：从0开始，每次可以增加1，2或3，直到数值加到n，求所有到达 n 的种类\n\n本题是可以通过暴力方法进行求解的，那么就是排序种类问题\n\n如果使用动态规划的方法呢？\n\n其实到达从上一步到达下一步的方法只有3种路径\n\n> 提示1：自上而下处理问题，先从最后一步开始\n\n最后一步有三种方法\n\n但是从 i 到 i+3 不止一种走法\n\n> 提示2：如果直到跳到第100级台阶之前的每一级台阶的跳法数量，可以计算第100级台阶的跳法数量吗？\n\n这个提示实在是太妙了\n\n那肯定是 【99级的跳法数量 + 98级跳法数量 + 97级跳法数量】\n\n虽然有以下几种情况：\n\n99级中有两种情况：\n\n- 98级 + 1级\n- 97级 + 2级\n\n98级一种情况：\n\n- 97级 + 1级\n\n但是这些情况并不影响各自到100级台阶的情况\n\n所以这是在提醒我，$sum_n = sum_{n-1}+sum_{n-2}+sum_{n-3}$\n\n> 提示3和提示4是在强调：相加还是相乘\n>\n> 提示4：\n>\n> 当我们先做什么再做什么，需要相乘\n>\n> 当我们这样做或那样做，需要相加\n\n初始条件：\n\nsum_0 = 0\n\nsum_1 = 1\n\nsum_2 = 2\n\nsum_3 = 4\n\nsum_4 = 7 …\n\n这么说这就是一个数列啊，直接按照数列的方法也是可以进行求解的！\n\n也就是说本题是在求解一个数列，不过这个数列的项不少，要找一个通项公式可能比较困难\n\n> 提示5，6是关于优化的，计算时间复杂度\n>\n> 制表法是什么，怎么样进行优化\n\n时间复杂度在哪，显然是在重复计算上，要不停变换三个加数，但是实际上加数是在不断交替的，而并非真的是在重新计算，但现在的情况是每个加数都进行了重新计算\n\n还有一个问题，是不是可以通过除以3来把这个过程优化一下？\n\n### 阅读题解\n\n题解中讲到的方法是使用矩阵实现快速计算\n\n但是实际上使用递推的方法就是可以实现的，问题是中间的数也会比较大，所以只在最后一步取模会导致空间和用时都比较高，可以考虑每一步都给 几个数值取模，这样的话不影响结果，还能保证时间和空间复杂度\n\n## 509. 斐波那契数\n\n输入：n\n\n输出：f(n)表示斐波那契数列的第n个数字\n\n注意：f(0) = 0, f(1)=1\n\n斐波那契数列的问题其实之前遇到过，确实有一些比较好的方法可以借鉴，很经典\n\n## 面试题16.17. 连续数列\n\n输入： 整数数组\n\n输出：子数组和\n\n要求：该子数组连续，且该子数组的和再所有子数组最大\n\n> 本题和53题，和offer42题为同一个问题\n\nf(n) 表示以n结尾的最大和的连续子数组的和\n\n那么$f(n+1) = max(f(n), f(n)+i_{n+1})$是吗？显然不一定，要让这个成立，只需要 $i_{n+1}$是正数就可以了【错了！！！】\n\n是$f(n+1) = max(f(n)+i_{n+1}, i_{n+1})$，其实也还是重置的方法\n\n> 提示1：把数字想象成正负交替的数字序列\n>\n> 因为实际上不会只包含正序列或者负序列\n\n> 提示2：如果有一个和为负数的数列，那么一定不是一个数列的开始或结束（因为这个数列完全可以去掉）\n>\n> 如果它们连接了另外两个数列，那么就可以以一个数列的形式出现\n\n> 提示3：从数组的开头开始，当这个子数列增长时，仍然是最佳子数列\n>\n> 但是一旦变成负数，就没有意义了\n\n这让我想起以前做过的一道题，就是把类似的数列的和存储了下来\n\n只要是负的就重置，并把变负之前的和记录下来\n\n相当于是在计算以每一个数字开头的数组的最大连续正数和\n\n> 总结一下，这类题已经做了三遍了：\n>\n> - 刚开始还愿意仔细分析序列的正负特点，到后来只愿意使用动态规划来做了\n>\n> - 动态规划上，关于连续的特点，要么是接着上一个序列，要么是从头开始：$f(n+1) = max(f(n)+i_{n+1}, i_{n+1})$\n> - 而间断的特点就是，可以是上一个，或者是上一个加上当前的：$f(n+1) = max(f(n), f(n)+i_{n+1})$\n>\n> 有的题目需要给出连续的个数\n>\n> 有的题需要给出最后的和，一定要适应一下\n\n# 图\n\n## 1203. 项目管理 - 图，拓扑排序\n\n输入： n - 项目数量， m - 小组数，group - 每个项目对应的小组，beforeItems - 每个项目的先决项目\n\n输出：列表 - 项目排序\n\n要求：\n\n- 每个项目对应的小组写在 group中，最多一个小组负责，全程不需要修改，只需要判断，-1表示没有小组接手，但是仍然需要进行排序\n- 同小组的项目需要相邻\n- 要先完成先决项目，才能完成后续项目\n- 小组和项目都是从0开始排序\n\n---\n\n从示例来看，首先需要把先决项目完成\n\n然后可以根据项目组进行排序\n\n> 感觉是使用树结构的方法会比较好\n>\n> 从before开始查找整个树\n>\n> 官方标签：深度优先搜索，图，拓扑排序\n\n---\n\n三个提示：\n\n- 图问题\n- 在 dependency graph 的基础上找一个拓扑排序的方法\n- 建立两个图，一个基于小组，一个基于项目\n\n---\n\n在本问题中，我需要知道的是：\n\n（1）我应该怎么样构建一个图？\n\n（2）怎样使用图进行排序\n\n> 拓扑排序\n>\n> 有向图G，将G的n个点排列成一组序列，任意一对顶点（u -> v）之间判断边\n>\n> 如果存在有向边 u -> v，那么 u 在序列中需要出现在 v 的前面\n\n本题中\n\n（1）把项目 items 抽象成点，项目间的依赖关系抽象成边，依赖条件就是有向边，进行拓扑排序\n\n（2）==【同组项目要彼此相邻】== = 组与组之间也存在依赖关系，所以要解决组之间的拓扑排序\n\n所以，本题分两步\n\n（1）首先解决组与组之间的依赖关系，组抽象成点，组与组的关系抽象成边，建图判断是否存在拓扑排序（groupTopSort，以组为先）\n\n（2）存在拓扑关系（groupTopSort），再确定组内依赖关系，遍历拓扑序，对于任意 组 g，对所有属于组 g 的点再进行拓扑排序，最后把组内拓扑排序按顺序放入答案数组\n\n细节\n\n（1）部分项目无人接手，groupId = -1，不利于编码，可以重新编号，但又不能与真实的小组编号冲突，可以从 m 开始正序编号【真实小组编号在0到m-1之间】\n\n（2）将拓扑排序抽象成一个函数进行复用，函数定义 `topSort(deg, graph, items)`表示：\n\n- 待排序点集 items\n- 点的入度数组 deg\n- 点的连边关系 graph，graph[i] 表示点 i 连出点组成的集合\n\n（3）建图过程中，如果发现两个项目属于不同的项目组，组间关系图添加相应边，否则在组内关系图中添加相应边\n\n---\n\n### 阅读题解\n\n> 参考一个题解说明：[[Python] 两次拓扑排序100%](https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/python-liang-ci-tuo-bu-pai-xu-100-by-mil-rtwg/)\n>\n> 入度：\n>\n> 有向图G中，对于节点 v，从节点 n1，n2，…，nm出发都可以一步到达 v，那么节点 v 的入度就是 m（是说v的来源有m条吗？）\n>\n> 拓扑排序\n>\n> 图中节点与节点之间的访问顺序，可用拓扑排序方法生成一个可行的访问序列\n>\n> （1）建图\n>\n> （2）统计图中所有节点的入度\n>\n> （3）BFS 方法获得访问序列\n>\n> - 将入度为0的节点添加到队列中\n> - 遍历队列\n>   - 得到队首节点并出队\n>   - 将当前节点添加到访问序列中\n>   - 将当前节点所有邻居节点的入度 -1\n>   - 如果邻居节点的入度变为0，将邻居节点入队\n>\n> 【？？？】确实没看懂\n\n方法：\n\n两次嵌套拓扑排序\n\n思路：\n\n1. 建图\n2. 对小组进行拓扑排序，获得访问小组的顺序\n3. 遍历小组的访问顺序\n   1. 得到该组的项目顺序\n   2. 将项目顺序添加到答案中\n\n建图：\n\n- 无组项目给全新组号\n- 小组建图计算组入度\n- 统计各组有哪些项目\n- 组内建图算项目入度\n\n**返回空列表的条件：**\n\n- 小组不在得到的访问顺序中\n- 项目不在得到的该组项目的访问顺序中\n\n> `queue = collections.deque()`\n>\n> deque 是一个**双端队列**，可以从两端进行 append 的数据结构【不过从左端加入使用的是 `queue.appendleft()`】\n>\n> 还可以从两端出队列 `queue.pop()` 和 `queue.popleft()`\n>\n> 一般需要提前 `from collections import deque`\n>\n> 参考：[collections中 deque的使用](https://blog.csdn.net/u010339879/article/details/80767293)\n\n### 代码分析\n\n组数 m 也就是 group_id 的最大值\n\n遍历 n 个项目，给没有组接手的项目重新标记组号 m, m+1, …\n\n初始化几个列表：【列表的初始化建议】\n\n- 项目入度列表 - n个0 `[0]*n`\n- 小组入度列表\n- 项目邻居列表 - n个子列表 `[[] for _ in range(n)]`\n- 小组邻居列表\n- group_to_tasks 【这个列表用来做什么？】\n\n遍历任务==【组间排序】==\n\n- 按照各项目所属的小组号，在 group_to_tasks的相应位置，添加任务号\n  - 也就是说，这个数组存放的是 各组对应的任务数\n\n- 遍历先决任务的list\n  - 这个list 的id是当前任务，value 是先决任务\n  - 可以判断两个任务的是不是同组 `group[id] 和 group[value]`\n    - 不同组，那么该小组的入度 +1，先决组的邻居加上当前组【组间建图】\n    - 同组，那么任务的入度 +1，先决任务的邻居加上当前任务【组内建图】\n\n接下来获得小组的访问顺序\n\n- 使用自定义函数 `self.topological_sort`，输入是 任务或者小组，入度，邻居三个内容【具体分析见下一个部分】\n- 首先对小组间进行排序，输入小组号的列表，所有小组的入度列表，所有小组的邻居列表\n\n做一个判断：如果**组外排序**数组数量【排的是小组的访问顺序】，不等于所有组的数量，那么就直接返回空列表【为什么】\n\n最后遍历小组号，注意小组号超过 m 的就不用了==【组内排序】==【排的是组间的排序】\n\n- 对组内根据任务进行拓扑排序\n  - 输入：group_to_tasks[group_id]，任务入度，任务邻居\n- 做一个判断，如果任务排序后的长度不等于每组对应的任务数，那么就返回空\n- 把排序号的任务列表添加到最后输出列表中\n\n把最终排序列表输出\n\n---\n\n其实这里面自定义的函数==拓扑排序函数==才是关键\n\n自定义函数的具体内容：\n\n输入：待排序数组，对应入度，对应邻居列表\n\n初始化双端队列和输出列表\n\n遍历待排序列表，item\n\n- 如果 item 对应入度为0，直接将 item 加入双端列表\n- <u>【入度为0表示这就是最底层的节点了，如果不是0，那么就是说还有子节点，不饿能直接进行排序？】</u>\n\n如果双端列表为空，直接返回空数组【双端列表究竟是什么意义】\n\n接下来是广度优先排序（BFS）\n\n- 只要双端列表不为空就一直循环\n- 将双端列表的左元素移出，放入输出列表中\n  - 对该元素的邻居进行遍历\n  - 各邻居的入度 -1\n  - 如果有邻居的入度为0，那么也将这个邻居加入双端列表\n\n- 直到双端列表为空\n\n最后输出输出列表\n\n----\n\n仔细体会各步骤的用意\n\n1. 找到了每一个组对应的所有任务\n2. 避免无人认领项目的影响【至少不能认为他们是同组的】\n3. 两步排序的方法分了组间排序和组内排序，分别考虑组要靠在一起，其次是组内顺序也要考虑\n4. 首先考虑的是任务的先后关系\n   1. 先后任务在同组，那么任务入度不同\n   2. 先后任务在不同组，那么小组入度不同【小组的入度 = 先决组的数量，先决组是小组的邻居】，至于说各任务在组内入度就要看是不是还和组内任务有先后关系\n   3. 如果==任务的先决任务列表==恰好为空，那刚好，对该任务的入度和邻居都不影响【那么直接排顺序就好了，这是最简单的情况】\n5. ==【入度本身是强调先后顺序，有入度，那么该小组或者该项目就应该往后排】==\n   1. 入度越小的项目或者小组，就越应该往前排\n   2. 全都有入度，那么这个任务或者小组根本就不可行\n6. 组间排序考虑各小组的入度，组内排序考虑各项目的入度\n7. 拓扑排序的方法，就是从入度来判断一个值能不能进行排序，然后对该值的邻居排序，未排序的内容入度就应该减小，相当于在剩下的内容中进行排序\n\n> 这样通过遍历任务，获得了小组的入度和项目的入度，邻居则是同时获得的【左邻居还是右邻居并不重要，重要的是邻居都要包含在列表里面】【一个小组或者一个项目的邻居有上限吗，有什么样的意义】\n\n==建图的关键是两个列表：入度 和 邻居==\n\n```python\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for task in range(n):\n            if group[task] == -1:\n                group[task] = max_group_id\n                max_group_id += 1\n        # 到此，共有 max_group_id 个组\n\n        group_indegree = [0] * max_group_id\n        task_indegree = [0] * n\n        group_neighbours = [[] for _ in range(max_group_id)]\n        task_neighbours = [[] for _ in range(n)]\n        group_to_tasks = [[] for _ in range(max_group_id)]\n\n        for task in group:\n            group_to_tasks[task].append(task)\n        print(group_to_tasks)\n```\n\n上面是我写的一个初步的代码，我们分析一下第 16 行，我希望能够得到 每个组对应的task情况，但是这种遍历方法肯定是不对的，而是应该\n\n```python\nfor task in range(n):\n    group_to_tasks[group[task]].append(task)\n```\n\n这样才可以实现把 task 放到对应的 group 中的想法。\n\n然后，我根据回忆进行程序的复现过程中，另一个问题是组内排序的方法，应该遍历已经排好序的组的列表\n\n这样可以获得组号\n\n然后根据组号去查找每组里面的任务\n\n对任务进行排序\n\n最后把排好序的任务放到最终输出的列表就完成了！\n\n---\n\nOK，本期的解题就是这些，总体来说，简单题虽然能够尝试，但是限制了对真正算法的现象和理解，还是需要多对其他难度和其他类型的题进行尝试，从而获得更好的学习效果！","source":"_posts/LeetCode刷题笔记四.md","raw":"---\ntitle: LeetCode刷题笔记（四）\ndate: 2021-01-12 21:48:50\ncategories:\n\t- 算法\ntags:\n\t- 图\n\t- 动态规划\n\t- 数组\n\t- 排序\n\t- 拓扑排序\n---\n\n每期10题，上一期参见[LeetCode刷题笔记（三）](https://sunyoe.github.io/2020/12/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/)。\n\n本期内容动态规划内容出现复习情况，数组内容略有新意，图理论和拓扑排列初步入门。\n\n# 数组和排序\n\n## 1046. 最后一块石头的重量 - 排序问题\n\n输入：整数数组（不会超过30个数字，1到1000之间）\n\n输出：特定 int 值\n\n每次运算：选出两个最大数字，返回差值（如果是0就不用返回），直到只剩下0个或1个数值，无法比较，返回该数字\n\n<!--more-->\n\n（1）暴力解法\n\n每次需要找最大的两个数字，这一步的时间和空间复杂度就已经比较高了$O(n^2)$，然后再相减，加入到新的序列中，其实还可以接受\n\n> 对呀，这个问题：怎么给一个list排序（如果不使用现成的库）\n>\n> 首先：需要对比所有数字，确定是最大的，第二大那就排除第一个再对比一遍，做差\n>\n> 然后：把差值和所有数字对比，放在合适的位置（重排位置确实是用链表更好一点，但是如果执意要用列表呢，就需要拆一下再合并了）\n>\n> 这个方法确实是过于复杂\n\n（2）差值，有什么规律？\n\n简单一点，如果是1-10递增，那么每次相减都是1，连续四次之后，多了4个1，还剩1和2，然后5个1，可以预见最后有个1\n\n如果2，4，6，8，那么2，4，2，然后2，2，然后0\n\n这题好像确实也没有什么太多的方法就是按方法排好序就好了！\n\n相当于本题的核心目的就是实现排序！！\n\n排序的关键是找到数字在列表中的位置。\n\n> 如果需要排列一个从大到小的数列，那么就应该比较当前数字是不是比已有序列中的数字大\n\n所以我最后的步骤是：\n\n（1）先写一个独立函数，在已经排好顺序的序列中找到当前元素应该放置的位置，放进去\n\n（2）对原始序列进行一次排序（分两步）\n\n- 遍历原序列，移位\n- 把原序列中的当前数值放到新序列该放的位置上\n\n（3）不停做差值，把差值放到序列中\n\n> 看题解，很多用了sort\n>\n> 我没有用sort，除了一些list的用法，几乎是完全自主的\n\n## 605. 种花问题\n\n输入：整数数组 flowered（只有0和1），整数 n\n\n输入：布尔量\n\n功能：向数组中添加n个1，要求这些1不能相邻，如果能做到，返回true，做不到，返回false\n\n限制：数组长度在1到20000之间，n非负，不会超过数组大小；按照题目的意思来看，已经是1的位置应该是不能被替换\n\n思路：\n\n这首先是回答能不能，而不是回答怎么做，所以更像一个数学问题：\n\n如果当前数组中全部是在奇数位置，那么非常简单，计算有多少个奇数位置\n\n比较糟糕的是有的在奇数位置，有的在偶数位置，这样在非常紧密地排列时少不了要相遇，会少一\n\n怎么检查现有数值的位置？\n\n另一个思路：\n\n两个1之间有多少个0：\n\n（1）奇数个0，直接减1除以2\n\n（2）偶数个0，直接减2除以2\n\n特殊情况，头部为0，偶数不用减2\n\n尾部为0，偶数不用减2\n\n> 头部的确需要考虑，那么当遇到1了，就直接表示头部过了就可以了\n>\n> 但是尾部其实不用考虑，会跳出的\n\n现在遇到一个问题：[0] 的情况，那么这个应该是可以种植1个，但是按之前的计数方法是不可以的\n\n所以最终方法是：\n\n（1）全0的数组，直接加1除以2，比较就好了\n\n（2）开头为0，设置一个start的flag，遇到1就会转换，并计算开头情况\n\n（3）逐步前进，遇到1重置，计算中间的数量\n\n（4）来到末尾，根据最后一个数值是1还是0做最后叠加\n\n（5）最后判断输出即可\n\n![image-20210101123109261](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210101123109261.png)\n\n这个用时非常Amazing！\n\n## 303 区域和检索 - 数组不可变\n\n这道题我一开始有点懵逼\n\n题目的意思是完成一个class的编写，该类的初始函数需要完成的是实例化类（传递列表）\n\n另一个函数则是用来计算该数列第i个到第j个的总和\n\n那么我直接用sum就计算好了\n\n确实就这么完成了，但是问题当然是：这样相当于比如要计算多个总和的时候，就要一个一个计算了，是不是显得有一点冗余？\n\n那还应该怎么做？\n\n### 阅读题解\n\n其实关键问题就是上面说的，每次计算一次总和，肯定是重复了，这样是不好的\n\n比较省心的方法就是：\n\n计算到第i步的总和$f_i$，第j步的总和$f_j$，最后结果等于$f_j-f_i$\n\n而且$f_{i+1}=f_i+x_{i+1}$，这样的话就能避免循环，节省时间，确实是一种好方法\n\n但是我写完之后遇到一些小问题：\n\n（1）如果是从0到2的序列，那么$f_0$应该是0的，但是按以往的方法却不是的\n\n- 看到题解中有一种巧妙的方法：sums = [0, ]\n- 然后把每次计算好的 新的sums值 append 在后面：`nums.append(self.num_sum[i]+nums[i])`\n\n（2）关于 **序列为空**（NoneArray）的问题，如果是空的序列，**计算长度 len 函数**（`n = len(nums)`）是会出问题的！【我刚才的问题可能是返回了0，而没有返回None】\n\n- 但是奇怪的是，在 for 循环中使用 `for i in range(len(nums))` 即使nums是空的也没有问题\n\n## 剑指offer 03. 数组中重复的数值\n\n输入：整数数组\n\n输出：数组中的某个数值\n\n要求：该数值一定是在数组中重复出现过的\n\n老办法：计算所有数字出现过的次数，然后>2的都可以输出\n\n代码：\n\n```python\nclass Solution:\n    def findRepeatNumber(self, nums: List[int]) -> int:\n        sort = [0] * (max(nums)+1)\n        for i in nums:\n            sort[i] += 1\n        return sort.index(max(sort))\n```\n\n也的确可以通过，但是这种方法不太好\n\n![image-20210105161105089](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210105161105089.png)\n\n有没有其他减少复杂度的方法，比如先排个序？不行，并不能保证重复的数字出现在某个位置\n\n### 阅读题解\n\n（1）遍历数组\n\n这个方法告诉我们，根本就不用遍历完，只需要遇到重复的数字立马返回\n\n当然新的数字需要加入到一个新的集合中，然后判断下一个数字是新数字还是已经遇到的数字\n\n（2）原地交换\n\n本题中有一个条件：数组长度为n，而且所有数字小于 n\n\n那么可以让元素的索引和值一一对应\n\n第一次遇到，交换索引\n\n第二次遇到，直接能够判断$nums[x] = x$，所以就得到了重复的数字\n\n## 830. 较大分组的位置\n\n输入：字符串s，全是小写字母\n\n输出：二维数组，每个元素是一个还有两个整数的数组\n\n条件：较大分组指的是连续三个字符及以上的分组，两个整数分别是起始坐标和终止坐标\n\n这个简单啊，直接遍历不就好了，如果不相等直接重置\n\n相等累计，直到结尾\n\n然后把数组汇总一下就可以了\n\n一个特例：就是最后几个字母是一样的，那么就会一直continue，所以到最后再判断一次end和start是不是相等，得出答案\n\n代码：\n\n```python\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        if not len(s):\n            return []\n        output = []\n        start, end = 0, 0\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                end += 1\n                continue\n            if end - start >= 2:\n                output.append([start, end])\n            start, end = i, i\n        if end - start >= 2:\n            output.append([start, end])\n        return output\n```\n\n可以通过，但是速度和空间都比较糟糕\n\n![image-20210105163910474](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210105163910474.png)\n\n### 阅读题解\n\n就是一次遍历的方法，记录当前分组的长度，如果字符不同，那么就说明已经到尾部了\n\n但是为什么我的这个代码这么慢呢？\n\n（1）其实不用同时更新start和end，其实可以只记录start，因为end会直接由 i 来确定\n\n减少一个变量之后，确实减少了部分用时，但是内存还是比较大\n\n## 189. 旋转数组 - 数组\n\n输入：整数数组nums，非负数 k\n\n输出：没有输出，不要输出，直接对原数组进行调整即可\n\n功能：间数组中的元素向右移动 k 个位置\n\n---\n\n题目中说至少有三种方法可以解决该问题，而且要求空间复杂度 O(1) - 原地算法\n\n---\n\n从示例观察来看，直接把数组中 -k到最后一个数字整体搬到最前面就好了，但是如果 k 比数组长度还要大呢？\n\n问题是，没有输出，那我怎么输出呢\n\n我这种方法就是使用呢额外的数组，需要注意的是，必须要使用调整nums的方法，而不是生成nums的方法\n\n==这个方法的本质是把原数组中下标为 $i$ 的元素，放在了新数组的 $(i+k)\\mod n$的位置==\n\n---\n\n所给提示：\n\n（1）最简单的方法需要增加存储空间\n\n（2）比较困难的就是再不添加任何空间的情况下解决问题，这意味着需要使用某种方法在原始数组的基础上移动相关的元素\n\n（3）一种方法是 reversing the array（or part of it），翻转？\n\n---\n\n### 阅读题解\n\n**环状替换**\n\n![image-20210108104525947](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210108104525947.png)\n\n- 比如从 0 =》 到 $(0+k)\\mod n$，然后从 $(0+k)\\mod n$ 到$(0+2k)\\mod n$，一直到回到 0 位置，这个过程一定是走了整数个圈数\n- 比如 a 圈，总共遍历了 b 个元素\n- 那么 $ an = bk$ 总的元素数量是相等的，所以 an 一定是 n 和 k 的公倍数（不能重复，所以是最小公倍数 $lcm (n,k)$)\n- b 也就是这个最小公倍数 除以 k ，$lcm(n,k)/k$\n- 每次遍历会 访问 b 个元素，所以最后应该遍历 $n/b$ 次\n- 由于 b，n，k之间的关系\n\n![image-20210108105810711](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210108105810711.png)\n\n所以最后需要遍历 n 和 k 的最大公约数次\n\n应该说，这个方法看起来的可行性高，而且也不难\n\n**数组翻转**\n\n基于事实：将数组元素向右移动k次，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置\n\n所以就可以先把所有元素翻转，这样尾部的 k mod n 个元素被移至头部\n\n然后再翻转前后两个区间，以 k mod n -1 为界，就得到了最后的大浪\n\n这里的示例中写了一个翻转的函数，简单来说就是用 一个调换数组元素的方法 实现 整个数组的翻转\n\n（1）指定 start 和end结点\n\n（2）判断 start 和end 的关系，然后将两个数字对应的数组中的数字互换\n\n（3）start +1，end -1\n\n然后循环，这个方法很不错\n\n> 问：python中对数组的操作都有哪些？\n>\n> list.reverse() 就是对列表进行反向\n>\n> list.sort() 对原列表进行排序\n\n但是截取一段，然后进行翻转的方法是不可以的，这样其实还是相当于增加了空\n\n# 动态规划\n\n## 面试题08.01 三步问题\n\n输入：int 类型数值 n\n\n输出：int 类型数值\n\n功能：从0开始，每次可以增加1，2或3，直到数值加到n，求所有到达 n 的种类\n\n本题是可以通过暴力方法进行求解的，那么就是排序种类问题\n\n如果使用动态规划的方法呢？\n\n其实到达从上一步到达下一步的方法只有3种路径\n\n> 提示1：自上而下处理问题，先从最后一步开始\n\n最后一步有三种方法\n\n但是从 i 到 i+3 不止一种走法\n\n> 提示2：如果直到跳到第100级台阶之前的每一级台阶的跳法数量，可以计算第100级台阶的跳法数量吗？\n\n这个提示实在是太妙了\n\n那肯定是 【99级的跳法数量 + 98级跳法数量 + 97级跳法数量】\n\n虽然有以下几种情况：\n\n99级中有两种情况：\n\n- 98级 + 1级\n- 97级 + 2级\n\n98级一种情况：\n\n- 97级 + 1级\n\n但是这些情况并不影响各自到100级台阶的情况\n\n所以这是在提醒我，$sum_n = sum_{n-1}+sum_{n-2}+sum_{n-3}$\n\n> 提示3和提示4是在强调：相加还是相乘\n>\n> 提示4：\n>\n> 当我们先做什么再做什么，需要相乘\n>\n> 当我们这样做或那样做，需要相加\n\n初始条件：\n\nsum_0 = 0\n\nsum_1 = 1\n\nsum_2 = 2\n\nsum_3 = 4\n\nsum_4 = 7 …\n\n这么说这就是一个数列啊，直接按照数列的方法也是可以进行求解的！\n\n也就是说本题是在求解一个数列，不过这个数列的项不少，要找一个通项公式可能比较困难\n\n> 提示5，6是关于优化的，计算时间复杂度\n>\n> 制表法是什么，怎么样进行优化\n\n时间复杂度在哪，显然是在重复计算上，要不停变换三个加数，但是实际上加数是在不断交替的，而并非真的是在重新计算，但现在的情况是每个加数都进行了重新计算\n\n还有一个问题，是不是可以通过除以3来把这个过程优化一下？\n\n### 阅读题解\n\n题解中讲到的方法是使用矩阵实现快速计算\n\n但是实际上使用递推的方法就是可以实现的，问题是中间的数也会比较大，所以只在最后一步取模会导致空间和用时都比较高，可以考虑每一步都给 几个数值取模，这样的话不影响结果，还能保证时间和空间复杂度\n\n## 509. 斐波那契数\n\n输入：n\n\n输出：f(n)表示斐波那契数列的第n个数字\n\n注意：f(0) = 0, f(1)=1\n\n斐波那契数列的问题其实之前遇到过，确实有一些比较好的方法可以借鉴，很经典\n\n## 面试题16.17. 连续数列\n\n输入： 整数数组\n\n输出：子数组和\n\n要求：该子数组连续，且该子数组的和再所有子数组最大\n\n> 本题和53题，和offer42题为同一个问题\n\nf(n) 表示以n结尾的最大和的连续子数组的和\n\n那么$f(n+1) = max(f(n), f(n)+i_{n+1})$是吗？显然不一定，要让这个成立，只需要 $i_{n+1}$是正数就可以了【错了！！！】\n\n是$f(n+1) = max(f(n)+i_{n+1}, i_{n+1})$，其实也还是重置的方法\n\n> 提示1：把数字想象成正负交替的数字序列\n>\n> 因为实际上不会只包含正序列或者负序列\n\n> 提示2：如果有一个和为负数的数列，那么一定不是一个数列的开始或结束（因为这个数列完全可以去掉）\n>\n> 如果它们连接了另外两个数列，那么就可以以一个数列的形式出现\n\n> 提示3：从数组的开头开始，当这个子数列增长时，仍然是最佳子数列\n>\n> 但是一旦变成负数，就没有意义了\n\n这让我想起以前做过的一道题，就是把类似的数列的和存储了下来\n\n只要是负的就重置，并把变负之前的和记录下来\n\n相当于是在计算以每一个数字开头的数组的最大连续正数和\n\n> 总结一下，这类题已经做了三遍了：\n>\n> - 刚开始还愿意仔细分析序列的正负特点，到后来只愿意使用动态规划来做了\n>\n> - 动态规划上，关于连续的特点，要么是接着上一个序列，要么是从头开始：$f(n+1) = max(f(n)+i_{n+1}, i_{n+1})$\n> - 而间断的特点就是，可以是上一个，或者是上一个加上当前的：$f(n+1) = max(f(n), f(n)+i_{n+1})$\n>\n> 有的题目需要给出连续的个数\n>\n> 有的题需要给出最后的和，一定要适应一下\n\n# 图\n\n## 1203. 项目管理 - 图，拓扑排序\n\n输入： n - 项目数量， m - 小组数，group - 每个项目对应的小组，beforeItems - 每个项目的先决项目\n\n输出：列表 - 项目排序\n\n要求：\n\n- 每个项目对应的小组写在 group中，最多一个小组负责，全程不需要修改，只需要判断，-1表示没有小组接手，但是仍然需要进行排序\n- 同小组的项目需要相邻\n- 要先完成先决项目，才能完成后续项目\n- 小组和项目都是从0开始排序\n\n---\n\n从示例来看，首先需要把先决项目完成\n\n然后可以根据项目组进行排序\n\n> 感觉是使用树结构的方法会比较好\n>\n> 从before开始查找整个树\n>\n> 官方标签：深度优先搜索，图，拓扑排序\n\n---\n\n三个提示：\n\n- 图问题\n- 在 dependency graph 的基础上找一个拓扑排序的方法\n- 建立两个图，一个基于小组，一个基于项目\n\n---\n\n在本问题中，我需要知道的是：\n\n（1）我应该怎么样构建一个图？\n\n（2）怎样使用图进行排序\n\n> 拓扑排序\n>\n> 有向图G，将G的n个点排列成一组序列，任意一对顶点（u -> v）之间判断边\n>\n> 如果存在有向边 u -> v，那么 u 在序列中需要出现在 v 的前面\n\n本题中\n\n（1）把项目 items 抽象成点，项目间的依赖关系抽象成边，依赖条件就是有向边，进行拓扑排序\n\n（2）==【同组项目要彼此相邻】== = 组与组之间也存在依赖关系，所以要解决组之间的拓扑排序\n\n所以，本题分两步\n\n（1）首先解决组与组之间的依赖关系，组抽象成点，组与组的关系抽象成边，建图判断是否存在拓扑排序（groupTopSort，以组为先）\n\n（2）存在拓扑关系（groupTopSort），再确定组内依赖关系，遍历拓扑序，对于任意 组 g，对所有属于组 g 的点再进行拓扑排序，最后把组内拓扑排序按顺序放入答案数组\n\n细节\n\n（1）部分项目无人接手，groupId = -1，不利于编码，可以重新编号，但又不能与真实的小组编号冲突，可以从 m 开始正序编号【真实小组编号在0到m-1之间】\n\n（2）将拓扑排序抽象成一个函数进行复用，函数定义 `topSort(deg, graph, items)`表示：\n\n- 待排序点集 items\n- 点的入度数组 deg\n- 点的连边关系 graph，graph[i] 表示点 i 连出点组成的集合\n\n（3）建图过程中，如果发现两个项目属于不同的项目组，组间关系图添加相应边，否则在组内关系图中添加相应边\n\n---\n\n### 阅读题解\n\n> 参考一个题解说明：[[Python] 两次拓扑排序100%](https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/python-liang-ci-tuo-bu-pai-xu-100-by-mil-rtwg/)\n>\n> 入度：\n>\n> 有向图G中，对于节点 v，从节点 n1，n2，…，nm出发都可以一步到达 v，那么节点 v 的入度就是 m（是说v的来源有m条吗？）\n>\n> 拓扑排序\n>\n> 图中节点与节点之间的访问顺序，可用拓扑排序方法生成一个可行的访问序列\n>\n> （1）建图\n>\n> （2）统计图中所有节点的入度\n>\n> （3）BFS 方法获得访问序列\n>\n> - 将入度为0的节点添加到队列中\n> - 遍历队列\n>   - 得到队首节点并出队\n>   - 将当前节点添加到访问序列中\n>   - 将当前节点所有邻居节点的入度 -1\n>   - 如果邻居节点的入度变为0，将邻居节点入队\n>\n> 【？？？】确实没看懂\n\n方法：\n\n两次嵌套拓扑排序\n\n思路：\n\n1. 建图\n2. 对小组进行拓扑排序，获得访问小组的顺序\n3. 遍历小组的访问顺序\n   1. 得到该组的项目顺序\n   2. 将项目顺序添加到答案中\n\n建图：\n\n- 无组项目给全新组号\n- 小组建图计算组入度\n- 统计各组有哪些项目\n- 组内建图算项目入度\n\n**返回空列表的条件：**\n\n- 小组不在得到的访问顺序中\n- 项目不在得到的该组项目的访问顺序中\n\n> `queue = collections.deque()`\n>\n> deque 是一个**双端队列**，可以从两端进行 append 的数据结构【不过从左端加入使用的是 `queue.appendleft()`】\n>\n> 还可以从两端出队列 `queue.pop()` 和 `queue.popleft()`\n>\n> 一般需要提前 `from collections import deque`\n>\n> 参考：[collections中 deque的使用](https://blog.csdn.net/u010339879/article/details/80767293)\n\n### 代码分析\n\n组数 m 也就是 group_id 的最大值\n\n遍历 n 个项目，给没有组接手的项目重新标记组号 m, m+1, …\n\n初始化几个列表：【列表的初始化建议】\n\n- 项目入度列表 - n个0 `[0]*n`\n- 小组入度列表\n- 项目邻居列表 - n个子列表 `[[] for _ in range(n)]`\n- 小组邻居列表\n- group_to_tasks 【这个列表用来做什么？】\n\n遍历任务==【组间排序】==\n\n- 按照各项目所属的小组号，在 group_to_tasks的相应位置，添加任务号\n  - 也就是说，这个数组存放的是 各组对应的任务数\n\n- 遍历先决任务的list\n  - 这个list 的id是当前任务，value 是先决任务\n  - 可以判断两个任务的是不是同组 `group[id] 和 group[value]`\n    - 不同组，那么该小组的入度 +1，先决组的邻居加上当前组【组间建图】\n    - 同组，那么任务的入度 +1，先决任务的邻居加上当前任务【组内建图】\n\n接下来获得小组的访问顺序\n\n- 使用自定义函数 `self.topological_sort`，输入是 任务或者小组，入度，邻居三个内容【具体分析见下一个部分】\n- 首先对小组间进行排序，输入小组号的列表，所有小组的入度列表，所有小组的邻居列表\n\n做一个判断：如果**组外排序**数组数量【排的是小组的访问顺序】，不等于所有组的数量，那么就直接返回空列表【为什么】\n\n最后遍历小组号，注意小组号超过 m 的就不用了==【组内排序】==【排的是组间的排序】\n\n- 对组内根据任务进行拓扑排序\n  - 输入：group_to_tasks[group_id]，任务入度，任务邻居\n- 做一个判断，如果任务排序后的长度不等于每组对应的任务数，那么就返回空\n- 把排序号的任务列表添加到最后输出列表中\n\n把最终排序列表输出\n\n---\n\n其实这里面自定义的函数==拓扑排序函数==才是关键\n\n自定义函数的具体内容：\n\n输入：待排序数组，对应入度，对应邻居列表\n\n初始化双端队列和输出列表\n\n遍历待排序列表，item\n\n- 如果 item 对应入度为0，直接将 item 加入双端列表\n- <u>【入度为0表示这就是最底层的节点了，如果不是0，那么就是说还有子节点，不饿能直接进行排序？】</u>\n\n如果双端列表为空，直接返回空数组【双端列表究竟是什么意义】\n\n接下来是广度优先排序（BFS）\n\n- 只要双端列表不为空就一直循环\n- 将双端列表的左元素移出，放入输出列表中\n  - 对该元素的邻居进行遍历\n  - 各邻居的入度 -1\n  - 如果有邻居的入度为0，那么也将这个邻居加入双端列表\n\n- 直到双端列表为空\n\n最后输出输出列表\n\n----\n\n仔细体会各步骤的用意\n\n1. 找到了每一个组对应的所有任务\n2. 避免无人认领项目的影响【至少不能认为他们是同组的】\n3. 两步排序的方法分了组间排序和组内排序，分别考虑组要靠在一起，其次是组内顺序也要考虑\n4. 首先考虑的是任务的先后关系\n   1. 先后任务在同组，那么任务入度不同\n   2. 先后任务在不同组，那么小组入度不同【小组的入度 = 先决组的数量，先决组是小组的邻居】，至于说各任务在组内入度就要看是不是还和组内任务有先后关系\n   3. 如果==任务的先决任务列表==恰好为空，那刚好，对该任务的入度和邻居都不影响【那么直接排顺序就好了，这是最简单的情况】\n5. ==【入度本身是强调先后顺序，有入度，那么该小组或者该项目就应该往后排】==\n   1. 入度越小的项目或者小组，就越应该往前排\n   2. 全都有入度，那么这个任务或者小组根本就不可行\n6. 组间排序考虑各小组的入度，组内排序考虑各项目的入度\n7. 拓扑排序的方法，就是从入度来判断一个值能不能进行排序，然后对该值的邻居排序，未排序的内容入度就应该减小，相当于在剩下的内容中进行排序\n\n> 这样通过遍历任务，获得了小组的入度和项目的入度，邻居则是同时获得的【左邻居还是右邻居并不重要，重要的是邻居都要包含在列表里面】【一个小组或者一个项目的邻居有上限吗，有什么样的意义】\n\n==建图的关键是两个列表：入度 和 邻居==\n\n```python\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for task in range(n):\n            if group[task] == -1:\n                group[task] = max_group_id\n                max_group_id += 1\n        # 到此，共有 max_group_id 个组\n\n        group_indegree = [0] * max_group_id\n        task_indegree = [0] * n\n        group_neighbours = [[] for _ in range(max_group_id)]\n        task_neighbours = [[] for _ in range(n)]\n        group_to_tasks = [[] for _ in range(max_group_id)]\n\n        for task in group:\n            group_to_tasks[task].append(task)\n        print(group_to_tasks)\n```\n\n上面是我写的一个初步的代码，我们分析一下第 16 行，我希望能够得到 每个组对应的task情况，但是这种遍历方法肯定是不对的，而是应该\n\n```python\nfor task in range(n):\n    group_to_tasks[group[task]].append(task)\n```\n\n这样才可以实现把 task 放到对应的 group 中的想法。\n\n然后，我根据回忆进行程序的复现过程中，另一个问题是组内排序的方法，应该遍历已经排好序的组的列表\n\n这样可以获得组号\n\n然后根据组号去查找每组里面的任务\n\n对任务进行排序\n\n最后把排好序的任务放到最终输出的列表就完成了！\n\n---\n\nOK，本期的解题就是这些，总体来说，简单题虽然能够尝试，但是限制了对真正算法的现象和理解，还是需要多对其他难度和其他类型的题进行尝试，从而获得更好的学习效果！","slug":"LeetCode刷题笔记四","published":1,"updated":"2021-01-26T06:17:31.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n89w0056k8tl3g892gag","content":"<p>每期10题，上一期参见<a href=\"https://sunyoe.github.io/2020/12/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/\" target=\"_blank\" rel=\"noopener\">LeetCode刷题笔记（三）</a>。</p>\n<p>本期内容动态规划内容出现复习情况，数组内容略有新意，图理论和拓扑排列初步入门。</p>\n<h1 id=\"数组和排序\"><a href=\"#数组和排序\" class=\"headerlink\" title=\"数组和排序\"></a>数组和排序</h1><h2 id=\"1046-最后一块石头的重量-排序问题\"><a href=\"#1046-最后一块石头的重量-排序问题\" class=\"headerlink\" title=\"1046. 最后一块石头的重量 - 排序问题\"></a>1046. 最后一块石头的重量 - 排序问题</h2><p>输入：整数数组（不会超过30个数字，1到1000之间）</p>\n<p>输出：特定 int 值</p>\n<p>每次运算：选出两个最大数字，返回差值（如果是0就不用返回），直到只剩下0个或1个数值，无法比较，返回该数字</p>\n<a id=\"more\"></a>\n<p>（1）暴力解法</p>\n<p>每次需要找最大的两个数字，这一步的时间和空间复杂度就已经比较高了$O(n^2)$，然后再相减，加入到新的序列中，其实还可以接受</p>\n<blockquote>\n<p>对呀，这个问题：怎么给一个list排序（如果不使用现成的库）</p>\n<p>首先：需要对比所有数字，确定是最大的，第二大那就排除第一个再对比一遍，做差</p>\n<p>然后：把差值和所有数字对比，放在合适的位置（重排位置确实是用链表更好一点，但是如果执意要用列表呢，就需要拆一下再合并了）</p>\n<p>这个方法确实是过于复杂</p>\n</blockquote>\n<p>（2）差值，有什么规律？</p>\n<p>简单一点，如果是1-10递增，那么每次相减都是1，连续四次之后，多了4个1，还剩1和2，然后5个1，可以预见最后有个1</p>\n<p>如果2，4，6，8，那么2，4，2，然后2，2，然后0</p>\n<p>这题好像确实也没有什么太多的方法就是按方法排好序就好了！</p>\n<p>相当于本题的核心目的就是实现排序！！</p>\n<p>排序的关键是找到数字在列表中的位置。</p>\n<blockquote>\n<p>如果需要排列一个从大到小的数列，那么就应该比较当前数字是不是比已有序列中的数字大</p>\n</blockquote>\n<p>所以我最后的步骤是：</p>\n<p>（1）先写一个独立函数，在已经排好顺序的序列中找到当前元素应该放置的位置，放进去</p>\n<p>（2）对原始序列进行一次排序（分两步）</p>\n<ul>\n<li>遍历原序列，移位</li>\n<li>把原序列中的当前数值放到新序列该放的位置上</li>\n</ul>\n<p>（3）不停做差值，把差值放到序列中</p>\n<blockquote>\n<p>看题解，很多用了sort</p>\n<p>我没有用sort，除了一些list的用法，几乎是完全自主的</p>\n</blockquote>\n<h2 id=\"605-种花问题\"><a href=\"#605-种花问题\" class=\"headerlink\" title=\"605. 种花问题\"></a>605. 种花问题</h2><p>输入：整数数组 flowered（只有0和1），整数 n</p>\n<p>输入：布尔量</p>\n<p>功能：向数组中添加n个1，要求这些1不能相邻，如果能做到，返回true，做不到，返回false</p>\n<p>限制：数组长度在1到20000之间，n非负，不会超过数组大小；按照题目的意思来看，已经是1的位置应该是不能被替换</p>\n<p>思路：</p>\n<p>这首先是回答能不能，而不是回答怎么做，所以更像一个数学问题：</p>\n<p>如果当前数组中全部是在奇数位置，那么非常简单，计算有多少个奇数位置</p>\n<p>比较糟糕的是有的在奇数位置，有的在偶数位置，这样在非常紧密地排列时少不了要相遇，会少一</p>\n<p>怎么检查现有数值的位置？</p>\n<p>另一个思路：</p>\n<p>两个1之间有多少个0：</p>\n<p>（1）奇数个0，直接减1除以2</p>\n<p>（2）偶数个0，直接减2除以2</p>\n<p>特殊情况，头部为0，偶数不用减2</p>\n<p>尾部为0，偶数不用减2</p>\n<blockquote>\n<p>头部的确需要考虑，那么当遇到1了，就直接表示头部过了就可以了</p>\n<p>但是尾部其实不用考虑，会跳出的</p>\n</blockquote>\n<p>现在遇到一个问题：[0] 的情况，那么这个应该是可以种植1个，但是按之前的计数方法是不可以的</p>\n<p>所以最终方法是：</p>\n<p>（1）全0的数组，直接加1除以2，比较就好了</p>\n<p>（2）开头为0，设置一个start的flag，遇到1就会转换，并计算开头情况</p>\n<p>（3）逐步前进，遇到1重置，计算中间的数量</p>\n<p>（4）来到末尾，根据最后一个数值是1还是0做最后叠加</p>\n<p>（5）最后判断输出即可</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210101123109261.png\" alt=\"image-20210101123109261\"></p>\n<p>这个用时非常Amazing！</p>\n<h2 id=\"303-区域和检索-数组不可变\"><a href=\"#303-区域和检索-数组不可变\" class=\"headerlink\" title=\"303 区域和检索 - 数组不可变\"></a>303 区域和检索 - 数组不可变</h2><p>这道题我一开始有点懵逼</p>\n<p>题目的意思是完成一个class的编写，该类的初始函数需要完成的是实例化类（传递列表）</p>\n<p>另一个函数则是用来计算该数列第i个到第j个的总和</p>\n<p>那么我直接用sum就计算好了</p>\n<p>确实就这么完成了，但是问题当然是：这样相当于比如要计算多个总和的时候，就要一个一个计算了，是不是显得有一点冗余？</p>\n<p>那还应该怎么做？</p>\n<h3 id=\"阅读题解\"><a href=\"#阅读题解\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>其实关键问题就是上面说的，每次计算一次总和，肯定是重复了，这样是不好的</p>\n<p>比较省心的方法就是：</p>\n<p>计算到第i步的总和$f_i$，第j步的总和$f_j$，最后结果等于$f_j-f_i$</p>\n<p>而且$f_{i+1}=f_i+x_{i+1}$，这样的话就能避免循环，节省时间，确实是一种好方法</p>\n<p>但是我写完之后遇到一些小问题：</p>\n<p>（1）如果是从0到2的序列，那么$f_0$应该是0的，但是按以往的方法却不是的</p>\n<ul>\n<li>看到题解中有一种巧妙的方法：sums = [0, ]</li>\n<li>然后把每次计算好的 新的sums值 append 在后面：<code>nums.append(self.num_sum[i]+nums[i])</code></li>\n</ul>\n<p>（2）关于 <strong>序列为空</strong>（NoneArray）的问题，如果是空的序列，<strong>计算长度 len 函数</strong>（<code>n = len(nums)</code>）是会出问题的！【我刚才的问题可能是返回了0，而没有返回None】</p>\n<ul>\n<li>但是奇怪的是，在 for 循环中使用 <code>for i in range(len(nums))</code> 即使nums是空的也没有问题</li>\n</ul>\n<h2 id=\"剑指offer-03-数组中重复的数值\"><a href=\"#剑指offer-03-数组中重复的数值\" class=\"headerlink\" title=\"剑指offer 03. 数组中重复的数值\"></a>剑指offer 03. 数组中重复的数值</h2><p>输入：整数数组</p>\n<p>输出：数组中的某个数值</p>\n<p>要求：该数值一定是在数组中重复出现过的</p>\n<p>老办法：计算所有数字出现过的次数，然后&gt;2的都可以输出</p>\n<p>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRepeatNumber</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        sort = [<span class=\"number\">0</span>] * (max(nums)+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            sort[i] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort.index(max(sort))</span><br></pre></td></tr></table></figure>\n<p>也的确可以通过，但是这种方法不太好</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210105161105089.png\" alt=\"image-20210105161105089\"></p>\n<p>有没有其他减少复杂度的方法，比如先排个序？不行，并不能保证重复的数字出现在某个位置</p>\n<h3 id=\"阅读题解-1\"><a href=\"#阅读题解-1\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>（1）遍历数组</p>\n<p>这个方法告诉我们，根本就不用遍历完，只需要遇到重复的数字立马返回</p>\n<p>当然新的数字需要加入到一个新的集合中，然后判断下一个数字是新数字还是已经遇到的数字</p>\n<p>（2）原地交换</p>\n<p>本题中有一个条件：数组长度为n，而且所有数字小于 n</p>\n<p>那么可以让元素的索引和值一一对应</p>\n<p>第一次遇到，交换索引</p>\n<p>第二次遇到，直接能够判断$nums[x] = x$，所以就得到了重复的数字</p>\n<h2 id=\"830-较大分组的位置\"><a href=\"#830-较大分组的位置\" class=\"headerlink\" title=\"830. 较大分组的位置\"></a>830. 较大分组的位置</h2><p>输入：字符串s，全是小写字母</p>\n<p>输出：二维数组，每个元素是一个还有两个整数的数组</p>\n<p>条件：较大分组指的是连续三个字符及以上的分组，两个整数分别是起始坐标和终止坐标</p>\n<p>这个简单啊，直接遍历不就好了，如果不相等直接重置</p>\n<p>相等累计，直到结尾</p>\n<p>然后把数组汇总一下就可以了</p>\n<p>一个特例：就是最后几个字母是一样的，那么就会一直continue，所以到最后再判断一次end和start是不是相等，得出答案</p>\n<p>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largeGroupPositions</span><span class=\"params\">(self, s: str)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len(s):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        output = []</span><br><span class=\"line\">        start, end = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == s[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                end += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> end - start &gt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">                output.append([start, end])</span><br><span class=\"line\">            start, end = i, i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> end - start &gt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">            output.append([start, end])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br></pre></td></tr></table></figure>\n<p>可以通过，但是速度和空间都比较糟糕</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210105163910474.png\" alt=\"image-20210105163910474\"></p>\n<h3 id=\"阅读题解-2\"><a href=\"#阅读题解-2\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>就是一次遍历的方法，记录当前分组的长度，如果字符不同，那么就说明已经到尾部了</p>\n<p>但是为什么我的这个代码这么慢呢？</p>\n<p>（1）其实不用同时更新start和end，其实可以只记录start，因为end会直接由 i 来确定</p>\n<p>减少一个变量之后，确实减少了部分用时，但是内存还是比较大</p>\n<h2 id=\"189-旋转数组-数组\"><a href=\"#189-旋转数组-数组\" class=\"headerlink\" title=\"189. 旋转数组 - 数组\"></a>189. 旋转数组 - 数组</h2><p>输入：整数数组nums，非负数 k</p>\n<p>输出：没有输出，不要输出，直接对原数组进行调整即可</p>\n<p>功能：间数组中的元素向右移动 k 个位置</p>\n<hr>\n<p>题目中说至少有三种方法可以解决该问题，而且要求空间复杂度 O(1) - 原地算法</p>\n<hr>\n<p>从示例观察来看，直接把数组中 -k到最后一个数字整体搬到最前面就好了，但是如果 k 比数组长度还要大呢？</p>\n<p>问题是，没有输出，那我怎么输出呢</p>\n<p>我这种方法就是使用呢额外的数组，需要注意的是，必须要使用调整nums的方法，而不是生成nums的方法</p>\n<p>==这个方法的本质是把原数组中下标为 $i$ 的元素，放在了新数组的 $(i+k)\\mod n$的位置==</p>\n<hr>\n<p>所给提示：</p>\n<p>（1）最简单的方法需要增加存储空间</p>\n<p>（2）比较困难的就是再不添加任何空间的情况下解决问题，这意味着需要使用某种方法在原始数组的基础上移动相关的元素</p>\n<p>（3）一种方法是 reversing the array（or part of it），翻转？</p>\n<hr>\n<h3 id=\"阅读题解-3\"><a href=\"#阅读题解-3\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p><strong>环状替换</strong></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210108104525947.png\" alt=\"image-20210108104525947\"></p>\n<ul>\n<li>比如从 0 =》 到 $(0+k)\\mod n$，然后从 $(0+k)\\mod n$ 到$(0+2k)\\mod n$，一直到回到 0 位置，这个过程一定是走了整数个圈数</li>\n<li>比如 a 圈，总共遍历了 b 个元素</li>\n<li>那么 $ an = bk$ 总的元素数量是相等的，所以 an 一定是 n 和 k 的公倍数（不能重复，所以是最小公倍数 $lcm (n,k)$)</li>\n<li>b 也就是这个最小公倍数 除以 k ，$lcm(n,k)/k$</li>\n<li>每次遍历会 访问 b 个元素，所以最后应该遍历 $n/b$ 次</li>\n<li>由于 b，n，k之间的关系</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210108105810711.png\" alt=\"image-20210108105810711\"></p>\n<p>所以最后需要遍历 n 和 k 的最大公约数次</p>\n<p>应该说，这个方法看起来的可行性高，而且也不难</p>\n<p><strong>数组翻转</strong></p>\n<p>基于事实：将数组元素向右移动k次，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置</p>\n<p>所以就可以先把所有元素翻转，这样尾部的 k mod n 个元素被移至头部</p>\n<p>然后再翻转前后两个区间，以 k mod n -1 为界，就得到了最后的大浪</p>\n<p>这里的示例中写了一个翻转的函数，简单来说就是用 一个调换数组元素的方法 实现 整个数组的翻转</p>\n<p>（1）指定 start 和end结点</p>\n<p>（2）判断 start 和end 的关系，然后将两个数字对应的数组中的数字互换</p>\n<p>（3）start +1，end -1</p>\n<p>然后循环，这个方法很不错</p>\n<blockquote>\n<p>问：python中对数组的操作都有哪些？</p>\n<p>list.reverse() 就是对列表进行反向</p>\n<p>list.sort() 对原列表进行排序</p>\n</blockquote>\n<p>但是截取一段，然后进行翻转的方法是不可以的，这样其实还是相当于增加了空</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"面试题08-01-三步问题\"><a href=\"#面试题08-01-三步问题\" class=\"headerlink\" title=\"面试题08.01 三步问题\"></a>面试题08.01 三步问题</h2><p>输入：int 类型数值 n</p>\n<p>输出：int 类型数值</p>\n<p>功能：从0开始，每次可以增加1，2或3，直到数值加到n，求所有到达 n 的种类</p>\n<p>本题是可以通过暴力方法进行求解的，那么就是排序种类问题</p>\n<p>如果使用动态规划的方法呢？</p>\n<p>其实到达从上一步到达下一步的方法只有3种路径</p>\n<blockquote>\n<p>提示1：自上而下处理问题，先从最后一步开始</p>\n</blockquote>\n<p>最后一步有三种方法</p>\n<p>但是从 i 到 i+3 不止一种走法</p>\n<blockquote>\n<p>提示2：如果直到跳到第100级台阶之前的每一级台阶的跳法数量，可以计算第100级台阶的跳法数量吗？</p>\n</blockquote>\n<p>这个提示实在是太妙了</p>\n<p>那肯定是 【99级的跳法数量 + 98级跳法数量 + 97级跳法数量】</p>\n<p>虽然有以下几种情况：</p>\n<p>99级中有两种情况：</p>\n<ul>\n<li>98级 + 1级</li>\n<li>97级 + 2级</li>\n</ul>\n<p>98级一种情况：</p>\n<ul>\n<li>97级 + 1级</li>\n</ul>\n<p>但是这些情况并不影响各自到100级台阶的情况</p>\n<p>所以这是在提醒我，$sum_n = sum_{n-1}+sum_{n-2}+sum_{n-3}$</p>\n<blockquote>\n<p>提示3和提示4是在强调：相加还是相乘</p>\n<p>提示4：</p>\n<p>当我们先做什么再做什么，需要相乘</p>\n<p>当我们这样做或那样做，需要相加</p>\n</blockquote>\n<p>初始条件：</p>\n<p>sum_0 = 0</p>\n<p>sum_1 = 1</p>\n<p>sum_2 = 2</p>\n<p>sum_3 = 4</p>\n<p>sum_4 = 7 …</p>\n<p>这么说这就是一个数列啊，直接按照数列的方法也是可以进行求解的！</p>\n<p>也就是说本题是在求解一个数列，不过这个数列的项不少，要找一个通项公式可能比较困难</p>\n<blockquote>\n<p>提示5，6是关于优化的，计算时间复杂度</p>\n<p>制表法是什么，怎么样进行优化</p>\n</blockquote>\n<p>时间复杂度在哪，显然是在重复计算上，要不停变换三个加数，但是实际上加数是在不断交替的，而并非真的是在重新计算，但现在的情况是每个加数都进行了重新计算</p>\n<p>还有一个问题，是不是可以通过除以3来把这个过程优化一下？</p>\n<h3 id=\"阅读题解-4\"><a href=\"#阅读题解-4\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>题解中讲到的方法是使用矩阵实现快速计算</p>\n<p>但是实际上使用递推的方法就是可以实现的，问题是中间的数也会比较大，所以只在最后一步取模会导致空间和用时都比较高，可以考虑每一步都给 几个数值取模，这样的话不影响结果，还能保证时间和空间复杂度</p>\n<h2 id=\"509-斐波那契数\"><a href=\"#509-斐波那契数\" class=\"headerlink\" title=\"509. 斐波那契数\"></a>509. 斐波那契数</h2><p>输入：n</p>\n<p>输出：f(n)表示斐波那契数列的第n个数字</p>\n<p>注意：f(0) = 0, f(1)=1</p>\n<p>斐波那契数列的问题其实之前遇到过，确实有一些比较好的方法可以借鉴，很经典</p>\n<h2 id=\"面试题16-17-连续数列\"><a href=\"#面试题16-17-连续数列\" class=\"headerlink\" title=\"面试题16.17. 连续数列\"></a>面试题16.17. 连续数列</h2><p>输入： 整数数组</p>\n<p>输出：子数组和</p>\n<p>要求：该子数组连续，且该子数组的和再所有子数组最大</p>\n<blockquote>\n<p>本题和53题，和offer42题为同一个问题</p>\n</blockquote>\n<p>f(n) 表示以n结尾的最大和的连续子数组的和</p>\n<p>那么$f(n+1) = max(f(n), f(n)+i_{n+1})$是吗？显然不一定，要让这个成立，只需要 $i_{n+1}$是正数就可以了【错了！！！】</p>\n<p>是$f(n+1) = max(f(n)+i_{n+1}, i_{n+1})$，其实也还是重置的方法</p>\n<blockquote>\n<p>提示1：把数字想象成正负交替的数字序列</p>\n<p>因为实际上不会只包含正序列或者负序列</p>\n<p>提示2：如果有一个和为负数的数列，那么一定不是一个数列的开始或结束（因为这个数列完全可以去掉）</p>\n<p>如果它们连接了另外两个数列，那么就可以以一个数列的形式出现</p>\n<p>提示3：从数组的开头开始，当这个子数列增长时，仍然是最佳子数列</p>\n<p>但是一旦变成负数，就没有意义了</p>\n</blockquote>\n<p>这让我想起以前做过的一道题，就是把类似的数列的和存储了下来</p>\n<p>只要是负的就重置，并把变负之前的和记录下来</p>\n<p>相当于是在计算以每一个数字开头的数组的最大连续正数和</p>\n<blockquote>\n<p>总结一下，这类题已经做了三遍了：</p>\n<ul>\n<li><p>刚开始还愿意仔细分析序列的正负特点，到后来只愿意使用动态规划来做了</p>\n</li>\n<li><p>动态规划上，关于连续的特点，要么是接着上一个序列，要么是从头开始：$f(n+1) = max(f(n)+i_{n+1}, i_{n+1})$</p>\n</li>\n<li>而间断的特点就是，可以是上一个，或者是上一个加上当前的：$f(n+1) = max(f(n), f(n)+i_{n+1})$</li>\n</ul>\n<p>有的题目需要给出连续的个数</p>\n<p>有的题需要给出最后的和，一定要适应一下</p>\n</blockquote>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><h2 id=\"1203-项目管理-图，拓扑排序\"><a href=\"#1203-项目管理-图，拓扑排序\" class=\"headerlink\" title=\"1203. 项目管理 - 图，拓扑排序\"></a>1203. 项目管理 - 图，拓扑排序</h2><p>输入： n - 项目数量， m - 小组数，group - 每个项目对应的小组，beforeItems - 每个项目的先决项目</p>\n<p>输出：列表 - 项目排序</p>\n<p>要求：</p>\n<ul>\n<li>每个项目对应的小组写在 group中，最多一个小组负责，全程不需要修改，只需要判断，-1表示没有小组接手，但是仍然需要进行排序</li>\n<li>同小组的项目需要相邻</li>\n<li>要先完成先决项目，才能完成后续项目</li>\n<li>小组和项目都是从0开始排序</li>\n</ul>\n<hr>\n<p>从示例来看，首先需要把先决项目完成</p>\n<p>然后可以根据项目组进行排序</p>\n<blockquote>\n<p>感觉是使用树结构的方法会比较好</p>\n<p>从before开始查找整个树</p>\n<p>官方标签：深度优先搜索，图，拓扑排序</p>\n</blockquote>\n<hr>\n<p>三个提示：</p>\n<ul>\n<li>图问题</li>\n<li>在 dependency graph 的基础上找一个拓扑排序的方法</li>\n<li>建立两个图，一个基于小组，一个基于项目</li>\n</ul>\n<hr>\n<p>在本问题中，我需要知道的是：</p>\n<p>（1）我应该怎么样构建一个图？</p>\n<p>（2）怎样使用图进行排序</p>\n<blockquote>\n<p>拓扑排序</p>\n<p>有向图G，将G的n个点排列成一组序列，任意一对顶点（u -&gt; v）之间判断边</p>\n<p>如果存在有向边 u -&gt; v，那么 u 在序列中需要出现在 v 的前面</p>\n</blockquote>\n<p>本题中</p>\n<p>（1）把项目 items 抽象成点，项目间的依赖关系抽象成边，依赖条件就是有向边，进行拓扑排序</p>\n<p>（2）==【同组项目要彼此相邻】== = 组与组之间也存在依赖关系，所以要解决组之间的拓扑排序</p>\n<p>所以，本题分两步</p>\n<p>（1）首先解决组与组之间的依赖关系，组抽象成点，组与组的关系抽象成边，建图判断是否存在拓扑排序（groupTopSort，以组为先）</p>\n<p>（2）存在拓扑关系（groupTopSort），再确定组内依赖关系，遍历拓扑序，对于任意 组 g，对所有属于组 g 的点再进行拓扑排序，最后把组内拓扑排序按顺序放入答案数组</p>\n<p>细节</p>\n<p>（1）部分项目无人接手，groupId = -1，不利于编码，可以重新编号，但又不能与真实的小组编号冲突，可以从 m 开始正序编号【真实小组编号在0到m-1之间】</p>\n<p>（2）将拓扑排序抽象成一个函数进行复用，函数定义 <code>topSort(deg, graph, items)</code>表示：</p>\n<ul>\n<li>待排序点集 items</li>\n<li>点的入度数组 deg</li>\n<li>点的连边关系 graph，graph[i] 表示点 i 连出点组成的集合</li>\n</ul>\n<p>（3）建图过程中，如果发现两个项目属于不同的项目组，组间关系图添加相应边，否则在组内关系图中添加相应边</p>\n<hr>\n<h3 id=\"阅读题解-5\"><a href=\"#阅读题解-5\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><blockquote>\n<p>参考一个题解说明：<a href=\"https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/python-liang-ci-tuo-bu-pai-xu-100-by-mil-rtwg/\" target=\"_blank\" rel=\"noopener\">[Python] 两次拓扑排序100%</a></p>\n<p>入度：</p>\n<p>有向图G中，对于节点 v，从节点 n1，n2，…，nm出发都可以一步到达 v，那么节点 v 的入度就是 m（是说v的来源有m条吗？）</p>\n<p>拓扑排序</p>\n<p>图中节点与节点之间的访问顺序，可用拓扑排序方法生成一个可行的访问序列</p>\n<p>（1）建图</p>\n<p>（2）统计图中所有节点的入度</p>\n<p>（3）BFS 方法获得访问序列</p>\n<ul>\n<li>将入度为0的节点添加到队列中</li>\n<li>遍历队列<ul>\n<li>得到队首节点并出队</li>\n<li>将当前节点添加到访问序列中</li>\n<li>将当前节点所有邻居节点的入度 -1</li>\n<li>如果邻居节点的入度变为0，将邻居节点入队</li>\n</ul>\n</li>\n</ul>\n<p>【？？？】确实没看懂</p>\n</blockquote>\n<p>方法：</p>\n<p>两次嵌套拓扑排序</p>\n<p>思路：</p>\n<ol>\n<li>建图</li>\n<li>对小组进行拓扑排序，获得访问小组的顺序</li>\n<li>遍历小组的访问顺序<ol>\n<li>得到该组的项目顺序</li>\n<li>将项目顺序添加到答案中</li>\n</ol>\n</li>\n</ol>\n<p>建图：</p>\n<ul>\n<li>无组项目给全新组号</li>\n<li>小组建图计算组入度</li>\n<li>统计各组有哪些项目</li>\n<li>组内建图算项目入度</li>\n</ul>\n<p><strong>返回空列表的条件：</strong></p>\n<ul>\n<li>小组不在得到的访问顺序中</li>\n<li>项目不在得到的该组项目的访问顺序中</li>\n</ul>\n<blockquote>\n<p><code>queue = collections.deque()</code></p>\n<p>deque 是一个<strong>双端队列</strong>，可以从两端进行 append 的数据结构【不过从左端加入使用的是 <code>queue.appendleft()</code>】</p>\n<p>还可以从两端出队列 <code>queue.pop()</code> 和 <code>queue.popleft()</code></p>\n<p>一般需要提前 <code>from collections import deque</code></p>\n<p>参考：<a href=\"https://blog.csdn.net/u010339879/article/details/80767293\" target=\"_blank\" rel=\"noopener\">collections中 deque的使用</a></p>\n</blockquote>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>组数 m 也就是 group_id 的最大值</p>\n<p>遍历 n 个项目，给没有组接手的项目重新标记组号 m, m+1, …</p>\n<p>初始化几个列表：【列表的初始化建议】</p>\n<ul>\n<li>项目入度列表 - n个0 <code>[0]*n</code></li>\n<li>小组入度列表</li>\n<li>项目邻居列表 - n个子列表 <code>[[] for _ in range(n)]</code></li>\n<li>小组邻居列表</li>\n<li>group_to_tasks 【这个列表用来做什么？】</li>\n</ul>\n<p>遍历任务==【组间排序】==</p>\n<ul>\n<li><p>按照各项目所属的小组号，在 group_to_tasks的相应位置，添加任务号</p>\n<ul>\n<li>也就是说，这个数组存放的是 各组对应的任务数</li>\n</ul>\n</li>\n<li><p>遍历先决任务的list</p>\n<ul>\n<li>这个list 的id是当前任务，value 是先决任务</li>\n<li>可以判断两个任务的是不是同组 <code>group[id] 和 group[value]</code><ul>\n<li>不同组，那么该小组的入度 +1，先决组的邻居加上当前组【组间建图】</li>\n<li>同组，那么任务的入度 +1，先决任务的邻居加上当前任务【组内建图】</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>接下来获得小组的访问顺序</p>\n<ul>\n<li>使用自定义函数 <code>self.topological_sort</code>，输入是 任务或者小组，入度，邻居三个内容【具体分析见下一个部分】</li>\n<li>首先对小组间进行排序，输入小组号的列表，所有小组的入度列表，所有小组的邻居列表</li>\n</ul>\n<p>做一个判断：如果<strong>组外排序</strong>数组数量【排的是小组的访问顺序】，不等于所有组的数量，那么就直接返回空列表【为什么】</p>\n<p>最后遍历小组号，注意小组号超过 m 的就不用了==【组内排序】==【排的是组间的排序】</p>\n<ul>\n<li>对组内根据任务进行拓扑排序<ul>\n<li>输入：group_to_tasks[group_id]，任务入度，任务邻居</li>\n</ul>\n</li>\n<li>做一个判断，如果任务排序后的长度不等于每组对应的任务数，那么就返回空</li>\n<li>把排序号的任务列表添加到最后输出列表中</li>\n</ul>\n<p>把最终排序列表输出</p>\n<hr>\n<p>其实这里面自定义的函数==拓扑排序函数==才是关键</p>\n<p>自定义函数的具体内容：</p>\n<p>输入：待排序数组，对应入度，对应邻居列表</p>\n<p>初始化双端队列和输出列表</p>\n<p>遍历待排序列表，item</p>\n<ul>\n<li>如果 item 对应入度为0，直接将 item 加入双端列表</li>\n<li><u>【入度为0表示这就是最底层的节点了，如果不是0，那么就是说还有子节点，不饿能直接进行排序？】</u></li>\n</ul>\n<p>如果双端列表为空，直接返回空数组【双端列表究竟是什么意义】</p>\n<p>接下来是广度优先排序（BFS）</p>\n<ul>\n<li>只要双端列表不为空就一直循环</li>\n<li><p>将双端列表的左元素移出，放入输出列表中</p>\n<ul>\n<li>对该元素的邻居进行遍历</li>\n<li>各邻居的入度 -1</li>\n<li>如果有邻居的入度为0，那么也将这个邻居加入双端列表</li>\n</ul>\n</li>\n<li><p>直到双端列表为空</p>\n</li>\n</ul>\n<p>最后输出输出列表</p>\n<hr>\n<p>仔细体会各步骤的用意</p>\n<ol>\n<li>找到了每一个组对应的所有任务</li>\n<li>避免无人认领项目的影响【至少不能认为他们是同组的】</li>\n<li>两步排序的方法分了组间排序和组内排序，分别考虑组要靠在一起，其次是组内顺序也要考虑</li>\n<li>首先考虑的是任务的先后关系<ol>\n<li>先后任务在同组，那么任务入度不同</li>\n<li>先后任务在不同组，那么小组入度不同【小组的入度 = 先决组的数量，先决组是小组的邻居】，至于说各任务在组内入度就要看是不是还和组内任务有先后关系</li>\n<li>如果==任务的先决任务列表==恰好为空，那刚好，对该任务的入度和邻居都不影响【那么直接排顺序就好了，这是最简单的情况】</li>\n</ol>\n</li>\n<li>==【入度本身是强调先后顺序，有入度，那么该小组或者该项目就应该往后排】==<ol>\n<li>入度越小的项目或者小组，就越应该往前排</li>\n<li>全都有入度，那么这个任务或者小组根本就不可行</li>\n</ol>\n</li>\n<li>组间排序考虑各小组的入度，组内排序考虑各项目的入度</li>\n<li>拓扑排序的方法，就是从入度来判断一个值能不能进行排序，然后对该值的邻居排序，未排序的内容入度就应该减小，相当于在剩下的内容中进行排序</li>\n</ol>\n<blockquote>\n<p>这样通过遍历任务，获得了小组的入度和项目的入度，邻居则是同时获得的【左邻居还是右邻居并不重要，重要的是邻居都要包含在列表里面】【一个小组或者一个项目的邻居有上限吗，有什么样的意义】</p>\n</blockquote>\n<p>==建图的关键是两个列表：入度 和 邻居==</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortItems</span><span class=\"params\">(self, n: int, m: int, group: List[int], beforeItems: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        max_group_id = m</span><br><span class=\"line\">        <span class=\"keyword\">for</span> task <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> group[task] == <span class=\"number\">-1</span>:</span><br><span class=\"line\">                group[task] = max_group_id</span><br><span class=\"line\">                max_group_id += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 到此，共有 max_group_id 个组</span></span><br><span class=\"line\"></span><br><span class=\"line\">        group_indegree = [<span class=\"number\">0</span>] * max_group_id</span><br><span class=\"line\">        task_indegree = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">        group_neighbours = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_group_id)]</span><br><span class=\"line\">        task_neighbours = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        group_to_tasks = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_group_id)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> task <span class=\"keyword\">in</span> group:</span><br><span class=\"line\">            group_to_tasks[task].append(task)</span><br><span class=\"line\">        print(group_to_tasks)</span><br></pre></td></tr></table></figure>\n<p>上面是我写的一个初步的代码，我们分析一下第 16 行，我希望能够得到 每个组对应的task情况，但是这种遍历方法肯定是不对的，而是应该</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> task <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    group_to_tasks[group[task]].append(task)</span><br></pre></td></tr></table></figure>\n<p>这样才可以实现把 task 放到对应的 group 中的想法。</p>\n<p>然后，我根据回忆进行程序的复现过程中，另一个问题是组内排序的方法，应该遍历已经排好序的组的列表</p>\n<p>这样可以获得组号</p>\n<p>然后根据组号去查找每组里面的任务</p>\n<p>对任务进行排序</p>\n<p>最后把排好序的任务放到最终输出的列表就完成了！</p>\n<hr>\n<p>OK，本期的解题就是这些，总体来说，简单题虽然能够尝试，但是限制了对真正算法的现象和理解，还是需要多对其他难度和其他类型的题进行尝试，从而获得更好的学习效果！</p>\n","site":{"data":{}},"excerpt":"<p>每期10题，上一期参见<a href=\"https://sunyoe.github.io/2020/12/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/\" target=\"_blank\" rel=\"noopener\">LeetCode刷题笔记（三）</a>。</p>\n<p>本期内容动态规划内容出现复习情况，数组内容略有新意，图理论和拓扑排列初步入门。</p>\n<h1 id=\"数组和排序\"><a href=\"#数组和排序\" class=\"headerlink\" title=\"数组和排序\"></a>数组和排序</h1><h2 id=\"1046-最后一块石头的重量-排序问题\"><a href=\"#1046-最后一块石头的重量-排序问题\" class=\"headerlink\" title=\"1046. 最后一块石头的重量 - 排序问题\"></a>1046. 最后一块石头的重量 - 排序问题</h2><p>输入：整数数组（不会超过30个数字，1到1000之间）</p>\n<p>输出：特定 int 值</p>\n<p>每次运算：选出两个最大数字，返回差值（如果是0就不用返回），直到只剩下0个或1个数值，无法比较，返回该数字</p>","more":"<p>（1）暴力解法</p>\n<p>每次需要找最大的两个数字，这一步的时间和空间复杂度就已经比较高了$O(n^2)$，然后再相减，加入到新的序列中，其实还可以接受</p>\n<blockquote>\n<p>对呀，这个问题：怎么给一个list排序（如果不使用现成的库）</p>\n<p>首先：需要对比所有数字，确定是最大的，第二大那就排除第一个再对比一遍，做差</p>\n<p>然后：把差值和所有数字对比，放在合适的位置（重排位置确实是用链表更好一点，但是如果执意要用列表呢，就需要拆一下再合并了）</p>\n<p>这个方法确实是过于复杂</p>\n</blockquote>\n<p>（2）差值，有什么规律？</p>\n<p>简单一点，如果是1-10递增，那么每次相减都是1，连续四次之后，多了4个1，还剩1和2，然后5个1，可以预见最后有个1</p>\n<p>如果2，4，6，8，那么2，4，2，然后2，2，然后0</p>\n<p>这题好像确实也没有什么太多的方法就是按方法排好序就好了！</p>\n<p>相当于本题的核心目的就是实现排序！！</p>\n<p>排序的关键是找到数字在列表中的位置。</p>\n<blockquote>\n<p>如果需要排列一个从大到小的数列，那么就应该比较当前数字是不是比已有序列中的数字大</p>\n</blockquote>\n<p>所以我最后的步骤是：</p>\n<p>（1）先写一个独立函数，在已经排好顺序的序列中找到当前元素应该放置的位置，放进去</p>\n<p>（2）对原始序列进行一次排序（分两步）</p>\n<ul>\n<li>遍历原序列，移位</li>\n<li>把原序列中的当前数值放到新序列该放的位置上</li>\n</ul>\n<p>（3）不停做差值，把差值放到序列中</p>\n<blockquote>\n<p>看题解，很多用了sort</p>\n<p>我没有用sort，除了一些list的用法，几乎是完全自主的</p>\n</blockquote>\n<h2 id=\"605-种花问题\"><a href=\"#605-种花问题\" class=\"headerlink\" title=\"605. 种花问题\"></a>605. 种花问题</h2><p>输入：整数数组 flowered（只有0和1），整数 n</p>\n<p>输入：布尔量</p>\n<p>功能：向数组中添加n个1，要求这些1不能相邻，如果能做到，返回true，做不到，返回false</p>\n<p>限制：数组长度在1到20000之间，n非负，不会超过数组大小；按照题目的意思来看，已经是1的位置应该是不能被替换</p>\n<p>思路：</p>\n<p>这首先是回答能不能，而不是回答怎么做，所以更像一个数学问题：</p>\n<p>如果当前数组中全部是在奇数位置，那么非常简单，计算有多少个奇数位置</p>\n<p>比较糟糕的是有的在奇数位置，有的在偶数位置，这样在非常紧密地排列时少不了要相遇，会少一</p>\n<p>怎么检查现有数值的位置？</p>\n<p>另一个思路：</p>\n<p>两个1之间有多少个0：</p>\n<p>（1）奇数个0，直接减1除以2</p>\n<p>（2）偶数个0，直接减2除以2</p>\n<p>特殊情况，头部为0，偶数不用减2</p>\n<p>尾部为0，偶数不用减2</p>\n<blockquote>\n<p>头部的确需要考虑，那么当遇到1了，就直接表示头部过了就可以了</p>\n<p>但是尾部其实不用考虑，会跳出的</p>\n</blockquote>\n<p>现在遇到一个问题：[0] 的情况，那么这个应该是可以种植1个，但是按之前的计数方法是不可以的</p>\n<p>所以最终方法是：</p>\n<p>（1）全0的数组，直接加1除以2，比较就好了</p>\n<p>（2）开头为0，设置一个start的flag，遇到1就会转换，并计算开头情况</p>\n<p>（3）逐步前进，遇到1重置，计算中间的数量</p>\n<p>（4）来到末尾，根据最后一个数值是1还是0做最后叠加</p>\n<p>（5）最后判断输出即可</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210101123109261.png\" alt=\"image-20210101123109261\"></p>\n<p>这个用时非常Amazing！</p>\n<h2 id=\"303-区域和检索-数组不可变\"><a href=\"#303-区域和检索-数组不可变\" class=\"headerlink\" title=\"303 区域和检索 - 数组不可变\"></a>303 区域和检索 - 数组不可变</h2><p>这道题我一开始有点懵逼</p>\n<p>题目的意思是完成一个class的编写，该类的初始函数需要完成的是实例化类（传递列表）</p>\n<p>另一个函数则是用来计算该数列第i个到第j个的总和</p>\n<p>那么我直接用sum就计算好了</p>\n<p>确实就这么完成了，但是问题当然是：这样相当于比如要计算多个总和的时候，就要一个一个计算了，是不是显得有一点冗余？</p>\n<p>那还应该怎么做？</p>\n<h3 id=\"阅读题解\"><a href=\"#阅读题解\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>其实关键问题就是上面说的，每次计算一次总和，肯定是重复了，这样是不好的</p>\n<p>比较省心的方法就是：</p>\n<p>计算到第i步的总和$f_i$，第j步的总和$f_j$，最后结果等于$f_j-f_i$</p>\n<p>而且$f_{i+1}=f_i+x_{i+1}$，这样的话就能避免循环，节省时间，确实是一种好方法</p>\n<p>但是我写完之后遇到一些小问题：</p>\n<p>（1）如果是从0到2的序列，那么$f_0$应该是0的，但是按以往的方法却不是的</p>\n<ul>\n<li>看到题解中有一种巧妙的方法：sums = [0, ]</li>\n<li>然后把每次计算好的 新的sums值 append 在后面：<code>nums.append(self.num_sum[i]+nums[i])</code></li>\n</ul>\n<p>（2）关于 <strong>序列为空</strong>（NoneArray）的问题，如果是空的序列，<strong>计算长度 len 函数</strong>（<code>n = len(nums)</code>）是会出问题的！【我刚才的问题可能是返回了0，而没有返回None】</p>\n<ul>\n<li>但是奇怪的是，在 for 循环中使用 <code>for i in range(len(nums))</code> 即使nums是空的也没有问题</li>\n</ul>\n<h2 id=\"剑指offer-03-数组中重复的数值\"><a href=\"#剑指offer-03-数组中重复的数值\" class=\"headerlink\" title=\"剑指offer 03. 数组中重复的数值\"></a>剑指offer 03. 数组中重复的数值</h2><p>输入：整数数组</p>\n<p>输出：数组中的某个数值</p>\n<p>要求：该数值一定是在数组中重复出现过的</p>\n<p>老办法：计算所有数字出现过的次数，然后&gt;2的都可以输出</p>\n<p>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findRepeatNumber</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        sort = [<span class=\"number\">0</span>] * (max(nums)+<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            sort[i] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort.index(max(sort))</span><br></pre></td></tr></table></figure>\n<p>也的确可以通过，但是这种方法不太好</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210105161105089.png\" alt=\"image-20210105161105089\"></p>\n<p>有没有其他减少复杂度的方法，比如先排个序？不行，并不能保证重复的数字出现在某个位置</p>\n<h3 id=\"阅读题解-1\"><a href=\"#阅读题解-1\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>（1）遍历数组</p>\n<p>这个方法告诉我们，根本就不用遍历完，只需要遇到重复的数字立马返回</p>\n<p>当然新的数字需要加入到一个新的集合中，然后判断下一个数字是新数字还是已经遇到的数字</p>\n<p>（2）原地交换</p>\n<p>本题中有一个条件：数组长度为n，而且所有数字小于 n</p>\n<p>那么可以让元素的索引和值一一对应</p>\n<p>第一次遇到，交换索引</p>\n<p>第二次遇到，直接能够判断$nums[x] = x$，所以就得到了重复的数字</p>\n<h2 id=\"830-较大分组的位置\"><a href=\"#830-较大分组的位置\" class=\"headerlink\" title=\"830. 较大分组的位置\"></a>830. 较大分组的位置</h2><p>输入：字符串s，全是小写字母</p>\n<p>输出：二维数组，每个元素是一个还有两个整数的数组</p>\n<p>条件：较大分组指的是连续三个字符及以上的分组，两个整数分别是起始坐标和终止坐标</p>\n<p>这个简单啊，直接遍历不就好了，如果不相等直接重置</p>\n<p>相等累计，直到结尾</p>\n<p>然后把数组汇总一下就可以了</p>\n<p>一个特例：就是最后几个字母是一样的，那么就会一直continue，所以到最后再判断一次end和start是不是相等，得出答案</p>\n<p>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largeGroupPositions</span><span class=\"params\">(self, s: str)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len(s):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        output = []</span><br><span class=\"line\">        start, end = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] == s[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                end += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> end - start &gt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">                output.append([start, end])</span><br><span class=\"line\">            start, end = i, i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> end - start &gt;= <span class=\"number\">2</span>:</span><br><span class=\"line\">            output.append([start, end])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br></pre></td></tr></table></figure>\n<p>可以通过，但是速度和空间都比较糟糕</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210105163910474.png\" alt=\"image-20210105163910474\"></p>\n<h3 id=\"阅读题解-2\"><a href=\"#阅读题解-2\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>就是一次遍历的方法，记录当前分组的长度，如果字符不同，那么就说明已经到尾部了</p>\n<p>但是为什么我的这个代码这么慢呢？</p>\n<p>（1）其实不用同时更新start和end，其实可以只记录start，因为end会直接由 i 来确定</p>\n<p>减少一个变量之后，确实减少了部分用时，但是内存还是比较大</p>\n<h2 id=\"189-旋转数组-数组\"><a href=\"#189-旋转数组-数组\" class=\"headerlink\" title=\"189. 旋转数组 - 数组\"></a>189. 旋转数组 - 数组</h2><p>输入：整数数组nums，非负数 k</p>\n<p>输出：没有输出，不要输出，直接对原数组进行调整即可</p>\n<p>功能：间数组中的元素向右移动 k 个位置</p>\n<hr>\n<p>题目中说至少有三种方法可以解决该问题，而且要求空间复杂度 O(1) - 原地算法</p>\n<hr>\n<p>从示例观察来看，直接把数组中 -k到最后一个数字整体搬到最前面就好了，但是如果 k 比数组长度还要大呢？</p>\n<p>问题是，没有输出，那我怎么输出呢</p>\n<p>我这种方法就是使用呢额外的数组，需要注意的是，必须要使用调整nums的方法，而不是生成nums的方法</p>\n<p>==这个方法的本质是把原数组中下标为 $i$ 的元素，放在了新数组的 $(i+k)\\mod n$的位置==</p>\n<hr>\n<p>所给提示：</p>\n<p>（1）最简单的方法需要增加存储空间</p>\n<p>（2）比较困难的就是再不添加任何空间的情况下解决问题，这意味着需要使用某种方法在原始数组的基础上移动相关的元素</p>\n<p>（3）一种方法是 reversing the array（or part of it），翻转？</p>\n<hr>\n<h3 id=\"阅读题解-3\"><a href=\"#阅读题解-3\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p><strong>环状替换</strong></p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210108104525947.png\" alt=\"image-20210108104525947\"></p>\n<ul>\n<li>比如从 0 =》 到 $(0+k)\\mod n$，然后从 $(0+k)\\mod n$ 到$(0+2k)\\mod n$，一直到回到 0 位置，这个过程一定是走了整数个圈数</li>\n<li>比如 a 圈，总共遍历了 b 个元素</li>\n<li>那么 $ an = bk$ 总的元素数量是相等的，所以 an 一定是 n 和 k 的公倍数（不能重复，所以是最小公倍数 $lcm (n,k)$)</li>\n<li>b 也就是这个最小公倍数 除以 k ，$lcm(n,k)/k$</li>\n<li>每次遍历会 访问 b 个元素，所以最后应该遍历 $n/b$ 次</li>\n<li>由于 b，n，k之间的关系</li>\n</ul>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210108105810711.png\" alt=\"image-20210108105810711\"></p>\n<p>所以最后需要遍历 n 和 k 的最大公约数次</p>\n<p>应该说，这个方法看起来的可行性高，而且也不难</p>\n<p><strong>数组翻转</strong></p>\n<p>基于事实：将数组元素向右移动k次，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置</p>\n<p>所以就可以先把所有元素翻转，这样尾部的 k mod n 个元素被移至头部</p>\n<p>然后再翻转前后两个区间，以 k mod n -1 为界，就得到了最后的大浪</p>\n<p>这里的示例中写了一个翻转的函数，简单来说就是用 一个调换数组元素的方法 实现 整个数组的翻转</p>\n<p>（1）指定 start 和end结点</p>\n<p>（2）判断 start 和end 的关系，然后将两个数字对应的数组中的数字互换</p>\n<p>（3）start +1，end -1</p>\n<p>然后循环，这个方法很不错</p>\n<blockquote>\n<p>问：python中对数组的操作都有哪些？</p>\n<p>list.reverse() 就是对列表进行反向</p>\n<p>list.sort() 对原列表进行排序</p>\n</blockquote>\n<p>但是截取一段，然后进行翻转的方法是不可以的，这样其实还是相当于增加了空</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"面试题08-01-三步问题\"><a href=\"#面试题08-01-三步问题\" class=\"headerlink\" title=\"面试题08.01 三步问题\"></a>面试题08.01 三步问题</h2><p>输入：int 类型数值 n</p>\n<p>输出：int 类型数值</p>\n<p>功能：从0开始，每次可以增加1，2或3，直到数值加到n，求所有到达 n 的种类</p>\n<p>本题是可以通过暴力方法进行求解的，那么就是排序种类问题</p>\n<p>如果使用动态规划的方法呢？</p>\n<p>其实到达从上一步到达下一步的方法只有3种路径</p>\n<blockquote>\n<p>提示1：自上而下处理问题，先从最后一步开始</p>\n</blockquote>\n<p>最后一步有三种方法</p>\n<p>但是从 i 到 i+3 不止一种走法</p>\n<blockquote>\n<p>提示2：如果直到跳到第100级台阶之前的每一级台阶的跳法数量，可以计算第100级台阶的跳法数量吗？</p>\n</blockquote>\n<p>这个提示实在是太妙了</p>\n<p>那肯定是 【99级的跳法数量 + 98级跳法数量 + 97级跳法数量】</p>\n<p>虽然有以下几种情况：</p>\n<p>99级中有两种情况：</p>\n<ul>\n<li>98级 + 1级</li>\n<li>97级 + 2级</li>\n</ul>\n<p>98级一种情况：</p>\n<ul>\n<li>97级 + 1级</li>\n</ul>\n<p>但是这些情况并不影响各自到100级台阶的情况</p>\n<p>所以这是在提醒我，$sum_n = sum_{n-1}+sum_{n-2}+sum_{n-3}$</p>\n<blockquote>\n<p>提示3和提示4是在强调：相加还是相乘</p>\n<p>提示4：</p>\n<p>当我们先做什么再做什么，需要相乘</p>\n<p>当我们这样做或那样做，需要相加</p>\n</blockquote>\n<p>初始条件：</p>\n<p>sum_0 = 0</p>\n<p>sum_1 = 1</p>\n<p>sum_2 = 2</p>\n<p>sum_3 = 4</p>\n<p>sum_4 = 7 …</p>\n<p>这么说这就是一个数列啊，直接按照数列的方法也是可以进行求解的！</p>\n<p>也就是说本题是在求解一个数列，不过这个数列的项不少，要找一个通项公式可能比较困难</p>\n<blockquote>\n<p>提示5，6是关于优化的，计算时间复杂度</p>\n<p>制表法是什么，怎么样进行优化</p>\n</blockquote>\n<p>时间复杂度在哪，显然是在重复计算上，要不停变换三个加数，但是实际上加数是在不断交替的，而并非真的是在重新计算，但现在的情况是每个加数都进行了重新计算</p>\n<p>还有一个问题，是不是可以通过除以3来把这个过程优化一下？</p>\n<h3 id=\"阅读题解-4\"><a href=\"#阅读题解-4\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>题解中讲到的方法是使用矩阵实现快速计算</p>\n<p>但是实际上使用递推的方法就是可以实现的，问题是中间的数也会比较大，所以只在最后一步取模会导致空间和用时都比较高，可以考虑每一步都给 几个数值取模，这样的话不影响结果，还能保证时间和空间复杂度</p>\n<h2 id=\"509-斐波那契数\"><a href=\"#509-斐波那契数\" class=\"headerlink\" title=\"509. 斐波那契数\"></a>509. 斐波那契数</h2><p>输入：n</p>\n<p>输出：f(n)表示斐波那契数列的第n个数字</p>\n<p>注意：f(0) = 0, f(1)=1</p>\n<p>斐波那契数列的问题其实之前遇到过，确实有一些比较好的方法可以借鉴，很经典</p>\n<h2 id=\"面试题16-17-连续数列\"><a href=\"#面试题16-17-连续数列\" class=\"headerlink\" title=\"面试题16.17. 连续数列\"></a>面试题16.17. 连续数列</h2><p>输入： 整数数组</p>\n<p>输出：子数组和</p>\n<p>要求：该子数组连续，且该子数组的和再所有子数组最大</p>\n<blockquote>\n<p>本题和53题，和offer42题为同一个问题</p>\n</blockquote>\n<p>f(n) 表示以n结尾的最大和的连续子数组的和</p>\n<p>那么$f(n+1) = max(f(n), f(n)+i_{n+1})$是吗？显然不一定，要让这个成立，只需要 $i_{n+1}$是正数就可以了【错了！！！】</p>\n<p>是$f(n+1) = max(f(n)+i_{n+1}, i_{n+1})$，其实也还是重置的方法</p>\n<blockquote>\n<p>提示1：把数字想象成正负交替的数字序列</p>\n<p>因为实际上不会只包含正序列或者负序列</p>\n<p>提示2：如果有一个和为负数的数列，那么一定不是一个数列的开始或结束（因为这个数列完全可以去掉）</p>\n<p>如果它们连接了另外两个数列，那么就可以以一个数列的形式出现</p>\n<p>提示3：从数组的开头开始，当这个子数列增长时，仍然是最佳子数列</p>\n<p>但是一旦变成负数，就没有意义了</p>\n</blockquote>\n<p>这让我想起以前做过的一道题，就是把类似的数列的和存储了下来</p>\n<p>只要是负的就重置，并把变负之前的和记录下来</p>\n<p>相当于是在计算以每一个数字开头的数组的最大连续正数和</p>\n<blockquote>\n<p>总结一下，这类题已经做了三遍了：</p>\n<ul>\n<li><p>刚开始还愿意仔细分析序列的正负特点，到后来只愿意使用动态规划来做了</p>\n</li>\n<li><p>动态规划上，关于连续的特点，要么是接着上一个序列，要么是从头开始：$f(n+1) = max(f(n)+i_{n+1}, i_{n+1})$</p>\n</li>\n<li>而间断的特点就是，可以是上一个，或者是上一个加上当前的：$f(n+1) = max(f(n), f(n)+i_{n+1})$</li>\n</ul>\n<p>有的题目需要给出连续的个数</p>\n<p>有的题需要给出最后的和，一定要适应一下</p>\n</blockquote>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><h2 id=\"1203-项目管理-图，拓扑排序\"><a href=\"#1203-项目管理-图，拓扑排序\" class=\"headerlink\" title=\"1203. 项目管理 - 图，拓扑排序\"></a>1203. 项目管理 - 图，拓扑排序</h2><p>输入： n - 项目数量， m - 小组数，group - 每个项目对应的小组，beforeItems - 每个项目的先决项目</p>\n<p>输出：列表 - 项目排序</p>\n<p>要求：</p>\n<ul>\n<li>每个项目对应的小组写在 group中，最多一个小组负责，全程不需要修改，只需要判断，-1表示没有小组接手，但是仍然需要进行排序</li>\n<li>同小组的项目需要相邻</li>\n<li>要先完成先决项目，才能完成后续项目</li>\n<li>小组和项目都是从0开始排序</li>\n</ul>\n<hr>\n<p>从示例来看，首先需要把先决项目完成</p>\n<p>然后可以根据项目组进行排序</p>\n<blockquote>\n<p>感觉是使用树结构的方法会比较好</p>\n<p>从before开始查找整个树</p>\n<p>官方标签：深度优先搜索，图，拓扑排序</p>\n</blockquote>\n<hr>\n<p>三个提示：</p>\n<ul>\n<li>图问题</li>\n<li>在 dependency graph 的基础上找一个拓扑排序的方法</li>\n<li>建立两个图，一个基于小组，一个基于项目</li>\n</ul>\n<hr>\n<p>在本问题中，我需要知道的是：</p>\n<p>（1）我应该怎么样构建一个图？</p>\n<p>（2）怎样使用图进行排序</p>\n<blockquote>\n<p>拓扑排序</p>\n<p>有向图G，将G的n个点排列成一组序列，任意一对顶点（u -&gt; v）之间判断边</p>\n<p>如果存在有向边 u -&gt; v，那么 u 在序列中需要出现在 v 的前面</p>\n</blockquote>\n<p>本题中</p>\n<p>（1）把项目 items 抽象成点，项目间的依赖关系抽象成边，依赖条件就是有向边，进行拓扑排序</p>\n<p>（2）==【同组项目要彼此相邻】== = 组与组之间也存在依赖关系，所以要解决组之间的拓扑排序</p>\n<p>所以，本题分两步</p>\n<p>（1）首先解决组与组之间的依赖关系，组抽象成点，组与组的关系抽象成边，建图判断是否存在拓扑排序（groupTopSort，以组为先）</p>\n<p>（2）存在拓扑关系（groupTopSort），再确定组内依赖关系，遍历拓扑序，对于任意 组 g，对所有属于组 g 的点再进行拓扑排序，最后把组内拓扑排序按顺序放入答案数组</p>\n<p>细节</p>\n<p>（1）部分项目无人接手，groupId = -1，不利于编码，可以重新编号，但又不能与真实的小组编号冲突，可以从 m 开始正序编号【真实小组编号在0到m-1之间】</p>\n<p>（2）将拓扑排序抽象成一个函数进行复用，函数定义 <code>topSort(deg, graph, items)</code>表示：</p>\n<ul>\n<li>待排序点集 items</li>\n<li>点的入度数组 deg</li>\n<li>点的连边关系 graph，graph[i] 表示点 i 连出点组成的集合</li>\n</ul>\n<p>（3）建图过程中，如果发现两个项目属于不同的项目组，组间关系图添加相应边，否则在组内关系图中添加相应边</p>\n<hr>\n<h3 id=\"阅读题解-5\"><a href=\"#阅读题解-5\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><blockquote>\n<p>参考一个题解说明：<a href=\"https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/python-liang-ci-tuo-bu-pai-xu-100-by-mil-rtwg/\" target=\"_blank\" rel=\"noopener\">[Python] 两次拓扑排序100%</a></p>\n<p>入度：</p>\n<p>有向图G中，对于节点 v，从节点 n1，n2，…，nm出发都可以一步到达 v，那么节点 v 的入度就是 m（是说v的来源有m条吗？）</p>\n<p>拓扑排序</p>\n<p>图中节点与节点之间的访问顺序，可用拓扑排序方法生成一个可行的访问序列</p>\n<p>（1）建图</p>\n<p>（2）统计图中所有节点的入度</p>\n<p>（3）BFS 方法获得访问序列</p>\n<ul>\n<li>将入度为0的节点添加到队列中</li>\n<li>遍历队列<ul>\n<li>得到队首节点并出队</li>\n<li>将当前节点添加到访问序列中</li>\n<li>将当前节点所有邻居节点的入度 -1</li>\n<li>如果邻居节点的入度变为0，将邻居节点入队</li>\n</ul>\n</li>\n</ul>\n<p>【？？？】确实没看懂</p>\n</blockquote>\n<p>方法：</p>\n<p>两次嵌套拓扑排序</p>\n<p>思路：</p>\n<ol>\n<li>建图</li>\n<li>对小组进行拓扑排序，获得访问小组的顺序</li>\n<li>遍历小组的访问顺序<ol>\n<li>得到该组的项目顺序</li>\n<li>将项目顺序添加到答案中</li>\n</ol>\n</li>\n</ol>\n<p>建图：</p>\n<ul>\n<li>无组项目给全新组号</li>\n<li>小组建图计算组入度</li>\n<li>统计各组有哪些项目</li>\n<li>组内建图算项目入度</li>\n</ul>\n<p><strong>返回空列表的条件：</strong></p>\n<ul>\n<li>小组不在得到的访问顺序中</li>\n<li>项目不在得到的该组项目的访问顺序中</li>\n</ul>\n<blockquote>\n<p><code>queue = collections.deque()</code></p>\n<p>deque 是一个<strong>双端队列</strong>，可以从两端进行 append 的数据结构【不过从左端加入使用的是 <code>queue.appendleft()</code>】</p>\n<p>还可以从两端出队列 <code>queue.pop()</code> 和 <code>queue.popleft()</code></p>\n<p>一般需要提前 <code>from collections import deque</code></p>\n<p>参考：<a href=\"https://blog.csdn.net/u010339879/article/details/80767293\" target=\"_blank\" rel=\"noopener\">collections中 deque的使用</a></p>\n</blockquote>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>组数 m 也就是 group_id 的最大值</p>\n<p>遍历 n 个项目，给没有组接手的项目重新标记组号 m, m+1, …</p>\n<p>初始化几个列表：【列表的初始化建议】</p>\n<ul>\n<li>项目入度列表 - n个0 <code>[0]*n</code></li>\n<li>小组入度列表</li>\n<li>项目邻居列表 - n个子列表 <code>[[] for _ in range(n)]</code></li>\n<li>小组邻居列表</li>\n<li>group_to_tasks 【这个列表用来做什么？】</li>\n</ul>\n<p>遍历任务==【组间排序】==</p>\n<ul>\n<li><p>按照各项目所属的小组号，在 group_to_tasks的相应位置，添加任务号</p>\n<ul>\n<li>也就是说，这个数组存放的是 各组对应的任务数</li>\n</ul>\n</li>\n<li><p>遍历先决任务的list</p>\n<ul>\n<li>这个list 的id是当前任务，value 是先决任务</li>\n<li>可以判断两个任务的是不是同组 <code>group[id] 和 group[value]</code><ul>\n<li>不同组，那么该小组的入度 +1，先决组的邻居加上当前组【组间建图】</li>\n<li>同组，那么任务的入度 +1，先决任务的邻居加上当前任务【组内建图】</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>接下来获得小组的访问顺序</p>\n<ul>\n<li>使用自定义函数 <code>self.topological_sort</code>，输入是 任务或者小组，入度，邻居三个内容【具体分析见下一个部分】</li>\n<li>首先对小组间进行排序，输入小组号的列表，所有小组的入度列表，所有小组的邻居列表</li>\n</ul>\n<p>做一个判断：如果<strong>组外排序</strong>数组数量【排的是小组的访问顺序】，不等于所有组的数量，那么就直接返回空列表【为什么】</p>\n<p>最后遍历小组号，注意小组号超过 m 的就不用了==【组内排序】==【排的是组间的排序】</p>\n<ul>\n<li>对组内根据任务进行拓扑排序<ul>\n<li>输入：group_to_tasks[group_id]，任务入度，任务邻居</li>\n</ul>\n</li>\n<li>做一个判断，如果任务排序后的长度不等于每组对应的任务数，那么就返回空</li>\n<li>把排序号的任务列表添加到最后输出列表中</li>\n</ul>\n<p>把最终排序列表输出</p>\n<hr>\n<p>其实这里面自定义的函数==拓扑排序函数==才是关键</p>\n<p>自定义函数的具体内容：</p>\n<p>输入：待排序数组，对应入度，对应邻居列表</p>\n<p>初始化双端队列和输出列表</p>\n<p>遍历待排序列表，item</p>\n<ul>\n<li>如果 item 对应入度为0，直接将 item 加入双端列表</li>\n<li><u>【入度为0表示这就是最底层的节点了，如果不是0，那么就是说还有子节点，不饿能直接进行排序？】</u></li>\n</ul>\n<p>如果双端列表为空，直接返回空数组【双端列表究竟是什么意义】</p>\n<p>接下来是广度优先排序（BFS）</p>\n<ul>\n<li>只要双端列表不为空就一直循环</li>\n<li><p>将双端列表的左元素移出，放入输出列表中</p>\n<ul>\n<li>对该元素的邻居进行遍历</li>\n<li>各邻居的入度 -1</li>\n<li>如果有邻居的入度为0，那么也将这个邻居加入双端列表</li>\n</ul>\n</li>\n<li><p>直到双端列表为空</p>\n</li>\n</ul>\n<p>最后输出输出列表</p>\n<hr>\n<p>仔细体会各步骤的用意</p>\n<ol>\n<li>找到了每一个组对应的所有任务</li>\n<li>避免无人认领项目的影响【至少不能认为他们是同组的】</li>\n<li>两步排序的方法分了组间排序和组内排序，分别考虑组要靠在一起，其次是组内顺序也要考虑</li>\n<li>首先考虑的是任务的先后关系<ol>\n<li>先后任务在同组，那么任务入度不同</li>\n<li>先后任务在不同组，那么小组入度不同【小组的入度 = 先决组的数量，先决组是小组的邻居】，至于说各任务在组内入度就要看是不是还和组内任务有先后关系</li>\n<li>如果==任务的先决任务列表==恰好为空，那刚好，对该任务的入度和邻居都不影响【那么直接排顺序就好了，这是最简单的情况】</li>\n</ol>\n</li>\n<li>==【入度本身是强调先后顺序，有入度，那么该小组或者该项目就应该往后排】==<ol>\n<li>入度越小的项目或者小组，就越应该往前排</li>\n<li>全都有入度，那么这个任务或者小组根本就不可行</li>\n</ol>\n</li>\n<li>组间排序考虑各小组的入度，组内排序考虑各项目的入度</li>\n<li>拓扑排序的方法，就是从入度来判断一个值能不能进行排序，然后对该值的邻居排序，未排序的内容入度就应该减小，相当于在剩下的内容中进行排序</li>\n</ol>\n<blockquote>\n<p>这样通过遍历任务，获得了小组的入度和项目的入度，邻居则是同时获得的【左邻居还是右邻居并不重要，重要的是邻居都要包含在列表里面】【一个小组或者一个项目的邻居有上限吗，有什么样的意义】</p>\n</blockquote>\n<p>==建图的关键是两个列表：入度 和 邻居==</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortItems</span><span class=\"params\">(self, n: int, m: int, group: List[int], beforeItems: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=\"line\">        max_group_id = m</span><br><span class=\"line\">        <span class=\"keyword\">for</span> task <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> group[task] == <span class=\"number\">-1</span>:</span><br><span class=\"line\">                group[task] = max_group_id</span><br><span class=\"line\">                max_group_id += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 到此，共有 max_group_id 个组</span></span><br><span class=\"line\"></span><br><span class=\"line\">        group_indegree = [<span class=\"number\">0</span>] * max_group_id</span><br><span class=\"line\">        task_indegree = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">        group_neighbours = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_group_id)]</span><br><span class=\"line\">        task_neighbours = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        group_to_tasks = [[] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_group_id)]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> task <span class=\"keyword\">in</span> group:</span><br><span class=\"line\">            group_to_tasks[task].append(task)</span><br><span class=\"line\">        print(group_to_tasks)</span><br></pre></td></tr></table></figure>\n<p>上面是我写的一个初步的代码，我们分析一下第 16 行，我希望能够得到 每个组对应的task情况，但是这种遍历方法肯定是不对的，而是应该</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> task <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    group_to_tasks[group[task]].append(task)</span><br></pre></td></tr></table></figure>\n<p>这样才可以实现把 task 放到对应的 group 中的想法。</p>\n<p>然后，我根据回忆进行程序的复现过程中，另一个问题是组内排序的方法，应该遍历已经排好序的组的列表</p>\n<p>这样可以获得组号</p>\n<p>然后根据组号去查找每组里面的任务</p>\n<p>对任务进行排序</p>\n<p>最后把排好序的任务放到最终输出的列表就完成了！</p>\n<hr>\n<p>OK，本期的解题就是这些，总体来说，简单题虽然能够尝试，但是限制了对真正算法的现象和理解，还是需要多对其他难度和其他类型的题进行尝试，从而获得更好的学习效果！</p>"},{"title":"LeetCode刷题笔记（五）","date":"2021-02-02T03:58:49.000Z","_content":"\n每期10题，上一期参见[LeetCode刷题笔记（四）](https://sunyoe.github.io/2021/01/12/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/)。\n\n本期内容紧贴2021年1月leetcode每日一题，本月主要内容是并查集（包括深度优先或广度优先）及双指针，包括在周赛中也遇到双指针题目，需要重点考虑。\n\n## 1018. 可被5整除的二进制前缀\n\n输入：整数列表 - 只有 0 和 1\n\n输出：布尔列表 - 只有 false 和 true\n\n要求：依次选择整数列表中 从 第0位到第i位的所有数字，这是一个二进制数字，如果可以被5整除，那么布尔列表的第 i 位为true，否则为false。\n\n<!--more-->\n\n---\n\n### 自我解读\n\n方案：\n\n（1）先获得十进制数字\n\n由于本身就是列表，确实要稍微容易一点\n\n$num_{10} = num_2[-1] * 1 + num_2[-2] * 2 +...+num_2[-i] * 2^{i-1}$\n\n但是如果每次都是从头开始计算，2的幂需要计算，空间占用会比较多\n\n（2）能不能被 5 整除其实最关键的就是看最后一位，5或者0就可以\n\n观察一下：1，2，4，8，16，32，64，128，256，…，已经有规律了\n\n| 阶数     | 0    | 1     | 2     | 3     | 4     |\n| -------- | ---- | ----- | ----- | ----- | ----- |\n| 最后一位 | 1    | 2     | 4     | 8     | 6     |\n| **阶数** |      | **5** | **6** | **7** | **8** |\n| 最后一位 |      | 2     | 4     | 8     | 6     |\n\n那么能够产生被5整除的情况：\n\n- [x] 1 + 4：索引0 + 索引2+4n\n- [x] 2 + 8：索引1+4n + 索引3+4n\n- [x] 4 + 6：索引2+4n + 索引4+4n\n\n对以上组合的对数进行计算，只要能配好对，那就可以整除\n\n我觉的这个思路就好很多，尤其对一些比较长的数字会比较好\n\n存在几个问题：\n\n（1）那么问题是到底要怎么样进行遍历呢：比如我可以判断 2+4n 有没有超过 len\n\n（2）能不能利用前面的数据判断当前的情况？其实应该是可以的，每次应该计算出下一位需要几，如果是那么就是true，如果不是那么就是false；这样形成一个动态规划\n\n比如说刚开始形成3个存储数字A1，A2，B1，B2，C1\n\n- 开始，如果索引0是1，A1+1\n- 如果索引2+4n是1，A2+1\n- 如果索引1+4n是1，B1+1\n- 如果索引3+4n是1，B2+1\n- 如果索引4+4n是1，C1+1\n\n最后判断：A1+C1 == A2，B1 == B2，这样又会出现一个问题，如果刚好是 22222，那么也是可以的，这样是1+4n为奇数\n\n注意，0对数值大小完全没有影响\n\n（3）新方案，设一个数值Res，直接遍历字符串，然后\n\n- 索引0是1，Res+1\n- 索引1+4n是1，每个+2\n- 索引2+4n是1，每个+4\n- 索引3+4n是1，每个+8\n- 索引4n是1，每个+6\n\n最后，如果Res可以被5整除，那么就是true，如果不是那就不行\n\n然后，每次是在结尾增加了一位数字\n\n- 索引0 -》索引1，Res+1\n\n- 索引1+4n -》 索引2+4n，每个+2\n\n- 索引2+4n -》 索引 3+4n，每个+4\n\n- 索引3+4n -》 索引 4n，每个-2\n\n- 索引4n -》 索引1+4n，每个-4\n\n确实是可以进行抵消的，但问题是前面各索引有1有0需要计数吗？\n\n也就是说我只统计各索引的次数，然后每次把这些数字进行移动（轮换）\n\n---\n\n### 观察题解\n\n官方题解\n\n从二进制到十进制数字的特点是：$N_i = N_{i-1} \\times 2 +A[i]$\n\n每添加一位数字，计算余数，看能不能被5整除就可以了，这个方法也不错，还很简单\n\n相对来说，我的方法还是复杂了，惭愧！\n\n# <!--并查集系列-->\n\n## 947. 移除最多的同行或同列石头 - 并查集\n\n输入：二维整数数组，每个子数组只有两个整数元素，相当于坐标\n\n输出：一个整数\n\n要求：同行（第一个元素相同），或者同列（第二个元素相同）的子数组只能保留一个，最后输出的就是要去除的子数组的数量\n\n---\n\n### 自我解读\n\n遍历数组，如果行号是新的，行号list新增一个\n\n如果列号是新的，列号list新增一个\n\n遇到新的子数组，检查行号是不是在行号list中，是，del+1，直接下一个\n\n否，检查列号是不是在列号list中，是，del+1，直接下一个\n\n否，下一个，过\n\n> 但是，题目中要求是：==可以移除的石子的最大数量==\n\n比如示例1：\n\n```\n输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n输出：5\n```\n\n如果按照我的思路，先记录了【0，0】，那么会去掉【0，1】【1，0】，但是不会取消【1，2】\n\n但是实际答案说的却是：先移除【2，2】，因为它和【2，1】同行了，。。。最后就只剩下了【0，0】，就像是后来的先移除，这样一定是移除最多的吗？\n\n另一个问题：所有输入一定是一行一行进行展示的吗，这样的话岂不是要简单一点\n\n> 既然需要最大移除数量，那么就要把移除的石子的两个坐标也加入到list中，这样一定是最大的吗？\n\n还是存在一点问题的：\n\n例如一个输入：`[[0,1],[1,0],[1,1]]`，最多可以移除两个石子，但是按照上面的算法却只能去除一个石子\n\n![image-20210115142425858](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210115142425858.png)\n\n类似的，其实这样一个三角结构，会决定到底应该怎么样进行移除\n\n我们如果是从前往后，那么就只能移除1个，但是如果从后往前，就可以移除两个，同样，反过来也是一样的\n\n> 新增案例：`[[0,1],[1,2],[1,3],[3,3],[2,3],[0,2]]`\n\n这个案例说明了，子数组并不是按顺序的，如果不按顺序来进行排列\n\n就有可能导致少删除一个\n\n---\n\n### 阅读题解\n\n横坐标相同、或者纵坐标相同，那么就形成了一条边，有联系的边构成了一个连通图\n\n==**一定可以把一个连通图里的所有顶点根据该规则删到只剩下一个顶点**==\n\n原因是：连通图中，可以通过**遍历**方式遍历到该连通图中的所有顶点，按照遍历的逆向顺序移除石头就可以只剩下一块石头\n\n所以，题目的结果 = 石头总数 - 极大连通子图（连通块或连通分量）的个数（连通块的数量=最后剩下的石头的数量）\n\n并查集里的元素是描述 横坐表和纵坐标的数值\n\n遍历数组，每个元素的横坐表和纵坐标在并查集中进行合并\n\n> 合并：所有横坐标 为x的石头和所有纵坐标 为y的石头都属于同一个连通分量\n\n那么在并查集内部，我们要如何区分横纵坐标？\n\n石头的位置是 数组，并查集底层是一维，怎么样在并查集中区分横纵坐标\n\n方法是扩大坐标区间，比如题目说 $0<=x_i,y_i<=10^4$，那么就可以操作：$横坐标 \\pm 10001 $，从而超越原来的区间，保证不会重复\n\n==**问题是怎么合并**？==\n\n（1）第一种方法：需要**枚举计算任意两点间的连通性**，可以使用深度优先或者广度优先搜索的方法进行计算\n\n[官方题解](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/yi-chu-zui-duo-de-tong-xing-huo-tong-lie-m50r/)的python3代码中使用了`edge=collections.defaultdict(list)`来作为存储单元，用于建图，也就是通过枚举找到了**所有**相互关联的边\n\n但是到了深度优先搜索这里，看上去还是使用了一些库吗？`vis.add(x)`，但是vis并没有进行定义，也有可能是定义的晚了（在下方，函数调用前有一个定义`vis=set()`）？我个人觉得这个写法很糟糕，也许是和下面的代码进行了联动，但是展示出来的效果却非常差\n\n（2）第二种方法：\n\n上面的方法需要循环套循环进行元素的遍历完成建图，还是有一点麻烦了。\n\n任意两点之间直接相连或间接相连其实都是可以的，我们只关注两点之间的连通性。\n\n该方法说对于拥有k个石子的任意一行或者一列，都使用 k-1 条边进行连接\n\n所以方法就是：\n\n1. 先用哈希表存储每一行或每一列所拥有的石子，对纵坐标加了10000，以区分横纵坐标\n2. 然后分别处理每一行或每一列的连通属性\n\n非官方题解：\n\n**大多数方法建立了一个专门的==class（class UnionFind）==来归纳并查集的方法，然后对该类中的方法进行调用**\n\n---\n\n终于找到一个可能比较容易理解的算法了\n\n参考：[Python,并查集, O(nlogm)94%,O(m)19%](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/pythonbing-cha-ji-onlogm94om19-by-jasonc-3uv7/)\n\n仍然保留了两个关键：\n\n- 答案 = 石头总数 - 连通块的数量\n- 纵坐标+10000，==**这样就可以把坐标也看成edges了！**==\n\n这里举了例子：\n\n`[[0,0],[1,1],[1,2]]=>[[0,10000],[1,10001],[1,10002]]`\n\n这里（1）思考为5个nodes：`0,10000,1,10001,10002`\n\n（2）把`[0,10000]`视为 node 0和node 10000有edge连通，其他类似，这样就好理解为什么`+10000`能方便求解了\n\n然后转化为了熟悉的图并查集问题，遍历所有edges，找出所有连通组\n\n> 步骤一：给所有纵坐标+10000\n\n还是比较容易的\n\n```python\nfor stone in stones:\n    stone[-1] += 10000\n```\n\n> 步骤二：如何遍历所有的edges，找出所有连通组？\n\n代码中建立了一个字典吗？还是set？\n\n`dus={s+i*10000:s+i*10000 for stone in stones for i, s in enumerate(stone)}`\n\n遍历每一个石头，i 是第几个，s是坐标值啊，s+i*10000?这个我就不太理解了，是原来的意思吗\n\n神奇，我尝试了一下：\n\n```python\n>>> ss = [[0,0], [1,1], [2,2]]\n>>> dus = {k+i*10000:k+i*10000 for s in ss for i, k in enumerate(s)}\n>>> dus\n{0: 0, 10000: 10000, 1: 1, 10001: 10001, 2: 2, 10002: 10002}\n```\n\n没想到真的能出这样的结果\n\n当我打下下面的代码的时候，发现了问题所在：\n\n```python\n>>> for s in ss:\n...     for i,k in enumerate(s):\n...         print(k)\n...\n0\n0\n1\n1\n2\n2\n```\n\n这是因为 enumerate 针对的是stone，而不是stones！\n\n每个stone只有两个元素，所以 i 只有0 或1，而k就是横坐标或者纵坐标\n\n所以每个横坐标对应0，不会加10000，每个纵坐标对应1，会加10000，就区分开来了，而且使用的是字典，会自动去重！\n\n【妙啊】\n\n然后定义了一个find函数：\n\n- 输入是 i\n- 如果 字典中 i 对应的位置不是 i\n  - 那么继续find（字典中 i 对应的数值），并赋值给 字典中 i 的位置\n- 返回 字典中 i 对应的数值\n\n> 需要观察一下\n>\n> 比如说 字典 bus = {1:1, 2:2, 0:0}\n>\n> dus[0] = 0肯定的\n>\n> ---\n>\n> 如果 字典 bus = {1:2, 2:1, 0:1}\n>\n> dus[0] = 1，不等于0\n>\n> 那么我们再找 find(dus[0]) = find(1)\n>\n> find(1)中，dus[1]  = 2，也不等于 1，再找find(2)\n>\n> find(2)中，dus[2] = 1，也不等于 2，再找find(1)不停循环\n>\n> ---\n>\n> 也就是说不停找，直到找到字典中 key和value一样的值？\n\n然后遍历stones，如果横坐标在字典中，而且横坐标对应的值不等于纵坐标对应的值【这有可能相等吗】\n\n- 那么，字典中横坐标对应的位置，value等于纵坐标+10000对应的数值\n\n> 举个例子\n>\n> `stones = [[0,0], [0,1], [0,2]]`\n>\n> 那么\n>\n> `dus={0:0, 10000:10000, 10001:10001, 10002:10002}`\n>\n> - 首次循环：0 在dus，find(0) = 0 != find(0+10000)=10000【是否存在】\n>   - 所以 dus[find(0)] = dus[0] = find(0+10000) = 10000\n>   - `dus={0:10000, 10000:10000, 10001:10001, 10002:10002}`\n>\n> - 下一个循环：0 在dus，find(0)中，dus[0] = 10000 != 0了，找find(10000) = 10000，赋值给 dus[0]，最后输出10000 != find(10001) = 10001\n>   - 所以 dus[find(0)] = dus[10000] = find(10001) = 10001\n>   - `dus={0:10000, 10000:10001, 10001:10001, 10002:10002}`\n> - 下一个循环：0 在dus，find(0)中，dus[0] = 10000 != 0了，找find(10000) = 10001 != 10000，再找find(10001)=10001，赋值给 dus[0]，最后输出10001 != find(10002) = 10002\n>   - 所以dus[find(0)] = dus[10001] = find(10002) = 10002\n>   - `dus={0:10000, 10000:10001, 10001:10002, 10002:10002}`\n\n然后，需要再来一个循环：\n\n对dus字典中的每一个值进行遍历：\n\n`for k in dus: print(k)`\n\n这里要注意，输出的只有 字典dus 的键 key，而没有value值\n\n> 紧接着上面的注释\n>\n> 现在，find(0) = find(10000) = find(10001) = find(10002) = 10002\n>\n> 所以，最后的字典是：\n>\n> `dus={0:10002, 10000:10002, 10001:10002, 10002:10002}`\n\n最后一步，`set(dus.values())`\n\n应该是取字典 dus 的所有值 values，然后生成集合 set，会去重，再计算集合的长度就是连通域的数量了\n\n简直是太妙了！！！\n\n其实find函数就是寻找最高节点的过程；\n\n而第一个循环的意义就是把横坐标的指向改变，也就是添加连通边edge，建图的过程\n\n## 1584. 连接所有点的最小费用\n\n输入：二维整数数组，每个子数组有两个整数，表示坐标点\n\n输出：整数，表示将所有点连接起来的最小总费用\n\n要求：任意两点之间有且仅有一条简单路径，总路径长度和要最小\n\n---\n\n果然，又是一个图论的问题\n\n比如说我们要建图，每个点要连接到最近的一个点\n\n但是如果两个点互相是最近的点呢 - 构成了一个孤立的群，两个群之间找一个最短的边即可\n\n如果 A 周围最近的是 B，B 周围最近的是 C，C 周围最近的会不会是 A？不会，一定不是 A\n\n![image-20210119161038414](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210119161038414.png)\n\n不然的话，离 A 最近的就不是 B 了\n\n又是一个并查集的问题\n\n---\n\n### 官方题解\n\n满足任意两点之间有且仅有一条简单路径，只有 树结构 - tree\n\n该树 = 给定图的生成树，总权值最小的生成树，成为最小生成树\n\n经典算法：Kruskal 算法\n\n1. 图中所有边按照长度的由小到大进行排序，等长边任意顺序\n2. 从前往后（也就是从小到大）扫描排序后的边，如果扫描到的边 **连接了两个相异的连通块**，则将它插入图中\n3. 最后得到的图就是最小生成树\n\n所以现在的问题是 key **应该取edge的两个端点**，还是**选择edge 的边长**\n\n第一步：建立一个字典，字典的所有value就是list\n\n`rec = collections.defaultdict(list)` ，表示建立了一个具有默认值的字典，默认值是list\n\n\n\n# <!--数组系列-->\n\n## 56. 合并区间 - 数组\n\n输入：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端\n\n输出：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端\n\n要求：输入数组可能会有重叠，将重叠的两个区间进行合并，输出区间不能有重叠\n\n---\n\n我曾想到过一个方法，类似做直方图\n\n- 先新建了一个字典，默认为0\n- 然后遍历所有的区间，有这个区间，那就在这个区间内将所有的数字对应在字典中的value +1\n- 最后取出所有有数字的key值，再取start和end进行集合\n\n问题是遇到了一个样例：\n\n`[[1,4],[5,6]]`\n\n如果直接进行直方图，那么一定会得到 `[[1,6]]`\n\n但是实际上这两个区间并没有重叠\n\n原有代码;\n\n```python\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        # 先建立一个字典，对每一个key的默认值是int类型\n        merge_dict = collections.defaultdict(int)\n        merge_list = []\n\n        for interval in intervals:\n            start, end = interval[0], interval[1]\n            for i in range(start, end+1):\n                merge_dict[i] += 1\n\n        start = 0\n        max_key = max(merge_dict.keys())\n        for i in range(max_key+1):\n            if not start and merge_dict[i]:\n                start = i\n            if start:\n                if not merge_dict[i]:\n                    merge_list.append([start, i-1])\n                    start = 0\n                elif i == max_key:\n                    merge_list.append([start, i])\n                    break\n            i += 1\n        return merge_list\n```\n\n### 官方题解\n\n**排序方法**\n\n如果按照区间的左端点进行排序，在排序后：\n\n==**可以合并的区间一定是连续的**==\n\n> 官方证明中举例是： a[i], a[j], a[k]，a[i]和a[k] 能合并，但是 a[i] 和 a[j], a[j] 和 a[k]均不能合并\n>\n> 但是我自己举了一个例子：`[1,10],[2,5],[10,11]`，这个例子明显不满足上面说的 `a[i]`和`a[j]`也不能合并的条件，所以其实并不满足题意\n\n用 merged 区间表示最后需要输出的多维列表，先将第一个列表存储到区间中：\n\n遍历所有区间\n\n- 左端点在上一个区间的右端点后\n  - 是，表示不重合，那么加入输出数组\n  - 否，表示重合，那么需要更新右端点\n\n第一步：排序，怎样按照第一个元素的大小进行排序？\n\n`list.sort()`方法的使用\n\n`list.sort(key=lambda x: x[0])`就可以根据第一个元素的大小进行排序\n\n> 排序保证了后一个区间的起始点不会小于前一个区间的起始点，所以只需要比较尾巴，不用比较头了\n\n第二步：遍历，进行对比\n\n==本方法的独特性在于，直接与上一个区间进行对比，而不需要再对前面的区间进行对比了==\n\n比如上面的区间对比完了之后已经存储在 `merged` 里面了，那么现在最新的一个区间，只需要和 `meged[-1]`进行对比，就可以了，而不需要从 `merged[0] `开始进行对比\n\n最后的程序：\n\n```python\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key = lambda x: x[0])\n        merged = []\n\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            elif merged[-1][1] >= interval[0]:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged\n```\n\n## 154-offer 11 旋转数组的最小数字\n\n二分查找方法\n\n首先说明旋转数组是指能旋转一次就变成升序数组的数组\n\n所以特点就是，原来的数组是升序排列的\n\n当旋转一次后，其排列规律是：\n\n![fig1](https://assets.leetcode-cn.com/solution-static/jianzhi_11/1.png)\n\n最小值右侧的元素都是小于等于右边界点的\n\n最小值左侧的元素都是大于等于左边界点的\n\n可以利用以上的性质从而缩小最小值所在的区间\n\n有一种情况是中间某个点的数值大小 等于 边界点\n\n![fig4](https://assets.leetcode-cn.com/solution-static/jianzhi_11/4.png)\n\n那么这个时候不能简单说明该点左侧或者右侧是区间，而应该调整边界点（边界点一定是满足降序要求的，从而找出区间）\n\n## 面试题04.二维数组中的查找\n\n一个二维数组，每一列从上到下递增，每一行从左到右递增\n\n请在该数组中找某一个数值时候存在，当存在时返回 True，不存在 返回 False\n\n暴力方法，直接查找\n\n线性查找，比如从数组的左下角开始查找，如果比target大，那么行数 -1，如果比 target 小，那么列数 +1\n\n## 674. 最长连续递增序列\n\n输入：一个递增数组\n\n输出：最长连续递增子数组的长度\n\n非常的明白，就是贪心法把最长的找出来\n\n可能会遇到两个问题：\n\n（1）怎么处理末尾的问题，到末尾，一方面要继续比较是不是递增序列，另一方面还要把当前的子序列输入进结果\n\n（2）怎么样重置，重置为0是不好的，应该重置为1\n\n所以我的代码是：\n\n```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        len_list = []\n        len_max = 0\n        for i,num in enumerate(nums):\n            if not i:\n                len_max += 1\n            elif num > nums[i-1]:\n                len_max += 1\n            else:\n                len_list.append(len_max)\n                len_max = 1\n            if i == len(nums)-1:\n                len_list.append(len_max)\n        return 0 if not len_list else max(len_list) \n```\n\n而官方的代码是：\n\n```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        start = 0\n\n        for i in range(n):\n            if i > 0 and nums[i] <= nums[i - 1]:\n                start = i\n            ans = max(ans, i - start + 1)\n        \n        return ans\n```\n\n每次计算的过程中都在更新最大值，这样能够减少对空间的使用\n\n其次记录的并不是递增序列的长度，而是起始位置，这样也可以减少空间的消耗，只有在变小的时候才会更新起始位置\n\n# <!--双指针系列-->\n\n## 15. 三数之和\n\n本次周赛的过程中，遇到这类问题，找到四个数字构成定积元组一类的问题，怎么样减小时间复杂度？\n\n发现15、16、18三道题都是这样的问题，看来需要进行一个专题的解决。\n\n相似题目：两数之和、最接近的三数之和、四数之和、较小的三数之和\n\n标签：数组，双指针\n\n---\n\n输入：一个整数数组\n\n输出：二维整数数组，每个子数组中有3个数字，和为0\n\n要求：\n\n- 找出所给整数数组中和为0的所有组合\n- 组合不能重复\n- 所给整数数组中的数字是有可能重复的\n\n---\n\n在示例中出现了一种情况，如果本身数字比较少，少于3个，直接可以返回结果为空\n\n如果数字在3个以上，那也只好进行遍历了，找到所有组合，这样的话，一定需要 $O(n^3)$\n\n提示：\n\n1. 如果能固定一个数字，那么就变成了一个“两数之和”的问题了\n2. 在两数之和问题中，如果我们固定一个数组，我们就需要扫描整个数组，找最后一个数字是不是存在，可不可以**修改这个数组**从而让这个查找变得更快呢？\n3. 或者在不改变数组的情况下，我们呢是不是可以**通过使用额外空间 的方法**，比如哈希表来加速搜索\n\n我直接用遍历的方法进行计算，遇到一个问题：可能会出现相同的元组\n\n例如：`nums=[-1,0,1,2,-1,-4]`\n\n如果从头开始遍历，可能有 `[-1,0,1]`，然后又会遇到`[0,1,-1]`，这两个元组会重复（如果是list确实不重复），但是`[-1,-1,2]`又是可以的\n\n### 官方题解\n\n1. 用排序避免重复答案\n\n2. 所谓双指针的方法是说：一个头指针，一个尾指针，如果和比较小，移动头指针，如果和比较大，移动尾指针，直到找到值\n\n但即使如此，还没有完全解决问题，比如 `[0,0,0,0]`，也只能出一个结果 `[0,0,0]`，但是如果只是进行移动，而没有进行判断，最后会出两个`[0,0,0]`\n\n实际题解中用了一些细节来解决各种问题：\n\n1. 如果这次的首位数字和上一次的首位数字相同，直接跳过\n2. 第二个元素虽说是左指针，但是也可以用for循环\n3. 这次的第二个元素也应该和上一次的第二个数字不同，也就是所找一个全新的第二个数字\n4. 只移动右指针即可\n\n官方代码：\n\n```python\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        nums.sort()\n        ans = list()\n        \n        # 枚举 a\n        for first in range(n):\n            # 需要和上一次枚举的数不相同\n            if first > 0 and nums[first] == nums[first - 1]:\n                continue\n            # c 对应的指针初始指向数组的最右端\n            third = n - 1\n            target = -nums[first]\n            # 枚举 b\n            for second in range(first + 1, n):\n                # 需要和上一次枚举的数不相同\n                if second > first + 1 and nums[second] == nums[second - 1]:\n                    continue\n                # 需要保证 b 的指针在 c 的指针的左侧\n                while second < third and nums[second] + nums[third] > target:\n                    third -= 1\n                # 如果指针重合，随着 b 后续的增加\n                # 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环\n                if second == third:\n                    break\n                if nums[second] + nums[third] == target:\n                    ans.append([nums[first], nums[second], nums[third]])\n        \n        return ans\n\n作者：LeetCode-Solution\n链接：https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n我的错误代码（时间会比较长）：\n\n```python\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        result = []\n        # 排序，以免重复\n        nums.sort()\n\n        # 遍历第一个数字 A\n        for i in range(n):\n            # 确保在i循环中，该数字不会重复\n            if i>0 and nums[i] == nums[i-1]:\n                continue\n\n            # 遍历第二个数字 B，正着遍历\n            for j in range(i+1,n):\n                # 确保在j循环里面，该遍历数字是不会重复的\n                if j>i+1 and nums[j] == nums[j-1]:\n                    continue\n                target = - nums[i] - nums[j]\n\n                # 第三个数字，从尾部遍历\n                k = n-1\n                while j<k and nums[k]>target:\n                    k -= 1\n                if j == k:\n                    # 说明到头了，这个循环结束了\n                    break\n                if target==nums[k]:\n                    result.append([nums[i],nums[j],nums[k]])\n        return result\n```\n\n关键的原因请看第22行： `k=n-1`这行代码如果放在 `j`循环中，那么就跟3个循环是一样的！！\n\n如果放在 `j`循环的外面，立马就不一样了，j 增加， k并没有每次都归 （n-1），这样就减少了一次循环，这是非常重要的！\n\n## 16. 最接近的三数之和\n\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n输入：整数数组 nums，整数target\n\n输出：整数\n\n要求：在nums中找3个数字，其和与target最接近，输出的整数即为该和，假设只有一个答案\n\n---\n\n那么这一次，我们需要记录最小的和，也就是差值最小的和，然后每次去比较差值，如果没有更小的了，那就是它了\n\n还是双指针\n\n先要做一个排序\n\n第一个数字遍历\n\n- 开头取一个，结尾取一个\n- 如果大了，结尾小一位，如果小了，开头就要加一位，最终会有一个最接近的\n\n```python\nsort\nfor i in len:\n    first_num = list[i]\n    k = n-1\n    for j in i+1:len:\n        second_num = list[j]\n        sum = first_num + second_num\n        sum_des = target - sum\n        while list[k] > sum_des:\n            k -= 1\n        sum += second_num + third_num\n        \n```\n\n但是此时的比较方案和上面又不太一样了，如果 k减到最后已经比最后的差值小了，再升 j 还是小\n\n没关系，我们可以额外使用一个变量，用来比较和存储比较小的差值\n\n本题的三个数字是不是还需要像上面的题一样避免重复？\n\n- i 不变的情况下，确实 j 不用再重复了\n- i 如果重复呢，确实也不用，所以 i 最好也不要重复了\n\n---\n\n### 官方题解\n\n1. 本题和15题不一样的地方在于，本题要的是最小差距，而不是枚举所有的最小差距的取值\n\n2. 双指针既可以用之前的双循环的方式进行书写，也可以使用真的双指针，两个索引的方式进行书写\n\n3. 初始化 最佳答案的方法是，直接赋值，赋一个很大的值，比如1e7\n\n最后完成的代码是：\n\n```python\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        # 首先排序\n        nums.sort()\n        len_num = len(nums)\n        min_tar = 1e7\n\n        # 第一个数字的索引\n        for i in range(len_num):\n            # 防止重复\n            if i and nums[i] == nums[i-1]:\n                continue\n            # 第二个数字的索引\n            j = i + 1\n            # 第三个数字的索引\n            k = len_num - 1\n            while j < k:\n                sum_three = nums[i] + nums[j] + nums[k]\n                if sum_three > target:\n                    k -= 1\n                elif sum_three == target:\n                    return sum_three\n                else:\n                    j += 1\n                if abs(sum_three - target) < abs(min_tar - target):\n                    min_tar = sum_three\n        return min_tar\n```\n\n相比官方答案有一点偷懒的地方就是更改 j和k 的时候是直接改，并没有去检查一下修改后的实际数值和修改前的有什么区别，这样其实不太好，确实会重复计算。\n\n## 18. 四数之和\n\n输入：整数数组nums，目标值 target\n\n输出：二维数组\n\n判断nums中是否存在 a,b,c,d，满足 $a+b+c+d=target$，找出所有满足的组合（不能重复）\n\n---\n\n本题看上去还是用双指针的方法进行解决\n\n**第一种遍历方法：固定1、2、4，然后让第3位数字遍历**\n\n先排序\n\n第一个数字 i 直接循环\n\n第二个数字 j从 i+1 开始递增\n\n最后一个数字 从 n-1 开始递减\n\n然后第三个数字 就要在 j 到 k 之间进行遍历\n\n要注意的是，这一次，j和k的遍历都不能重复了，要保证是不同的\n\n> 之前的问题中，实现这一目标，有两种方法：\n>\n> 1. 循环用 for，然后在循环体中添加判断 当相同的时候就continue\n>\n> 2. 循环用 while，循环体中直接判断，判断结束后直接修改索引（第二种方法可能看起来比较容易，实际上两个方法可能消耗的时间差不多）\n>\n>    这种方法的不足之处是，需要修改的时候，考虑的会比较多\n>\n>    而且使用while比较的时候似乎需要考虑会不会超出索引边界\n\n```python\nsort\nfor a in list:\n    if a == last_a:\n        continue\n    \n    j = a+1\n    k = len-1\n    while j<k-1:\n        for c in range j->k:\n\t        if a+j+c+k == target:\n    \t        result.append(this_group)\n        # 该怎样控制 j 和 k 的增减产生双指针的效果呢？        \n```\n\n**在写上面那种方法的时候突然想到，如果我们先固定1，2，那么3，4不就是一个新的双指针了吗？而且这种方法看起来更可靠**\n\n但是同样需要注意，2可以和1重复，但是2和之前的2不要重复，1和之前的1也不要重复，3也不要重复\n\n出现的问题是在运行过程中，不是**超出了时间限制**，就是**超出了内存限制**\n\n哦，我忘了一件事，就是在 ==等于target的时候，也需要进行移动==，不然就出不去了\n\n### 官方题解\n\n阅读官方的代码，发现了几个有意思的点：\n\n1. 第一个数字的索引区间是 0到 n-3\n\n2. 第二个数字的索引区间是 i+1 到 n-2，还使用了 j>i+1 保证满足j的区间正确\n\n3. 还有就是一些比较基础的判断：\n\n   - i,i+1,i+2,i+3 这样四个数字加起来如果都比target大，就不用再循环了\n   - i，n-1，n-2，n-3这样四个数字加起来如果比 target小，那也不用循环了\n   - i，j，j+1，j+2，这样四个数字加起来比 target 大，本轮（第二层循环）可以结束了\n   - i，j，n-1，n-2，这样四个数字加起来比target 小，本轮（第二层循环）可以结束了\n\n4. 最后在修改 左右区间的时候\n\n   1. 只有=target的情况下，修改区间才需要判断是不是和之前的相等\n   2. 不等于target，那就直接更改左右边界，不用判断和之前的是不是重复\n\n5. 还有很有意思的地方：\n\n   1. 官方题解中\n\n      ```python\n      while left < right and nums[left] == nums[left + 1]:\n          left += 1\n      left += 1\n      ```\n\n      因为是和右侧对比，所以可以先对比，最后再 +1\n\n   2. 我刚开始的方法是，先+1，然后再和左侧进行对比\n\n   3. 应该说两者还是有一些细节上的不同的\n\n果然，使用基础判断条件能够极大减少判断时间！\n\n再把 和的计算结果保存下来，又能节省一点时间（毕竟后面多次用到了计算出来的和）\n\n# 小岛问题 - DFS练习\n\n参考：[小岛问题  - DFS子专题](https://github.com/azl397985856/leetcode/blob/master/thinkings/island.md)\n\n深度优先遍历的方法\n\n经典方法：（四联通）\n\n```python\ndef dfs(i,j):\n    if i或j 出界: return\n    if (i,j)已经遍历过: return\n    temp = board[i][j]\n    # 将（i，j）添加到已经遍历过的列表中\n    seen.add((i,j))\n    # 按照四连通，分别对上下左右四个方向进行递归遍历\n    dfs(i+1, j)\n    dfs(i-1, j)    \n    dfs(i, j+1)    \n    dfs(i, j-1)    \n    # 撤销标记\n    seen.remove((i,j))\n\n# 使用算法：单点搜索\ndfs(0, 0)\n# 多点搜索\nfor i in range(M):\n    for j in range(N):\n        dfs(i, j)\n```\n\n这种方法的标记是专门用了一个列表来存放遍历过的点\n\n还有一种标记方法是原地标记，比如直接把遍历过的点的values变成 -1\n\n参考：[深度优先遍历](https://github.com/azl397985856/leetcode/blob/master/thinkings/DFS.md)\n\nDepth-First-Search 深度优先搜索算法，遍历或搜索树或图的算法\n\n- 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。\n- 当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。\n- 这一过程一直进行到已发现从源节点可达的所有节点为止。\n- 如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。\n- 属于**盲目搜索**。（对应启发式搜索，有目的地搜索）\n\nDFS是图论中的经典算法，和图、拓扑排序密切相关\n\n对于树的题目，基本上都可以使用DFS来解决\n\nDFS通常可以基于递归来做，因此算法会更简洁\n\n# 并查集练习\n\n有个同学这样进行描述：[并查集 union-find](https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md)\n\n一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。\n\n有一个联合-查找算法（Union-find Algorithm），两个操作：\n\n- find：确定元素属于哪一个子集【建图和压缩路径】\n- union：将两个子集合并成同一个集合\n\n不带权并查集\n\n带权并查集\n\n以下对无权并查集的基本类进行研究：\n\nclass UF：\n\n初始化函数：\n\n（1）建立一个字典parent表示父元素的集合\n\n（2）建立一个整数cnt，用于记录？\n\n查找（find）：\n\n- 如果不在父集合中\n  - cnt +1\n  - 父集合中添加元素\n\n集合（union）：\n\n- 调用连通判断函数（connected）检测 两个元素是不是连通的\n\n连通（connected）：\n\n- 通过 find 函数判断两个元素的find值是不是相等\n\n说真的这个class包括里面的函数不是很好理解\n\n# 字典的使用\n\n## 使用 collections.defaultdict() 建立字典\n\n`collections.defaultdict()`为字典提供默认值，以免字典中Key不存在的时候引发`KeyError`的异常\n\n这是一种==提供了默认值的字典==\n\n该函数返回一个类似字典的对象\n\n`defaultdict` 是 Python 内建字典类（dict）的一个子类\n\n`rec = collections.defaultdict(list)` \n\n那么在调用的时候，使用`rec.items` 可以比较完整地调用key和values的值对，也可以通过 `rec.values()`调用所有的values，这样不会包括 keys\n\n参考：\n\n- [collections.defaultdict() 和 dict.values()与*dict.values() 的区别](https://blog.csdn.net/clearlove100/article/details/111028876)\n\n- [默认字典collections.defaultdict()的使用](https://blog.csdn.net/weixin_44110891/article/details/89575020)\n\n**该博客中说，key 值可以自定义，value 的类型与括号中设置类型先沟通，比如括号中是list，那么最后的键值对的值就是list**\n\n## 修改字典\n\n如果 字典的 value是`list`：可以 `rec[k].append(v)`\n\n如果 字典的 value是`set`：可以 `rec[k].add(v)`\n\n如果 字典的 value是`int`：可以 `rec[k]+=1`\n\n# list.sort()综合排序方法\n\n`list.sort(cmp, key, reverse)`\n\n- cmp - 使用该参数的方法进行排序\n- key - 每个列表中用来进行比较的元素，可以取自于可迭代对象中，指定可迭代对象中的一个元素进行排序\n- reverse - 降序标志，默认是false升序\n\n比如如果需要对列表的第一个元素进行比较，可以这样进行使用：\n\n`list.sort(key = lambda x: x[0])`\n\n---\n\nOK，本期的解题就是这些，并查集其实理解还不够深入，深度优先和广度优先将是一个大的领域，接下来需要重点关注！","source":"_posts/LeetCode刷题笔记五.md","raw":"---\ntitle: LeetCode刷题笔记（五）\ndate: 2021-02-02 11:58:49\ncategories:\n\t- 算法\ntags:\n\t- 并查集\n\t- 双指针\n\t- 数组\n---\n\n每期10题，上一期参见[LeetCode刷题笔记（四）](https://sunyoe.github.io/2021/01/12/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/)。\n\n本期内容紧贴2021年1月leetcode每日一题，本月主要内容是并查集（包括深度优先或广度优先）及双指针，包括在周赛中也遇到双指针题目，需要重点考虑。\n\n## 1018. 可被5整除的二进制前缀\n\n输入：整数列表 - 只有 0 和 1\n\n输出：布尔列表 - 只有 false 和 true\n\n要求：依次选择整数列表中 从 第0位到第i位的所有数字，这是一个二进制数字，如果可以被5整除，那么布尔列表的第 i 位为true，否则为false。\n\n<!--more-->\n\n---\n\n### 自我解读\n\n方案：\n\n（1）先获得十进制数字\n\n由于本身就是列表，确实要稍微容易一点\n\n$num_{10} = num_2[-1] * 1 + num_2[-2] * 2 +...+num_2[-i] * 2^{i-1}$\n\n但是如果每次都是从头开始计算，2的幂需要计算，空间占用会比较多\n\n（2）能不能被 5 整除其实最关键的就是看最后一位，5或者0就可以\n\n观察一下：1，2，4，8，16，32，64，128，256，…，已经有规律了\n\n| 阶数     | 0    | 1     | 2     | 3     | 4     |\n| -------- | ---- | ----- | ----- | ----- | ----- |\n| 最后一位 | 1    | 2     | 4     | 8     | 6     |\n| **阶数** |      | **5** | **6** | **7** | **8** |\n| 最后一位 |      | 2     | 4     | 8     | 6     |\n\n那么能够产生被5整除的情况：\n\n- [x] 1 + 4：索引0 + 索引2+4n\n- [x] 2 + 8：索引1+4n + 索引3+4n\n- [x] 4 + 6：索引2+4n + 索引4+4n\n\n对以上组合的对数进行计算，只要能配好对，那就可以整除\n\n我觉的这个思路就好很多，尤其对一些比较长的数字会比较好\n\n存在几个问题：\n\n（1）那么问题是到底要怎么样进行遍历呢：比如我可以判断 2+4n 有没有超过 len\n\n（2）能不能利用前面的数据判断当前的情况？其实应该是可以的，每次应该计算出下一位需要几，如果是那么就是true，如果不是那么就是false；这样形成一个动态规划\n\n比如说刚开始形成3个存储数字A1，A2，B1，B2，C1\n\n- 开始，如果索引0是1，A1+1\n- 如果索引2+4n是1，A2+1\n- 如果索引1+4n是1，B1+1\n- 如果索引3+4n是1，B2+1\n- 如果索引4+4n是1，C1+1\n\n最后判断：A1+C1 == A2，B1 == B2，这样又会出现一个问题，如果刚好是 22222，那么也是可以的，这样是1+4n为奇数\n\n注意，0对数值大小完全没有影响\n\n（3）新方案，设一个数值Res，直接遍历字符串，然后\n\n- 索引0是1，Res+1\n- 索引1+4n是1，每个+2\n- 索引2+4n是1，每个+4\n- 索引3+4n是1，每个+8\n- 索引4n是1，每个+6\n\n最后，如果Res可以被5整除，那么就是true，如果不是那就不行\n\n然后，每次是在结尾增加了一位数字\n\n- 索引0 -》索引1，Res+1\n\n- 索引1+4n -》 索引2+4n，每个+2\n\n- 索引2+4n -》 索引 3+4n，每个+4\n\n- 索引3+4n -》 索引 4n，每个-2\n\n- 索引4n -》 索引1+4n，每个-4\n\n确实是可以进行抵消的，但问题是前面各索引有1有0需要计数吗？\n\n也就是说我只统计各索引的次数，然后每次把这些数字进行移动（轮换）\n\n---\n\n### 观察题解\n\n官方题解\n\n从二进制到十进制数字的特点是：$N_i = N_{i-1} \\times 2 +A[i]$\n\n每添加一位数字，计算余数，看能不能被5整除就可以了，这个方法也不错，还很简单\n\n相对来说，我的方法还是复杂了，惭愧！\n\n# <!--并查集系列-->\n\n## 947. 移除最多的同行或同列石头 - 并查集\n\n输入：二维整数数组，每个子数组只有两个整数元素，相当于坐标\n\n输出：一个整数\n\n要求：同行（第一个元素相同），或者同列（第二个元素相同）的子数组只能保留一个，最后输出的就是要去除的子数组的数量\n\n---\n\n### 自我解读\n\n遍历数组，如果行号是新的，行号list新增一个\n\n如果列号是新的，列号list新增一个\n\n遇到新的子数组，检查行号是不是在行号list中，是，del+1，直接下一个\n\n否，检查列号是不是在列号list中，是，del+1，直接下一个\n\n否，下一个，过\n\n> 但是，题目中要求是：==可以移除的石子的最大数量==\n\n比如示例1：\n\n```\n输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n输出：5\n```\n\n如果按照我的思路，先记录了【0，0】，那么会去掉【0，1】【1，0】，但是不会取消【1，2】\n\n但是实际答案说的却是：先移除【2，2】，因为它和【2，1】同行了，。。。最后就只剩下了【0，0】，就像是后来的先移除，这样一定是移除最多的吗？\n\n另一个问题：所有输入一定是一行一行进行展示的吗，这样的话岂不是要简单一点\n\n> 既然需要最大移除数量，那么就要把移除的石子的两个坐标也加入到list中，这样一定是最大的吗？\n\n还是存在一点问题的：\n\n例如一个输入：`[[0,1],[1,0],[1,1]]`，最多可以移除两个石子，但是按照上面的算法却只能去除一个石子\n\n![image-20210115142425858](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210115142425858.png)\n\n类似的，其实这样一个三角结构，会决定到底应该怎么样进行移除\n\n我们如果是从前往后，那么就只能移除1个，但是如果从后往前，就可以移除两个，同样，反过来也是一样的\n\n> 新增案例：`[[0,1],[1,2],[1,3],[3,3],[2,3],[0,2]]`\n\n这个案例说明了，子数组并不是按顺序的，如果不按顺序来进行排列\n\n就有可能导致少删除一个\n\n---\n\n### 阅读题解\n\n横坐标相同、或者纵坐标相同，那么就形成了一条边，有联系的边构成了一个连通图\n\n==**一定可以把一个连通图里的所有顶点根据该规则删到只剩下一个顶点**==\n\n原因是：连通图中，可以通过**遍历**方式遍历到该连通图中的所有顶点，按照遍历的逆向顺序移除石头就可以只剩下一块石头\n\n所以，题目的结果 = 石头总数 - 极大连通子图（连通块或连通分量）的个数（连通块的数量=最后剩下的石头的数量）\n\n并查集里的元素是描述 横坐表和纵坐标的数值\n\n遍历数组，每个元素的横坐表和纵坐标在并查集中进行合并\n\n> 合并：所有横坐标 为x的石头和所有纵坐标 为y的石头都属于同一个连通分量\n\n那么在并查集内部，我们要如何区分横纵坐标？\n\n石头的位置是 数组，并查集底层是一维，怎么样在并查集中区分横纵坐标\n\n方法是扩大坐标区间，比如题目说 $0<=x_i,y_i<=10^4$，那么就可以操作：$横坐标 \\pm 10001 $，从而超越原来的区间，保证不会重复\n\n==**问题是怎么合并**？==\n\n（1）第一种方法：需要**枚举计算任意两点间的连通性**，可以使用深度优先或者广度优先搜索的方法进行计算\n\n[官方题解](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/yi-chu-zui-duo-de-tong-xing-huo-tong-lie-m50r/)的python3代码中使用了`edge=collections.defaultdict(list)`来作为存储单元，用于建图，也就是通过枚举找到了**所有**相互关联的边\n\n但是到了深度优先搜索这里，看上去还是使用了一些库吗？`vis.add(x)`，但是vis并没有进行定义，也有可能是定义的晚了（在下方，函数调用前有一个定义`vis=set()`）？我个人觉得这个写法很糟糕，也许是和下面的代码进行了联动，但是展示出来的效果却非常差\n\n（2）第二种方法：\n\n上面的方法需要循环套循环进行元素的遍历完成建图，还是有一点麻烦了。\n\n任意两点之间直接相连或间接相连其实都是可以的，我们只关注两点之间的连通性。\n\n该方法说对于拥有k个石子的任意一行或者一列，都使用 k-1 条边进行连接\n\n所以方法就是：\n\n1. 先用哈希表存储每一行或每一列所拥有的石子，对纵坐标加了10000，以区分横纵坐标\n2. 然后分别处理每一行或每一列的连通属性\n\n非官方题解：\n\n**大多数方法建立了一个专门的==class（class UnionFind）==来归纳并查集的方法，然后对该类中的方法进行调用**\n\n---\n\n终于找到一个可能比较容易理解的算法了\n\n参考：[Python,并查集, O(nlogm)94%,O(m)19%](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/pythonbing-cha-ji-onlogm94om19-by-jasonc-3uv7/)\n\n仍然保留了两个关键：\n\n- 答案 = 石头总数 - 连通块的数量\n- 纵坐标+10000，==**这样就可以把坐标也看成edges了！**==\n\n这里举了例子：\n\n`[[0,0],[1,1],[1,2]]=>[[0,10000],[1,10001],[1,10002]]`\n\n这里（1）思考为5个nodes：`0,10000,1,10001,10002`\n\n（2）把`[0,10000]`视为 node 0和node 10000有edge连通，其他类似，这样就好理解为什么`+10000`能方便求解了\n\n然后转化为了熟悉的图并查集问题，遍历所有edges，找出所有连通组\n\n> 步骤一：给所有纵坐标+10000\n\n还是比较容易的\n\n```python\nfor stone in stones:\n    stone[-1] += 10000\n```\n\n> 步骤二：如何遍历所有的edges，找出所有连通组？\n\n代码中建立了一个字典吗？还是set？\n\n`dus={s+i*10000:s+i*10000 for stone in stones for i, s in enumerate(stone)}`\n\n遍历每一个石头，i 是第几个，s是坐标值啊，s+i*10000?这个我就不太理解了，是原来的意思吗\n\n神奇，我尝试了一下：\n\n```python\n>>> ss = [[0,0], [1,1], [2,2]]\n>>> dus = {k+i*10000:k+i*10000 for s in ss for i, k in enumerate(s)}\n>>> dus\n{0: 0, 10000: 10000, 1: 1, 10001: 10001, 2: 2, 10002: 10002}\n```\n\n没想到真的能出这样的结果\n\n当我打下下面的代码的时候，发现了问题所在：\n\n```python\n>>> for s in ss:\n...     for i,k in enumerate(s):\n...         print(k)\n...\n0\n0\n1\n1\n2\n2\n```\n\n这是因为 enumerate 针对的是stone，而不是stones！\n\n每个stone只有两个元素，所以 i 只有0 或1，而k就是横坐标或者纵坐标\n\n所以每个横坐标对应0，不会加10000，每个纵坐标对应1，会加10000，就区分开来了，而且使用的是字典，会自动去重！\n\n【妙啊】\n\n然后定义了一个find函数：\n\n- 输入是 i\n- 如果 字典中 i 对应的位置不是 i\n  - 那么继续find（字典中 i 对应的数值），并赋值给 字典中 i 的位置\n- 返回 字典中 i 对应的数值\n\n> 需要观察一下\n>\n> 比如说 字典 bus = {1:1, 2:2, 0:0}\n>\n> dus[0] = 0肯定的\n>\n> ---\n>\n> 如果 字典 bus = {1:2, 2:1, 0:1}\n>\n> dus[0] = 1，不等于0\n>\n> 那么我们再找 find(dus[0]) = find(1)\n>\n> find(1)中，dus[1]  = 2，也不等于 1，再找find(2)\n>\n> find(2)中，dus[2] = 1，也不等于 2，再找find(1)不停循环\n>\n> ---\n>\n> 也就是说不停找，直到找到字典中 key和value一样的值？\n\n然后遍历stones，如果横坐标在字典中，而且横坐标对应的值不等于纵坐标对应的值【这有可能相等吗】\n\n- 那么，字典中横坐标对应的位置，value等于纵坐标+10000对应的数值\n\n> 举个例子\n>\n> `stones = [[0,0], [0,1], [0,2]]`\n>\n> 那么\n>\n> `dus={0:0, 10000:10000, 10001:10001, 10002:10002}`\n>\n> - 首次循环：0 在dus，find(0) = 0 != find(0+10000)=10000【是否存在】\n>   - 所以 dus[find(0)] = dus[0] = find(0+10000) = 10000\n>   - `dus={0:10000, 10000:10000, 10001:10001, 10002:10002}`\n>\n> - 下一个循环：0 在dus，find(0)中，dus[0] = 10000 != 0了，找find(10000) = 10000，赋值给 dus[0]，最后输出10000 != find(10001) = 10001\n>   - 所以 dus[find(0)] = dus[10000] = find(10001) = 10001\n>   - `dus={0:10000, 10000:10001, 10001:10001, 10002:10002}`\n> - 下一个循环：0 在dus，find(0)中，dus[0] = 10000 != 0了，找find(10000) = 10001 != 10000，再找find(10001)=10001，赋值给 dus[0]，最后输出10001 != find(10002) = 10002\n>   - 所以dus[find(0)] = dus[10001] = find(10002) = 10002\n>   - `dus={0:10000, 10000:10001, 10001:10002, 10002:10002}`\n\n然后，需要再来一个循环：\n\n对dus字典中的每一个值进行遍历：\n\n`for k in dus: print(k)`\n\n这里要注意，输出的只有 字典dus 的键 key，而没有value值\n\n> 紧接着上面的注释\n>\n> 现在，find(0) = find(10000) = find(10001) = find(10002) = 10002\n>\n> 所以，最后的字典是：\n>\n> `dus={0:10002, 10000:10002, 10001:10002, 10002:10002}`\n\n最后一步，`set(dus.values())`\n\n应该是取字典 dus 的所有值 values，然后生成集合 set，会去重，再计算集合的长度就是连通域的数量了\n\n简直是太妙了！！！\n\n其实find函数就是寻找最高节点的过程；\n\n而第一个循环的意义就是把横坐标的指向改变，也就是添加连通边edge，建图的过程\n\n## 1584. 连接所有点的最小费用\n\n输入：二维整数数组，每个子数组有两个整数，表示坐标点\n\n输出：整数，表示将所有点连接起来的最小总费用\n\n要求：任意两点之间有且仅有一条简单路径，总路径长度和要最小\n\n---\n\n果然，又是一个图论的问题\n\n比如说我们要建图，每个点要连接到最近的一个点\n\n但是如果两个点互相是最近的点呢 - 构成了一个孤立的群，两个群之间找一个最短的边即可\n\n如果 A 周围最近的是 B，B 周围最近的是 C，C 周围最近的会不会是 A？不会，一定不是 A\n\n![image-20210119161038414](https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210119161038414.png)\n\n不然的话，离 A 最近的就不是 B 了\n\n又是一个并查集的问题\n\n---\n\n### 官方题解\n\n满足任意两点之间有且仅有一条简单路径，只有 树结构 - tree\n\n该树 = 给定图的生成树，总权值最小的生成树，成为最小生成树\n\n经典算法：Kruskal 算法\n\n1. 图中所有边按照长度的由小到大进行排序，等长边任意顺序\n2. 从前往后（也就是从小到大）扫描排序后的边，如果扫描到的边 **连接了两个相异的连通块**，则将它插入图中\n3. 最后得到的图就是最小生成树\n\n所以现在的问题是 key **应该取edge的两个端点**，还是**选择edge 的边长**\n\n第一步：建立一个字典，字典的所有value就是list\n\n`rec = collections.defaultdict(list)` ，表示建立了一个具有默认值的字典，默认值是list\n\n\n\n# <!--数组系列-->\n\n## 56. 合并区间 - 数组\n\n输入：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端\n\n输出：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端\n\n要求：输入数组可能会有重叠，将重叠的两个区间进行合并，输出区间不能有重叠\n\n---\n\n我曾想到过一个方法，类似做直方图\n\n- 先新建了一个字典，默认为0\n- 然后遍历所有的区间，有这个区间，那就在这个区间内将所有的数字对应在字典中的value +1\n- 最后取出所有有数字的key值，再取start和end进行集合\n\n问题是遇到了一个样例：\n\n`[[1,4],[5,6]]`\n\n如果直接进行直方图，那么一定会得到 `[[1,6]]`\n\n但是实际上这两个区间并没有重叠\n\n原有代码;\n\n```python\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        # 先建立一个字典，对每一个key的默认值是int类型\n        merge_dict = collections.defaultdict(int)\n        merge_list = []\n\n        for interval in intervals:\n            start, end = interval[0], interval[1]\n            for i in range(start, end+1):\n                merge_dict[i] += 1\n\n        start = 0\n        max_key = max(merge_dict.keys())\n        for i in range(max_key+1):\n            if not start and merge_dict[i]:\n                start = i\n            if start:\n                if not merge_dict[i]:\n                    merge_list.append([start, i-1])\n                    start = 0\n                elif i == max_key:\n                    merge_list.append([start, i])\n                    break\n            i += 1\n        return merge_list\n```\n\n### 官方题解\n\n**排序方法**\n\n如果按照区间的左端点进行排序，在排序后：\n\n==**可以合并的区间一定是连续的**==\n\n> 官方证明中举例是： a[i], a[j], a[k]，a[i]和a[k] 能合并，但是 a[i] 和 a[j], a[j] 和 a[k]均不能合并\n>\n> 但是我自己举了一个例子：`[1,10],[2,5],[10,11]`，这个例子明显不满足上面说的 `a[i]`和`a[j]`也不能合并的条件，所以其实并不满足题意\n\n用 merged 区间表示最后需要输出的多维列表，先将第一个列表存储到区间中：\n\n遍历所有区间\n\n- 左端点在上一个区间的右端点后\n  - 是，表示不重合，那么加入输出数组\n  - 否，表示重合，那么需要更新右端点\n\n第一步：排序，怎样按照第一个元素的大小进行排序？\n\n`list.sort()`方法的使用\n\n`list.sort(key=lambda x: x[0])`就可以根据第一个元素的大小进行排序\n\n> 排序保证了后一个区间的起始点不会小于前一个区间的起始点，所以只需要比较尾巴，不用比较头了\n\n第二步：遍历，进行对比\n\n==本方法的独特性在于，直接与上一个区间进行对比，而不需要再对前面的区间进行对比了==\n\n比如上面的区间对比完了之后已经存储在 `merged` 里面了，那么现在最新的一个区间，只需要和 `meged[-1]`进行对比，就可以了，而不需要从 `merged[0] `开始进行对比\n\n最后的程序：\n\n```python\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key = lambda x: x[0])\n        merged = []\n\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            elif merged[-1][1] >= interval[0]:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged\n```\n\n## 154-offer 11 旋转数组的最小数字\n\n二分查找方法\n\n首先说明旋转数组是指能旋转一次就变成升序数组的数组\n\n所以特点就是，原来的数组是升序排列的\n\n当旋转一次后，其排列规律是：\n\n![fig1](https://assets.leetcode-cn.com/solution-static/jianzhi_11/1.png)\n\n最小值右侧的元素都是小于等于右边界点的\n\n最小值左侧的元素都是大于等于左边界点的\n\n可以利用以上的性质从而缩小最小值所在的区间\n\n有一种情况是中间某个点的数值大小 等于 边界点\n\n![fig4](https://assets.leetcode-cn.com/solution-static/jianzhi_11/4.png)\n\n那么这个时候不能简单说明该点左侧或者右侧是区间，而应该调整边界点（边界点一定是满足降序要求的，从而找出区间）\n\n## 面试题04.二维数组中的查找\n\n一个二维数组，每一列从上到下递增，每一行从左到右递增\n\n请在该数组中找某一个数值时候存在，当存在时返回 True，不存在 返回 False\n\n暴力方法，直接查找\n\n线性查找，比如从数组的左下角开始查找，如果比target大，那么行数 -1，如果比 target 小，那么列数 +1\n\n## 674. 最长连续递增序列\n\n输入：一个递增数组\n\n输出：最长连续递增子数组的长度\n\n非常的明白，就是贪心法把最长的找出来\n\n可能会遇到两个问题：\n\n（1）怎么处理末尾的问题，到末尾，一方面要继续比较是不是递增序列，另一方面还要把当前的子序列输入进结果\n\n（2）怎么样重置，重置为0是不好的，应该重置为1\n\n所以我的代码是：\n\n```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        len_list = []\n        len_max = 0\n        for i,num in enumerate(nums):\n            if not i:\n                len_max += 1\n            elif num > nums[i-1]:\n                len_max += 1\n            else:\n                len_list.append(len_max)\n                len_max = 1\n            if i == len(nums)-1:\n                len_list.append(len_max)\n        return 0 if not len_list else max(len_list) \n```\n\n而官方的代码是：\n\n```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        start = 0\n\n        for i in range(n):\n            if i > 0 and nums[i] <= nums[i - 1]:\n                start = i\n            ans = max(ans, i - start + 1)\n        \n        return ans\n```\n\n每次计算的过程中都在更新最大值，这样能够减少对空间的使用\n\n其次记录的并不是递增序列的长度，而是起始位置，这样也可以减少空间的消耗，只有在变小的时候才会更新起始位置\n\n# <!--双指针系列-->\n\n## 15. 三数之和\n\n本次周赛的过程中，遇到这类问题，找到四个数字构成定积元组一类的问题，怎么样减小时间复杂度？\n\n发现15、16、18三道题都是这样的问题，看来需要进行一个专题的解决。\n\n相似题目：两数之和、最接近的三数之和、四数之和、较小的三数之和\n\n标签：数组，双指针\n\n---\n\n输入：一个整数数组\n\n输出：二维整数数组，每个子数组中有3个数字，和为0\n\n要求：\n\n- 找出所给整数数组中和为0的所有组合\n- 组合不能重复\n- 所给整数数组中的数字是有可能重复的\n\n---\n\n在示例中出现了一种情况，如果本身数字比较少，少于3个，直接可以返回结果为空\n\n如果数字在3个以上，那也只好进行遍历了，找到所有组合，这样的话，一定需要 $O(n^3)$\n\n提示：\n\n1. 如果能固定一个数字，那么就变成了一个“两数之和”的问题了\n2. 在两数之和问题中，如果我们固定一个数组，我们就需要扫描整个数组，找最后一个数字是不是存在，可不可以**修改这个数组**从而让这个查找变得更快呢？\n3. 或者在不改变数组的情况下，我们呢是不是可以**通过使用额外空间 的方法**，比如哈希表来加速搜索\n\n我直接用遍历的方法进行计算，遇到一个问题：可能会出现相同的元组\n\n例如：`nums=[-1,0,1,2,-1,-4]`\n\n如果从头开始遍历，可能有 `[-1,0,1]`，然后又会遇到`[0,1,-1]`，这两个元组会重复（如果是list确实不重复），但是`[-1,-1,2]`又是可以的\n\n### 官方题解\n\n1. 用排序避免重复答案\n\n2. 所谓双指针的方法是说：一个头指针，一个尾指针，如果和比较小，移动头指针，如果和比较大，移动尾指针，直到找到值\n\n但即使如此，还没有完全解决问题，比如 `[0,0,0,0]`，也只能出一个结果 `[0,0,0]`，但是如果只是进行移动，而没有进行判断，最后会出两个`[0,0,0]`\n\n实际题解中用了一些细节来解决各种问题：\n\n1. 如果这次的首位数字和上一次的首位数字相同，直接跳过\n2. 第二个元素虽说是左指针，但是也可以用for循环\n3. 这次的第二个元素也应该和上一次的第二个数字不同，也就是所找一个全新的第二个数字\n4. 只移动右指针即可\n\n官方代码：\n\n```python\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        nums.sort()\n        ans = list()\n        \n        # 枚举 a\n        for first in range(n):\n            # 需要和上一次枚举的数不相同\n            if first > 0 and nums[first] == nums[first - 1]:\n                continue\n            # c 对应的指针初始指向数组的最右端\n            third = n - 1\n            target = -nums[first]\n            # 枚举 b\n            for second in range(first + 1, n):\n                # 需要和上一次枚举的数不相同\n                if second > first + 1 and nums[second] == nums[second - 1]:\n                    continue\n                # 需要保证 b 的指针在 c 的指针的左侧\n                while second < third and nums[second] + nums[third] > target:\n                    third -= 1\n                # 如果指针重合，随着 b 后续的增加\n                # 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环\n                if second == third:\n                    break\n                if nums[second] + nums[third] == target:\n                    ans.append([nums[first], nums[second], nums[third]])\n        \n        return ans\n\n作者：LeetCode-Solution\n链接：https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n我的错误代码（时间会比较长）：\n\n```python\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        result = []\n        # 排序，以免重复\n        nums.sort()\n\n        # 遍历第一个数字 A\n        for i in range(n):\n            # 确保在i循环中，该数字不会重复\n            if i>0 and nums[i] == nums[i-1]:\n                continue\n\n            # 遍历第二个数字 B，正着遍历\n            for j in range(i+1,n):\n                # 确保在j循环里面，该遍历数字是不会重复的\n                if j>i+1 and nums[j] == nums[j-1]:\n                    continue\n                target = - nums[i] - nums[j]\n\n                # 第三个数字，从尾部遍历\n                k = n-1\n                while j<k and nums[k]>target:\n                    k -= 1\n                if j == k:\n                    # 说明到头了，这个循环结束了\n                    break\n                if target==nums[k]:\n                    result.append([nums[i],nums[j],nums[k]])\n        return result\n```\n\n关键的原因请看第22行： `k=n-1`这行代码如果放在 `j`循环中，那么就跟3个循环是一样的！！\n\n如果放在 `j`循环的外面，立马就不一样了，j 增加， k并没有每次都归 （n-1），这样就减少了一次循环，这是非常重要的！\n\n## 16. 最接近的三数之和\n\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n输入：整数数组 nums，整数target\n\n输出：整数\n\n要求：在nums中找3个数字，其和与target最接近，输出的整数即为该和，假设只有一个答案\n\n---\n\n那么这一次，我们需要记录最小的和，也就是差值最小的和，然后每次去比较差值，如果没有更小的了，那就是它了\n\n还是双指针\n\n先要做一个排序\n\n第一个数字遍历\n\n- 开头取一个，结尾取一个\n- 如果大了，结尾小一位，如果小了，开头就要加一位，最终会有一个最接近的\n\n```python\nsort\nfor i in len:\n    first_num = list[i]\n    k = n-1\n    for j in i+1:len:\n        second_num = list[j]\n        sum = first_num + second_num\n        sum_des = target - sum\n        while list[k] > sum_des:\n            k -= 1\n        sum += second_num + third_num\n        \n```\n\n但是此时的比较方案和上面又不太一样了，如果 k减到最后已经比最后的差值小了，再升 j 还是小\n\n没关系，我们可以额外使用一个变量，用来比较和存储比较小的差值\n\n本题的三个数字是不是还需要像上面的题一样避免重复？\n\n- i 不变的情况下，确实 j 不用再重复了\n- i 如果重复呢，确实也不用，所以 i 最好也不要重复了\n\n---\n\n### 官方题解\n\n1. 本题和15题不一样的地方在于，本题要的是最小差距，而不是枚举所有的最小差距的取值\n\n2. 双指针既可以用之前的双循环的方式进行书写，也可以使用真的双指针，两个索引的方式进行书写\n\n3. 初始化 最佳答案的方法是，直接赋值，赋一个很大的值，比如1e7\n\n最后完成的代码是：\n\n```python\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        # 首先排序\n        nums.sort()\n        len_num = len(nums)\n        min_tar = 1e7\n\n        # 第一个数字的索引\n        for i in range(len_num):\n            # 防止重复\n            if i and nums[i] == nums[i-1]:\n                continue\n            # 第二个数字的索引\n            j = i + 1\n            # 第三个数字的索引\n            k = len_num - 1\n            while j < k:\n                sum_three = nums[i] + nums[j] + nums[k]\n                if sum_three > target:\n                    k -= 1\n                elif sum_three == target:\n                    return sum_three\n                else:\n                    j += 1\n                if abs(sum_three - target) < abs(min_tar - target):\n                    min_tar = sum_three\n        return min_tar\n```\n\n相比官方答案有一点偷懒的地方就是更改 j和k 的时候是直接改，并没有去检查一下修改后的实际数值和修改前的有什么区别，这样其实不太好，确实会重复计算。\n\n## 18. 四数之和\n\n输入：整数数组nums，目标值 target\n\n输出：二维数组\n\n判断nums中是否存在 a,b,c,d，满足 $a+b+c+d=target$，找出所有满足的组合（不能重复）\n\n---\n\n本题看上去还是用双指针的方法进行解决\n\n**第一种遍历方法：固定1、2、4，然后让第3位数字遍历**\n\n先排序\n\n第一个数字 i 直接循环\n\n第二个数字 j从 i+1 开始递增\n\n最后一个数字 从 n-1 开始递减\n\n然后第三个数字 就要在 j 到 k 之间进行遍历\n\n要注意的是，这一次，j和k的遍历都不能重复了，要保证是不同的\n\n> 之前的问题中，实现这一目标，有两种方法：\n>\n> 1. 循环用 for，然后在循环体中添加判断 当相同的时候就continue\n>\n> 2. 循环用 while，循环体中直接判断，判断结束后直接修改索引（第二种方法可能看起来比较容易，实际上两个方法可能消耗的时间差不多）\n>\n>    这种方法的不足之处是，需要修改的时候，考虑的会比较多\n>\n>    而且使用while比较的时候似乎需要考虑会不会超出索引边界\n\n```python\nsort\nfor a in list:\n    if a == last_a:\n        continue\n    \n    j = a+1\n    k = len-1\n    while j<k-1:\n        for c in range j->k:\n\t        if a+j+c+k == target:\n    \t        result.append(this_group)\n        # 该怎样控制 j 和 k 的增减产生双指针的效果呢？        \n```\n\n**在写上面那种方法的时候突然想到，如果我们先固定1，2，那么3，4不就是一个新的双指针了吗？而且这种方法看起来更可靠**\n\n但是同样需要注意，2可以和1重复，但是2和之前的2不要重复，1和之前的1也不要重复，3也不要重复\n\n出现的问题是在运行过程中，不是**超出了时间限制**，就是**超出了内存限制**\n\n哦，我忘了一件事，就是在 ==等于target的时候，也需要进行移动==，不然就出不去了\n\n### 官方题解\n\n阅读官方的代码，发现了几个有意思的点：\n\n1. 第一个数字的索引区间是 0到 n-3\n\n2. 第二个数字的索引区间是 i+1 到 n-2，还使用了 j>i+1 保证满足j的区间正确\n\n3. 还有就是一些比较基础的判断：\n\n   - i,i+1,i+2,i+3 这样四个数字加起来如果都比target大，就不用再循环了\n   - i，n-1，n-2，n-3这样四个数字加起来如果比 target小，那也不用循环了\n   - i，j，j+1，j+2，这样四个数字加起来比 target 大，本轮（第二层循环）可以结束了\n   - i，j，n-1，n-2，这样四个数字加起来比target 小，本轮（第二层循环）可以结束了\n\n4. 最后在修改 左右区间的时候\n\n   1. 只有=target的情况下，修改区间才需要判断是不是和之前的相等\n   2. 不等于target，那就直接更改左右边界，不用判断和之前的是不是重复\n\n5. 还有很有意思的地方：\n\n   1. 官方题解中\n\n      ```python\n      while left < right and nums[left] == nums[left + 1]:\n          left += 1\n      left += 1\n      ```\n\n      因为是和右侧对比，所以可以先对比，最后再 +1\n\n   2. 我刚开始的方法是，先+1，然后再和左侧进行对比\n\n   3. 应该说两者还是有一些细节上的不同的\n\n果然，使用基础判断条件能够极大减少判断时间！\n\n再把 和的计算结果保存下来，又能节省一点时间（毕竟后面多次用到了计算出来的和）\n\n# 小岛问题 - DFS练习\n\n参考：[小岛问题  - DFS子专题](https://github.com/azl397985856/leetcode/blob/master/thinkings/island.md)\n\n深度优先遍历的方法\n\n经典方法：（四联通）\n\n```python\ndef dfs(i,j):\n    if i或j 出界: return\n    if (i,j)已经遍历过: return\n    temp = board[i][j]\n    # 将（i，j）添加到已经遍历过的列表中\n    seen.add((i,j))\n    # 按照四连通，分别对上下左右四个方向进行递归遍历\n    dfs(i+1, j)\n    dfs(i-1, j)    \n    dfs(i, j+1)    \n    dfs(i, j-1)    \n    # 撤销标记\n    seen.remove((i,j))\n\n# 使用算法：单点搜索\ndfs(0, 0)\n# 多点搜索\nfor i in range(M):\n    for j in range(N):\n        dfs(i, j)\n```\n\n这种方法的标记是专门用了一个列表来存放遍历过的点\n\n还有一种标记方法是原地标记，比如直接把遍历过的点的values变成 -1\n\n参考：[深度优先遍历](https://github.com/azl397985856/leetcode/blob/master/thinkings/DFS.md)\n\nDepth-First-Search 深度优先搜索算法，遍历或搜索树或图的算法\n\n- 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。\n- 当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。\n- 这一过程一直进行到已发现从源节点可达的所有节点为止。\n- 如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。\n- 属于**盲目搜索**。（对应启发式搜索，有目的地搜索）\n\nDFS是图论中的经典算法，和图、拓扑排序密切相关\n\n对于树的题目，基本上都可以使用DFS来解决\n\nDFS通常可以基于递归来做，因此算法会更简洁\n\n# 并查集练习\n\n有个同学这样进行描述：[并查集 union-find](https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md)\n\n一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。\n\n有一个联合-查找算法（Union-find Algorithm），两个操作：\n\n- find：确定元素属于哪一个子集【建图和压缩路径】\n- union：将两个子集合并成同一个集合\n\n不带权并查集\n\n带权并查集\n\n以下对无权并查集的基本类进行研究：\n\nclass UF：\n\n初始化函数：\n\n（1）建立一个字典parent表示父元素的集合\n\n（2）建立一个整数cnt，用于记录？\n\n查找（find）：\n\n- 如果不在父集合中\n  - cnt +1\n  - 父集合中添加元素\n\n集合（union）：\n\n- 调用连通判断函数（connected）检测 两个元素是不是连通的\n\n连通（connected）：\n\n- 通过 find 函数判断两个元素的find值是不是相等\n\n说真的这个class包括里面的函数不是很好理解\n\n# 字典的使用\n\n## 使用 collections.defaultdict() 建立字典\n\n`collections.defaultdict()`为字典提供默认值，以免字典中Key不存在的时候引发`KeyError`的异常\n\n这是一种==提供了默认值的字典==\n\n该函数返回一个类似字典的对象\n\n`defaultdict` 是 Python 内建字典类（dict）的一个子类\n\n`rec = collections.defaultdict(list)` \n\n那么在调用的时候，使用`rec.items` 可以比较完整地调用key和values的值对，也可以通过 `rec.values()`调用所有的values，这样不会包括 keys\n\n参考：\n\n- [collections.defaultdict() 和 dict.values()与*dict.values() 的区别](https://blog.csdn.net/clearlove100/article/details/111028876)\n\n- [默认字典collections.defaultdict()的使用](https://blog.csdn.net/weixin_44110891/article/details/89575020)\n\n**该博客中说，key 值可以自定义，value 的类型与括号中设置类型先沟通，比如括号中是list，那么最后的键值对的值就是list**\n\n## 修改字典\n\n如果 字典的 value是`list`：可以 `rec[k].append(v)`\n\n如果 字典的 value是`set`：可以 `rec[k].add(v)`\n\n如果 字典的 value是`int`：可以 `rec[k]+=1`\n\n# list.sort()综合排序方法\n\n`list.sort(cmp, key, reverse)`\n\n- cmp - 使用该参数的方法进行排序\n- key - 每个列表中用来进行比较的元素，可以取自于可迭代对象中，指定可迭代对象中的一个元素进行排序\n- reverse - 降序标志，默认是false升序\n\n比如如果需要对列表的第一个元素进行比较，可以这样进行使用：\n\n`list.sort(key = lambda x: x[0])`\n\n---\n\nOK，本期的解题就是这些，并查集其实理解还不够深入，深度优先和广度优先将是一个大的领域，接下来需要重点关注！","slug":"LeetCode刷题笔记五","published":1,"updated":"2021-03-03T08:43:37.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknv5n89z005mk8tl81pr2cd1","content":"<p>每期10题，上一期参见<a href=\"https://sunyoe.github.io/2021/01/12/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/\" target=\"_blank\" rel=\"noopener\">LeetCode刷题笔记（四）</a>。</p>\n<p>本期内容紧贴2021年1月leetcode每日一题，本月主要内容是并查集（包括深度优先或广度优先）及双指针，包括在周赛中也遇到双指针题目，需要重点考虑。</p>\n<h2 id=\"1018-可被5整除的二进制前缀\"><a href=\"#1018-可被5整除的二进制前缀\" class=\"headerlink\" title=\"1018. 可被5整除的二进制前缀\"></a>1018. 可被5整除的二进制前缀</h2><p>输入：整数列表 - 只有 0 和 1</p>\n<p>输出：布尔列表 - 只有 false 和 true</p>\n<p>要求：依次选择整数列表中 从 第0位到第i位的所有数字，这是一个二进制数字，如果可以被5整除，那么布尔列表的第 i 位为true，否则为false。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"自我解读\"><a href=\"#自我解读\" class=\"headerlink\" title=\"自我解读\"></a>自我解读</h3><p>方案：</p>\n<p>（1）先获得十进制数字</p>\n<p>由于本身就是列表，确实要稍微容易一点</p>\n<p>$num_{10} = num_2[-1] <em> 1 + num_2[-2] </em> 2 +…+num_2[-i] * 2^{i-1}$</p>\n<p>但是如果每次都是从头开始计算，2的幂需要计算，空间占用会比较多</p>\n<p>（2）能不能被 5 整除其实最关键的就是看最后一位，5或者0就可以</p>\n<p>观察一下：1，2，4，8，16，32，64，128，256，…，已经有规律了</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>阶数</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最后一位</td>\n<td>1</td>\n<td>2</td>\n<td>4</td>\n<td>8</td>\n<td>6</td>\n</tr>\n<tr>\n<td><strong>阶数</strong></td>\n<td></td>\n<td><strong>5</strong></td>\n<td><strong>6</strong></td>\n<td><strong>7</strong></td>\n<td><strong>8</strong></td>\n</tr>\n<tr>\n<td>最后一位</td>\n<td></td>\n<td>2</td>\n<td>4</td>\n<td>8</td>\n<td>6</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>那么能够产生被5整除的情况：</p>\n<ul>\n<li>[x] 1 + 4：索引0 + 索引2+4n</li>\n<li>[x] 2 + 8：索引1+4n + 索引3+4n</li>\n<li>[x] 4 + 6：索引2+4n + 索引4+4n</li>\n</ul>\n<p>对以上组合的对数进行计算，只要能配好对，那就可以整除</p>\n<p>我觉的这个思路就好很多，尤其对一些比较长的数字会比较好</p>\n<p>存在几个问题：</p>\n<p>（1）那么问题是到底要怎么样进行遍历呢：比如我可以判断 2+4n 有没有超过 len</p>\n<p>（2）能不能利用前面的数据判断当前的情况？其实应该是可以的，每次应该计算出下一位需要几，如果是那么就是true，如果不是那么就是false；这样形成一个动态规划</p>\n<p>比如说刚开始形成3个存储数字A1，A2，B1，B2，C1</p>\n<ul>\n<li>开始，如果索引0是1，A1+1</li>\n<li>如果索引2+4n是1，A2+1</li>\n<li>如果索引1+4n是1，B1+1</li>\n<li>如果索引3+4n是1，B2+1</li>\n<li>如果索引4+4n是1，C1+1</li>\n</ul>\n<p>最后判断：A1+C1 == A2，B1 == B2，这样又会出现一个问题，如果刚好是 22222，那么也是可以的，这样是1+4n为奇数</p>\n<p>注意，0对数值大小完全没有影响</p>\n<p>（3）新方案，设一个数值Res，直接遍历字符串，然后</p>\n<ul>\n<li>索引0是1，Res+1</li>\n<li>索引1+4n是1，每个+2</li>\n<li>索引2+4n是1，每个+4</li>\n<li>索引3+4n是1，每个+8</li>\n<li>索引4n是1，每个+6</li>\n</ul>\n<p>最后，如果Res可以被5整除，那么就是true，如果不是那就不行</p>\n<p>然后，每次是在结尾增加了一位数字</p>\n<ul>\n<li><p>索引0 -》索引1，Res+1</p>\n</li>\n<li><p>索引1+4n -》 索引2+4n，每个+2</p>\n</li>\n<li><p>索引2+4n -》 索引 3+4n，每个+4</p>\n</li>\n<li><p>索引3+4n -》 索引 4n，每个-2</p>\n</li>\n<li><p>索引4n -》 索引1+4n，每个-4</p>\n</li>\n</ul>\n<p>确实是可以进行抵消的，但问题是前面各索引有1有0需要计数吗？</p>\n<p>也就是说我只统计各索引的次数，然后每次把这些数字进行移动（轮换）</p>\n<hr>\n<h3 id=\"观察题解\"><a href=\"#观察题解\" class=\"headerlink\" title=\"观察题解\"></a>观察题解</h3><p>官方题解</p>\n<p>从二进制到十进制数字的特点是：$N_i = N_{i-1} \\times 2 +A[i]$</p>\n<p>每添加一位数字，计算余数，看能不能被5整除就可以了，这个方法也不错，还很简单</p>\n<p>相对来说，我的方法还是复杂了，惭愧！</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><!--并查集系列--></h1><h2 id=\"947-移除最多的同行或同列石头-并查集\"><a href=\"#947-移除最多的同行或同列石头-并查集\" class=\"headerlink\" title=\"947. 移除最多的同行或同列石头 - 并查集\"></a>947. 移除最多的同行或同列石头 - 并查集</h2><p>输入：二维整数数组，每个子数组只有两个整数元素，相当于坐标</p>\n<p>输出：一个整数</p>\n<p>要求：同行（第一个元素相同），或者同列（第二个元素相同）的子数组只能保留一个，最后输出的就是要去除的子数组的数量</p>\n<hr>\n<h3 id=\"自我解读-1\"><a href=\"#自我解读-1\" class=\"headerlink\" title=\"自我解读\"></a>自我解读</h3><p>遍历数组，如果行号是新的，行号list新增一个</p>\n<p>如果列号是新的，列号list新增一个</p>\n<p>遇到新的子数组，检查行号是不是在行号list中，是，del+1，直接下一个</p>\n<p>否，检查列号是不是在列号list中，是，del+1，直接下一个</p>\n<p>否，下一个，过</p>\n<blockquote>\n<p>但是，题目中要求是：==可以移除的石子的最大数量==</p>\n</blockquote>\n<p>比如示例1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：stones &#x3D; [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class=\"line\">输出：5</span><br></pre></td></tr></table></figure>\n<p>如果按照我的思路，先记录了【0，0】，那么会去掉【0，1】【1，0】，但是不会取消【1，2】</p>\n<p>但是实际答案说的却是：先移除【2，2】，因为它和【2，1】同行了，。。。最后就只剩下了【0，0】，就像是后来的先移除，这样一定是移除最多的吗？</p>\n<p>另一个问题：所有输入一定是一行一行进行展示的吗，这样的话岂不是要简单一点</p>\n<blockquote>\n<p>既然需要最大移除数量，那么就要把移除的石子的两个坐标也加入到list中，这样一定是最大的吗？</p>\n</blockquote>\n<p>还是存在一点问题的：</p>\n<p>例如一个输入：<code>[[0,1],[1,0],[1,1]]</code>，最多可以移除两个石子，但是按照上面的算法却只能去除一个石子</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210115142425858.png\" alt=\"image-20210115142425858\"></p>\n<p>类似的，其实这样一个三角结构，会决定到底应该怎么样进行移除</p>\n<p>我们如果是从前往后，那么就只能移除1个，但是如果从后往前，就可以移除两个，同样，反过来也是一样的</p>\n<blockquote>\n<p>新增案例：<code>[[0,1],[1,2],[1,3],[3,3],[2,3],[0,2]]</code></p>\n</blockquote>\n<p>这个案例说明了，子数组并不是按顺序的，如果不按顺序来进行排列</p>\n<p>就有可能导致少删除一个</p>\n<hr>\n<h3 id=\"阅读题解\"><a href=\"#阅读题解\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>横坐标相同、或者纵坐标相同，那么就形成了一条边，有联系的边构成了一个连通图</p>\n<p>==<strong>一定可以把一个连通图里的所有顶点根据该规则删到只剩下一个顶点</strong>==</p>\n<p>原因是：连通图中，可以通过<strong>遍历</strong>方式遍历到该连通图中的所有顶点，按照遍历的逆向顺序移除石头就可以只剩下一块石头</p>\n<p>所以，题目的结果 = 石头总数 - 极大连通子图（连通块或连通分量）的个数（连通块的数量=最后剩下的石头的数量）</p>\n<p>并查集里的元素是描述 横坐表和纵坐标的数值</p>\n<p>遍历数组，每个元素的横坐表和纵坐标在并查集中进行合并</p>\n<blockquote>\n<p>合并：所有横坐标 为x的石头和所有纵坐标 为y的石头都属于同一个连通分量</p>\n</blockquote>\n<p>那么在并查集内部，我们要如何区分横纵坐标？</p>\n<p>石头的位置是 数组，并查集底层是一维，怎么样在并查集中区分横纵坐标</p>\n<p>方法是扩大坐标区间，比如题目说 $0&lt;=x_i,y_i&lt;=10^4$，那么就可以操作：$横坐标 \\pm 10001 $，从而超越原来的区间，保证不会重复</p>\n<p>==<strong>问题是怎么合并</strong>？==</p>\n<p>（1）第一种方法：需要<strong>枚举计算任意两点间的连通性</strong>，可以使用深度优先或者广度优先搜索的方法进行计算</p>\n<p><a href=\"https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/yi-chu-zui-duo-de-tong-xing-huo-tong-lie-m50r/\" target=\"_blank\" rel=\"noopener\">官方题解</a>的python3代码中使用了<code>edge=collections.defaultdict(list)</code>来作为存储单元，用于建图，也就是通过枚举找到了<strong>所有</strong>相互关联的边</p>\n<p>但是到了深度优先搜索这里，看上去还是使用了一些库吗？<code>vis.add(x)</code>，但是vis并没有进行定义，也有可能是定义的晚了（在下方，函数调用前有一个定义<code>vis=set()</code>）？我个人觉得这个写法很糟糕，也许是和下面的代码进行了联动，但是展示出来的效果却非常差</p>\n<p>（2）第二种方法：</p>\n<p>上面的方法需要循环套循环进行元素的遍历完成建图，还是有一点麻烦了。</p>\n<p>任意两点之间直接相连或间接相连其实都是可以的，我们只关注两点之间的连通性。</p>\n<p>该方法说对于拥有k个石子的任意一行或者一列，都使用 k-1 条边进行连接</p>\n<p>所以方法就是：</p>\n<ol>\n<li>先用哈希表存储每一行或每一列所拥有的石子，对纵坐标加了10000，以区分横纵坐标</li>\n<li>然后分别处理每一行或每一列的连通属性</li>\n</ol>\n<p>非官方题解：</p>\n<p><strong>大多数方法建立了一个专门的==class（class UnionFind）==来归纳并查集的方法，然后对该类中的方法进行调用</strong></p>\n<hr>\n<p>终于找到一个可能比较容易理解的算法了</p>\n<p>参考：<a href=\"https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/pythonbing-cha-ji-onlogm94om19-by-jasonc-3uv7/\" target=\"_blank\" rel=\"noopener\">Python,并查集, O(nlogm)94%,O(m)19%</a></p>\n<p>仍然保留了两个关键：</p>\n<ul>\n<li>答案 = 石头总数 - 连通块的数量</li>\n<li>纵坐标+10000，==<strong>这样就可以把坐标也看成edges了！</strong>==</li>\n</ul>\n<p>这里举了例子：</p>\n<p><code>[[0,0],[1,1],[1,2]]=&gt;[[0,10000],[1,10001],[1,10002]]</code></p>\n<p>这里（1）思考为5个nodes：<code>0,10000,1,10001,10002</code></p>\n<p>（2）把<code>[0,10000]</code>视为 node 0和node 10000有edge连通，其他类似，这样就好理解为什么<code>+10000</code>能方便求解了</p>\n<p>然后转化为了熟悉的图并查集问题，遍历所有edges，找出所有连通组</p>\n<blockquote>\n<p>步骤一：给所有纵坐标+10000</p>\n</blockquote>\n<p>还是比较容易的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> stone <span class=\"keyword\">in</span> stones:</span><br><span class=\"line\">    stone[<span class=\"number\">-1</span>] += <span class=\"number\">10000</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>步骤二：如何遍历所有的edges，找出所有连通组？</p>\n</blockquote>\n<p>代码中建立了一个字典吗？还是set？</p>\n<p><code>dus={s+i*10000:s+i*10000 for stone in stones for i, s in enumerate(stone)}</code></p>\n<p>遍历每一个石头，i 是第几个，s是坐标值啊，s+i*10000?这个我就不太理解了，是原来的意思吗</p>\n<p>神奇，我尝试了一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ss = [[<span class=\"number\">0</span>,<span class=\"number\">0</span>], [<span class=\"number\">1</span>,<span class=\"number\">1</span>], [<span class=\"number\">2</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dus = &#123;k+i*<span class=\"number\">10000</span>:k+i*<span class=\"number\">10000</span> <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> ss <span class=\"keyword\">for</span> i, k <span class=\"keyword\">in</span> enumerate(s)&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dus</span><br><span class=\"line\">&#123;<span class=\"number\">0</span>: <span class=\"number\">0</span>, <span class=\"number\">10000</span>: <span class=\"number\">10000</span>, <span class=\"number\">1</span>: <span class=\"number\">1</span>, <span class=\"number\">10001</span>: <span class=\"number\">10001</span>, <span class=\"number\">2</span>: <span class=\"number\">2</span>, <span class=\"number\">10002</span>: <span class=\"number\">10002</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>没想到真的能出这样的结果</p>\n<p>当我打下下面的代码的时候，发现了问题所在：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> ss:</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">for</span> i,k <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\"><span class=\"meta\">... </span>        print(k)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>这是因为 enumerate 针对的是stone，而不是stones！</p>\n<p>每个stone只有两个元素，所以 i 只有0 或1，而k就是横坐标或者纵坐标</p>\n<p>所以每个横坐标对应0，不会加10000，每个纵坐标对应1，会加10000，就区分开来了，而且使用的是字典，会自动去重！</p>\n<p>【妙啊】</p>\n<p>然后定义了一个find函数：</p>\n<ul>\n<li>输入是 i</li>\n<li>如果 字典中 i 对应的位置不是 i<ul>\n<li>那么继续find（字典中 i 对应的数值），并赋值给 字典中 i 的位置</li>\n</ul>\n</li>\n<li>返回 字典中 i 对应的数值</li>\n</ul>\n<blockquote>\n<p>需要观察一下</p>\n<p>比如说 字典 bus = {1:1, 2:2, 0:0}</p>\n<p>dus[0] = 0肯定的</p>\n<hr>\n<p>如果 字典 bus = {1:2, 2:1, 0:1}</p>\n<p>dus[0] = 1，不等于0</p>\n<p>那么我们再找 find(dus[0]) = find(1)</p>\n<p>find(1)中，dus[1]  = 2，也不等于 1，再找find(2)</p>\n<p>find(2)中，dus[2] = 1，也不等于 2，再找find(1)不停循环</p>\n<hr>\n<p>也就是说不停找，直到找到字典中 key和value一样的值？</p>\n</blockquote>\n<p>然后遍历stones，如果横坐标在字典中，而且横坐标对应的值不等于纵坐标对应的值【这有可能相等吗】</p>\n<ul>\n<li>那么，字典中横坐标对应的位置，value等于纵坐标+10000对应的数值</li>\n</ul>\n<blockquote>\n<p>举个例子</p>\n<p><code>stones = [[0,0], [0,1], [0,2]]</code></p>\n<p>那么</p>\n<p><code>dus={0:0, 10000:10000, 10001:10001, 10002:10002}</code></p>\n<ul>\n<li><p>首次循环：0 在dus，find(0) = 0 != find(0+10000)=10000【是否存在】</p>\n<ul>\n<li>所以 dus[find(0)] = dus[0] = find(0+10000) = 10000</li>\n<li><code>dus={0:10000, 10000:10000, 10001:10001, 10002:10002}</code></li>\n</ul>\n</li>\n<li><p>下一个循环：0 在dus，find(0)中，dus[0] = 10000 != 0了，找find(10000) = 10000，赋值给 dus[0]，最后输出10000 != find(10001) = 10001</p>\n<ul>\n<li>所以 dus[find(0)] = dus[10000] = find(10001) = 10001</li>\n<li><code>dus={0:10000, 10000:10001, 10001:10001, 10002:10002}</code></li>\n</ul>\n</li>\n<li>下一个循环：0 在dus，find(0)中，dus[0] = 10000 != 0了，找find(10000) = 10001 != 10000，再找find(10001)=10001，赋值给 dus[0]，最后输出10001 != find(10002) = 10002<ul>\n<li>所以dus[find(0)] = dus[10001] = find(10002) = 10002</li>\n<li><code>dus={0:10000, 10000:10001, 10001:10002, 10002:10002}</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>然后，需要再来一个循环：</p>\n<p>对dus字典中的每一个值进行遍历：</p>\n<p><code>for k in dus: print(k)</code></p>\n<p>这里要注意，输出的只有 字典dus 的键 key，而没有value值</p>\n<blockquote>\n<p>紧接着上面的注释</p>\n<p>现在，find(0) = find(10000) = find(10001) = find(10002) = 10002</p>\n<p>所以，最后的字典是：</p>\n<p><code>dus={0:10002, 10000:10002, 10001:10002, 10002:10002}</code></p>\n</blockquote>\n<p>最后一步，<code>set(dus.values())</code></p>\n<p>应该是取字典 dus 的所有值 values，然后生成集合 set，会去重，再计算集合的长度就是连通域的数量了</p>\n<p>简直是太妙了！！！</p>\n<p>其实find函数就是寻找最高节点的过程；</p>\n<p>而第一个循环的意义就是把横坐标的指向改变，也就是添加连通边edge，建图的过程</p>\n<h2 id=\"1584-连接所有点的最小费用\"><a href=\"#1584-连接所有点的最小费用\" class=\"headerlink\" title=\"1584. 连接所有点的最小费用\"></a>1584. 连接所有点的最小费用</h2><p>输入：二维整数数组，每个子数组有两个整数，表示坐标点</p>\n<p>输出：整数，表示将所有点连接起来的最小总费用</p>\n<p>要求：任意两点之间有且仅有一条简单路径，总路径长度和要最小</p>\n<hr>\n<p>果然，又是一个图论的问题</p>\n<p>比如说我们要建图，每个点要连接到最近的一个点</p>\n<p>但是如果两个点互相是最近的点呢 - 构成了一个孤立的群，两个群之间找一个最短的边即可</p>\n<p>如果 A 周围最近的是 B，B 周围最近的是 C，C 周围最近的会不会是 A？不会，一定不是 A</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210119161038414.png\" alt=\"image-20210119161038414\"></p>\n<p>不然的话，离 A 最近的就不是 B 了</p>\n<p>又是一个并查集的问题</p>\n<hr>\n<h3 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>满足任意两点之间有且仅有一条简单路径，只有 树结构 - tree</p>\n<p>该树 = 给定图的生成树，总权值最小的生成树，成为最小生成树</p>\n<p>经典算法：Kruskal 算法</p>\n<ol>\n<li>图中所有边按照长度的由小到大进行排序，等长边任意顺序</li>\n<li>从前往后（也就是从小到大）扫描排序后的边，如果扫描到的边 <strong>连接了两个相异的连通块</strong>，则将它插入图中</li>\n<li>最后得到的图就是最小生成树</li>\n</ol>\n<p>所以现在的问题是 key <strong>应该取edge的两个端点</strong>，还是<strong>选择edge 的边长</strong></p>\n<p>第一步：建立一个字典，字典的所有value就是list</p>\n<p><code>rec = collections.defaultdict(list)</code> ，表示建立了一个具有默认值的字典，默认值是list</p>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><!--数组系列--></h1><h2 id=\"56-合并区间-数组\"><a href=\"#56-合并区间-数组\" class=\"headerlink\" title=\"56. 合并区间 - 数组\"></a>56. 合并区间 - 数组</h2><p>输入：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端</p>\n<p>输出：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端</p>\n<p>要求：输入数组可能会有重叠，将重叠的两个区间进行合并，输出区间不能有重叠</p>\n<hr>\n<p>我曾想到过一个方法，类似做直方图</p>\n<ul>\n<li>先新建了一个字典，默认为0</li>\n<li>然后遍历所有的区间，有这个区间，那就在这个区间内将所有的数字对应在字典中的value +1</li>\n<li>最后取出所有有数字的key值，再取start和end进行集合</li>\n</ul>\n<p>问题是遇到了一个样例：</p>\n<p><code>[[1,4],[5,6]]</code></p>\n<p>如果直接进行直方图，那么一定会得到 <code>[[1,6]]</code></p>\n<p>但是实际上这两个区间并没有重叠</p>\n<p>原有代码;</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"comment\"># 先建立一个字典，对每一个key的默认值是int类型</span></span><br><span class=\"line\">        merge_dict = collections.defaultdict(int)</span><br><span class=\"line\">        merge_list = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            start, end = interval[<span class=\"number\">0</span>], interval[<span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(start, end+<span class=\"number\">1</span>):</span><br><span class=\"line\">                merge_dict[i] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        start = <span class=\"number\">0</span></span><br><span class=\"line\">        max_key = max(merge_dict.keys())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(max_key+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> start <span class=\"keyword\">and</span> merge_dict[i]:</span><br><span class=\"line\">                start = i</span><br><span class=\"line\">            <span class=\"keyword\">if</span> start:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> merge_dict[i]:</span><br><span class=\"line\">                    merge_list.append([start, i<span class=\"number\">-1</span>])</span><br><span class=\"line\">                    start = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i == max_key:</span><br><span class=\"line\">                    merge_list.append([start, i])</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge_list</span><br></pre></td></tr></table></figure>\n<h3 id=\"官方题解-1\"><a href=\"#官方题解-1\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p><strong>排序方法</strong></p>\n<p>如果按照区间的左端点进行排序，在排序后：</p>\n<p>==<strong>可以合并的区间一定是连续的</strong>==</p>\n<blockquote>\n<p>官方证明中举例是： a[i], a[j], a[k]，a[i]和a[k] 能合并，但是 a[i] 和 a[j], a[j] 和 a[k]均不能合并</p>\n<p>但是我自己举了一个例子：<code>[1,10],[2,5],[10,11]</code>，这个例子明显不满足上面说的 <code>a[i]</code>和<code>a[j]</code>也不能合并的条件，所以其实并不满足题意</p>\n</blockquote>\n<p>用 merged 区间表示最后需要输出的多维列表，先将第一个列表存储到区间中：</p>\n<p>遍历所有区间</p>\n<ul>\n<li>左端点在上一个区间的右端点后<ul>\n<li>是，表示不重合，那么加入输出数组</li>\n<li>否，表示重合，那么需要更新右端点</li>\n</ul>\n</li>\n</ul>\n<p>第一步：排序，怎样按照第一个元素的大小进行排序？</p>\n<p><code>list.sort()</code>方法的使用</p>\n<p><code>list.sort(key=lambda x: x[0])</code>就可以根据第一个元素的大小进行排序</p>\n<blockquote>\n<p>排序保证了后一个区间的起始点不会小于前一个区间的起始点，所以只需要比较尾巴，不用比较头了</p>\n</blockquote>\n<p>第二步：遍历，进行对比</p>\n<p>==本方法的独特性在于，直接与上一个区间进行对比，而不需要再对前面的区间进行对比了==</p>\n<p>比如上面的区间对比完了之后已经存储在 <code>merged</code> 里面了，那么现在最新的一个区间，只需要和 <code>meged[-1]</code>进行对比，就可以了，而不需要从 <code>merged[0]</code>开始进行对比</p>\n<p>最后的程序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        intervals.sort(key = <span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>])</span><br><span class=\"line\">        merged = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> merged <span class=\"keyword\">or</span> merged[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] &lt; interval[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                merged.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> merged[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] &gt;= interval[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                merged[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] = max(merged[<span class=\"number\">-1</span>][<span class=\"number\">1</span>], interval[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged</span><br></pre></td></tr></table></figure>\n<h2 id=\"154-offer-11-旋转数组的最小数字\"><a href=\"#154-offer-11-旋转数组的最小数字\" class=\"headerlink\" title=\"154-offer 11 旋转数组的最小数字\"></a>154-offer 11 旋转数组的最小数字</h2><p>二分查找方法</p>\n<p>首先说明旋转数组是指能旋转一次就变成升序数组的数组</p>\n<p>所以特点就是，原来的数组是升序排列的</p>\n<p>当旋转一次后，其排列规律是：</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/jianzhi_11/1.png\" alt=\"fig1\"></p>\n<p>最小值右侧的元素都是小于等于右边界点的</p>\n<p>最小值左侧的元素都是大于等于左边界点的</p>\n<p>可以利用以上的性质从而缩小最小值所在的区间</p>\n<p>有一种情况是中间某个点的数值大小 等于 边界点</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/jianzhi_11/4.png\" alt=\"fig4\"></p>\n<p>那么这个时候不能简单说明该点左侧或者右侧是区间，而应该调整边界点（边界点一定是满足降序要求的，从而找出区间）</p>\n<h2 id=\"面试题04-二维数组中的查找\"><a href=\"#面试题04-二维数组中的查找\" class=\"headerlink\" title=\"面试题04.二维数组中的查找\"></a>面试题04.二维数组中的查找</h2><p>一个二维数组，每一列从上到下递增，每一行从左到右递增</p>\n<p>请在该数组中找某一个数值时候存在，当存在时返回 True，不存在 返回 False</p>\n<p>暴力方法，直接查找</p>\n<p>线性查找，比如从数组的左下角开始查找，如果比target大，那么行数 -1，如果比 target 小，那么列数 +1</p>\n<h2 id=\"674-最长连续递增序列\"><a href=\"#674-最长连续递增序列\" class=\"headerlink\" title=\"674. 最长连续递增序列\"></a>674. 最长连续递增序列</h2><p>输入：一个递增数组</p>\n<p>输出：最长连续递增子数组的长度</p>\n<p>非常的明白，就是贪心法把最长的找出来</p>\n<p>可能会遇到两个问题：</p>\n<p>（1）怎么处理末尾的问题，到末尾，一方面要继续比较是不是递增序列，另一方面还要把当前的子序列输入进结果</p>\n<p>（2）怎么样重置，重置为0是不好的，应该重置为1</p>\n<p>所以我的代码是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        len_list = []</span><br><span class=\"line\">        len_max = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i,num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> i:</span><br><span class=\"line\">                len_max += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> num &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                len_max += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                len_list.append(len_max)</span><br><span class=\"line\">                len_max = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == len(nums)<span class=\"number\">-1</span>:</span><br><span class=\"line\">                len_list.append(len_max)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len_list <span class=\"keyword\">else</span> max(len_list)</span><br></pre></td></tr></table></figure>\n<p>而官方的代码是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        start = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] &lt;= nums[i - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                start = i</span><br><span class=\"line\">            ans = max(ans, i - start + <span class=\"number\">1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>每次计算的过程中都在更新最大值，这样能够减少对空间的使用</p>\n<p>其次记录的并不是递增序列的长度，而是起始位置，这样也可以减少空间的消耗，只有在变小的时候才会更新起始位置</p>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><!--双指针系列--></h1><h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a>15. 三数之和</h2><p>本次周赛的过程中，遇到这类问题，找到四个数字构成定积元组一类的问题，怎么样减小时间复杂度？</p>\n<p>发现15、16、18三道题都是这样的问题，看来需要进行一个专题的解决。</p>\n<p>相似题目：两数之和、最接近的三数之和、四数之和、较小的三数之和</p>\n<p>标签：数组，双指针</p>\n<hr>\n<p>输入：一个整数数组</p>\n<p>输出：二维整数数组，每个子数组中有3个数字，和为0</p>\n<p>要求：</p>\n<ul>\n<li>找出所给整数数组中和为0的所有组合</li>\n<li>组合不能重复</li>\n<li>所给整数数组中的数字是有可能重复的</li>\n</ul>\n<hr>\n<p>在示例中出现了一种情况，如果本身数字比较少，少于3个，直接可以返回结果为空</p>\n<p>如果数字在3个以上，那也只好进行遍历了，找到所有组合，这样的话，一定需要 $O(n^3)$</p>\n<p>提示：</p>\n<ol>\n<li>如果能固定一个数字，那么就变成了一个“两数之和”的问题了</li>\n<li>在两数之和问题中，如果我们固定一个数组，我们就需要扫描整个数组，找最后一个数字是不是存在，可不可以<strong>修改这个数组</strong>从而让这个查找变得更快呢？</li>\n<li>或者在不改变数组的情况下，我们呢是不是可以<strong>通过使用额外空间 的方法</strong>，比如哈希表来加速搜索</li>\n</ol>\n<p>我直接用遍历的方法进行计算，遇到一个问题：可能会出现相同的元组</p>\n<p>例如：<code>nums=[-1,0,1,2,-1,-4]</code></p>\n<p>如果从头开始遍历，可能有 <code>[-1,0,1]</code>，然后又会遇到<code>[0,1,-1]</code>，这两个元组会重复（如果是list确实不重复），但是<code>[-1,-1,2]</code>又是可以的</p>\n<h3 id=\"官方题解-2\"><a href=\"#官方题解-2\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><ol>\n<li><p>用排序避免重复答案</p>\n</li>\n<li><p>所谓双指针的方法是说：一个头指针，一个尾指针，如果和比较小，移动头指针，如果和比较大，移动尾指针，直到找到值</p>\n</li>\n</ol>\n<p>但即使如此，还没有完全解决问题，比如 <code>[0,0,0,0]</code>，也只能出一个结果 <code>[0,0,0]</code>，但是如果只是进行移动，而没有进行判断，最后会出两个<code>[0,0,0]</code></p>\n<p>实际题解中用了一些细节来解决各种问题：</p>\n<ol>\n<li>如果这次的首位数字和上一次的首位数字相同，直接跳过</li>\n<li>第二个元素虽说是左指针，但是也可以用for循环</li>\n<li>这次的第二个元素也应该和上一次的第二个数字不同，也就是所找一个全新的第二个数字</li>\n<li>只移动右指针即可</li>\n</ol>\n<p>官方代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        ans = list()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 枚举 a</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> first <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"comment\"># 需要和上一次枚举的数不相同</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> first &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[first] == nums[first - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"comment\"># c 对应的指针初始指向数组的最右端</span></span><br><span class=\"line\">            third = n - <span class=\"number\">1</span></span><br><span class=\"line\">            target = -nums[first]</span><br><span class=\"line\">            <span class=\"comment\"># 枚举 b</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> second <span class=\"keyword\">in</span> range(first + <span class=\"number\">1</span>, n):</span><br><span class=\"line\">                <span class=\"comment\"># 需要和上一次枚举的数不相同</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> second &gt; first + <span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[second] == nums[second - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"comment\"># 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> second &lt; third <span class=\"keyword\">and</span> nums[second] + nums[third] &gt; target:</span><br><span class=\"line\">                    third -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"comment\"># 如果指针重合，随着 b 后续的增加</span></span><br><span class=\"line\">                <span class=\"comment\"># 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> second == third:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[second] + nums[third] == target:</span><br><span class=\"line\">                    ans.append([nums[first], nums[second], nums[third]])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https://leetcode-cn.com/problems/<span class=\"number\">3</span>sum/solution/san-shu-zhi-he-by-leetcode-solution/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<p>我的错误代码（时间会比较长）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"comment\"># 排序，以免重复</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 遍历第一个数字 A</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"comment\"># 确保在i循环中，该数字不会重复</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 遍历第二个数字 B，正着遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,n):</span><br><span class=\"line\">                <span class=\"comment\"># 确保在j循环里面，该遍历数字是不会重复的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> j&gt;i+<span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[j] == nums[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                target = - nums[i] - nums[j]</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># 第三个数字，从尾部遍历</span></span><br><span class=\"line\">                k = n<span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> j&lt;k <span class=\"keyword\">and</span> nums[k]&gt;target:</span><br><span class=\"line\">                    k -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> j == k:</span><br><span class=\"line\">                    <span class=\"comment\"># 说明到头了，这个循环结束了</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> target==nums[k]:</span><br><span class=\"line\">                    result.append([nums[i],nums[j],nums[k]])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p>关键的原因请看第22行： <code>k=n-1</code>这行代码如果放在 <code>j</code>循环中，那么就跟3个循环是一样的！！</p>\n<p>如果放在 <code>j</code>循环的外面，立马就不一样了，j 增加， k并没有每次都归 （n-1），这样就减少了一次循环，这是非常重要的！</p>\n<h2 id=\"16-最接近的三数之和\"><a href=\"#16-最接近的三数之和\" class=\"headerlink\" title=\"16. 最接近的三数之和\"></a>16. 最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>\n<p>输入：整数数组 nums，整数target</p>\n<p>输出：整数</p>\n<p>要求：在nums中找3个数字，其和与target最接近，输出的整数即为该和，假设只有一个答案</p>\n<hr>\n<p>那么这一次，我们需要记录最小的和，也就是差值最小的和，然后每次去比较差值，如果没有更小的了，那就是它了</p>\n<p>还是双指针</p>\n<p>先要做一个排序</p>\n<p>第一个数字遍历</p>\n<ul>\n<li>开头取一个，结尾取一个</li>\n<li>如果大了，结尾小一位，如果小了，开头就要加一位，最终会有一个最接近的</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> len:</span><br><span class=\"line\">    first_num = list[i]</span><br><span class=\"line\">    k = n<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> i+<span class=\"number\">1</span>:len:</span><br><span class=\"line\">        second_num = list[j]</span><br><span class=\"line\">        sum = first_num + second_num</span><br><span class=\"line\">        sum_des = target - sum</span><br><span class=\"line\">        <span class=\"keyword\">while</span> list[k] &gt; sum_des:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        sum += second_num + third_num</span><br></pre></td></tr></table></figure>\n<p>但是此时的比较方案和上面又不太一样了，如果 k减到最后已经比最后的差值小了，再升 j 还是小</p>\n<p>没关系，我们可以额外使用一个变量，用来比较和存储比较小的差值</p>\n<p>本题的三个数字是不是还需要像上面的题一样避免重复？</p>\n<ul>\n<li>i 不变的情况下，确实 j 不用再重复了</li>\n<li>i 如果重复呢，确实也不用，所以 i 最好也不要重复了</li>\n</ul>\n<hr>\n<h3 id=\"官方题解-3\"><a href=\"#官方题解-3\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><ol>\n<li><p>本题和15题不一样的地方在于，本题要的是最小差距，而不是枚举所有的最小差距的取值</p>\n</li>\n<li><p>双指针既可以用之前的双循环的方式进行书写，也可以使用真的双指针，两个索引的方式进行书写</p>\n</li>\n<li><p>初始化 最佳答案的方法是，直接赋值，赋一个很大的值，比如1e7</p>\n</li>\n</ol>\n<p>最后完成的代码是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 首先排序</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        len_num = len(nums)</span><br><span class=\"line\">        min_tar = <span class=\"number\">1e7</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 第一个数字的索引</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_num):</span><br><span class=\"line\">            <span class=\"comment\"># 防止重复</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"comment\"># 第二个数字的索引</span></span><br><span class=\"line\">            j = i + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\"># 第三个数字的索引</span></span><br><span class=\"line\">            k = len_num - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; k:</span><br><span class=\"line\">                sum_three = nums[i] + nums[j] + nums[k]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum_three &gt; target:</span><br><span class=\"line\">                    k -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> sum_three == target:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> sum_three</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    j += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(sum_three - target) &lt; abs(min_tar - target):</span><br><span class=\"line\">                    min_tar = sum_three</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min_tar</span><br></pre></td></tr></table></figure>\n<p>相比官方答案有一点偷懒的地方就是更改 j和k 的时候是直接改，并没有去检查一下修改后的实际数值和修改前的有什么区别，这样其实不太好，确实会重复计算。</p>\n<h2 id=\"18-四数之和\"><a href=\"#18-四数之和\" class=\"headerlink\" title=\"18. 四数之和\"></a>18. 四数之和</h2><p>输入：整数数组nums，目标值 target</p>\n<p>输出：二维数组</p>\n<p>判断nums中是否存在 a,b,c,d，满足 $a+b+c+d=target$，找出所有满足的组合（不能重复）</p>\n<hr>\n<p>本题看上去还是用双指针的方法进行解决</p>\n<p><strong>第一种遍历方法：固定1、2、4，然后让第3位数字遍历</strong></p>\n<p>先排序</p>\n<p>第一个数字 i 直接循环</p>\n<p>第二个数字 j从 i+1 开始递增</p>\n<p>最后一个数字 从 n-1 开始递减</p>\n<p>然后第三个数字 就要在 j 到 k 之间进行遍历</p>\n<p>要注意的是，这一次，j和k的遍历都不能重复了，要保证是不同的</p>\n<blockquote>\n<p>之前的问题中，实现这一目标，有两种方法：</p>\n<ol>\n<li><p>循环用 for，然后在循环体中添加判断 当相同的时候就continue</p>\n</li>\n<li><p>循环用 while，循环体中直接判断，判断结束后直接修改索引（第二种方法可能看起来比较容易，实际上两个方法可能消耗的时间差不多）</p>\n<p>这种方法的不足之处是，需要修改的时候，考虑的会比较多</p>\n<p>而且使用while比较的时候似乎需要考虑会不会超出索引边界</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort</span><br><span class=\"line\"><span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> list:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == last_a:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    j = a+<span class=\"number\">1</span></span><br><span class=\"line\">    k = len<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> j&lt;k<span class=\"number\">-1</span>:</span><br><span class=\"line\">        for c in range j-&gt;k:</span><br><span class=\"line\">\t        <span class=\"keyword\">if</span> a+j+c+k == target:</span><br><span class=\"line\">    \t        result.append(this_group)</span><br><span class=\"line\">        <span class=\"comment\"># 该怎样控制 j 和 k 的增减产生双指针的效果呢？</span></span><br></pre></td></tr></table></figure>\n<p><strong>在写上面那种方法的时候突然想到，如果我们先固定1，2，那么3，4不就是一个新的双指针了吗？而且这种方法看起来更可靠</strong></p>\n<p>但是同样需要注意，2可以和1重复，但是2和之前的2不要重复，1和之前的1也不要重复，3也不要重复</p>\n<p>出现的问题是在运行过程中，不是<strong>超出了时间限制</strong>，就是<strong>超出了内存限制</strong></p>\n<p>哦，我忘了一件事，就是在 ==等于target的时候，也需要进行移动==，不然就出不去了</p>\n<h3 id=\"官方题解-4\"><a href=\"#官方题解-4\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>阅读官方的代码，发现了几个有意思的点：</p>\n<ol>\n<li><p>第一个数字的索引区间是 0到 n-3</p>\n</li>\n<li><p>第二个数字的索引区间是 i+1 到 n-2，还使用了 j&gt;i+1 保证满足j的区间正确</p>\n</li>\n<li><p>还有就是一些比较基础的判断：</p>\n<ul>\n<li>i,i+1,i+2,i+3 这样四个数字加起来如果都比target大，就不用再循环了</li>\n<li>i，n-1，n-2，n-3这样四个数字加起来如果比 target小，那也不用循环了</li>\n<li>i，j，j+1，j+2，这样四个数字加起来比 target 大，本轮（第二层循环）可以结束了</li>\n<li>i，j，n-1，n-2，这样四个数字加起来比target 小，本轮（第二层循环）可以结束了</li>\n</ul>\n</li>\n<li><p>最后在修改 左右区间的时候</p>\n<ol>\n<li>只有=target的情况下，修改区间才需要判断是不是和之前的相等</li>\n<li>不等于target，那就直接更改左右边界，不用判断和之前的是不是重复</li>\n</ol>\n</li>\n<li><p>还有很有意思的地方：</p>\n<ol>\n<li><p>官方题解中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[left] == nums[left + <span class=\"number\">1</span>]:</span><br><span class=\"line\">    left += <span class=\"number\">1</span></span><br><span class=\"line\">left += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>因为是和右侧对比，所以可以先对比，最后再 +1</p>\n</li>\n<li><p>我刚开始的方法是，先+1，然后再和左侧进行对比</p>\n</li>\n<li><p>应该说两者还是有一些细节上的不同的</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>果然，使用基础判断条件能够极大减少判断时间！</p>\n<p>再把 和的计算结果保存下来，又能节省一点时间（毕竟后面多次用到了计算出来的和）</p>\n<h1 id=\"小岛问题-DFS练习\"><a href=\"#小岛问题-DFS练习\" class=\"headerlink\" title=\"小岛问题 - DFS练习\"></a>小岛问题 - DFS练习</h1><p>参考：<a href=\"https://github.com/azl397985856/leetcode/blob/master/thinkings/island.md\" target=\"_blank\" rel=\"noopener\">小岛问题  - DFS子专题</a></p>\n<p>深度优先遍历的方法</p>\n<p>经典方法：（四联通）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i,j)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i或j 出界: <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i,j)已经遍历过: <span class=\"keyword\">return</span></span><br><span class=\"line\">    temp = board[i][j]</span><br><span class=\"line\">    <span class=\"comment\"># 将（i，j）添加到已经遍历过的列表中</span></span><br><span class=\"line\">    seen.add((i,j))</span><br><span class=\"line\">    <span class=\"comment\"># 按照四连通，分别对上下左右四个方向进行递归遍历</span></span><br><span class=\"line\">    dfs(i+<span class=\"number\">1</span>, j)</span><br><span class=\"line\">    dfs(i<span class=\"number\">-1</span>, j)    </span><br><span class=\"line\">    dfs(i, j+<span class=\"number\">1</span>)    </span><br><span class=\"line\">    dfs(i, j<span class=\"number\">-1</span>)    </span><br><span class=\"line\">    <span class=\"comment\"># 撤销标记</span></span><br><span class=\"line\">    seen.remove((i,j))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用算法：单点搜索</span></span><br><span class=\"line\">dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 多点搜索</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        dfs(i, j)</span><br></pre></td></tr></table></figure>\n<p>这种方法的标记是专门用了一个列表来存放遍历过的点</p>\n<p>还有一种标记方法是原地标记，比如直接把遍历过的点的values变成 -1</p>\n<p>参考：<a href=\"https://github.com/azl397985856/leetcode/blob/master/thinkings/DFS.md\" target=\"_blank\" rel=\"noopener\">深度优先遍历</a></p>\n<p>Depth-First-Search 深度优先搜索算法，遍历或搜索树或图的算法</p>\n<ul>\n<li>沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</li>\n<li>当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。</li>\n<li>这一过程一直进行到已发现从源节点可达的所有节点为止。</li>\n<li>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</li>\n<li>属于<strong>盲目搜索</strong>。（对应启发式搜索，有目的地搜索）</li>\n</ul>\n<p>DFS是图论中的经典算法，和图、拓扑排序密切相关</p>\n<p>对于树的题目，基本上都可以使用DFS来解决</p>\n<p>DFS通常可以基于递归来做，因此算法会更简洁</p>\n<h1 id=\"并查集练习\"><a href=\"#并查集练习\" class=\"headerlink\" title=\"并查集练习\"></a>并查集练习</h1><p>有个同学这样进行描述：<a href=\"https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md\" target=\"_blank\" rel=\"noopener\">并查集 union-find</a></p>\n<p>一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。</p>\n<p>有一个联合-查找算法（Union-find Algorithm），两个操作：</p>\n<ul>\n<li>find：确定元素属于哪一个子集【建图和压缩路径】</li>\n<li>union：将两个子集合并成同一个集合</li>\n</ul>\n<p>不带权并查集</p>\n<p>带权并查集</p>\n<p>以下对无权并查集的基本类进行研究：</p>\n<p>class UF：</p>\n<p>初始化函数：</p>\n<p>（1）建立一个字典parent表示父元素的集合</p>\n<p>（2）建立一个整数cnt，用于记录？</p>\n<p>查找（find）：</p>\n<ul>\n<li>如果不在父集合中<ul>\n<li>cnt +1</li>\n<li>父集合中添加元素</li>\n</ul>\n</li>\n</ul>\n<p>集合（union）：</p>\n<ul>\n<li>调用连通判断函数（connected）检测 两个元素是不是连通的</li>\n</ul>\n<p>连通（connected）：</p>\n<ul>\n<li>通过 find 函数判断两个元素的find值是不是相等</li>\n</ul>\n<p>说真的这个class包括里面的函数不是很好理解</p>\n<h1 id=\"字典的使用\"><a href=\"#字典的使用\" class=\"headerlink\" title=\"字典的使用\"></a>字典的使用</h1><h2 id=\"使用-collections-defaultdict-建立字典\"><a href=\"#使用-collections-defaultdict-建立字典\" class=\"headerlink\" title=\"使用 collections.defaultdict() 建立字典\"></a>使用 collections.defaultdict() 建立字典</h2><p><code>collections.defaultdict()</code>为字典提供默认值，以免字典中Key不存在的时候引发<code>KeyError</code>的异常</p>\n<p>这是一种==提供了默认值的字典==</p>\n<p>该函数返回一个类似字典的对象</p>\n<p><code>defaultdict</code> 是 Python 内建字典类（dict）的一个子类</p>\n<p><code>rec = collections.defaultdict(list)</code> </p>\n<p>那么在调用的时候，使用<code>rec.items</code> 可以比较完整地调用key和values的值对，也可以通过 <code>rec.values()</code>调用所有的values，这样不会包括 keys</p>\n<p>参考：</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/clearlove100/article/details/111028876\" target=\"_blank\" rel=\"noopener\">collections.defaultdict() 和 dict.values()与*dict.values() 的区别</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/weixin_44110891/article/details/89575020\" target=\"_blank\" rel=\"noopener\">默认字典collections.defaultdict()的使用</a></p>\n</li>\n</ul>\n<p><strong>该博客中说，key 值可以自定义，value 的类型与括号中设置类型先沟通，比如括号中是list，那么最后的键值对的值就是list</strong></p>\n<h2 id=\"修改字典\"><a href=\"#修改字典\" class=\"headerlink\" title=\"修改字典\"></a>修改字典</h2><p>如果 字典的 value是<code>list</code>：可以 <code>rec[k].append(v)</code></p>\n<p>如果 字典的 value是<code>set</code>：可以 <code>rec[k].add(v)</code></p>\n<p>如果 字典的 value是<code>int</code>：可以 <code>rec[k]+=1</code></p>\n<h1 id=\"list-sort-综合排序方法\"><a href=\"#list-sort-综合排序方法\" class=\"headerlink\" title=\"list.sort()综合排序方法\"></a>list.sort()综合排序方法</h1><p><code>list.sort(cmp, key, reverse)</code></p>\n<ul>\n<li>cmp - 使用该参数的方法进行排序</li>\n<li>key - 每个列表中用来进行比较的元素，可以取自于可迭代对象中，指定可迭代对象中的一个元素进行排序</li>\n<li>reverse - 降序标志，默认是false升序</li>\n</ul>\n<p>比如如果需要对列表的第一个元素进行比较，可以这样进行使用：</p>\n<p><code>list.sort(key = lambda x: x[0])</code></p>\n<hr>\n<p>OK，本期的解题就是这些，并查集其实理解还不够深入，深度优先和广度优先将是一个大的领域，接下来需要重点关注！</p>\n","site":{"data":{}},"excerpt":"<p>每期10题，上一期参见<a href=\"https://sunyoe.github.io/2021/01/12/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/\" target=\"_blank\" rel=\"noopener\">LeetCode刷题笔记（四）</a>。</p>\n<p>本期内容紧贴2021年1月leetcode每日一题，本月主要内容是并查集（包括深度优先或广度优先）及双指针，包括在周赛中也遇到双指针题目，需要重点考虑。</p>\n<h2 id=\"1018-可被5整除的二进制前缀\"><a href=\"#1018-可被5整除的二进制前缀\" class=\"headerlink\" title=\"1018. 可被5整除的二进制前缀\"></a>1018. 可被5整除的二进制前缀</h2><p>输入：整数列表 - 只有 0 和 1</p>\n<p>输出：布尔列表 - 只有 false 和 true</p>\n<p>要求：依次选择整数列表中 从 第0位到第i位的所有数字，这是一个二进制数字，如果可以被5整除，那么布尔列表的第 i 位为true，否则为false。</p>","more":"<hr>\n<h3 id=\"自我解读\"><a href=\"#自我解读\" class=\"headerlink\" title=\"自我解读\"></a>自我解读</h3><p>方案：</p>\n<p>（1）先获得十进制数字</p>\n<p>由于本身就是列表，确实要稍微容易一点</p>\n<p>$num_{10} = num_2[-1] <em> 1 + num_2[-2] </em> 2 +…+num_2[-i] * 2^{i-1}$</p>\n<p>但是如果每次都是从头开始计算，2的幂需要计算，空间占用会比较多</p>\n<p>（2）能不能被 5 整除其实最关键的就是看最后一位，5或者0就可以</p>\n<p>观察一下：1，2，4，8，16，32，64，128，256，…，已经有规律了</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>阶数</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最后一位</td>\n<td>1</td>\n<td>2</td>\n<td>4</td>\n<td>8</td>\n<td>6</td>\n</tr>\n<tr>\n<td><strong>阶数</strong></td>\n<td></td>\n<td><strong>5</strong></td>\n<td><strong>6</strong></td>\n<td><strong>7</strong></td>\n<td><strong>8</strong></td>\n</tr>\n<tr>\n<td>最后一位</td>\n<td></td>\n<td>2</td>\n<td>4</td>\n<td>8</td>\n<td>6</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>那么能够产生被5整除的情况：</p>\n<ul>\n<li>[x] 1 + 4：索引0 + 索引2+4n</li>\n<li>[x] 2 + 8：索引1+4n + 索引3+4n</li>\n<li>[x] 4 + 6：索引2+4n + 索引4+4n</li>\n</ul>\n<p>对以上组合的对数进行计算，只要能配好对，那就可以整除</p>\n<p>我觉的这个思路就好很多，尤其对一些比较长的数字会比较好</p>\n<p>存在几个问题：</p>\n<p>（1）那么问题是到底要怎么样进行遍历呢：比如我可以判断 2+4n 有没有超过 len</p>\n<p>（2）能不能利用前面的数据判断当前的情况？其实应该是可以的，每次应该计算出下一位需要几，如果是那么就是true，如果不是那么就是false；这样形成一个动态规划</p>\n<p>比如说刚开始形成3个存储数字A1，A2，B1，B2，C1</p>\n<ul>\n<li>开始，如果索引0是1，A1+1</li>\n<li>如果索引2+4n是1，A2+1</li>\n<li>如果索引1+4n是1，B1+1</li>\n<li>如果索引3+4n是1，B2+1</li>\n<li>如果索引4+4n是1，C1+1</li>\n</ul>\n<p>最后判断：A1+C1 == A2，B1 == B2，这样又会出现一个问题，如果刚好是 22222，那么也是可以的，这样是1+4n为奇数</p>\n<p>注意，0对数值大小完全没有影响</p>\n<p>（3）新方案，设一个数值Res，直接遍历字符串，然后</p>\n<ul>\n<li>索引0是1，Res+1</li>\n<li>索引1+4n是1，每个+2</li>\n<li>索引2+4n是1，每个+4</li>\n<li>索引3+4n是1，每个+8</li>\n<li>索引4n是1，每个+6</li>\n</ul>\n<p>最后，如果Res可以被5整除，那么就是true，如果不是那就不行</p>\n<p>然后，每次是在结尾增加了一位数字</p>\n<ul>\n<li><p>索引0 -》索引1，Res+1</p>\n</li>\n<li><p>索引1+4n -》 索引2+4n，每个+2</p>\n</li>\n<li><p>索引2+4n -》 索引 3+4n，每个+4</p>\n</li>\n<li><p>索引3+4n -》 索引 4n，每个-2</p>\n</li>\n<li><p>索引4n -》 索引1+4n，每个-4</p>\n</li>\n</ul>\n<p>确实是可以进行抵消的，但问题是前面各索引有1有0需要计数吗？</p>\n<p>也就是说我只统计各索引的次数，然后每次把这些数字进行移动（轮换）</p>\n<hr>\n<h3 id=\"观察题解\"><a href=\"#观察题解\" class=\"headerlink\" title=\"观察题解\"></a>观察题解</h3><p>官方题解</p>\n<p>从二进制到十进制数字的特点是：$N_i = N_{i-1} \\times 2 +A[i]$</p>\n<p>每添加一位数字，计算余数，看能不能被5整除就可以了，这个方法也不错，还很简单</p>\n<p>相对来说，我的方法还是复杂了，惭愧！</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><!--并查集系列--></h1><h2 id=\"947-移除最多的同行或同列石头-并查集\"><a href=\"#947-移除最多的同行或同列石头-并查集\" class=\"headerlink\" title=\"947. 移除最多的同行或同列石头 - 并查集\"></a>947. 移除最多的同行或同列石头 - 并查集</h2><p>输入：二维整数数组，每个子数组只有两个整数元素，相当于坐标</p>\n<p>输出：一个整数</p>\n<p>要求：同行（第一个元素相同），或者同列（第二个元素相同）的子数组只能保留一个，最后输出的就是要去除的子数组的数量</p>\n<hr>\n<h3 id=\"自我解读-1\"><a href=\"#自我解读-1\" class=\"headerlink\" title=\"自我解读\"></a>自我解读</h3><p>遍历数组，如果行号是新的，行号list新增一个</p>\n<p>如果列号是新的，列号list新增一个</p>\n<p>遇到新的子数组，检查行号是不是在行号list中，是，del+1，直接下一个</p>\n<p>否，检查列号是不是在列号list中，是，del+1，直接下一个</p>\n<p>否，下一个，过</p>\n<blockquote>\n<p>但是，题目中要求是：==可以移除的石子的最大数量==</p>\n</blockquote>\n<p>比如示例1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：stones &#x3D; [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class=\"line\">输出：5</span><br></pre></td></tr></table></figure>\n<p>如果按照我的思路，先记录了【0，0】，那么会去掉【0，1】【1，0】，但是不会取消【1，2】</p>\n<p>但是实际答案说的却是：先移除【2，2】，因为它和【2，1】同行了，。。。最后就只剩下了【0，0】，就像是后来的先移除，这样一定是移除最多的吗？</p>\n<p>另一个问题：所有输入一定是一行一行进行展示的吗，这样的话岂不是要简单一点</p>\n<blockquote>\n<p>既然需要最大移除数量，那么就要把移除的石子的两个坐标也加入到list中，这样一定是最大的吗？</p>\n</blockquote>\n<p>还是存在一点问题的：</p>\n<p>例如一个输入：<code>[[0,1],[1,0],[1,1]]</code>，最多可以移除两个石子，但是按照上面的算法却只能去除一个石子</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210115142425858.png\" alt=\"image-20210115142425858\"></p>\n<p>类似的，其实这样一个三角结构，会决定到底应该怎么样进行移除</p>\n<p>我们如果是从前往后，那么就只能移除1个，但是如果从后往前，就可以移除两个，同样，反过来也是一样的</p>\n<blockquote>\n<p>新增案例：<code>[[0,1],[1,2],[1,3],[3,3],[2,3],[0,2]]</code></p>\n</blockquote>\n<p>这个案例说明了，子数组并不是按顺序的，如果不按顺序来进行排列</p>\n<p>就有可能导致少删除一个</p>\n<hr>\n<h3 id=\"阅读题解\"><a href=\"#阅读题解\" class=\"headerlink\" title=\"阅读题解\"></a>阅读题解</h3><p>横坐标相同、或者纵坐标相同，那么就形成了一条边，有联系的边构成了一个连通图</p>\n<p>==<strong>一定可以把一个连通图里的所有顶点根据该规则删到只剩下一个顶点</strong>==</p>\n<p>原因是：连通图中，可以通过<strong>遍历</strong>方式遍历到该连通图中的所有顶点，按照遍历的逆向顺序移除石头就可以只剩下一块石头</p>\n<p>所以，题目的结果 = 石头总数 - 极大连通子图（连通块或连通分量）的个数（连通块的数量=最后剩下的石头的数量）</p>\n<p>并查集里的元素是描述 横坐表和纵坐标的数值</p>\n<p>遍历数组，每个元素的横坐表和纵坐标在并查集中进行合并</p>\n<blockquote>\n<p>合并：所有横坐标 为x的石头和所有纵坐标 为y的石头都属于同一个连通分量</p>\n</blockquote>\n<p>那么在并查集内部，我们要如何区分横纵坐标？</p>\n<p>石头的位置是 数组，并查集底层是一维，怎么样在并查集中区分横纵坐标</p>\n<p>方法是扩大坐标区间，比如题目说 $0&lt;=x_i,y_i&lt;=10^4$，那么就可以操作：$横坐标 \\pm 10001 $，从而超越原来的区间，保证不会重复</p>\n<p>==<strong>问题是怎么合并</strong>？==</p>\n<p>（1）第一种方法：需要<strong>枚举计算任意两点间的连通性</strong>，可以使用深度优先或者广度优先搜索的方法进行计算</p>\n<p><a href=\"https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/yi-chu-zui-duo-de-tong-xing-huo-tong-lie-m50r/\" target=\"_blank\" rel=\"noopener\">官方题解</a>的python3代码中使用了<code>edge=collections.defaultdict(list)</code>来作为存储单元，用于建图，也就是通过枚举找到了<strong>所有</strong>相互关联的边</p>\n<p>但是到了深度优先搜索这里，看上去还是使用了一些库吗？<code>vis.add(x)</code>，但是vis并没有进行定义，也有可能是定义的晚了（在下方，函数调用前有一个定义<code>vis=set()</code>）？我个人觉得这个写法很糟糕，也许是和下面的代码进行了联动，但是展示出来的效果却非常差</p>\n<p>（2）第二种方法：</p>\n<p>上面的方法需要循环套循环进行元素的遍历完成建图，还是有一点麻烦了。</p>\n<p>任意两点之间直接相连或间接相连其实都是可以的，我们只关注两点之间的连通性。</p>\n<p>该方法说对于拥有k个石子的任意一行或者一列，都使用 k-1 条边进行连接</p>\n<p>所以方法就是：</p>\n<ol>\n<li>先用哈希表存储每一行或每一列所拥有的石子，对纵坐标加了10000，以区分横纵坐标</li>\n<li>然后分别处理每一行或每一列的连通属性</li>\n</ol>\n<p>非官方题解：</p>\n<p><strong>大多数方法建立了一个专门的==class（class UnionFind）==来归纳并查集的方法，然后对该类中的方法进行调用</strong></p>\n<hr>\n<p>终于找到一个可能比较容易理解的算法了</p>\n<p>参考：<a href=\"https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/pythonbing-cha-ji-onlogm94om19-by-jasonc-3uv7/\" target=\"_blank\" rel=\"noopener\">Python,并查集, O(nlogm)94%,O(m)19%</a></p>\n<p>仍然保留了两个关键：</p>\n<ul>\n<li>答案 = 石头总数 - 连通块的数量</li>\n<li>纵坐标+10000，==<strong>这样就可以把坐标也看成edges了！</strong>==</li>\n</ul>\n<p>这里举了例子：</p>\n<p><code>[[0,0],[1,1],[1,2]]=&gt;[[0,10000],[1,10001],[1,10002]]</code></p>\n<p>这里（1）思考为5个nodes：<code>0,10000,1,10001,10002</code></p>\n<p>（2）把<code>[0,10000]</code>视为 node 0和node 10000有edge连通，其他类似，这样就好理解为什么<code>+10000</code>能方便求解了</p>\n<p>然后转化为了熟悉的图并查集问题，遍历所有edges，找出所有连通组</p>\n<blockquote>\n<p>步骤一：给所有纵坐标+10000</p>\n</blockquote>\n<p>还是比较容易的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> stone <span class=\"keyword\">in</span> stones:</span><br><span class=\"line\">    stone[<span class=\"number\">-1</span>] += <span class=\"number\">10000</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>步骤二：如何遍历所有的edges，找出所有连通组？</p>\n</blockquote>\n<p>代码中建立了一个字典吗？还是set？</p>\n<p><code>dus={s+i*10000:s+i*10000 for stone in stones for i, s in enumerate(stone)}</code></p>\n<p>遍历每一个石头，i 是第几个，s是坐标值啊，s+i*10000?这个我就不太理解了，是原来的意思吗</p>\n<p>神奇，我尝试了一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ss = [[<span class=\"number\">0</span>,<span class=\"number\">0</span>], [<span class=\"number\">1</span>,<span class=\"number\">1</span>], [<span class=\"number\">2</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dus = &#123;k+i*<span class=\"number\">10000</span>:k+i*<span class=\"number\">10000</span> <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> ss <span class=\"keyword\">for</span> i, k <span class=\"keyword\">in</span> enumerate(s)&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dus</span><br><span class=\"line\">&#123;<span class=\"number\">0</span>: <span class=\"number\">0</span>, <span class=\"number\">10000</span>: <span class=\"number\">10000</span>, <span class=\"number\">1</span>: <span class=\"number\">1</span>, <span class=\"number\">10001</span>: <span class=\"number\">10001</span>, <span class=\"number\">2</span>: <span class=\"number\">2</span>, <span class=\"number\">10002</span>: <span class=\"number\">10002</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>没想到真的能出这样的结果</p>\n<p>当我打下下面的代码的时候，发现了问题所在：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> ss:</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">for</span> i,k <span class=\"keyword\">in</span> enumerate(s):</span><br><span class=\"line\"><span class=\"meta\">... </span>        print(k)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>这是因为 enumerate 针对的是stone，而不是stones！</p>\n<p>每个stone只有两个元素，所以 i 只有0 或1，而k就是横坐标或者纵坐标</p>\n<p>所以每个横坐标对应0，不会加10000，每个纵坐标对应1，会加10000，就区分开来了，而且使用的是字典，会自动去重！</p>\n<p>【妙啊】</p>\n<p>然后定义了一个find函数：</p>\n<ul>\n<li>输入是 i</li>\n<li>如果 字典中 i 对应的位置不是 i<ul>\n<li>那么继续find（字典中 i 对应的数值），并赋值给 字典中 i 的位置</li>\n</ul>\n</li>\n<li>返回 字典中 i 对应的数值</li>\n</ul>\n<blockquote>\n<p>需要观察一下</p>\n<p>比如说 字典 bus = {1:1, 2:2, 0:0}</p>\n<p>dus[0] = 0肯定的</p>\n<hr>\n<p>如果 字典 bus = {1:2, 2:1, 0:1}</p>\n<p>dus[0] = 1，不等于0</p>\n<p>那么我们再找 find(dus[0]) = find(1)</p>\n<p>find(1)中，dus[1]  = 2，也不等于 1，再找find(2)</p>\n<p>find(2)中，dus[2] = 1，也不等于 2，再找find(1)不停循环</p>\n<hr>\n<p>也就是说不停找，直到找到字典中 key和value一样的值？</p>\n</blockquote>\n<p>然后遍历stones，如果横坐标在字典中，而且横坐标对应的值不等于纵坐标对应的值【这有可能相等吗】</p>\n<ul>\n<li>那么，字典中横坐标对应的位置，value等于纵坐标+10000对应的数值</li>\n</ul>\n<blockquote>\n<p>举个例子</p>\n<p><code>stones = [[0,0], [0,1], [0,2]]</code></p>\n<p>那么</p>\n<p><code>dus={0:0, 10000:10000, 10001:10001, 10002:10002}</code></p>\n<ul>\n<li><p>首次循环：0 在dus，find(0) = 0 != find(0+10000)=10000【是否存在】</p>\n<ul>\n<li>所以 dus[find(0)] = dus[0] = find(0+10000) = 10000</li>\n<li><code>dus={0:10000, 10000:10000, 10001:10001, 10002:10002}</code></li>\n</ul>\n</li>\n<li><p>下一个循环：0 在dus，find(0)中，dus[0] = 10000 != 0了，找find(10000) = 10000，赋值给 dus[0]，最后输出10000 != find(10001) = 10001</p>\n<ul>\n<li>所以 dus[find(0)] = dus[10000] = find(10001) = 10001</li>\n<li><code>dus={0:10000, 10000:10001, 10001:10001, 10002:10002}</code></li>\n</ul>\n</li>\n<li>下一个循环：0 在dus，find(0)中，dus[0] = 10000 != 0了，找find(10000) = 10001 != 10000，再找find(10001)=10001，赋值给 dus[0]，最后输出10001 != find(10002) = 10002<ul>\n<li>所以dus[find(0)] = dus[10001] = find(10002) = 10002</li>\n<li><code>dus={0:10000, 10000:10001, 10001:10002, 10002:10002}</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>然后，需要再来一个循环：</p>\n<p>对dus字典中的每一个值进行遍历：</p>\n<p><code>for k in dus: print(k)</code></p>\n<p>这里要注意，输出的只有 字典dus 的键 key，而没有value值</p>\n<blockquote>\n<p>紧接着上面的注释</p>\n<p>现在，find(0) = find(10000) = find(10001) = find(10002) = 10002</p>\n<p>所以，最后的字典是：</p>\n<p><code>dus={0:10002, 10000:10002, 10001:10002, 10002:10002}</code></p>\n</blockquote>\n<p>最后一步，<code>set(dus.values())</code></p>\n<p>应该是取字典 dus 的所有值 values，然后生成集合 set，会去重，再计算集合的长度就是连通域的数量了</p>\n<p>简直是太妙了！！！</p>\n<p>其实find函数就是寻找最高节点的过程；</p>\n<p>而第一个循环的意义就是把横坐标的指向改变，也就是添加连通边edge，建图的过程</p>\n<h2 id=\"1584-连接所有点的最小费用\"><a href=\"#1584-连接所有点的最小费用\" class=\"headerlink\" title=\"1584. 连接所有点的最小费用\"></a>1584. 连接所有点的最小费用</h2><p>输入：二维整数数组，每个子数组有两个整数，表示坐标点</p>\n<p>输出：整数，表示将所有点连接起来的最小总费用</p>\n<p>要求：任意两点之间有且仅有一条简单路径，总路径长度和要最小</p>\n<hr>\n<p>果然，又是一个图论的问题</p>\n<p>比如说我们要建图，每个点要连接到最近的一个点</p>\n<p>但是如果两个点互相是最近的点呢 - 构成了一个孤立的群，两个群之间找一个最短的边即可</p>\n<p>如果 A 周围最近的是 B，B 周围最近的是 C，C 周围最近的会不会是 A？不会，一定不是 A</p>\n<p><img src=\"https://typoraim.oss-cn-shanghai.aliyuncs.com/image/image-20210119161038414.png\" alt=\"image-20210119161038414\"></p>\n<p>不然的话，离 A 最近的就不是 B 了</p>\n<p>又是一个并查集的问题</p>\n<hr>\n<h3 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>满足任意两点之间有且仅有一条简单路径，只有 树结构 - tree</p>\n<p>该树 = 给定图的生成树，总权值最小的生成树，成为最小生成树</p>\n<p>经典算法：Kruskal 算法</p>\n<ol>\n<li>图中所有边按照长度的由小到大进行排序，等长边任意顺序</li>\n<li>从前往后（也就是从小到大）扫描排序后的边，如果扫描到的边 <strong>连接了两个相异的连通块</strong>，则将它插入图中</li>\n<li>最后得到的图就是最小生成树</li>\n</ol>\n<p>所以现在的问题是 key <strong>应该取edge的两个端点</strong>，还是<strong>选择edge 的边长</strong></p>\n<p>第一步：建立一个字典，字典的所有value就是list</p>\n<p><code>rec = collections.defaultdict(list)</code> ，表示建立了一个具有默认值的字典，默认值是list</p>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><!--数组系列--></h1><h2 id=\"56-合并区间-数组\"><a href=\"#56-合并区间-数组\" class=\"headerlink\" title=\"56. 合并区间 - 数组\"></a>56. 合并区间 - 数组</h2><p>输入：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端</p>\n<p>输出：一个二维数组，每个子数组包含两个整数，表示一个区间的起始和终止端</p>\n<p>要求：输入数组可能会有重叠，将重叠的两个区间进行合并，输出区间不能有重叠</p>\n<hr>\n<p>我曾想到过一个方法，类似做直方图</p>\n<ul>\n<li>先新建了一个字典，默认为0</li>\n<li>然后遍历所有的区间，有这个区间，那就在这个区间内将所有的数字对应在字典中的value +1</li>\n<li>最后取出所有有数字的key值，再取start和end进行集合</li>\n</ul>\n<p>问题是遇到了一个样例：</p>\n<p><code>[[1,4],[5,6]]</code></p>\n<p>如果直接进行直方图，那么一定会得到 <code>[[1,6]]</code></p>\n<p>但是实际上这两个区间并没有重叠</p>\n<p>原有代码;</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        <span class=\"comment\"># 先建立一个字典，对每一个key的默认值是int类型</span></span><br><span class=\"line\">        merge_dict = collections.defaultdict(int)</span><br><span class=\"line\">        merge_list = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            start, end = interval[<span class=\"number\">0</span>], interval[<span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(start, end+<span class=\"number\">1</span>):</span><br><span class=\"line\">                merge_dict[i] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        start = <span class=\"number\">0</span></span><br><span class=\"line\">        max_key = max(merge_dict.keys())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(max_key+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> start <span class=\"keyword\">and</span> merge_dict[i]:</span><br><span class=\"line\">                start = i</span><br><span class=\"line\">            <span class=\"keyword\">if</span> start:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> merge_dict[i]:</span><br><span class=\"line\">                    merge_list.append([start, i<span class=\"number\">-1</span>])</span><br><span class=\"line\">                    start = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i == max_key:</span><br><span class=\"line\">                    merge_list.append([start, i])</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge_list</span><br></pre></td></tr></table></figure>\n<h3 id=\"官方题解-1\"><a href=\"#官方题解-1\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p><strong>排序方法</strong></p>\n<p>如果按照区间的左端点进行排序，在排序后：</p>\n<p>==<strong>可以合并的区间一定是连续的</strong>==</p>\n<blockquote>\n<p>官方证明中举例是： a[i], a[j], a[k]，a[i]和a[k] 能合并，但是 a[i] 和 a[j], a[j] 和 a[k]均不能合并</p>\n<p>但是我自己举了一个例子：<code>[1,10],[2,5],[10,11]</code>，这个例子明显不满足上面说的 <code>a[i]</code>和<code>a[j]</code>也不能合并的条件，所以其实并不满足题意</p>\n</blockquote>\n<p>用 merged 区间表示最后需要输出的多维列表，先将第一个列表存储到区间中：</p>\n<p>遍历所有区间</p>\n<ul>\n<li>左端点在上一个区间的右端点后<ul>\n<li>是，表示不重合，那么加入输出数组</li>\n<li>否，表示重合，那么需要更新右端点</li>\n</ul>\n</li>\n</ul>\n<p>第一步：排序，怎样按照第一个元素的大小进行排序？</p>\n<p><code>list.sort()</code>方法的使用</p>\n<p><code>list.sort(key=lambda x: x[0])</code>就可以根据第一个元素的大小进行排序</p>\n<blockquote>\n<p>排序保证了后一个区间的起始点不会小于前一个区间的起始点，所以只需要比较尾巴，不用比较头了</p>\n</blockquote>\n<p>第二步：遍历，进行对比</p>\n<p>==本方法的独特性在于，直接与上一个区间进行对比，而不需要再对前面的区间进行对比了==</p>\n<p>比如上面的区间对比完了之后已经存储在 <code>merged</code> 里面了，那么现在最新的一个区间，只需要和 <code>meged[-1]</code>进行对比，就可以了，而不需要从 <code>merged[0]</code>开始进行对比</p>\n<p>最后的程序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        intervals.sort(key = <span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>])</span><br><span class=\"line\">        merged = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> merged <span class=\"keyword\">or</span> merged[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] &lt; interval[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                merged.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> merged[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] &gt;= interval[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                merged[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] = max(merged[<span class=\"number\">-1</span>][<span class=\"number\">1</span>], interval[<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged</span><br></pre></td></tr></table></figure>\n<h2 id=\"154-offer-11-旋转数组的最小数字\"><a href=\"#154-offer-11-旋转数组的最小数字\" class=\"headerlink\" title=\"154-offer 11 旋转数组的最小数字\"></a>154-offer 11 旋转数组的最小数字</h2><p>二分查找方法</p>\n<p>首先说明旋转数组是指能旋转一次就变成升序数组的数组</p>\n<p>所以特点就是，原来的数组是升序排列的</p>\n<p>当旋转一次后，其排列规律是：</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/jianzhi_11/1.png\" alt=\"fig1\"></p>\n<p>最小值右侧的元素都是小于等于右边界点的</p>\n<p>最小值左侧的元素都是大于等于左边界点的</p>\n<p>可以利用以上的性质从而缩小最小值所在的区间</p>\n<p>有一种情况是中间某个点的数值大小 等于 边界点</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/jianzhi_11/4.png\" alt=\"fig4\"></p>\n<p>那么这个时候不能简单说明该点左侧或者右侧是区间，而应该调整边界点（边界点一定是满足降序要求的，从而找出区间）</p>\n<h2 id=\"面试题04-二维数组中的查找\"><a href=\"#面试题04-二维数组中的查找\" class=\"headerlink\" title=\"面试题04.二维数组中的查找\"></a>面试题04.二维数组中的查找</h2><p>一个二维数组，每一列从上到下递增，每一行从左到右递增</p>\n<p>请在该数组中找某一个数值时候存在，当存在时返回 True，不存在 返回 False</p>\n<p>暴力方法，直接查找</p>\n<p>线性查找，比如从数组的左下角开始查找，如果比target大，那么行数 -1，如果比 target 小，那么列数 +1</p>\n<h2 id=\"674-最长连续递增序列\"><a href=\"#674-最长连续递增序列\" class=\"headerlink\" title=\"674. 最长连续递增序列\"></a>674. 最长连续递增序列</h2><p>输入：一个递增数组</p>\n<p>输出：最长连续递增子数组的长度</p>\n<p>非常的明白，就是贪心法把最长的找出来</p>\n<p>可能会遇到两个问题：</p>\n<p>（1）怎么处理末尾的问题，到末尾，一方面要继续比较是不是递增序列，另一方面还要把当前的子序列输入进结果</p>\n<p>（2）怎么样重置，重置为0是不好的，应该重置为1</p>\n<p>所以我的代码是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        len_list = []</span><br><span class=\"line\">        len_max = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i,num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> i:</span><br><span class=\"line\">                len_max += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> num &gt; nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                len_max += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                len_list.append(len_max)</span><br><span class=\"line\">                len_max = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == len(nums)<span class=\"number\">-1</span>:</span><br><span class=\"line\">                len_list.append(len_max)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> len_list <span class=\"keyword\">else</span> max(len_list)</span><br></pre></td></tr></table></figure>\n<p>而官方的代码是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        start = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] &lt;= nums[i - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                start = i</span><br><span class=\"line\">            ans = max(ans, i - start + <span class=\"number\">1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>每次计算的过程中都在更新最大值，这样能够减少对空间的使用</p>\n<p>其次记录的并不是递增序列的长度，而是起始位置，这样也可以减少空间的消耗，只有在变小的时候才会更新起始位置</p>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><!--双指针系列--></h1><h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a>15. 三数之和</h2><p>本次周赛的过程中，遇到这类问题，找到四个数字构成定积元组一类的问题，怎么样减小时间复杂度？</p>\n<p>发现15、16、18三道题都是这样的问题，看来需要进行一个专题的解决。</p>\n<p>相似题目：两数之和、最接近的三数之和、四数之和、较小的三数之和</p>\n<p>标签：数组，双指针</p>\n<hr>\n<p>输入：一个整数数组</p>\n<p>输出：二维整数数组，每个子数组中有3个数字，和为0</p>\n<p>要求：</p>\n<ul>\n<li>找出所给整数数组中和为0的所有组合</li>\n<li>组合不能重复</li>\n<li>所给整数数组中的数字是有可能重复的</li>\n</ul>\n<hr>\n<p>在示例中出现了一种情况，如果本身数字比较少，少于3个，直接可以返回结果为空</p>\n<p>如果数字在3个以上，那也只好进行遍历了，找到所有组合，这样的话，一定需要 $O(n^3)$</p>\n<p>提示：</p>\n<ol>\n<li>如果能固定一个数字，那么就变成了一个“两数之和”的问题了</li>\n<li>在两数之和问题中，如果我们固定一个数组，我们就需要扫描整个数组，找最后一个数字是不是存在，可不可以<strong>修改这个数组</strong>从而让这个查找变得更快呢？</li>\n<li>或者在不改变数组的情况下，我们呢是不是可以<strong>通过使用额外空间 的方法</strong>，比如哈希表来加速搜索</li>\n</ol>\n<p>我直接用遍历的方法进行计算，遇到一个问题：可能会出现相同的元组</p>\n<p>例如：<code>nums=[-1,0,1,2,-1,-4]</code></p>\n<p>如果从头开始遍历，可能有 <code>[-1,0,1]</code>，然后又会遇到<code>[0,1,-1]</code>，这两个元组会重复（如果是list确实不重复），但是<code>[-1,-1,2]</code>又是可以的</p>\n<h3 id=\"官方题解-2\"><a href=\"#官方题解-2\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><ol>\n<li><p>用排序避免重复答案</p>\n</li>\n<li><p>所谓双指针的方法是说：一个头指针，一个尾指针，如果和比较小，移动头指针，如果和比较大，移动尾指针，直到找到值</p>\n</li>\n</ol>\n<p>但即使如此，还没有完全解决问题，比如 <code>[0,0,0,0]</code>，也只能出一个结果 <code>[0,0,0]</code>，但是如果只是进行移动，而没有进行判断，最后会出两个<code>[0,0,0]</code></p>\n<p>实际题解中用了一些细节来解决各种问题：</p>\n<ol>\n<li>如果这次的首位数字和上一次的首位数字相同，直接跳过</li>\n<li>第二个元素虽说是左指针，但是也可以用for循环</li>\n<li>这次的第二个元素也应该和上一次的第二个数字不同，也就是所找一个全新的第二个数字</li>\n<li>只移动右指针即可</li>\n</ol>\n<p>官方代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        ans = list()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 枚举 a</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> first <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"comment\"># 需要和上一次枚举的数不相同</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> first &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[first] == nums[first - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"comment\"># c 对应的指针初始指向数组的最右端</span></span><br><span class=\"line\">            third = n - <span class=\"number\">1</span></span><br><span class=\"line\">            target = -nums[first]</span><br><span class=\"line\">            <span class=\"comment\"># 枚举 b</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> second <span class=\"keyword\">in</span> range(first + <span class=\"number\">1</span>, n):</span><br><span class=\"line\">                <span class=\"comment\"># 需要和上一次枚举的数不相同</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> second &gt; first + <span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[second] == nums[second - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"comment\"># 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> second &lt; third <span class=\"keyword\">and</span> nums[second] + nums[third] &gt; target:</span><br><span class=\"line\">                    third -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"comment\"># 如果指针重合，随着 b 后续的增加</span></span><br><span class=\"line\">                <span class=\"comment\"># 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> second == third:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[second] + nums[third] == target:</span><br><span class=\"line\">                    ans.append([nums[first], nums[second], nums[third]])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">作者：LeetCode-Solution</span><br><span class=\"line\">链接：https://leetcode-cn.com/problems/<span class=\"number\">3</span>sum/solution/san-shu-zhi-he-by-leetcode-solution/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<p>我的错误代码（时间会比较长）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"comment\"># 排序，以免重复</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 遍历第一个数字 A</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"comment\"># 确保在i循环中，该数字不会重复</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 遍历第二个数字 B，正着遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,n):</span><br><span class=\"line\">                <span class=\"comment\"># 确保在j循环里面，该遍历数字是不会重复的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> j&gt;i+<span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[j] == nums[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                target = - nums[i] - nums[j]</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># 第三个数字，从尾部遍历</span></span><br><span class=\"line\">                k = n<span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> j&lt;k <span class=\"keyword\">and</span> nums[k]&gt;target:</span><br><span class=\"line\">                    k -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> j == k:</span><br><span class=\"line\">                    <span class=\"comment\"># 说明到头了，这个循环结束了</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> target==nums[k]:</span><br><span class=\"line\">                    result.append([nums[i],nums[j],nums[k]])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p>关键的原因请看第22行： <code>k=n-1</code>这行代码如果放在 <code>j</code>循环中，那么就跟3个循环是一样的！！</p>\n<p>如果放在 <code>j</code>循环的外面，立马就不一样了，j 增加， k并没有每次都归 （n-1），这样就减少了一次循环，这是非常重要的！</p>\n<h2 id=\"16-最接近的三数之和\"><a href=\"#16-最接近的三数之和\" class=\"headerlink\" title=\"16. 最接近的三数之和\"></a>16. 最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>\n<p>输入：整数数组 nums，整数target</p>\n<p>输出：整数</p>\n<p>要求：在nums中找3个数字，其和与target最接近，输出的整数即为该和，假设只有一个答案</p>\n<hr>\n<p>那么这一次，我们需要记录最小的和，也就是差值最小的和，然后每次去比较差值，如果没有更小的了，那就是它了</p>\n<p>还是双指针</p>\n<p>先要做一个排序</p>\n<p>第一个数字遍历</p>\n<ul>\n<li>开头取一个，结尾取一个</li>\n<li>如果大了，结尾小一位，如果小了，开头就要加一位，最终会有一个最接近的</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> len:</span><br><span class=\"line\">    first_num = list[i]</span><br><span class=\"line\">    k = n<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> i+<span class=\"number\">1</span>:len:</span><br><span class=\"line\">        second_num = list[j]</span><br><span class=\"line\">        sum = first_num + second_num</span><br><span class=\"line\">        sum_des = target - sum</span><br><span class=\"line\">        <span class=\"keyword\">while</span> list[k] &gt; sum_des:</span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        sum += second_num + third_num</span><br></pre></td></tr></table></figure>\n<p>但是此时的比较方案和上面又不太一样了，如果 k减到最后已经比最后的差值小了，再升 j 还是小</p>\n<p>没关系，我们可以额外使用一个变量，用来比较和存储比较小的差值</p>\n<p>本题的三个数字是不是还需要像上面的题一样避免重复？</p>\n<ul>\n<li>i 不变的情况下，确实 j 不用再重复了</li>\n<li>i 如果重复呢，确实也不用，所以 i 最好也不要重复了</li>\n</ul>\n<hr>\n<h3 id=\"官方题解-3\"><a href=\"#官方题解-3\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><ol>\n<li><p>本题和15题不一样的地方在于，本题要的是最小差距，而不是枚举所有的最小差距的取值</p>\n</li>\n<li><p>双指针既可以用之前的双循环的方式进行书写，也可以使用真的双指针，两个索引的方式进行书写</p>\n</li>\n<li><p>初始化 最佳答案的方法是，直接赋值，赋一个很大的值，比如1e7</p>\n</li>\n</ol>\n<p>最后完成的代码是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"comment\"># 首先排序</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        len_num = len(nums)</span><br><span class=\"line\">        min_tar = <span class=\"number\">1e7</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 第一个数字的索引</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_num):</span><br><span class=\"line\">            <span class=\"comment\"># 防止重复</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"comment\"># 第二个数字的索引</span></span><br><span class=\"line\">            j = i + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\"># 第三个数字的索引</span></span><br><span class=\"line\">            k = len_num - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; k:</span><br><span class=\"line\">                sum_three = nums[i] + nums[j] + nums[k]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum_three &gt; target:</span><br><span class=\"line\">                    k -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> sum_three == target:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> sum_three</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    j += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(sum_three - target) &lt; abs(min_tar - target):</span><br><span class=\"line\">                    min_tar = sum_three</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min_tar</span><br></pre></td></tr></table></figure>\n<p>相比官方答案有一点偷懒的地方就是更改 j和k 的时候是直接改，并没有去检查一下修改后的实际数值和修改前的有什么区别，这样其实不太好，确实会重复计算。</p>\n<h2 id=\"18-四数之和\"><a href=\"#18-四数之和\" class=\"headerlink\" title=\"18. 四数之和\"></a>18. 四数之和</h2><p>输入：整数数组nums，目标值 target</p>\n<p>输出：二维数组</p>\n<p>判断nums中是否存在 a,b,c,d，满足 $a+b+c+d=target$，找出所有满足的组合（不能重复）</p>\n<hr>\n<p>本题看上去还是用双指针的方法进行解决</p>\n<p><strong>第一种遍历方法：固定1、2、4，然后让第3位数字遍历</strong></p>\n<p>先排序</p>\n<p>第一个数字 i 直接循环</p>\n<p>第二个数字 j从 i+1 开始递增</p>\n<p>最后一个数字 从 n-1 开始递减</p>\n<p>然后第三个数字 就要在 j 到 k 之间进行遍历</p>\n<p>要注意的是，这一次，j和k的遍历都不能重复了，要保证是不同的</p>\n<blockquote>\n<p>之前的问题中，实现这一目标，有两种方法：</p>\n<ol>\n<li><p>循环用 for，然后在循环体中添加判断 当相同的时候就continue</p>\n</li>\n<li><p>循环用 while，循环体中直接判断，判断结束后直接修改索引（第二种方法可能看起来比较容易，实际上两个方法可能消耗的时间差不多）</p>\n<p>这种方法的不足之处是，需要修改的时候，考虑的会比较多</p>\n<p>而且使用while比较的时候似乎需要考虑会不会超出索引边界</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort</span><br><span class=\"line\"><span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> list:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == last_a:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    j = a+<span class=\"number\">1</span></span><br><span class=\"line\">    k = len<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> j&lt;k<span class=\"number\">-1</span>:</span><br><span class=\"line\">        for c in range j-&gt;k:</span><br><span class=\"line\">\t        <span class=\"keyword\">if</span> a+j+c+k == target:</span><br><span class=\"line\">    \t        result.append(this_group)</span><br><span class=\"line\">        <span class=\"comment\"># 该怎样控制 j 和 k 的增减产生双指针的效果呢？</span></span><br></pre></td></tr></table></figure>\n<p><strong>在写上面那种方法的时候突然想到，如果我们先固定1，2，那么3，4不就是一个新的双指针了吗？而且这种方法看起来更可靠</strong></p>\n<p>但是同样需要注意，2可以和1重复，但是2和之前的2不要重复，1和之前的1也不要重复，3也不要重复</p>\n<p>出现的问题是在运行过程中，不是<strong>超出了时间限制</strong>，就是<strong>超出了内存限制</strong></p>\n<p>哦，我忘了一件事，就是在 ==等于target的时候，也需要进行移动==，不然就出不去了</p>\n<h3 id=\"官方题解-4\"><a href=\"#官方题解-4\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h3><p>阅读官方的代码，发现了几个有意思的点：</p>\n<ol>\n<li><p>第一个数字的索引区间是 0到 n-3</p>\n</li>\n<li><p>第二个数字的索引区间是 i+1 到 n-2，还使用了 j&gt;i+1 保证满足j的区间正确</p>\n</li>\n<li><p>还有就是一些比较基础的判断：</p>\n<ul>\n<li>i,i+1,i+2,i+3 这样四个数字加起来如果都比target大，就不用再循环了</li>\n<li>i，n-1，n-2，n-3这样四个数字加起来如果比 target小，那也不用循环了</li>\n<li>i，j，j+1，j+2，这样四个数字加起来比 target 大，本轮（第二层循环）可以结束了</li>\n<li>i，j，n-1，n-2，这样四个数字加起来比target 小，本轮（第二层循环）可以结束了</li>\n</ul>\n</li>\n<li><p>最后在修改 左右区间的时候</p>\n<ol>\n<li>只有=target的情况下，修改区间才需要判断是不是和之前的相等</li>\n<li>不等于target，那就直接更改左右边界，不用判断和之前的是不是重复</li>\n</ol>\n</li>\n<li><p>还有很有意思的地方：</p>\n<ol>\n<li><p>官方题解中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[left] == nums[left + <span class=\"number\">1</span>]:</span><br><span class=\"line\">    left += <span class=\"number\">1</span></span><br><span class=\"line\">left += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>因为是和右侧对比，所以可以先对比，最后再 +1</p>\n</li>\n<li><p>我刚开始的方法是，先+1，然后再和左侧进行对比</p>\n</li>\n<li><p>应该说两者还是有一些细节上的不同的</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>果然，使用基础判断条件能够极大减少判断时间！</p>\n<p>再把 和的计算结果保存下来，又能节省一点时间（毕竟后面多次用到了计算出来的和）</p>\n<h1 id=\"小岛问题-DFS练习\"><a href=\"#小岛问题-DFS练习\" class=\"headerlink\" title=\"小岛问题 - DFS练习\"></a>小岛问题 - DFS练习</h1><p>参考：<a href=\"https://github.com/azl397985856/leetcode/blob/master/thinkings/island.md\" target=\"_blank\" rel=\"noopener\">小岛问题  - DFS子专题</a></p>\n<p>深度优先遍历的方法</p>\n<p>经典方法：（四联通）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(i,j)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i或j 出界: <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i,j)已经遍历过: <span class=\"keyword\">return</span></span><br><span class=\"line\">    temp = board[i][j]</span><br><span class=\"line\">    <span class=\"comment\"># 将（i，j）添加到已经遍历过的列表中</span></span><br><span class=\"line\">    seen.add((i,j))</span><br><span class=\"line\">    <span class=\"comment\"># 按照四连通，分别对上下左右四个方向进行递归遍历</span></span><br><span class=\"line\">    dfs(i+<span class=\"number\">1</span>, j)</span><br><span class=\"line\">    dfs(i<span class=\"number\">-1</span>, j)    </span><br><span class=\"line\">    dfs(i, j+<span class=\"number\">1</span>)    </span><br><span class=\"line\">    dfs(i, j<span class=\"number\">-1</span>)    </span><br><span class=\"line\">    <span class=\"comment\"># 撤销标记</span></span><br><span class=\"line\">    seen.remove((i,j))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用算法：单点搜索</span></span><br><span class=\"line\">dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 多点搜索</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(M):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(N):</span><br><span class=\"line\">        dfs(i, j)</span><br></pre></td></tr></table></figure>\n<p>这种方法的标记是专门用了一个列表来存放遍历过的点</p>\n<p>还有一种标记方法是原地标记，比如直接把遍历过的点的values变成 -1</p>\n<p>参考：<a href=\"https://github.com/azl397985856/leetcode/blob/master/thinkings/DFS.md\" target=\"_blank\" rel=\"noopener\">深度优先遍历</a></p>\n<p>Depth-First-Search 深度优先搜索算法，遍历或搜索树或图的算法</p>\n<ul>\n<li>沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</li>\n<li>当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。</li>\n<li>这一过程一直进行到已发现从源节点可达的所有节点为止。</li>\n<li>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</li>\n<li>属于<strong>盲目搜索</strong>。（对应启发式搜索，有目的地搜索）</li>\n</ul>\n<p>DFS是图论中的经典算法，和图、拓扑排序密切相关</p>\n<p>对于树的题目，基本上都可以使用DFS来解决</p>\n<p>DFS通常可以基于递归来做，因此算法会更简洁</p>\n<h1 id=\"并查集练习\"><a href=\"#并查集练习\" class=\"headerlink\" title=\"并查集练习\"></a>并查集练习</h1><p>有个同学这样进行描述：<a href=\"https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md\" target=\"_blank\" rel=\"noopener\">并查集 union-find</a></p>\n<p>一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。</p>\n<p>有一个联合-查找算法（Union-find Algorithm），两个操作：</p>\n<ul>\n<li>find：确定元素属于哪一个子集【建图和压缩路径】</li>\n<li>union：将两个子集合并成同一个集合</li>\n</ul>\n<p>不带权并查集</p>\n<p>带权并查集</p>\n<p>以下对无权并查集的基本类进行研究：</p>\n<p>class UF：</p>\n<p>初始化函数：</p>\n<p>（1）建立一个字典parent表示父元素的集合</p>\n<p>（2）建立一个整数cnt，用于记录？</p>\n<p>查找（find）：</p>\n<ul>\n<li>如果不在父集合中<ul>\n<li>cnt +1</li>\n<li>父集合中添加元素</li>\n</ul>\n</li>\n</ul>\n<p>集合（union）：</p>\n<ul>\n<li>调用连通判断函数（connected）检测 两个元素是不是连通的</li>\n</ul>\n<p>连通（connected）：</p>\n<ul>\n<li>通过 find 函数判断两个元素的find值是不是相等</li>\n</ul>\n<p>说真的这个class包括里面的函数不是很好理解</p>\n<h1 id=\"字典的使用\"><a href=\"#字典的使用\" class=\"headerlink\" title=\"字典的使用\"></a>字典的使用</h1><h2 id=\"使用-collections-defaultdict-建立字典\"><a href=\"#使用-collections-defaultdict-建立字典\" class=\"headerlink\" title=\"使用 collections.defaultdict() 建立字典\"></a>使用 collections.defaultdict() 建立字典</h2><p><code>collections.defaultdict()</code>为字典提供默认值，以免字典中Key不存在的时候引发<code>KeyError</code>的异常</p>\n<p>这是一种==提供了默认值的字典==</p>\n<p>该函数返回一个类似字典的对象</p>\n<p><code>defaultdict</code> 是 Python 内建字典类（dict）的一个子类</p>\n<p><code>rec = collections.defaultdict(list)</code> </p>\n<p>那么在调用的时候，使用<code>rec.items</code> 可以比较完整地调用key和values的值对，也可以通过 <code>rec.values()</code>调用所有的values，这样不会包括 keys</p>\n<p>参考：</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/clearlove100/article/details/111028876\" target=\"_blank\" rel=\"noopener\">collections.defaultdict() 和 dict.values()与*dict.values() 的区别</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/weixin_44110891/article/details/89575020\" target=\"_blank\" rel=\"noopener\">默认字典collections.defaultdict()的使用</a></p>\n</li>\n</ul>\n<p><strong>该博客中说，key 值可以自定义，value 的类型与括号中设置类型先沟通，比如括号中是list，那么最后的键值对的值就是list</strong></p>\n<h2 id=\"修改字典\"><a href=\"#修改字典\" class=\"headerlink\" title=\"修改字典\"></a>修改字典</h2><p>如果 字典的 value是<code>list</code>：可以 <code>rec[k].append(v)</code></p>\n<p>如果 字典的 value是<code>set</code>：可以 <code>rec[k].add(v)</code></p>\n<p>如果 字典的 value是<code>int</code>：可以 <code>rec[k]+=1</code></p>\n<h1 id=\"list-sort-综合排序方法\"><a href=\"#list-sort-综合排序方法\" class=\"headerlink\" title=\"list.sort()综合排序方法\"></a>list.sort()综合排序方法</h1><p><code>list.sort(cmp, key, reverse)</code></p>\n<ul>\n<li>cmp - 使用该参数的方法进行排序</li>\n<li>key - 每个列表中用来进行比较的元素，可以取自于可迭代对象中，指定可迭代对象中的一个元素进行排序</li>\n<li>reverse - 降序标志，默认是false升序</li>\n</ul>\n<p>比如如果需要对列表的第一个元素进行比较，可以这样进行使用：</p>\n<p><code>list.sort(key = lambda x: x[0])</code></p>\n<hr>\n<p>OK，本期的解题就是这些，并查集其实理解还不够深入，深度优先和广度优先将是一个大的领域，接下来需要重点关注！</p>"},{"title":"春招-笔试分享","date":"2021-04-26T02:42:49.000Z","_content":"\n字节跳动的笔试记录是最详细的，但是也是唯一一个没有成功的。\n\n今天带来的一手笔试题目难度各异，分别来自美团、阿里和华为。总体来说，阿里的题目数据量大、用时紧张，很难完整得出结果；美团的题目较多，但上手也比较容易；华为题目虽然相对简单，但是输入输出的数据格式非常糟糕。\n\n下面对部分留下记录的题目进行简单分析：\n\n# 1. 阿里笔试\n\n比较难，关键感受：测试用例非常完整，很难通过用例，一个测试用例都没有过。\n\n## 1）牌游戏问题\n\n题目描述：n副牌，每副有m张（就是1到m），每副牌中抽1张，问相加之和为k的抽取方案有多少种？\n\n给出的测试例会有T组，需要一下子给出他们的结果。\n\n这道题似乎在Leetcode上找到了近似的题目，ta的解决方法是**概率**的方法\n\n## 2） 零件优化问题\n\n题目描述：n个零件，对每个零件进行一次空间 或 时间优化（二选一，且必选），每种优化带来的不稳定值不同\n\n这些零件中，有的零件之间会有冲突，总计 m 条冲突，冲突零件不可组合\n\n请找到最佳组合方案，要求不稳定值最小。\n\n思路：这道题相比1）题其实可解性稍高，比如可以使用并查集的方式建立零件之间的联系（两种联系，一是冲突问题，二是不稳定值之和），然后寻找最小的不稳定值。\n\n## 其他笔试\n\n在早期的阿里云笔试中，题目是二叉树的中序遍历问题\n\n在一棵二叉搜索树中，找到第 k 小的数字\n\n# 2. 美团笔试\n\n一共5道题，难度适中，可解性比较高。\n\n## 1）积木问题\n\n题目描述：\n\n共有n块积木，每个积木上写了一个数字（0-9之间的数字）。\n\n可以任一将其中一块积木换成其他数字，希望更换后的数字串特点是：\n\n1）回文最好\n\n2）越小越好\n\n不能回文，就越小越好。\n\n输出：最佳的积木更换方案后的情况。\n\n思路：\n\n1）首先需要检查是不是回文，用双指针前后移动，观察到某一位是不是相同，如果不同，试图更换积木，看更换后是不是回文，仍然不是，那么特点1）无望，就换成更小的积木\n\n2）直接从最高位开始，不是0的那一位换成0，就是最小的\n\n现在看来，当时的解法有瑕疵，回文的检查做了两次，其实只需要一次就可以了，更换数字放在中间，然后继续检查就可以了\n\n这道题过了72%的样子。\n\n## 2）打龙技能问题\n\n题目描述：\n\n在一个游戏中要打龙，有两种技能 1和2，分别需要消耗 c1 和 c2 点体力，使用任意一种技能都可以打败龙。\n\n赢得游戏的要求是，不能连续输3局。\n\n现在给出一串字符串，T和F，表示不用技能的情况下每局的输赢情况。\n\n现在问，最少需要多少点体力，才能赢得游戏？\n\n思路：\n\n这道题的难度应该说很低了，贪心法。\n\n就是从头开始遍历，输的次数累计到3，自然就要用一次技能，计算需要使用技能的最少数量；\n\n两种技能中选择消耗体力比较少的那一种，就可以了。\n\n这道题似乎是全过了。\n\n## 3）爬树问题\n\n题目：有n棵树，高度分别为 $h_i$\n\n现在要选择一棵树，作为分界点：\n\n- 所有奇数树给一队\n- 所有偶数树给另一队\n\n注意：奇偶数是在去除选择的这棵树之后的顺序来计算的！！\n\n要求：找到合适的位置，使得两队的高度应该一致，无法一致就返回false\n\n思路：\n\n这道题我用了前缀和的方法，首先遍历一遍所有树，记录到每一棵树的位置，前面的所有树中奇数和偶数树的高度。\n\n然后遍历位置，以每个位置分界\n\n所有奇数树：该位置前的奇数树+该位置后的偶数树\n\n所有偶数树：该位置前的偶数树+该位置后的奇数树\n\n这个题就是这个索引比较头大，最后似乎通过了82%\n\n---\n\n还有两道题，题目已经不太记得了，通过率均为18%，进入面试环节。\n\n## 面试题目 - 大数加减法\n\n也就是计算器算法的实现\n\n# 3. 华为笔试\n\n## 1） 球赛积分问题\n\n足球小组赛中，通常是两两进行两次比赛，分别当一次主场，然后赢方积3分，平则各积1分\n\n给出一组比赛结果，记录了所有场次比赛的信息\n\n其中球队名称为 a-z 的字母，不会超过26支球队\n\n然后后面跟上比赛结果\n\n输出要求：按照积分高低输出球队名，同积分则按照字母顺序\n\n我的思路：\n\n1. 本题用一个哈希表，或者字典就能很好解决积分计算的问题\n2. 最关键的算法是字典的排序，要按照value大小进行排序\n\n问题：\n\n1. 本题在牛客网上进行时，还有一个问题是输入输出的格式问题，不是很规范，需要进行很多转换\n2. 字典的键的排序比较糟糕\n\n本题通过70%\n\n## 2）帽子问题\n\n每个人知道自己的帽子颜色，和在场所有人的帽子颜色\n\n现在给出一个数组，里面记录了部分人报告的数据，该数据表示在场人中帽子颜色和他相同的人的数量\n\n比如在场有4个人戴了蓝色帽子，那么其中任一人被问时，回答都会是 3：表示还有3个人的帽子和自己颜色相同。\n\n问：根据这个数组，在场最少有多少人。\n\n这个逻辑问题的关键是：比如两个颜色的帽子数量是相同的，那么这两个群体中所有人回答的数量都是一样的，如果这两个群体中的人并没有被全部提问，那么我们就可以少算几个人了！\n\n比如`2 2`\n\n有可能是 两个人颜色并不一样，但我们完全可以认为他们是一样的，这样全场最少就是3个人。\n\n因此，本题的算法应该可以认为是贪心法，用数学方法解决：\n\n用一个哈希表记录相同数字的数量，比如\n\n```python\n1: 2\t# 2个人答1\n2: 2\t# 2个人答2\n3: 5\t# 5个人答3\n```\n\n那么，相当于：\n\n```python\n2: 2\t# 二人同色，2人\n3: 2\t# 三人同色，2人\n4: 5\t# 四人同色，5人\n```\n\n最少的情况就是：\n\n$[\\frac{记录数量}{同色人数}]_{取整}*同色人数$\n\n比如：$[\\frac{5}{4}]_{取整}*4=2*4=8$，这里取整要向上取整\n\n本题全过。\n\n## 3）最少步数找到字符串\n\n给出：一个长字符串、一个短字符串、在长字符串中的起始位置\n\n要求：在长字符串的起始位置开始，可以向左或者向右开始找短字符串的头一个字符，然后按照顺序找下一个短字符串中的字符，找出总步数最少的那一种情况输出。\n\n本题还是有一点难度的，就是说我应该怎么找最短的路径，而且本题中的长字符串是可以循环的。\n\n结果：本题通过30%\n\n## 面试题目\n\nLeetCode - 11 装水的最大容器问题\n\n# 小结\n\n本文主要是作者个人知识积累和记录，以便后续查看，如果能够帮助其他同学，将不胜荣幸。希望能够继续努力，夯实基础，在职业生涯大放异彩！\n\n\n\n","source":"_posts/春招-笔试分享.md","raw":"---\ntitle: 春招-笔试分享\ndate: 2021-04-26 10:42:49\ncategories:\n\t- 算法\ntags:\n\t- 笔试\n---\n\n字节跳动的笔试记录是最详细的，但是也是唯一一个没有成功的。\n\n今天带来的一手笔试题目难度各异，分别来自美团、阿里和华为。总体来说，阿里的题目数据量大、用时紧张，很难完整得出结果；美团的题目较多，但上手也比较容易；华为题目虽然相对简单，但是输入输出的数据格式非常糟糕。\n\n下面对部分留下记录的题目进行简单分析：\n\n# 1. 阿里笔试\n\n比较难，关键感受：测试用例非常完整，很难通过用例，一个测试用例都没有过。\n\n## 1）牌游戏问题\n\n题目描述：n副牌，每副有m张（就是1到m），每副牌中抽1张，问相加之和为k的抽取方案有多少种？\n\n给出的测试例会有T组，需要一下子给出他们的结果。\n\n这道题似乎在Leetcode上找到了近似的题目，ta的解决方法是**概率**的方法\n\n## 2） 零件优化问题\n\n题目描述：n个零件，对每个零件进行一次空间 或 时间优化（二选一，且必选），每种优化带来的不稳定值不同\n\n这些零件中，有的零件之间会有冲突，总计 m 条冲突，冲突零件不可组合\n\n请找到最佳组合方案，要求不稳定值最小。\n\n思路：这道题相比1）题其实可解性稍高，比如可以使用并查集的方式建立零件之间的联系（两种联系，一是冲突问题，二是不稳定值之和），然后寻找最小的不稳定值。\n\n## 其他笔试\n\n在早期的阿里云笔试中，题目是二叉树的中序遍历问题\n\n在一棵二叉搜索树中，找到第 k 小的数字\n\n# 2. 美团笔试\n\n一共5道题，难度适中，可解性比较高。\n\n## 1）积木问题\n\n题目描述：\n\n共有n块积木，每个积木上写了一个数字（0-9之间的数字）。\n\n可以任一将其中一块积木换成其他数字，希望更换后的数字串特点是：\n\n1）回文最好\n\n2）越小越好\n\n不能回文，就越小越好。\n\n输出：最佳的积木更换方案后的情况。\n\n思路：\n\n1）首先需要检查是不是回文，用双指针前后移动，观察到某一位是不是相同，如果不同，试图更换积木，看更换后是不是回文，仍然不是，那么特点1）无望，就换成更小的积木\n\n2）直接从最高位开始，不是0的那一位换成0，就是最小的\n\n现在看来，当时的解法有瑕疵，回文的检查做了两次，其实只需要一次就可以了，更换数字放在中间，然后继续检查就可以了\n\n这道题过了72%的样子。\n\n## 2）打龙技能问题\n\n题目描述：\n\n在一个游戏中要打龙，有两种技能 1和2，分别需要消耗 c1 和 c2 点体力，使用任意一种技能都可以打败龙。\n\n赢得游戏的要求是，不能连续输3局。\n\n现在给出一串字符串，T和F，表示不用技能的情况下每局的输赢情况。\n\n现在问，最少需要多少点体力，才能赢得游戏？\n\n思路：\n\n这道题的难度应该说很低了，贪心法。\n\n就是从头开始遍历，输的次数累计到3，自然就要用一次技能，计算需要使用技能的最少数量；\n\n两种技能中选择消耗体力比较少的那一种，就可以了。\n\n这道题似乎是全过了。\n\n## 3）爬树问题\n\n题目：有n棵树，高度分别为 $h_i$\n\n现在要选择一棵树，作为分界点：\n\n- 所有奇数树给一队\n- 所有偶数树给另一队\n\n注意：奇偶数是在去除选择的这棵树之后的顺序来计算的！！\n\n要求：找到合适的位置，使得两队的高度应该一致，无法一致就返回false\n\n思路：\n\n这道题我用了前缀和的方法，首先遍历一遍所有树，记录到每一棵树的位置，前面的所有树中奇数和偶数树的高度。\n\n然后遍历位置，以每个位置分界\n\n所有奇数树：该位置前的奇数树+该位置后的偶数树\n\n所有偶数树：该位置前的偶数树+该位置后的奇数树\n\n这个题就是这个索引比较头大，最后似乎通过了82%\n\n---\n\n还有两道题，题目已经不太记得了，通过率均为18%，进入面试环节。\n\n## 面试题目 - 大数加减法\n\n也就是计算器算法的实现\n\n# 3. 华为笔试\n\n## 1） 球赛积分问题\n\n足球小组赛中，通常是两两进行两次比赛，分别当一次主场，然后赢方积3分，平则各积1分\n\n给出一组比赛结果，记录了所有场次比赛的信息\n\n其中球队名称为 a-z 的字母，不会超过26支球队\n\n然后后面跟上比赛结果\n\n输出要求：按照积分高低输出球队名，同积分则按照字母顺序\n\n我的思路：\n\n1. 本题用一个哈希表，或者字典就能很好解决积分计算的问题\n2. 最关键的算法是字典的排序，要按照value大小进行排序\n\n问题：\n\n1. 本题在牛客网上进行时，还有一个问题是输入输出的格式问题，不是很规范，需要进行很多转换\n2. 字典的键的排序比较糟糕\n\n本题通过70%\n\n## 2）帽子问题\n\n每个人知道自己的帽子颜色，和在场所有人的帽子颜色\n\n现在给出一个数组，里面记录了部分人报告的数据，该数据表示在场人中帽子颜色和他相同的人的数量\n\n比如在场有4个人戴了蓝色帽子，那么其中任一人被问时，回答都会是 3：表示还有3个人的帽子和自己颜色相同。\n\n问：根据这个数组，在场最少有多少人。\n\n这个逻辑问题的关键是：比如两个颜色的帽子数量是相同的，那么这两个群体中所有人回答的数量都是一样的，如果这两个群体中的人并没有被全部提问，那么我们就可以少算几个人了！\n\n比如`2 2`\n\n有可能是 两个人颜色并不一样，但我们完全可以认为他们是一样的，这样全场最少就是3个人。\n\n因此，本题的算法应该可以认为是贪心法，用数学方法解决：\n\n用一个哈希表记录相同数字的数量，比如\n\n```python\n1: 2\t# 2个人答1\n2: 2\t# 2个人答2\n3: 5\t# 5个人答3\n```\n\n那么，相当于：\n\n```python\n2: 2\t# 二人同色，2人\n3: 2\t# 三人同色，2人\n4: 5\t# 四人同色，5人\n```\n\n最少的情况就是：\n\n$[\\frac{记录数量}{同色人数}]_{取整}*同色人数$\n\n比如：$[\\frac{5}{4}]_{取整}*4=2*4=8$，这里取整要向上取整\n\n本题全过。\n\n## 3）最少步数找到字符串\n\n给出：一个长字符串、一个短字符串、在长字符串中的起始位置\n\n要求：在长字符串的起始位置开始，可以向左或者向右开始找短字符串的头一个字符，然后按照顺序找下一个短字符串中的字符，找出总步数最少的那一种情况输出。\n\n本题还是有一点难度的，就是说我应该怎么找最短的路径，而且本题中的长字符串是可以循环的。\n\n结果：本题通过30%\n\n## 面试题目\n\nLeetCode - 11 装水的最大容器问题\n\n# 小结\n\n本文主要是作者个人知识积累和记录，以便后续查看，如果能够帮助其他同学，将不胜荣幸。希望能够继续努力，夯实基础，在职业生涯大放异彩！\n\n\n\n","slug":"春招-笔试分享","published":1,"updated":"2021-04-26T02:53:46.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckny0b2fp0000q4tl36mv2uyw","content":"<p>字节跳动的笔试记录是最详细的，但是也是唯一一个没有成功的。</p>\n<p>今天带来的一手笔试题目难度各异，分别来自美团、阿里和华为。总体来说，阿里的题目数据量大、用时紧张，很难完整得出结果；美团的题目较多，但上手也比较容易；华为题目虽然相对简单，但是输入输出的数据格式非常糟糕。</p>\n<p>下面对部分留下记录的题目进行简单分析：</p>\n<h1 id=\"1-阿里笔试\"><a href=\"#1-阿里笔试\" class=\"headerlink\" title=\"1. 阿里笔试\"></a>1. 阿里笔试</h1><p>比较难，关键感受：测试用例非常完整，很难通过用例，一个测试用例都没有过。</p>\n<h2 id=\"1）牌游戏问题\"><a href=\"#1）牌游戏问题\" class=\"headerlink\" title=\"1）牌游戏问题\"></a>1）牌游戏问题</h2><p>题目描述：n副牌，每副有m张（就是1到m），每副牌中抽1张，问相加之和为k的抽取方案有多少种？</p>\n<p>给出的测试例会有T组，需要一下子给出他们的结果。</p>\n<p>这道题似乎在Leetcode上找到了近似的题目，ta的解决方法是<strong>概率</strong>的方法</p>\n<h2 id=\"2）-零件优化问题\"><a href=\"#2）-零件优化问题\" class=\"headerlink\" title=\"2） 零件优化问题\"></a>2） 零件优化问题</h2><p>题目描述：n个零件，对每个零件进行一次空间 或 时间优化（二选一，且必选），每种优化带来的不稳定值不同</p>\n<p>这些零件中，有的零件之间会有冲突，总计 m 条冲突，冲突零件不可组合</p>\n<p>请找到最佳组合方案，要求不稳定值最小。</p>\n<p>思路：这道题相比1）题其实可解性稍高，比如可以使用并查集的方式建立零件之间的联系（两种联系，一是冲突问题，二是不稳定值之和），然后寻找最小的不稳定值。</p>\n<h2 id=\"其他笔试\"><a href=\"#其他笔试\" class=\"headerlink\" title=\"其他笔试\"></a>其他笔试</h2><p>在早期的阿里云笔试中，题目是二叉树的中序遍历问题</p>\n<p>在一棵二叉搜索树中，找到第 k 小的数字</p>\n<h1 id=\"2-美团笔试\"><a href=\"#2-美团笔试\" class=\"headerlink\" title=\"2. 美团笔试\"></a>2. 美团笔试</h1><p>一共5道题，难度适中，可解性比较高。</p>\n<h2 id=\"1）积木问题\"><a href=\"#1）积木问题\" class=\"headerlink\" title=\"1）积木问题\"></a>1）积木问题</h2><p>题目描述：</p>\n<p>共有n块积木，每个积木上写了一个数字（0-9之间的数字）。</p>\n<p>可以任一将其中一块积木换成其他数字，希望更换后的数字串特点是：</p>\n<p>1）回文最好</p>\n<p>2）越小越好</p>\n<p>不能回文，就越小越好。</p>\n<p>输出：最佳的积木更换方案后的情况。</p>\n<p>思路：</p>\n<p>1）首先需要检查是不是回文，用双指针前后移动，观察到某一位是不是相同，如果不同，试图更换积木，看更换后是不是回文，仍然不是，那么特点1）无望，就换成更小的积木</p>\n<p>2）直接从最高位开始，不是0的那一位换成0，就是最小的</p>\n<p>现在看来，当时的解法有瑕疵，回文的检查做了两次，其实只需要一次就可以了，更换数字放在中间，然后继续检查就可以了</p>\n<p>这道题过了72%的样子。</p>\n<h2 id=\"2）打龙技能问题\"><a href=\"#2）打龙技能问题\" class=\"headerlink\" title=\"2）打龙技能问题\"></a>2）打龙技能问题</h2><p>题目描述：</p>\n<p>在一个游戏中要打龙，有两种技能 1和2，分别需要消耗 c1 和 c2 点体力，使用任意一种技能都可以打败龙。</p>\n<p>赢得游戏的要求是，不能连续输3局。</p>\n<p>现在给出一串字符串，T和F，表示不用技能的情况下每局的输赢情况。</p>\n<p>现在问，最少需要多少点体力，才能赢得游戏？</p>\n<p>思路：</p>\n<p>这道题的难度应该说很低了，贪心法。</p>\n<p>就是从头开始遍历，输的次数累计到3，自然就要用一次技能，计算需要使用技能的最少数量；</p>\n<p>两种技能中选择消耗体力比较少的那一种，就可以了。</p>\n<p>这道题似乎是全过了。</p>\n<h2 id=\"3）爬树问题\"><a href=\"#3）爬树问题\" class=\"headerlink\" title=\"3）爬树问题\"></a>3）爬树问题</h2><p>题目：有n棵树，高度分别为 $h_i$</p>\n<p>现在要选择一棵树，作为分界点：</p>\n<ul>\n<li>所有奇数树给一队</li>\n<li>所有偶数树给另一队</li>\n</ul>\n<p>注意：奇偶数是在去除选择的这棵树之后的顺序来计算的！！</p>\n<p>要求：找到合适的位置，使得两队的高度应该一致，无法一致就返回false</p>\n<p>思路：</p>\n<p>这道题我用了前缀和的方法，首先遍历一遍所有树，记录到每一棵树的位置，前面的所有树中奇数和偶数树的高度。</p>\n<p>然后遍历位置，以每个位置分界</p>\n<p>所有奇数树：该位置前的奇数树+该位置后的偶数树</p>\n<p>所有偶数树：该位置前的偶数树+该位置后的奇数树</p>\n<p>这个题就是这个索引比较头大，最后似乎通过了82%</p>\n<hr>\n<p>还有两道题，题目已经不太记得了，通过率均为18%，进入面试环节。</p>\n<h2 id=\"面试题目-大数加减法\"><a href=\"#面试题目-大数加减法\" class=\"headerlink\" title=\"面试题目 - 大数加减法\"></a>面试题目 - 大数加减法</h2><p>也就是计算器算法的实现</p>\n<h1 id=\"3-华为笔试\"><a href=\"#3-华为笔试\" class=\"headerlink\" title=\"3. 华为笔试\"></a>3. 华为笔试</h1><h2 id=\"1）-球赛积分问题\"><a href=\"#1）-球赛积分问题\" class=\"headerlink\" title=\"1） 球赛积分问题\"></a>1） 球赛积分问题</h2><p>足球小组赛中，通常是两两进行两次比赛，分别当一次主场，然后赢方积3分，平则各积1分</p>\n<p>给出一组比赛结果，记录了所有场次比赛的信息</p>\n<p>其中球队名称为 a-z 的字母，不会超过26支球队</p>\n<p>然后后面跟上比赛结果</p>\n<p>输出要求：按照积分高低输出球队名，同积分则按照字母顺序</p>\n<p>我的思路：</p>\n<ol>\n<li>本题用一个哈希表，或者字典就能很好解决积分计算的问题</li>\n<li>最关键的算法是字典的排序，要按照value大小进行排序</li>\n</ol>\n<p>问题：</p>\n<ol>\n<li>本题在牛客网上进行时，还有一个问题是输入输出的格式问题，不是很规范，需要进行很多转换</li>\n<li>字典的键的排序比较糟糕</li>\n</ol>\n<p>本题通过70%</p>\n<h2 id=\"2）帽子问题\"><a href=\"#2）帽子问题\" class=\"headerlink\" title=\"2）帽子问题\"></a>2）帽子问题</h2><p>每个人知道自己的帽子颜色，和在场所有人的帽子颜色</p>\n<p>现在给出一个数组，里面记录了部分人报告的数据，该数据表示在场人中帽子颜色和他相同的人的数量</p>\n<p>比如在场有4个人戴了蓝色帽子，那么其中任一人被问时，回答都会是 3：表示还有3个人的帽子和自己颜色相同。</p>\n<p>问：根据这个数组，在场最少有多少人。</p>\n<p>这个逻辑问题的关键是：比如两个颜色的帽子数量是相同的，那么这两个群体中所有人回答的数量都是一样的，如果这两个群体中的人并没有被全部提问，那么我们就可以少算几个人了！</p>\n<p>比如<code>2 2</code></p>\n<p>有可能是 两个人颜色并不一样，但我们完全可以认为他们是一样的，这样全场最少就是3个人。</p>\n<p>因此，本题的算法应该可以认为是贪心法，用数学方法解决：</p>\n<p>用一个哈希表记录相同数字的数量，比如</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>: <span class=\"number\">2</span>\t<span class=\"comment\"># 2个人答1</span></span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"number\">2</span>\t<span class=\"comment\"># 2个人答2</span></span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"number\">5</span>\t<span class=\"comment\"># 5个人答3</span></span><br></pre></td></tr></table></figure>\n<p>那么，相当于：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>: <span class=\"number\">2</span>\t<span class=\"comment\"># 二人同色，2人</span></span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"number\">2</span>\t<span class=\"comment\"># 三人同色，2人</span></span><br><span class=\"line\"><span class=\"number\">4</span>: <span class=\"number\">5</span>\t<span class=\"comment\"># 四人同色，5人</span></span><br></pre></td></tr></table></figure>\n<p>最少的情况就是：</p>\n<p>$[\\frac{记录数量}{同色人数}]_{取整}*同色人数$</p>\n<p>比如：$[\\frac{5}{4}]_{取整}<em>4=2</em>4=8$，这里取整要向上取整</p>\n<p>本题全过。</p>\n<h2 id=\"3）最少步数找到字符串\"><a href=\"#3）最少步数找到字符串\" class=\"headerlink\" title=\"3）最少步数找到字符串\"></a>3）最少步数找到字符串</h2><p>给出：一个长字符串、一个短字符串、在长字符串中的起始位置</p>\n<p>要求：在长字符串的起始位置开始，可以向左或者向右开始找短字符串的头一个字符，然后按照顺序找下一个短字符串中的字符，找出总步数最少的那一种情况输出。</p>\n<p>本题还是有一点难度的，就是说我应该怎么找最短的路径，而且本题中的长字符串是可以循环的。</p>\n<p>结果：本题通过30%</p>\n<h2 id=\"面试题目\"><a href=\"#面试题目\" class=\"headerlink\" title=\"面试题目\"></a>面试题目</h2><p>LeetCode - 11 装水的最大容器问题</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本文主要是作者个人知识积累和记录，以便后续查看，如果能够帮助其他同学，将不胜荣幸。希望能够继续努力，夯实基础，在职业生涯大放异彩！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>字节跳动的笔试记录是最详细的，但是也是唯一一个没有成功的。</p>\n<p>今天带来的一手笔试题目难度各异，分别来自美团、阿里和华为。总体来说，阿里的题目数据量大、用时紧张，很难完整得出结果；美团的题目较多，但上手也比较容易；华为题目虽然相对简单，但是输入输出的数据格式非常糟糕。</p>\n<p>下面对部分留下记录的题目进行简单分析：</p>\n<h1 id=\"1-阿里笔试\"><a href=\"#1-阿里笔试\" class=\"headerlink\" title=\"1. 阿里笔试\"></a>1. 阿里笔试</h1><p>比较难，关键感受：测试用例非常完整，很难通过用例，一个测试用例都没有过。</p>\n<h2 id=\"1）牌游戏问题\"><a href=\"#1）牌游戏问题\" class=\"headerlink\" title=\"1）牌游戏问题\"></a>1）牌游戏问题</h2><p>题目描述：n副牌，每副有m张（就是1到m），每副牌中抽1张，问相加之和为k的抽取方案有多少种？</p>\n<p>给出的测试例会有T组，需要一下子给出他们的结果。</p>\n<p>这道题似乎在Leetcode上找到了近似的题目，ta的解决方法是<strong>概率</strong>的方法</p>\n<h2 id=\"2）-零件优化问题\"><a href=\"#2）-零件优化问题\" class=\"headerlink\" title=\"2） 零件优化问题\"></a>2） 零件优化问题</h2><p>题目描述：n个零件，对每个零件进行一次空间 或 时间优化（二选一，且必选），每种优化带来的不稳定值不同</p>\n<p>这些零件中，有的零件之间会有冲突，总计 m 条冲突，冲突零件不可组合</p>\n<p>请找到最佳组合方案，要求不稳定值最小。</p>\n<p>思路：这道题相比1）题其实可解性稍高，比如可以使用并查集的方式建立零件之间的联系（两种联系，一是冲突问题，二是不稳定值之和），然后寻找最小的不稳定值。</p>\n<h2 id=\"其他笔试\"><a href=\"#其他笔试\" class=\"headerlink\" title=\"其他笔试\"></a>其他笔试</h2><p>在早期的阿里云笔试中，题目是二叉树的中序遍历问题</p>\n<p>在一棵二叉搜索树中，找到第 k 小的数字</p>\n<h1 id=\"2-美团笔试\"><a href=\"#2-美团笔试\" class=\"headerlink\" title=\"2. 美团笔试\"></a>2. 美团笔试</h1><p>一共5道题，难度适中，可解性比较高。</p>\n<h2 id=\"1）积木问题\"><a href=\"#1）积木问题\" class=\"headerlink\" title=\"1）积木问题\"></a>1）积木问题</h2><p>题目描述：</p>\n<p>共有n块积木，每个积木上写了一个数字（0-9之间的数字）。</p>\n<p>可以任一将其中一块积木换成其他数字，希望更换后的数字串特点是：</p>\n<p>1）回文最好</p>\n<p>2）越小越好</p>\n<p>不能回文，就越小越好。</p>\n<p>输出：最佳的积木更换方案后的情况。</p>\n<p>思路：</p>\n<p>1）首先需要检查是不是回文，用双指针前后移动，观察到某一位是不是相同，如果不同，试图更换积木，看更换后是不是回文，仍然不是，那么特点1）无望，就换成更小的积木</p>\n<p>2）直接从最高位开始，不是0的那一位换成0，就是最小的</p>\n<p>现在看来，当时的解法有瑕疵，回文的检查做了两次，其实只需要一次就可以了，更换数字放在中间，然后继续检查就可以了</p>\n<p>这道题过了72%的样子。</p>\n<h2 id=\"2）打龙技能问题\"><a href=\"#2）打龙技能问题\" class=\"headerlink\" title=\"2）打龙技能问题\"></a>2）打龙技能问题</h2><p>题目描述：</p>\n<p>在一个游戏中要打龙，有两种技能 1和2，分别需要消耗 c1 和 c2 点体力，使用任意一种技能都可以打败龙。</p>\n<p>赢得游戏的要求是，不能连续输3局。</p>\n<p>现在给出一串字符串，T和F，表示不用技能的情况下每局的输赢情况。</p>\n<p>现在问，最少需要多少点体力，才能赢得游戏？</p>\n<p>思路：</p>\n<p>这道题的难度应该说很低了，贪心法。</p>\n<p>就是从头开始遍历，输的次数累计到3，自然就要用一次技能，计算需要使用技能的最少数量；</p>\n<p>两种技能中选择消耗体力比较少的那一种，就可以了。</p>\n<p>这道题似乎是全过了。</p>\n<h2 id=\"3）爬树问题\"><a href=\"#3）爬树问题\" class=\"headerlink\" title=\"3）爬树问题\"></a>3）爬树问题</h2><p>题目：有n棵树，高度分别为 $h_i$</p>\n<p>现在要选择一棵树，作为分界点：</p>\n<ul>\n<li>所有奇数树给一队</li>\n<li>所有偶数树给另一队</li>\n</ul>\n<p>注意：奇偶数是在去除选择的这棵树之后的顺序来计算的！！</p>\n<p>要求：找到合适的位置，使得两队的高度应该一致，无法一致就返回false</p>\n<p>思路：</p>\n<p>这道题我用了前缀和的方法，首先遍历一遍所有树，记录到每一棵树的位置，前面的所有树中奇数和偶数树的高度。</p>\n<p>然后遍历位置，以每个位置分界</p>\n<p>所有奇数树：该位置前的奇数树+该位置后的偶数树</p>\n<p>所有偶数树：该位置前的偶数树+该位置后的奇数树</p>\n<p>这个题就是这个索引比较头大，最后似乎通过了82%</p>\n<hr>\n<p>还有两道题，题目已经不太记得了，通过率均为18%，进入面试环节。</p>\n<h2 id=\"面试题目-大数加减法\"><a href=\"#面试题目-大数加减法\" class=\"headerlink\" title=\"面试题目 - 大数加减法\"></a>面试题目 - 大数加减法</h2><p>也就是计算器算法的实现</p>\n<h1 id=\"3-华为笔试\"><a href=\"#3-华为笔试\" class=\"headerlink\" title=\"3. 华为笔试\"></a>3. 华为笔试</h1><h2 id=\"1）-球赛积分问题\"><a href=\"#1）-球赛积分问题\" class=\"headerlink\" title=\"1） 球赛积分问题\"></a>1） 球赛积分问题</h2><p>足球小组赛中，通常是两两进行两次比赛，分别当一次主场，然后赢方积3分，平则各积1分</p>\n<p>给出一组比赛结果，记录了所有场次比赛的信息</p>\n<p>其中球队名称为 a-z 的字母，不会超过26支球队</p>\n<p>然后后面跟上比赛结果</p>\n<p>输出要求：按照积分高低输出球队名，同积分则按照字母顺序</p>\n<p>我的思路：</p>\n<ol>\n<li>本题用一个哈希表，或者字典就能很好解决积分计算的问题</li>\n<li>最关键的算法是字典的排序，要按照value大小进行排序</li>\n</ol>\n<p>问题：</p>\n<ol>\n<li>本题在牛客网上进行时，还有一个问题是输入输出的格式问题，不是很规范，需要进行很多转换</li>\n<li>字典的键的排序比较糟糕</li>\n</ol>\n<p>本题通过70%</p>\n<h2 id=\"2）帽子问题\"><a href=\"#2）帽子问题\" class=\"headerlink\" title=\"2）帽子问题\"></a>2）帽子问题</h2><p>每个人知道自己的帽子颜色，和在场所有人的帽子颜色</p>\n<p>现在给出一个数组，里面记录了部分人报告的数据，该数据表示在场人中帽子颜色和他相同的人的数量</p>\n<p>比如在场有4个人戴了蓝色帽子，那么其中任一人被问时，回答都会是 3：表示还有3个人的帽子和自己颜色相同。</p>\n<p>问：根据这个数组，在场最少有多少人。</p>\n<p>这个逻辑问题的关键是：比如两个颜色的帽子数量是相同的，那么这两个群体中所有人回答的数量都是一样的，如果这两个群体中的人并没有被全部提问，那么我们就可以少算几个人了！</p>\n<p>比如<code>2 2</code></p>\n<p>有可能是 两个人颜色并不一样，但我们完全可以认为他们是一样的，这样全场最少就是3个人。</p>\n<p>因此，本题的算法应该可以认为是贪心法，用数学方法解决：</p>\n<p>用一个哈希表记录相同数字的数量，比如</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>: <span class=\"number\">2</span>\t<span class=\"comment\"># 2个人答1</span></span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"number\">2</span>\t<span class=\"comment\"># 2个人答2</span></span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"number\">5</span>\t<span class=\"comment\"># 5个人答3</span></span><br></pre></td></tr></table></figure>\n<p>那么，相当于：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>: <span class=\"number\">2</span>\t<span class=\"comment\"># 二人同色，2人</span></span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"number\">2</span>\t<span class=\"comment\"># 三人同色，2人</span></span><br><span class=\"line\"><span class=\"number\">4</span>: <span class=\"number\">5</span>\t<span class=\"comment\"># 四人同色，5人</span></span><br></pre></td></tr></table></figure>\n<p>最少的情况就是：</p>\n<p>$[\\frac{记录数量}{同色人数}]_{取整}*同色人数$</p>\n<p>比如：$[\\frac{5}{4}]_{取整}<em>4=2</em>4=8$，这里取整要向上取整</p>\n<p>本题全过。</p>\n<h2 id=\"3）最少步数找到字符串\"><a href=\"#3）最少步数找到字符串\" class=\"headerlink\" title=\"3）最少步数找到字符串\"></a>3）最少步数找到字符串</h2><p>给出：一个长字符串、一个短字符串、在长字符串中的起始位置</p>\n<p>要求：在长字符串的起始位置开始，可以向左或者向右开始找短字符串的头一个字符，然后按照顺序找下一个短字符串中的字符，找出总步数最少的那一种情况输出。</p>\n<p>本题还是有一点难度的，就是说我应该怎么找最短的路径，而且本题中的长字符串是可以循环的。</p>\n<p>结果：本题通过30%</p>\n<h2 id=\"面试题目\"><a href=\"#面试题目\" class=\"headerlink\" title=\"面试题目\"></a>面试题目</h2><p>LeetCode - 11 装水的最大容器问题</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本文主要是作者个人知识积累和记录，以便后续查看，如果能够帮助其他同学，将不胜荣幸。希望能够继续努力，夯实基础，在职业生涯大放异彩！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cknv5n87p0000k8tlct04brql","category_id":"cknv5n87w0003k8tlcswj8nm5","_id":"cknv5n881000dk8tlbzb0hbg3"},{"post_id":"cknv5n87u0002k8tlfyidgidd","category_id":"cknv5n87w0003k8tlcswj8nm5","_id":"cknv5n883000jk8tlew5x62h8"},{"post_id":"cknv5n87x0005k8tl4yg6euos","category_id":"cknv5n87w0003k8tlcswj8nm5","_id":"cknv5n885000pk8tlefdhg5vc"},{"post_id":"cknv5n87x0006k8tl2yzefioh","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n887000xk8tl5uzv3ru2"},{"post_id":"cknv5n885000tk8tlfr2ngsj0","category_id":"cknv5n87w0003k8tlcswj8nm5","_id":"cknv5n8880012k8tl3d6w0jsk"},{"post_id":"cknv5n87y0007k8tl18bvhofn","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n8890016k8tl8khpc91f"},{"post_id":"cknv5n886000vk8tlci9y94yp","category_id":"cknv5n87w0003k8tlcswj8nm5","_id":"cknv5n88a0019k8tlegb64zm2"},{"post_id":"cknv5n8870010k8tl8zaw95rh","category_id":"cknv5n87w0003k8tlcswj8nm5","_id":"cknv5n88b001ek8tleqkafjf6"},{"post_id":"cknv5n880000ak8tlfueo9wr5","category_id":"cknv5n887000wk8tl93nl009q","_id":"cknv5n88c001hk8tlajbafkkb"},{"post_id":"cknv5n8880011k8tlbnlo93o9","category_id":"cknv5n87w0003k8tlcswj8nm5","_id":"cknv5n88d001kk8tlcslk43aj"},{"post_id":"cknv5n8890015k8tlaifse32a","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n88d001ok8tlhz2f8h0s"},{"post_id":"cknv5n880000bk8tl1k9kafnk","category_id":"cknv5n8880014k8tles8h9mdz","_id":"cknv5n88e001rk8tlhhtvbz79"},{"post_id":"cknv5n88b001dk8tl6xjh1dzd","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n88f001uk8tl4yk647rj"},{"post_id":"cknv5n88b001gk8tl8t866c1j","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n88f001wk8tlgfax0paj"},{"post_id":"cknv5n883000hk8tl1ewh1oxk","category_id":"cknv5n88a001ck8tlhz3d6ex5","_id":"cknv5n88f001yk8tl332x0sg1"},{"post_id":"cknv5n88c001jk8tl2agc1bby","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n88f001zk8tlh0lkc2nh"},{"post_id":"cknv5n88d001nk8tl0fvxg7eo","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n88g0021k8tldc1dgt5a"},{"post_id":"cknv5n884000mk8tl0qab7dfa","category_id":"cknv5n8880014k8tles8h9mdz","_id":"cknv5n88g0022k8tlg6z0fdg7"},{"post_id":"cknv5n88e001qk8tlafr3dmch","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n88g0024k8tl7wthezsc"},{"post_id":"cknv5n8890018k8tl79bg883g","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"cknv5n88g0026k8tl6vyo1pyj"},{"post_id":"cknv5n88z0038k8tl2jtu3lz1","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n894003gk8tl54lz9mhd"},{"post_id":"cknv5n890003ak8tl4q2x0mtp","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n895003jk8tlc0cx0tdi"},{"post_id":"cknv5n893003fk8tl4jyn7loi","category_id":"cknv5n88a001ck8tlhz3d6ex5","_id":"cknv5n896003ok8tl796r4ttr"},{"post_id":"cknv5n891003dk8tl1bl08bhy","category_id":"cknv5n8880014k8tles8h9mdz","_id":"cknv5n897003qk8tl8k2u2kjz"},{"post_id":"cknv5n891003dk8tl1bl08bhy","category_id":"cknv5n88a001ck8tlhz3d6ex5","_id":"cknv5n897003sk8tlbn04dg5l"},{"post_id":"cknv5n895003lk8tlbvvyhohe","category_id":"cknv5n87w0003k8tlcswj8nm5","_id":"cknv5n898003uk8tl3epk72ra"},{"post_id":"cknv5n896003nk8tl07sbff6d","category_id":"cknv5n883000ik8tl00kw2igb","_id":"cknv5n898003wk8tlhydmd9fg"},{"post_id":"cknv5n894003ik8tl1mfce6xr","category_id":"cknv5n88a001ck8tlhz3d6ex5","_id":"cknv5n899003yk8tl2sgb580w"},{"post_id":"cknv5n894003ik8tl1mfce6xr","category_id":"cknv5n887000wk8tl93nl009q","_id":"cknv5n8990040k8tlale16wzr"},{"post_id":"cknv5n89g0041k8tl10fhfsx2","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"cknv5n89i0046k8tl0h2g4ia6"},{"post_id":"cknv5n89h0042k8tlfixydtc2","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"cknv5n89j0047k8tlh7xa4li7"},{"post_id":"cknv5n89h0044k8tl7q8c13su","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"cknv5n89j0049k8tl1zcccb3p"},{"post_id":"cknv5n89i0045k8tlc94t6zsi","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"cknv5n89j004ak8tl0pca87lg"},{"post_id":"cknv5n89w0055k8tl1htkhqql","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"cknv5n89x0058k8tlariwfkrt"},{"post_id":"cknv5n89w0056k8tl3g892gag","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"cknv5n89x0059k8tl2ap36i32"},{"post_id":"cknv5n89z005mk8tl81pr2cd1","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"cknv5n8a0005pk8tl2egd4fdy"},{"post_id":"ckny0b2fp0000q4tl36mv2uyw","category_id":"cknv5n88e001sk8tl7v9kd4t4","_id":"ckny0b2fv0002q4tle3nkf9ib"}],"PostTag":[{"post_id":"cknv5n87p0000k8tlct04brql","tag_id":"cknv5n87w0004k8tl9lwc2jk4","_id":"cknv5n882000gk8tl1xql0xg7"},{"post_id":"cknv5n87p0000k8tlct04brql","tag_id":"cknv5n87y0009k8tl4zl4fzz1","_id":"cknv5n883000kk8tlcq7scxva"},{"post_id":"cknv5n880000bk8tl1k9kafnk","tag_id":"cknv5n87w0004k8tl9lwc2jk4","_id":"cknv5n884000nk8tl5cch4v3r"},{"post_id":"cknv5n884000mk8tl0qab7dfa","tag_id":"cknv5n87w0004k8tl9lwc2jk4","_id":"cknv5n885000sk8tl8qe86tdd"},{"post_id":"cknv5n87u0002k8tlfyidgidd","tag_id":"cknv5n87w0004k8tl9lwc2jk4","_id":"cknv5n886000uk8tlgsvqeu4l"},{"post_id":"cknv5n87u0002k8tlfyidgidd","tag_id":"cknv5n87y0009k8tl4zl4fzz1","_id":"cknv5n887000zk8tlfcec6xw9"},{"post_id":"cknv5n87x0005k8tl4yg6euos","tag_id":"cknv5n87w0004k8tl9lwc2jk4","_id":"cknv5n8890017k8tl13n955kt"},{"post_id":"cknv5n87x0005k8tl4yg6euos","tag_id":"cknv5n87y0009k8tl4zl4fzz1","_id":"cknv5n88a001ak8tlhz50fa73"},{"post_id":"cknv5n87x0006k8tl2yzefioh","tag_id":"cknv5n8880013k8tla19pgzeq","_id":"cknv5n88b001fk8tlclc09l6s"},{"post_id":"cknv5n87y0007k8tl18bvhofn","tag_id":"cknv5n8880013k8tla19pgzeq","_id":"cknv5n88d001mk8tlhtuv73d3"},{"post_id":"cknv5n880000ak8tlfueo9wr5","tag_id":"cknv5n88c001ik8tlcfee737n","_id":"cknv5n88f001tk8tl8c868sul"},{"post_id":"cknv5n880000ak8tlfueo9wr5","tag_id":"cknv5n87w0004k8tl9lwc2jk4","_id":"cknv5n88f001vk8tlhyrr4bbk"},{"post_id":"cknv5n883000hk8tl1ewh1oxk","tag_id":"cknv5n88e001pk8tldqx83elb","_id":"cknv5n88g0025k8tl4vy1e21k"},{"post_id":"cknv5n883000hk8tl1ewh1oxk","tag_id":"cknv5n88f001xk8tleerw6l6f","_id":"cknv5n88g0027k8tl8mal5nkg"},{"post_id":"cknv5n883000hk8tl1ewh1oxk","tag_id":"cknv5n88c001ik8tlcfee737n","_id":"cknv5n88h0029k8tl9fzd3iln"},{"post_id":"cknv5n885000tk8tlfr2ngsj0","tag_id":"cknv5n88g0023k8tl6n9wgjgn","_id":"cknv5n88h002ck8tl8j005b7u"},{"post_id":"cknv5n885000tk8tlfr2ngsj0","tag_id":"cknv5n88g0028k8tlhj8g5c9k","_id":"cknv5n88h002dk8tl7dn9dmd5"},{"post_id":"cknv5n885000tk8tlfr2ngsj0","tag_id":"cknv5n88h002ak8tl6lq8cie4","_id":"cknv5n88h002fk8tlar95bhpu"},{"post_id":"cknv5n886000vk8tlci9y94yp","tag_id":"cknv5n88h002bk8tlhirq8yqn","_id":"cknv5n88i002hk8tl5qq6ebqf"},{"post_id":"cknv5n886000vk8tlci9y94yp","tag_id":"cknv5n88g0028k8tlhj8g5c9k","_id":"cknv5n88i002ik8tl9mkn4ar9"},{"post_id":"cknv5n8870010k8tl8zaw95rh","tag_id":"cknv5n88g0028k8tlhj8g5c9k","_id":"cknv5n88j002lk8tl02qw809e"},{"post_id":"cknv5n8870010k8tl8zaw95rh","tag_id":"cknv5n88i002jk8tl6hy31aps","_id":"cknv5n88j002mk8tl07ypcdns"},{"post_id":"cknv5n8880011k8tlbnlo93o9","tag_id":"cknv5n88i002kk8tlefxzaniw","_id":"cknv5n88k002pk8tl6qcu6i61"},{"post_id":"cknv5n8880011k8tlbnlo93o9","tag_id":"cknv5n88k002nk8tl836xam1m","_id":"cknv5n88k002qk8tl9xcl8s9c"},{"post_id":"cknv5n8890015k8tlaifse32a","tag_id":"cknv5n88k002ok8tlc90y3w3f","_id":"cknv5n88l002sk8tl650k7kfw"},{"post_id":"cknv5n8890018k8tl79bg883g","tag_id":"cknv5n88k002rk8tla3byh7zb","_id":"cknv5n88m002xk8tlb4tb3lj1"},{"post_id":"cknv5n8890018k8tl79bg883g","tag_id":"cknv5n88l002tk8tlanev0au0","_id":"cknv5n88m002yk8tlhr3w22c1"},{"post_id":"cknv5n8890018k8tl79bg883g","tag_id":"cknv5n88l002uk8tl0nxm05ct","_id":"cknv5n88m0030k8tldf744j68"},{"post_id":"cknv5n8890018k8tl79bg883g","tag_id":"cknv5n88m002vk8tl9aku2eyx","_id":"cknv5n88n0031k8tl5c6ydhr3"},{"post_id":"cknv5n88b001dk8tl6xjh1dzd","tag_id":"cknv5n88m002wk8tl3a9x0h4w","_id":"cknv5n88n0033k8tl05fndkx6"},{"post_id":"cknv5n88c001jk8tl2agc1bby","tag_id":"cknv5n88m002wk8tl3a9x0h4w","_id":"cknv5n88n0034k8tl68ed55sk"},{"post_id":"cknv5n88d001nk8tl0fvxg7eo","tag_id":"cknv5n88m002wk8tl3a9x0h4w","_id":"cknv5n88n0036k8tlezqcgzkn"},{"post_id":"cknv5n88e001qk8tlafr3dmch","tag_id":"cknv5n88m002wk8tl3a9x0h4w","_id":"cknv5n88n0037k8tl1e110evs"},{"post_id":"cknv5n88z0038k8tl2jtu3lz1","tag_id":"cknv5n88m002wk8tl3a9x0h4w","_id":"cknv5n891003ck8tlehn26zog"},{"post_id":"cknv5n890003ak8tl4q2x0mtp","tag_id":"cknv5n88m002wk8tl3a9x0h4w","_id":"cknv5n893003ek8tl0gm2gasj"},{"post_id":"cknv5n891003dk8tl1bl08bhy","tag_id":"cknv5n88e001pk8tldqx83elb","_id":"cknv5n894003hk8tlayq22xir"},{"post_id":"cknv5n891003dk8tl1bl08bhy","tag_id":"cknv5n88f001xk8tleerw6l6f","_id":"cknv5n895003kk8tl4nf5gmlc"},{"post_id":"cknv5n893003fk8tl4jyn7loi","tag_id":"cknv5n88f001xk8tleerw6l6f","_id":"cknv5n896003mk8tl1gpn73g2"},{"post_id":"cknv5n893003fk8tl4jyn7loi","tag_id":"cknv5n88e001pk8tldqx83elb","_id":"cknv5n897003pk8tlenas8uz4"},{"post_id":"cknv5n894003ik8tl1mfce6xr","tag_id":"cknv5n88f001xk8tleerw6l6f","_id":"cknv5n897003rk8tldtkr6o43"},{"post_id":"cknv5n894003ik8tl1mfce6xr","tag_id":"cknv5n88e001pk8tldqx83elb","_id":"cknv5n898003tk8tlbn4lekni"},{"post_id":"cknv5n895003lk8tlbvvyhohe","tag_id":"cknv5n88i002kk8tlefxzaniw","_id":"cknv5n898003vk8tlhhw76tth"},{"post_id":"cknv5n895003lk8tlbvvyhohe","tag_id":"cknv5n88k002nk8tl836xam1m","_id":"cknv5n898003xk8tl9fa6chg8"},{"post_id":"cknv5n896003nk8tl07sbff6d","tag_id":"cknv5n88m002wk8tl3a9x0h4w","_id":"cknv5n899003zk8tl9qr124t5"},{"post_id":"cknv5n89g0041k8tl10fhfsx2","tag_id":"cknv5n89h0043k8tl44jzgctg","_id":"cknv5n89l004dk8tlbopedzyj"},{"post_id":"cknv5n89g0041k8tl10fhfsx2","tag_id":"cknv5n89j0048k8tl1lns4obc","_id":"cknv5n89l004ek8tlfkfdg1dd"},{"post_id":"cknv5n89g0041k8tl10fhfsx2","tag_id":"cknv5n89j004bk8tldlwxff7c","_id":"cknv5n89m004gk8tl0gfc5n70"},{"post_id":"cknv5n89h0042k8tlfixydtc2","tag_id":"cknv5n89j004ck8tldn5c32on","_id":"cknv5n89n004lk8tl06v90lkg"},{"post_id":"cknv5n89h0042k8tlfixydtc2","tag_id":"cknv5n89l004fk8tla11z1ume","_id":"cknv5n89n004mk8tlb55j416p"},{"post_id":"cknv5n89h0042k8tlfixydtc2","tag_id":"cknv5n89m004hk8tl5z6ecpru","_id":"cknv5n89n004ok8tlc0fy1bvt"},{"post_id":"cknv5n89h0042k8tlfixydtc2","tag_id":"cknv5n89m004ik8tl82nw5mzc","_id":"cknv5n89n004pk8tlgoytgnmp"},{"post_id":"cknv5n89h0042k8tlfixydtc2","tag_id":"cknv5n89m004jk8tlgvf4ggzf","_id":"cknv5n89n004rk8tl31ch3bfl"},{"post_id":"cknv5n89h0044k8tl7q8c13su","tag_id":"cknv5n89h0043k8tl44jzgctg","_id":"cknv5n89o004uk8tl89fadgk8"},{"post_id":"cknv5n89h0044k8tl7q8c13su","tag_id":"cknv5n89n004nk8tl2bi29cx5","_id":"cknv5n89o004vk8tlcapx9a13"},{"post_id":"cknv5n89h0044k8tl7q8c13su","tag_id":"cknv5n89n004qk8tl4x5nfvqy","_id":"cknv5n89o004xk8tl4nqxdwoh"},{"post_id":"cknv5n89h0044k8tl7q8c13su","tag_id":"cknv5n89n004sk8tl2w2zaxy5","_id":"cknv5n89o004yk8tl6u0g9oek"},{"post_id":"cknv5n89i0045k8tlc94t6zsi","tag_id":"cknv5n89n004tk8tl5ey5fd3i","_id":"cknv5n89o0051k8tlhlv46p32"},{"post_id":"cknv5n89i0045k8tlc94t6zsi","tag_id":"cknv5n89o004wk8tl4t3x3uig","_id":"cknv5n89p0052k8tl658whqfh"},{"post_id":"cknv5n89i0045k8tlc94t6zsi","tag_id":"cknv5n89o004zk8tlgxxn1nj1","_id":"cknv5n89p0053k8tl1fw405yl"},{"post_id":"cknv5n89i0045k8tlc94t6zsi","tag_id":"cknv5n89o0050k8tldopefggq","_id":"cknv5n89p0054k8tlak3yfbgz"},{"post_id":"cknv5n89w0055k8tl1htkhqql","tag_id":"cknv5n89h0043k8tl44jzgctg","_id":"cknv5n89x005bk8tl6o8bd1fw"},{"post_id":"cknv5n89w0055k8tl1htkhqql","tag_id":"cknv5n89j004ck8tldn5c32on","_id":"cknv5n89x005ck8tlcxzcf9wi"},{"post_id":"cknv5n89w0055k8tl1htkhqql","tag_id":"cknv5n89x0057k8tl9hwnc05u","_id":"cknv5n89y005ek8tl0omlge2g"},{"post_id":"cknv5n89w0055k8tl1htkhqql","tag_id":"cknv5n89n004nk8tl2bi29cx5","_id":"cknv5n89y005fk8tl3xzn9koc"},{"post_id":"cknv5n89w0056k8tl3g892gag","tag_id":"cknv5n89x005ak8tlf2aufm8v","_id":"cknv5n89y005hk8tl2e8s7i2w"},{"post_id":"cknv5n89w0056k8tl3g892gag","tag_id":"cknv5n89n004nk8tl2bi29cx5","_id":"cknv5n89y005ik8tl8fb410gy"},{"post_id":"cknv5n89w0056k8tl3g892gag","tag_id":"cknv5n88m002vk8tl9aku2eyx","_id":"cknv5n89y005jk8tl55zjfk7g"},{"post_id":"cknv5n89w0056k8tl3g892gag","tag_id":"cknv5n89x005dk8tl1bz7cg3q","_id":"cknv5n89y005kk8tl3aaeeehr"},{"post_id":"cknv5n89w0056k8tl3g892gag","tag_id":"cknv5n89y005gk8tl8d8h5w7b","_id":"cknv5n89y005lk8tl91i374mr"},{"post_id":"cknv5n89z005mk8tl81pr2cd1","tag_id":"cknv5n88l002uk8tl0nxm05ct","_id":"cknv5n89z005nk8tlbhxq9wsl"},{"post_id":"cknv5n89z005mk8tl81pr2cd1","tag_id":"cknv5n89n004tk8tl5ey5fd3i","_id":"cknv5n8a0005ok8tld9gufbgn"},{"post_id":"cknv5n89z005mk8tl81pr2cd1","tag_id":"cknv5n88m002vk8tl9aku2eyx","_id":"cknv5n8a0005qk8tla8jic435"},{"post_id":"ckny0b2fp0000q4tl36mv2uyw","tag_id":"cknv5n88l002tk8tlanev0au0","_id":"ckny0b2fu0001q4tl650z7q84"}],"Tag":[{"name":"software","_id":"cknv5n87w0004k8tl9lwc2jk4"},{"name":"influxdb","_id":"cknv5n87y0009k8tl4zl4fzz1"},{"name":"PyTorch","_id":"cknv5n8880013k8tla19pgzeq"},{"name":"ROS","_id":"cknv5n88c001ik8tlcfee737n"},{"name":"OpenCV","_id":"cknv5n88e001pk8tldqx83elb"},{"name":"华为云无人车","_id":"cknv5n88f001xk8tleerw6l6f"},{"name":"json","_id":"cknv5n88g0023k8tl6n9wgjgn"},{"name":"Pandas","_id":"cknv5n88g0028k8tlhj8g5c9k"},{"name":"index","_id":"cknv5n88h002ak8tl6lq8cie4"},{"name":"Word Cloud","_id":"cknv5n88h002bk8tlhirq8yqn"},{"name":"os","_id":"cknv5n88i002jk8tl6hy31aps"},{"name":"MySQL","_id":"cknv5n88i002kk8tlefxzaniw"},{"name":"DataBases","_id":"cknv5n88k002nk8tl836xam1m"},{"name":"神经网络","_id":"cknv5n88k002ok8tlc90y3w3f"},{"name":"bytedance","_id":"cknv5n88k002rk8tla3byh7zb"},{"name":"笔试","_id":"cknv5n88l002tk8tlanev0au0"},{"name":"并查集","_id":"cknv5n88l002uk8tl0nxm05ct"},{"name":"数组","_id":"cknv5n88m002vk8tl9aku2eyx"},{"name":"统计学习方法","_id":"cknv5n88m002wk8tl3a9x0h4w"},{"name":"LeetCode","_id":"cknv5n89h0043k8tl44jzgctg"},{"name":"排序问题","_id":"cknv5n89j0048k8tl1lns4obc"},{"name":"滑动窗口","_id":"cknv5n89j004bk8tldlwxff7c"},{"name":"链表","_id":"cknv5n89j004ck8tldn5c32on"},{"name":"单调栈","_id":"cknv5n89l004fk8tla11z1ume"},{"name":"哈希表","_id":"cknv5n89m004hk8tl5z6ecpru"},{"name":"hot100","_id":"cknv5n89m004ik8tl82nw5mzc"},{"name":"ascii","_id":"cknv5n89m004jk8tlgvf4ggzf"},{"name":"动态规划","_id":"cknv5n89n004nk8tl2bi29cx5"},{"name":"贪心法","_id":"cknv5n89n004qk8tl4x5nfvqy"},{"name":"分治法","_id":"cknv5n89n004sk8tl2w2zaxy5"},{"name":"双指针","_id":"cknv5n89n004tk8tl5ey5fd3i"},{"name":"分治","_id":"cknv5n89o004wk8tl4t3x3uig"},{"name":"贪心","_id":"cknv5n89o004zk8tlgxxn1nj1"},{"name":"递归","_id":"cknv5n89o0050k8tldopefggq"},{"name":"List数组操作","_id":"cknv5n89x0057k8tl9hwnc05u"},{"name":"图","_id":"cknv5n89x005ak8tlf2aufm8v"},{"name":"排序","_id":"cknv5n89x005dk8tl1bz7cg3q"},{"name":"拓扑排序","_id":"cknv5n89y005gk8tl8d8h5w7b"}]}}